{"meta":{"title":"BeckoninGshy's Blog","subtitle":null,"description":"Welcome to BeckoninGshy's Blog.","author":"yangzebin","url":"https://yangzebin001.github.io"},"pages":[],"posts":[{"title":"LeetCode 61. 旋转链表","slug":"LeetCode-61-旋转链表","date":"2019-01-01T14:40:48.000Z","updated":"2019-01-01T14:41:13.703Z","comments":true,"path":"2019/01/01/LeetCode-61-旋转链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-61-旋转链表/","excerpt":"61. 旋转链表 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。Example: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL","text":"61. 旋转链表 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。Example: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 123456789101112131415161718192021222324252627282930int getListNodeLength(struct ListNode * head)&#123; struct ListNode * head1 = head; int len = 0; while(head1)&#123; len++; head1 = head1-&gt;next; &#125; return len;&#125;struct ListNode* getPosition(struct ListNode* head, int index)&#123; if(index &lt; 0) return NULL; struct ListNode * head1 = head; while(index)&#123; head1 = head1-&gt;next; index--; &#125; return head1;&#125;struct ListNode* rotateRight(struct ListNode* head, int k) &#123; int len = getListNodeLength(head); if(len &lt;=1 || (k %= len) &lt; 1) return head; int position = len-k-1; struct ListNode* oldlast = getPosition(head,len-1); struct ListNode* newhead = getPosition(head,position+1); struct ListNode* newlast = getPosition(head,position); oldlast-&gt;next = head; newlast-&gt;next = NULL; return newhead;&#125; 思路:该题看似是循环n次，实则将后K个元素移至头结点的位置。 直接找到最后一个元素，将它指向开始的位置。将倒数第k+1个元素指向NULL。 k可以大于链表的长度，所以要对链表长度取模。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 24. 两两交换链表中的节点","slug":"LeetCode-24-两两交换链表中的节点","date":"2019-01-01T14:39:50.000Z","updated":"2019-01-01T14:40:16.318Z","comments":true,"path":"2019/01/01/LeetCode-24-两两交换链表中的节点/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-24-两两交换链表中的节点/","excerpt":"24. 两两交换链表中的节点 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。Example：给定 1-&gt;2-&gt;3-&gt;4，你应该返回 2-&gt;1-&gt;4-&gt;3。","text":"24. 两两交换链表中的节点 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。Example：给定 1-&gt;2-&gt;3-&gt;4，你应该返回 2-&gt;1-&gt;4-&gt;3。 1234567891011121314151617181920struct ListNode* swapPairs(struct ListNode* head) &#123; //设置头结点 struct ListNode* first = (struct ListNode*)malloc(sizeof(struct ListNode)); first-&gt;next = head; //备份 struct ListNode* first1 = first; // 如果头结点后有两个结点 while(first-&gt;next &amp;&amp; first-&gt;next-&gt;next)&#123; //两个结点 struct ListNode* one = first-&gt;next; struct ListNode* two = first-&gt;next-&gt;next; //交换两个结点。 one-&gt;next = two-&gt;next; first-&gt;next = two; two-&gt;next = one; first = one; &#125; //返回 return first1-&gt;next;&#125; 思路：用一个指针从开始读，如果可以读到该节点与下个节点，就将这两个结点交换位置，这时需要注意与前后的结点连接。 为了方便，用一个头结点来完成这个连接的工作。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 86. 分隔链表","slug":"LeetCode-86-分隔链表","date":"2019-01-01T14:38:47.000Z","updated":"2019-01-01T14:39:26.683Z","comments":true,"path":"2019/01/01/LeetCode-86-分隔链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-86-分隔链表/","excerpt":"86. 分隔链表 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。你应当保留两个分区中每个节点的初始相对位置。Example：给定 head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2， x = 3。 你应该返回 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5。","text":"86. 分隔链表 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。你应当保留两个分区中每个节点的初始相对位置。Example：给定 head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2， x = 3。 你应该返回 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5。 Solution1：1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; //创建两个头结点 ListNode less_head(0); ListNode more_head(0); ListNode *less_ptr = &amp;less_head; ListNode *more_ptr = &amp;more_head; while(head)&#123; //将val小于x的分进less_ptr，大于等于的分进more_ptr; if(head-&gt;val &lt; x)&#123; less_ptr-&gt;next = head; less_ptr = less_ptr-&gt;next; &#125;else&#123; more_ptr-&gt;next = head; more_ptr = more_ptr-&gt;next; &#125; head = head-&gt;next; &#125; //连接两个指针。 less_ptr-&gt;next = more_head.next; more_ptr-&gt;next = NULL; return less_head.next; &#125;&#125;; 思路：用双指针。创建两个头结点。比x小的划到第一个里面，否则划到第二个里面，最后将两个链表链接返回。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 138. 复制带随机指针的链表","slug":"LeetCode-138-复制带随机指针的链表","date":"2019-01-01T14:36:49.000Z","updated":"2019-01-01T14:37:20.684Z","comments":true,"path":"2019/01/01/LeetCode-138-复制带随机指针的链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-138-复制带随机指针的链表/","excerpt":"138. 复制带随机指针的链表 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深度拷贝。","text":"138. 复制带随机指针的链表 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深度拷贝。 12345678/** * Definition for singly-linked list with a random pointer. * struct RandomListNode &#123; * int label; * RandomListNode *next, *random; * RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125; * &#125;; */ Solution: 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode *head) &#123; //建立结点与当前位置的映射 std::map&lt;RandomListNode *, int&gt; node_map; //存放copy了的所有结点。按位置。 std::vector&lt;RandomListNode *&gt; node_vec; RandomListNode *ptr = head; int i = 0; while(ptr)&#123; //创建与旧链表相等的结点。copy其中的值。 node_vec.push_back(new RandomListNode(ptr-&gt;label)); // 建立结点与当前位置的映射。 node_map[ptr] = i; ptr = ptr-&gt;next; i++; &#125; //push尾结点 node_vec.push_back(0); ptr = head; i = 0; while(ptr)&#123; //将依次排列的结点的next相连接。 node_vec[i]-&gt;next = node_vec[i+1]; if(ptr-&gt;random)&#123; //找到该结点对应所指向的random所映射的位置。然后赋给当前结点。 int id = node_map[ptr-&gt;random]; node_vec[i]-&gt;random = node_vec[id]; &#125; ptr = ptr-&gt;next; i++; &#125; //返回首结点 return node_vec[0]; &#125;&#125;; 思路:如果没有random域，copy链表只要依次创建结点，并将当前结点的next指向下一个结点就完成了。 有random域会比较麻烦一些。需要通过建立一张结点与其位置的表来完成。 当需要填充random指向时，通过原链表的random域在表中的位置来将vector中这一位置的结点地址赋给random域。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 23. 合并K个排序链表","slug":"LeetCode-23-合并K个排序链表","date":"2019-01-01T14:35:08.000Z","updated":"2019-01-01T14:36:03.748Z","comments":true,"path":"2019/01/01/LeetCode-23-合并K个排序链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-23-合并K个排序链表/","excerpt":"23. 合并K个排序链表 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。Solution1：","text":"23. 合并K个排序链表 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。Solution1： 1234567891011121314151617181920212223242526272829bool cmp(const ListNode* a,const ListNode *b)&#123; return a-&gt;val &lt; b-&gt;val;&#125;class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; std::vector&lt;ListNode*&gt; node_vec; //将每个结点push到vec中。 for(int i = 0; i &lt; lists.size(); i++)&#123; ListNode* head = lists[i]; while(head)&#123; node_vec.push_back(head); head = head-&gt;next; &#125; &#125; if(node_vec.size() == 0)&#123; return NULL; &#125; //将vec中的元素按val域排序。 std::sort(node_vec.begin(),node_vec.end(),cmp); //链接各个结点。 for(int i = 1;i &lt; node_vec.size();i++)&#123; node_vec[i-1]-&gt;next = node_vec[i]; &#125; //最后一个结点指向NULL node_vec[node_vec.size()-1]-&gt;next = NULL; return node_vec[0]; &#125;&#125;; 该方法比较粗暴。将所有的结点存入一个vector中，按结点中的值排序，然后依次将每个结点链接，最后返回。 Solution2：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode p0 = ListNode(0); ListNode* p = &amp;p0; ListNode* p1 = p; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; p-&gt;next = new ListNode(l1-&gt;val); p = p-&gt;next; l1 = l1-&gt;next; &#125;else&#123; new ListNode(l2-&gt;val); p-&gt;next = new ListNode(l2-&gt;val); p = p-&gt;next; l2 = l2-&gt;next; &#125; &#125; p-&gt;next = (l1!=NULL) ? l1 :(l2!=NULL) ? l2 : NULL; return p1-&gt;next; &#125; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; //两个终止条件。 if(lists.size() == 0)&#123; return NULL; &#125; if(lists.size() == 1)&#123; return lists[0]; &#125; //将lists拆分成两个子lists; int mid = lists.size()/2; std::vector&lt;ListNode*&gt; sub1_lists; std::vector&lt;ListNode*&gt; sub2_lists; for(int i = 0; i &lt; mid; i++)&#123; sub1_lists.push_back(lists[i]); &#125; for(int i = mid; i &lt; lists.size(); i++)&#123; sub2_lists.push_back(lists[i]); &#125; //递归调用 ListNode *l1 = mergeKLists(sub1_lists); ListNode *l2 = mergeKLists(sub2_lists); //返回两个链表合并的结果。 return mergeTwoLists(l1,l2); &#125;&#125;; 思路:（归并思想）递归算法。将k个链表分割为独立的链表，再向上两两合并。 合并两个有序链表的子问题参照：21. 合并两个排序链表","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 155. 最小栈","slug":"LeetCode-155-最小栈","date":"2019-01-01T14:33:56.000Z","updated":"2019-01-01T14:34:45.587Z","comments":true,"path":"2019/01/01/LeetCode-155-最小栈/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-155-最小栈/","excerpt":"155. 最小栈 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。 pop() – 删除栈顶的元素。 top() – 获取栈顶元素。 getMin() – 检索栈中的最小元素。 Solution：","text":"155. 最小栈 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。 pop() – 删除栈顶的元素。 top() – 获取栈顶元素。 getMin() – 检索栈中的最小元素。 Solution： 123456789101112131415161718192021222324252627282930class MinStack &#123; public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; _data.push(x); // 更新当前的最小值状态。 if(_min.empty() || _min.top() &gt;= x )&#123; _min.push(x); &#125; &#125; void pop() &#123; //如果是要弹出当前的最小值。将min中的值也一并弹出。 if(_data.top() == _min.top())&#123; _min.pop(); &#125; _data.pop(); &#125; int top() &#123; return _data.top(); &#125; int getMin() &#123; //返回最小栈的栈顶 return _min.top(); &#125; private: std::stack&lt;int&gt; _data; std::stack&lt;int&gt; _min;&#125;; 思路:原来想用一个变量来记录最小值，这在push的时候没什么问题，但是当执行pop操作的时候，就不知道怎么更新了。 所以需要将每次一更新最小值都记录下来。 使用另一个栈记录最小值的变更状态。 每插入一个值，与之比较最小栈的栈顶的元素，如果比栈顶的元素小，就更新其状态，如果与栈顶元素相等，也需要插入。 当出栈的时候，如果与最小栈栈顶元素相等，最小栈也出栈。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 92. 反转链表 II","slug":"LeetCode-92-反转链表-II","date":"2019-01-01T14:32:44.000Z","updated":"2019-01-01T14:35:41.621Z","comments":true,"path":"2019/01/01/LeetCode-92-反转链表-II/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-92-反转链表-II/","excerpt":"92. 反转链表 II 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 ###Solution：","text":"92. 反转链表 II 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 ###Solution： 1234567891011121314151617181920212223242526272829struct ListNode* reverseBetween(struct ListNode* head, int m, int n) &#123; int chang_len = n-m+1;//逆置的结点个数。 struct ListNode* prevHead = NULL;//记录开始逆置结点的前驱。 struct ListNode* result = head;//用于最后返回。 while(head &amp;&amp; --m)&#123; //到达开始逆置的位置。 prevHead = head; head = head-&gt;next; &#125; struct ListNode * modify_list_tail = head;//将该结点之前当前开始逆置的结点。 struct ListNode * newHead = NULL;//用于逆置结点。 while(head &amp;&amp; chang_len)&#123; struct ListNode * next = head-&gt;next; head-&gt;next = newHead; newHead = head; head = next; chang_len--; &#125; //此时head就到了n处，modify_list_tail就到了逆置段的最后一个结点。 //将modify_list_tail 与 head连接。 modify_list_tail-&gt;next = head; if(prevHead)&#123; //如果prevHead不为空，说明不是从第一个几点开始逆置的。 m &gt; 1。 prevHead-&gt;next = newHead; &#125;else&#123; result = newHead; //如果prevHead为空， 则说明是从第一个就开始逆置，直接将逆置后的头结点赋值给res，m=1。 &#125; return result;&#125; 思路：解决这个问题主要是要找关键节点。 这个题的关键节点为： 要逆置的结点的前一个结点（prevHead）。 要逆置的第一个结点。（直接用head来探测）。 要逆置的最后一个结点。（此结点为逆置前的第一个结点，逆置后就变为了最后一个结点） 要逆置的最后一个结点的后一个结点。（在用head逆置后，head就到了逆置后的这个结点。） 找到前两个结点。 从m开始，到n，一共需要n-m+1个结点需要逆置。所以要逆置n-m+1次。 将逆置后的尾结点 与 逆置段后面一个结点相连。 如果结点是从开始逆置，将逆置后的头结点返回。否则，将前面的结点与逆置后的头结点链接返回。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 160. 相交链表","slug":"LeetCode-160-相交链表","date":"2019-01-01T14:26:20.000Z","updated":"2019-01-01T14:26:59.967Z","comments":true,"path":"2019/01/01/LeetCode-160-相交链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-160-相交链表/","excerpt":"160. 相交链表 Solution1：","text":"160. 相交链表 Solution1： 1234567891011121314151617class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; std::set&lt;ListNode*&gt; node_set; while(headA)&#123; node_set.insert(headA); headA = headA-&gt;next; &#125; while(headB)&#123; if(node_set.find(headB)!=node_set.end())&#123; return headB; &#125; headB = headB-&gt;next; &#125; return NULL; &#125;&#125;; 思路：这种思路很简单。就是先将链表A的每个元素存入set中，在链表B的元素逐个去set中查找。找到就返回。缺点：使用了O(n)的空间。 Solution2：1234567891011121314151617181920212223242526272829303132333435363738394041//获得链表的长度。int get_list_length(ListNode * head)&#123; int len = 0; while(head)&#123; head = head-&gt;next; len++; &#125; return len;&#125;//将长的链表移动多余的步数；以致两个链表到了相等的长度。ListNode* forward_long_list(int long_len, int short_len, ListNode* head)&#123; int step = long_len-short_len; while(head &amp;&amp; step)&#123; head = head-&gt;next; step--; &#125; return head;&#125;class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; int headA_len = get_list_length(headA); int headB_len = get_list_length(headB); //先移动较长的链表至两个链表的长度相等。 if(headA_len&gt;headB_len)&#123; headA = forward_long_list(headA_len,headB_len,headA); &#125;else&#123; headB = forward_long_list(headB_len,headA_len,headB); &#125; //再同时开始移动。如果这两个结点相等了，就找到了 while(headA &amp;&amp; headB)&#123; if(headA == headB)&#123; return headA; &#125; headA = headA-&gt;next; headB = headB-&gt;next; &#125; return NULL; &#125;&#125;; 思路：由于后面的结点是两个链表共享的，所以链表在相交结点之前有可能长度不相等。 我们先将长的链表移动到与短链表相同的长度，然后两个链表同时移动，当两个结点变得相同时，就得到了相同结点。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 141. 环形链表","slug":"LeetCode-141-环形链表","date":"2018-12-30T07:55:13.000Z","updated":"2018-12-30T07:56:47.469Z","comments":true,"path":"2018/12/30/LeetCode-141-环形链表/","link":"","permalink":"https://yangzebin001.github.io/2018/12/30/LeetCode-141-环形链表/","excerpt":"141. 环形链表 题目描述：给定一个链表，判断链表中是否有环。Solution1:","text":"141. 环形链表 题目描述：给定一个链表，判断链表中是否有环。Solution1: 123456789101112131415class Solution &#123;public: bool hasCycle(ListNode *head) &#123; std::set&lt;ListNode*&gt; node_set; while(head)&#123; if(node_set.find(head) == node_set.end())&#123; node_set.insert(head); &#125;else&#123; return true; &#125; head = head-&gt;next; &#125; return false; &#125;&#125;; 思路：使用set。将每一个结点在set中检查，如果没有，就插入该结点。如果找到了，就说明有环。如果到头了，说明没环，返回false； 该方法由于使用了set，所以空间复杂度为O(n); Solution2：1234567891011121314151617bool hasCycle(struct ListNode *head) &#123; struct ListNode *slow = head; struct ListNode *fast = head; while(fast)&#123; slow = slow-&gt;next; fast = fast-&gt;next; if(fast)&#123; fast = fast-&gt;next; &#125;else&#123; return false; &#125; if(slow == fast)&#123; return true; &#125; &#125; return false;&#125; 思路：使用双指针。用两个移动速度快慢不相同的指针来判断是否有环。如果有环，两个指针终会相遇，返回true。 由于快指针一定在慢指针的前面，所以在移动指针时，只要判断快指针是否为空，如果是，就说明没有环。返回false；","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 234.回文链表","slug":"leetcode-234-回文链表","date":"2018-12-30T07:44:12.000Z","updated":"2018-12-30T07:48:53.986Z","comments":true,"path":"2018/12/30/leetcode-234-回文链表/","link":"","permalink":"https://yangzebin001.github.io/2018/12/30/leetcode-234-回文链表/","excerpt":"234.回文链表 请判断一个链表是否为回文链表。Solution1：","text":"234.回文链表 请判断一个链表是否为回文链表。Solution1： 1234567891011121314151617181920212223242526272829303132333435//获得链表长度int getListLength(ListNode* head)&#123; int len = 0; while(head)&#123; head = head-&gt;next; len++; &#125; return len;&#125;class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; ListNode* head1 = head; int listlen = getListLength(head1); if(listlen &lt;= 1) return true; int mid = listlen/2; std::stack&lt;int&gt; s; while(mid &amp;&amp; head)&#123; s.push(head-&gt;val); head = head-&gt;next; mid--; &#125; if(listlen%2 != 0)&#123; head = head-&gt;next; &#125; while(head)&#123; if(head-&gt;val != s.top())&#123; return false; &#125; s.pop(); head = head-&gt;next; &#125; return true; &#125;&#125;; 思路:借助stack。 将mid之前的元素值都push进stack中，然后到mid之后，将每个元素与栈顶值比较。不相等退出，相等继续下一轮。 Solution2：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//获得链表长度int getListLength(ListNode* head)&#123; int len = 0; while(head)&#123; head = head-&gt;next; len++; &#125; return len;&#125;//根据位置与所给链表，向后移动position步。ListNode* getNodeByPosition(ListNode* head,int position)&#123; while(position&gt;0)&#123; head = head-&gt;next; position--; &#125; return head;&#125;class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; //存储头结点。 ListNode* first = head; ListNode* head1 = head; int listlen = getListLength(head); int midposition = listlen/2; //如果链表长度&lt;=1，直接返回true; if(listlen &lt;= 1) return true; //到达需要翻转的长度，对于偶数，为（listlen/2）+1，对于奇数，为listlen/2; ListNode* mid = getNodeByPosition(head1,midposition); //翻转mid之后的指针。 ListNode * newHead = NULL; int position = listlen-midposition; while(mid &amp;&amp; position)&#123; ListNode* next = mid-&gt;next; mid-&gt;next = newHead; newHead = mid; mid = next; position--; &#125; //将翻转之后的链表与开头的链表的内容比较，向后比较listlen/2; //如果是偶数，则元素都会比较到，如果是奇数，最后一个元素不会比较到。他在原来的链表中就处于中心位置，不必比较。 while(first &amp;&amp; newHead &amp;&amp; midposition)&#123; //只要不相等，就为false; if(first-&gt;val != newHead-&gt;val) return false; first = first-&gt;next; newHead = newHead-&gt;next; midposition--; &#125; return true; &#125;&#125;; 思路：将链表的后半段翻转，从翻转位置开始与从头结点开始，依次比较（listlen/2次）。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 142. 环形链表 II","slug":"leetcode-142-环形链表-II","date":"2018-12-30T07:27:57.000Z","updated":"2018-12-30T07:44:41.534Z","comments":true,"path":"2018/12/30/leetcode-142-环形链表-II/","link":"","permalink":"https://yangzebin001.github.io/2018/12/30/leetcode-142-环形链表-II/","excerpt":"142. 环形链表 II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。","text":"142. 环形链表 II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 Solution1:123456789101112131415class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; std::set&lt;ListNode*&gt; node_set; while(head)&#123; if(node_set.find(head) == node_set.end())&#123; node_set.insert(head); &#125;else&#123; return head; &#125; head = head-&gt;next; &#125; return NULL; &#125;&#125;; 与141号问题的Solutions1一个思路，直接使用set。只不过返回的是结点不是boolean值罢了。 Solutions2:123456789101112131415161718192021222324252627282930313233class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; ListNode * head1 = head; ListNode * slow = head; ListNode * fast = head; //fast走一步，slow走两步 while(fast)&#123; slow = slow-&gt;next; fast = fast-&gt;next; if(fast)&#123; fast = fast-&gt;next; &#125;else&#123; //没有环退出 return NULL; &#125; //有环退出循环 if(fast == slow)&#123; break; &#125; &#125; //说明有环 while(head1 &amp;&amp; fast)&#123; if(head1 == fast)&#123; return fast; &#125; head1 = head1-&gt;next; fast = fast-&gt;next; &#125; //不会走到这步，只是为了保证函数正常运行 return NULL; &#125;&#125;; 思路：这种方法只会使用O(1)的空间。 该方法的思路需要一点数学基础： 在一个有环的链表中，slow指针与fast指针相遇，从该相遇的位置开始，与链表的头位置开始，两者走同样的步数，如果两者相交，就走到了环的开始位置。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"读书简录","slug":"reading-note","date":"2018-12-02T08:44:00.000Z","updated":"2018-12-02T01:27:53.823Z","comments":true,"path":"2018/12/02/reading-note/","link":"","permalink":"https://yangzebin001.github.io/2018/12/02/reading-note/","excerpt":"2017/09/01 《挪威的森林》《如何高效学习》《极简主义》","text":"2017/09/01 《挪威的森林》《如何高效学习》《极简主义》 《潜规则》 吴思《旋元佑进阶文法》2017/10/20 《遇见未知的自己》2017/11/10 《响应式WEB设计》《HTML5与CSS3基础教程》2017/12/12 《JavasrciptDOM编程艺术》2017/12/25 《Javascript高级程序设计》（第三版）2018/01/18 《明朝那些事》2018/01/21 《版式设计原理与应用》2018/03/28 《给青年的十二封信》朱光潜2018/04/28 《富爸爸穷爸爸》2018/06/22 《计算机学科概论》2018/07/09 《烟火人间》老舍2018/07/26 《C程序设计（第四版）》谭浩强2018/09/13 《算法图解》《浪潮之巅》2018/10/13 《数学之美》2018/10/25 《黑客与画家》2018/11/15 《c指针》2018/11/23 《沉默的大多数》王小波2018/11/25","categories":[],"tags":[{"name":"读书","slug":"读书","permalink":"https://yangzebin001.github.io/tags/读书/"}]},{"title":"一文学会Git","slug":"一文学会git","date":"2018-10-03T08:44:00.000Z","updated":"2018-10-05T14:10:57.810Z","comments":true,"path":"2018/10/03/一文学会git/","link":"","permalink":"https://yangzebin001.github.io/2018/10/03/一文学会git/","excerpt":"一、GIT下载、安装与配置1.下载与安装下载git只需要直接在官网下载就可以了，它会自动下载适合你电脑配置的版本。 官网 安装就一直下一步就可以了。","text":"一、GIT下载、安装与配置1.下载与安装下载git只需要直接在官网下载就可以了，它会自动下载适合你电脑配置的版本。 官网 安装就一直下一步就可以了。 2.配置安装完成之后右键菜单就会自动添加两个选项： Git GUI Git Bash 在任意目录下右键点击 Git Bash 打开Git 命令行，输入一下两条命令： 123git config --global user.name &quot;USERNAME&quot;git config --global user.email &quot;xxx@xx.com&quot; “USERNAME”填写你的用户名“xxx@xx.com”填写你的邮箱 这样配置完后你之后所创建的仓库都会默认创建在你的名下。 查看你的配置，输入下面的命令： 1git config --list 其中有两条条目为user.name和user.email即为你所配置的。 二、Git基本操作1、新建仓库进入一个你要进行Git的目录（通常是你的工程目录）然后在右键菜单中进入Git Bash，键入命令： 1git init 它会在当前目录下创建一个.git的隐藏文件夹用来保存与git操作有关的相关信息。 2、向仓库暂存区里添加文件1git add FILENAME 命令可以将文件添加到你所创建的仓库的暂存区中。 关于add命令有俩点需要注意： 1.add现在还没有真正添加到仓库中，而是作为预备项来决定是否最终添加到仓库中。 2.这里的添加文件并不是你所在仓库的文件有了这个文件就可以了。仓库创建好后并不等于你所在文件夹中的所有文件也同样包含于仓库中，你需要手动告诉Git你要添加当前目录下的哪些文件到它的仓库中。 你可以用以下命令来将所在文件夹下属的所有文件或者文件夹添加到暂存区中：123git add --all/-Aorgit add * 3、向仓库中提交文件我们已经把文件添加到了暂存区，那么怎样让文件真正进去仓库呢？用commit命令： 1git commit -m &quot;you need to record something&quot; 这个命令可以让你将暂存区中的文件添加到仓库中。 -m 选项是必选项，它需要你在提交时给他一下信息用于记录你的提交的原因。当然我们也提倡这样做。 4、一次性从工作区提交到仓库中有时候修改完文件要提交仓库中，要先添加到暂存区后再提交，很麻烦怎么办？给 git commit 加上 -a 选项： 1git commit -a -m &quot;say something&quot; 5、查看git状态不知道你的文件现在处于未跟踪状态还是处在暂存区，或者是一提交状态？用status命令： 1git status 它会告诉你当前文件夹中的文件的状态和分支情况。 6、从暂存区或仓库中移除文件如果你想删除一个文件，但是已经将它放入了暂存区中，如何去删除暂存区中的文件呢？先将本地文件删除，再使用下面的命令：1git rm FILENAME 就可以将暂存区中的文件移除了。当然，直接一同删除本地文件和暂存区文件也可以，添加 -f 选项。 那如果已经提交到仓库中了怎么办？从仓库中删除文件可以在上条命令的基础上添加–cached选项。 注意：如果之前你的本地目录中有该文件，从仓库中删除并不会把本地文件一并删除，所删除的文件在本地中会重新变为未跟踪状态。 那么我不想删除本地文件，又不想把它提交到仓库中，该怎么办呢？ 7、添加忽略列表可以在本地目录中添加一个名为 .gitignore 的文件，用来记录哪些文件需要被忽略。直接在.gitignore文件中添加你不想被跟踪的文件即可。 github上有一个项目列举了各种忽略列表：ignore 8、重命名文件你可以中暂存区和仓库中修改文件的名字。使用下面的命令： 1git mv FILE_FROM FILE_TO 实际上，git并不会直接将名字修改，mv命令相当于下面三条命令： 123mv README.md READMEgit rm README.mdgit add README 9、查看提交历史在提交了若干更新，又或者克隆了某个项目之后，如果查看提交历史呢？使用下面的命令：1git log 它会按照时间线（由近及远）列出你的提交历史，包括SHA-1 校验、日期、提交者以及提交说明。 log命令有很多选项，他可以满足你的各种查看需求： -p，用来显示每次提交的内容差异。 你也可以加上 -NUMBER 来仅显示最近两次提交：例如：1git log -p -2 来查看近俩次提交之间的差异。 –stat选项可以看到每次提交的简略的统计信息。 –pretty选项可以指定不同的显示格式。 其下有各种子选项：short、oneline、full、fuller、format等。 使用如下：1git log --pretty=oneline 会将每次提交在各自独自的一行中显示。 pretty选项中的format选项可以自定义选项格式：例如：1git log --pretty=format:&quot;%h - %an, %ar : %s&quot; 完成的选项如下图： 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 –date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者（committer）的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 –graph 显示 ASCII 图形表示的分支合并历史。 下面列举了一些常见的log下的选项： 选项 说明 -p 按补丁格式显示每个更新之间的差异。 –stat 显示每次更新的文件修改统计信息。 –shortstat 只显示 –stat 中最后的行数修改添加移除统计。 –name-only 仅在提交信息后显示已修改的文件清单。 –name-status 显示新增、修改、删除的文件清单。 –abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 –relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。 –graph 显示 ASCII 图形表示的分支合并历史。 –pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 你还可以限制输出的长度，包括按条目个数、时间和提交者等。这里就不一一列举了，需要的时候查一下即可。 10、回滚版本接下来我们学习git最核心的操作————回滚。我们学会了通过git log 来查看提交信息，会发现每次commit之后都有一串数字和字母的组合，而这串字符串是系统自动生成的唯一的代表了这次提交请求的一个ID，我们可以通过这串字符串来任意回滚到之前某一次提交上去。例如：1git checkout 9643a881f 将回退到这串字符串所代表的那次提交的状态上。 回滚的时候，并不需要将整个字符串都复制下来，从开头的一部分去截取也是可以的。 11、撤销操作（1）撤销提交后的操作当我们提交到了仓库文件以后，发现有一些文件漏添加了，或者提交信息写错了，这时就需要撤销操作。 先将你需要的文件添加到暂存区，然后使用下面的命令：1git commit --amend -m &quot;say something&quot; 来覆盖你之前的那次提交，之前的那次提交不会出现在你提交的历史中。也就是说最终你只用最后一次的提交结果。 （2）撤销暂存区中的操作如果不小心把不想放入暂存区的文件放入了暂存区，那么如何来撤销暂存区中的记录呢？使用下面的命令：1git reset HEAD FILENAME 执行之后你会发现原本在暂存区中的文件，已经变成 了未跟踪状态。 （3）撤销已修改文件的操作如果你修改了文件，却想撤回。此时文件并没有放入暂存区中，只是单纯的在工作环境中做了修改，那该怎么撤销呢？ 其实git status命令已经告诉你了： 123Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) 我们来使用下： 1git checkout --FIIENAME 这时你发现原本修改过的操作变成了之前未更改的状态。 12、给Git起别名如果不想使用Git本身的起名方式，那么可以通过起别名的方式来替换到Git默认的命令：1git config --global alias.ci commit 会将commit命令替换为ci，下次提交时，只要输入git ci就ok了。 当然，你也可以将常用的组合命令替换为一个命令：1git config --global alias.last &apos;log -1 HEAD&apos; 输入git last将会看到最后一次提交。 三、标签管理Git可以给历史中的某一次提交打上一个标签，用来标识这次提交，它相当于那次提交的引用，同样可以使用标签来回滚到所代表的提交。 1、创建标签如何在当前提交上打标签呢？使用下面的命令： 1git tag -a v1.9 -m &quot;some message&quot; -a选项表示创建一个新的标签。 -m和commit命令中的一样，为必填项，为标签添加一些注释。 还有一种轻量打标签的方式：1git tag v1.1.1 这种不需要选项而直接给当前的提交打上标签。 4、查看标签使用下面的命令来查看所有标签：1git tag 当然，在log命令中，你打的标签也会出现在提交的右边。 你也可以加-l 来进行特定的模式查找标签：1git tag -l v1.* 将列出tags中以v1.开头的标签。 你也可以查看某一标签所代表的提交，使用下面的命令： 1git show v1.1 将显示打标签者，标签信息，时间和哪一次提交。 5、给之前的提交打标签如何给之前的提交打标签呢？只要看一下那次提交的ID字符串就可以了：1git tag -a v1.2 9fceb02 将会给那次提交打上一个标签。 6、给远程仓库打标签由于默认情况下，git push命令不会将标签传输到远程仓库，你需要显示的将标签传送到远程仓库中：1git push origin TAGNAME 当然如果想传送的标签很多，可以使用带有–tags选项将所有标签全部传送到远程仓库中。 四、使用远程仓库我相信有相当大的一部分人，是想学习github的使用，之后才了解到了Git。这两者不是一种东西，git和github的关系，相当于球与球场的关系。git创建的是本地仓库，而github上存放了好多远程的仓库。这些仓库都是用户将自己的仓库上传到服务器上，让github来托管这些仓库。那么如何建立远程仓库以及让本地仓库与远程仓库关联起来呢？ 1、","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://yangzebin001.github.io/tags/Git/"}]},{"title":"makedown","slug":"2018-01-26-fjlskadjfgla","date":"2018-01-26T09:56:16.000Z","updated":"2018-01-26T10:11:45.499Z","comments":true,"path":"2018/01/26/2018-01-26-fjlskadjfgla/","link":"","permalink":"https://yangzebin001.github.io/2018/01/26/2018-01-26-fjlskadjfgla/","excerpt":"欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：","text":"欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://yangzebin001.github.io/tags/html/"},{"name":"JS","slug":"JS","permalink":"https://yangzebin001.github.io/tags/JS/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-25T11:15:35.791Z","updated":"2018-10-03T08:41:19.276Z","comments":true,"path":"2018/01/25/hello-world/","link":"","permalink":"https://yangzebin001.github.io/2018/01/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}