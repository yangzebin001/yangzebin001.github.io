{"meta":{"title":"BeckoninGshy's Blog","subtitle":null,"description":"Welcome to BeckoninGshy's Blog.","author":"yangzebin","url":"https://yangzebin001.github.io"},"pages":[{"title":"about","date":"2019-01-31T10:14:50.000Z","updated":"2019-01-31T11:00:04.413Z","comments":true,"path":"about/index.html","permalink":"https://yangzebin001.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-31T10:14:34.000Z","updated":"2019-01-31T10:15:23.630Z","comments":true,"path":"tags/index.html","permalink":"https://yangzebin001.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"1111-Test","slug":"1111-Test","date":"2020-04-01T05:21:38.000Z","updated":"2020-08-08T09:57:52.001Z","comments":true,"path":"2020/04/01/1111-Test/","link":"","permalink":"https://yangzebin001.github.io/2020/04/01/1111-Test/","excerpt":"Max Sum Plus Plus 题目描述加点东西Now I think you have got an AC in Ignatius.L’s “Max Sum” problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem. Given a consecutive number sequence S1, S2, S3, S4 … Sx, … Sn (1 ≤ x ≤ n ≤ 1,000,000, -32768 ≤ Sx ≤ 32767). We define a function sum(i, j) = Si + … + Sj (1 ≤ i ≤ j ≤ n). Now given an integer m (m &gt; 0), your task is to find m pairs of i and j which make sum(i1, j1) + sum(i2, j2) + sum(i3, j3) + … + sum(im, jm) maximal (ix ≤ iy ≤ jx or ix ≤ jy ≤ jx is not allowed). But I`m lazy, I don’t want to write a special-judge module, so you don’t have to output m pairs of i and j, just output the maximal summation of sum(ix, jx)(1 ≤ x ≤ m) instead. ^_^","text":"Max Sum Plus Plus 题目描述加点东西Now I think you have got an AC in Ignatius.L’s “Max Sum” problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem. Given a consecutive number sequence S1, S2, S3, S4 … Sx, … Sn (1 ≤ x ≤ n ≤ 1,000,000, -32768 ≤ Sx ≤ 32767). We define a function sum(i, j) = Si + … + Sj (1 ≤ i ≤ j ≤ n). Now given an integer m (m &gt; 0), your task is to find m pairs of i and j which make sum(i1, j1) + sum(i2, j2) + sum(i3, j3) + … + sum(im, jm) maximal (ix ≤ iy ≤ jx or ix ≤ jy ≤ jx is not allowed). But I`m lazy, I don’t want to write a special-judge module, so you don’t have to output m pairs of i and j, just output the maximal summation of sum(ix, jx)(1 ≤ x ≤ m) instead. ^_^ 输入Each test case will begin with two integers m and n, followed by n integers S1, S2, S3 … Sn.Process to the end of file. 输出Output the maximal summation described above in one line. 输入示例1 3 1 2 32 6 -1 4 -2 3 -2 3 输出示例68 Hint Huge input, scanf and dynamic programming is recommended. 题目大意：给定n个数，让其划分为k个不重叠的区间（不要求连续），求其中的最大值。 思路：因为给定一个区间，它的最大值是确定的，所以具有无后效性，所以我们考虑使用dp来解此题。 我们首先定义状态表示，很自然的想到： 1dp[i][j] = dp[i][j] 表示将前i个数字分成j段的最大子段和。 接下来考虑状态转移方程： 我们将状态转移分为： 与前面划分的区间不合并，即自成一组。 与前面划分的区间合并为一组。 第二种转移方程比较好考虑： 1dp[i][j] = dp[i-1][j] + v[i]; 自成一组需要找上一组从哪里转移。由于不需要保证连续性，所以就需要从第一段一直到j-1段都要考虑到。 1dp[i][j] = max&#123;dp[k][j-1](1 &lt;= k &lt; i)&#125; 由于只有k个长度的字符才能分成k段。所以这里取值范围应该改为: 1dp[i][j] = max&#123;dp[k][j-1](j-1 &lt;= k &lt; i)&#125; + v[i] 综合一下就是： 1dp[i][j] =max( dp[i-1][j], max&#123;dp[k][j-1](j-1 &lt;= k &lt; i)&#125; ) + v[i] 分析工作准备完毕，我们准备写代码时发现，这个数组范围比较大，会O（n2）的算法会超时，所以要优化。 第二种转移方程没什么好优化的，我们转移到第一种上，它在转移上依赖了他之上的好多行的数组，列却只依赖一列。这里想象为二维数组，我们把行，列的含义互换，想象这个二维数组逆时针旋转了90度。就得到了如下的转移方程： 1dp[i][j] = dp[i][j] 表示将前j个数字分成i段的最大子段和。 1dp[i][j] =max( dp[i][j-1], max&#123;dp[i-1][k](i-1 &lt;= k &lt; j)&#125; ) + v[j] 我们可以将 max{dp[i-1]k} 这个O(n)的时间，在上一层的d[i-1][j]计算结果时用一个变量来记录，使其优化为O(1)。 具体编程还是有些难度，需要好好思考。 12345678910111213141516171819202122232425262728293031323334353637/* * @Date: 2020-01-24 10:42:12 * @LastEditors : BeckoninGshy * @LastEditTime : 2020-01-25 11:37:00 */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN =1e6+10;int dp[MAXN],v[MAXN],numax[MAXN]; //保存上一层dp的最大值。int main()&#123; int k,n; while(cin &gt;&gt; k &gt;&gt; n)&#123; for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; v[i]; dp[i] = numax[i] = 0; &#125; dp[0] = numax[0] = 0; int lastmax = INT_MIN; for(int i = 1; i &lt;= k; i++)&#123; lastmax = INT_MIN; //保存上一层dp的最大值 for(int j = i; j &lt;= n; j++)&#123; //先利用之前的上一层最大值更新当前状态， dp[j] = max(dp[j-1],numax[j-1]) + v[j]; //再将j-1的最大值更新到上一层的最大值数组中， 将在i+1层循环中使用，当前循环不使用 numax[j-1] = lastmax; //存储当前层的最大值 lastmax = max(lastmax,dp[j]); &#125; &#125; cout &lt;&lt; lastmax &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-5. 最长回文子串（待补充）","slug":"LeetCode-5-最长回文子串（待补充）","date":"2019-03-16T12:46:42.000Z","updated":"2019-03-16T12:49:16.804Z","comments":true,"path":"2019/03/16/LeetCode-5-最长回文子串（待补充）/","link":"","permalink":"https://yangzebin001.github.io/2019/03/16/LeetCode-5-最长回文子串（待补充）/","excerpt":"5. 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。示例 1： 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。","text":"5. 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。示例 1： 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2： 12输入: &quot;cbbd&quot;输出: &quot;bb&quot; Solution1：123456789101112131415161718192021222324252627class Solution &#123;public: int expandAroundCenter(string s, int left, int right)&#123; int L = left, R = right; while(L &gt;= 0 &amp;&amp; R &lt; s.size() &amp;&amp; s[L] == s[R])&#123; L--; R++; &#125; return R - L - 1; &#125; string longestPalindrome(string s) &#123; if( s.size() &lt; 1) return \"\"; int start = 0, end = 0; for(int i = 0; i &lt; s.size(); i++)&#123; //以i为中心点开始探测。 int len1 = expandAroundCenter(s,i,i); //以i与i+1位置的之间开始探测。 int len2 = expandAroundCenter(s,i,i+1); int len = max(len1,len2); if(len &gt; end-start)&#123; start = i - (len-1)/2; end = i + len/2; &#125; &#125; return s.substr(start,end-start+1); &#125;&#125;; 思路：只想到了O(n3)复杂度的暴力解法。看题解做的。 由于回文串的两侧互为镜像，所以可以从中心向两侧展开进行探测。一共会有2n-1个中心点（一个点为中心，两点之间也可以看作一个中点）。时间复杂度为O(n2);","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"字符串","slug":"字符串","permalink":"https://yangzebin001.github.io/tags/字符串/"}]},{"title":"LeetCode-105. 从前序与中序遍历序列构造二叉树（待补充）","slug":"LeetCode-105-从前序与中序遍历序列构造二叉树（待补充）","date":"2019-03-16T12:42:24.000Z","updated":"2019-03-16T12:49:34.384Z","comments":true,"path":"2019/03/16/LeetCode-105-从前序与中序遍历序列构造二叉树（待补充）/","link":"","permalink":"https://yangzebin001.github.io/2019/03/16/LeetCode-105-从前序与中序遍历序列构造二叉树（待补充）/","excerpt":"105. 从前序与中序遍历序列构造二叉树 根据一棵树的前序遍历与中序遍历构造二叉树。注意:你可以假设树中没有重复的元素。 例如，给出","text":"105. 从前序与中序遍历序列构造二叉树 根据一棵树的前序遍历与中序遍历构造二叉树。注意:你可以假设树中没有重复的元素。 例如，给出 1234前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 12345 3 / \\9 20 / \\ 15 7 Solution1（递归版）：1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; int s = 0; return buildNode(preorder, s, inorder, 0, inorder.size()-1); &#125; TreeNode* buildNode(vector&lt;int&gt;&amp; preorder, int &amp;preindex, vector&lt;int&gt;&amp; inorder, int start, int end)&#123; if(start &lt;= end)&#123; int inIndex = INT_MAX; for(int i = start; i &lt;= end; i++)&#123; if(inorder[i] == preorder[preindex]) &#123; inIndex = i; break; &#125; &#125; if(inIndex &lt; start || inIndex &gt; end) return NULL; TreeNode* node = new TreeNode(preorder[preindex++]); node-&gt;left = buildNode(preorder, preindex, inorder, start, inIndex-1); node-&gt;right = buildNode(preorder,preindex , inorder, inIndex+1, end); return node; &#125; return NULL; &#125;&#125;; 思路:在前序遍历中，根结点是第一个元素。在中序遍历中，根节点之前的元素都在根结点的左子树上。根节点之后的元素都在根节点的右子树上。对于其他的结点，与根节点构建的方式一样。所以可以使用递归。 所以重点就是找到根节点在中序遍历中的位置。 每次找到前序遍历中的一个结点，在中序遍历中找到该结点的位置，建立该结点。然后给该结点之下的结点（子树）划分区域。继续递归下去，直到区域缩小为0为止。 Solution2（迭代版）:","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://yangzebin001.github.io/tags/二叉树/"}]},{"title":"LeetCode-958. 二叉树的完全性检验（待补充）","slug":"LeetCode-958-二叉树的完全性检验（待补充）","date":"2019-03-16T12:41:05.000Z","updated":"2019-03-16T12:48:44.160Z","comments":true,"path":"2019/03/16/LeetCode-958-二叉树的完全性检验（待补充）/","link":"","permalink":"https://yangzebin001.github.io/2019/03/16/LeetCode-958-二叉树的完全性检验（待补充）/","excerpt":"958. 二叉树的完全性检验 给定一个二叉树，确定它是否是一个完全二叉树。若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）","text":"958. 二叉树的完全性检验 给定一个二叉树，确定它是否是一个完全二叉树。若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。） Solution1（迭代版）：1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isCompleteTree(TreeNode* root) &#123; bool havenullnode = false; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; TreeNode* node = q.front(); q.pop(); if(!node)&#123; havenullnode = true; &#125;else&#123; if(havenullnode) return false; q.push(node-&gt;left); q.push(node-&gt;right); &#125; &#125; return true; &#125;&#125;; 思路：使用层序遍历，完全二叉树的遍历结果为只要遇到了null结点，之后的结点也都为null结点，否则就不是完全二叉树。 Solution2（递归版）:","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://yangzebin001.github.io/tags/二叉树/"}]},{"title":"LeetCode-34. 在排序数组中查找元素的第一个和最后一个位置","slug":"LeetCode-34-在排序数组中查找元素的第一个和最后一个位置","date":"2019-03-02T11:11:33.000Z","updated":"2019-03-02T14:24:09.928Z","comments":true,"path":"2019/03/02/LeetCode-34-在排序数组中查找元素的第一个和最后一个位置/","link":"","permalink":"https://yangzebin001.github.io/2019/03/02/LeetCode-34-在排序数组中查找元素的第一个和最后一个位置/","excerpt":"34. 在排序数组中查找元素的第一个和最后一个位置 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。","text":"34. 在排序数组中查找元素的第一个和最后一个位置 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。示例 1: 12输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例 2: 12输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] Solution：1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res; res.push_back(left_bound(nums,target)); res.push_back(right_bound(nums,target)); return res; &#125; int left_bound(vector&lt;int&gt; &amp; nums, int target)&#123; int lo = 0; int hi = nums.size()-1; while(lo &lt;= hi)&#123; int mid = (lo + hi)/2; if(nums[mid] == target)&#123; if(mid == 0 || nums[mid-1] &lt; target) return mid; hi = mid-1; &#125;else if(nums[mid] &lt; target)&#123; lo = mid +1; &#125;else&#123; hi = mid -1; &#125; &#125; return -1; &#125; int right_bound(vector&lt;int&gt; &amp; nums, int target)&#123; int lo = 0; int hi = nums.size()-1; while(lo &lt;= hi)&#123; int mid = (lo + hi)/2; if(nums[mid] == target &amp;&amp; (mid == nums.size()-1 || nums[mid+1] &gt; target))&#123; return mid; &#125; else if(nums[mid] &lt;= target)&#123; lo = mid +1; &#125;else&#123; hi = mid -1; &#125; &#125; return -1; &#125;&#125;; 遍历两个函数，分别寻找左右界。 具体就是要找到最接近target值的位置。每次缩小范围。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二分查找","slug":"二分查找","permalink":"https://yangzebin001.github.io/tags/二分查找/"}]},{"title":"LeetCode-35. 搜索插入位置","slug":"LeetCode-35-搜索插入位置","date":"2019-03-02T11:10:13.000Z","updated":"2019-03-02T14:24:16.476Z","comments":true,"path":"2019/03/02/LeetCode-35-搜索插入位置/","link":"","permalink":"https://yangzebin001.github.io/2019/03/02/LeetCode-35-搜索插入位置/","excerpt":"35. 搜索插入位置 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。","text":"35. 搜索插入位置 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。示例 1: 12输入: [1,3,5,6], 5输出: 2 示例 2: 12输入: [1,3,5,6], 2输出: 1 示例 3: 12输入: [1,3,5,6], 7输出: 4 示例 4: 12输入: [1,3,5,6], 0输出: 0 Solution：12345678910111213141516class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int low = 0, high = nums.size()-1; while(low&lt;=high)&#123; int mid = (low+high)/2; if(nums[mid] == target) return mid; else if(nums[mid] &gt; target) high = mid-1; else low = mid+1; &#125; //当小于第一个元素时，low会停在0，hi会是-1； //当在数组区间时，low=hi在期望的位置。 //当大于最后一个元素是，low = nums.size(), hi = nums.size(); return low; &#125;&#125;; 二分的初步题。 要十分深刻的了解指针的运行状态才能写出简洁的代码。 比如自己写的最终版本： 1234567891011121314151617class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = 0; int hi = nums.size()-1; int mid; if(target &lt; nums[0]) return 0; while(lo &lt;= hi)&#123; mid = (lo + hi)/2; if(nums[mid] == target) return mid; else if(nums[mid] &lt; target) lo = mid+1; else if(nums[mid] &gt; target) hi = mid-1; &#125; return nums[hi] &gt; target ? hi : hi+1; &#125;&#125;; 没有上面的简洁。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二分查找","slug":"二分查找","permalink":"https://yangzebin001.github.io/tags/二分查找/"}]},{"title":"PAT《团体程序设计天梯赛-练习集》-L3-016 二叉搜索树的结构 （30 分）","slug":"PAT《团体程序设计天梯赛-练习集》-L3-016-二叉搜索树的结构-（30-分）","date":"2019-02-28T14:56:41.000Z","updated":"2019-02-28T14:57:44.146Z","comments":true,"path":"2019/02/28/PAT《团体程序设计天梯赛-练习集》-L3-016-二叉搜索树的结构-（30-分）/","link":"","permalink":"https://yangzebin001.github.io/2019/02/28/PAT《团体程序设计天梯赛-练习集》-L3-016-二叉搜索树的结构-（30-分）/","excerpt":"L3-016 二叉搜索树的结构 （30 分） 二叉搜索树或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。（摘自百度百科）","text":"L3-016 二叉搜索树的结构 （30 分） 二叉搜索树或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。（摘自百度百科） 给定一系列互不相等的整数，将它们顺次插入一棵初始为空的二叉搜索树，然后对结果树的结构进行描述。你需要能判断给定的描述是否正确。例如将{ 2 4 1 3 0 }插入后，得到一棵二叉搜索树，则陈述句如“2是树的根”、“1和4是兄弟结点”、“3和0在同一层上”（指自顶向下的深度相同）、“2是4的双亲结点”、“3是4的左孩子”都是正确的；而“4是2的左孩子”、“1和3是兄弟结点”都是不正确的。 输入格式：输入在第一行给出一个正整数N（≤100），随后一行给出N个互不相同的整数，数字间以空格分隔，要求将之顺次插入一棵初始为空的二叉搜索树。之后给出一个正整数M（≤100），随后M行，每行给出一句待判断的陈述句。陈述句有以下6种： A is the root，即”A是树的根”； A and B are siblings，即”A和B是兄弟结点”； A is the parent of B，即”A是B的双亲结点”； A is the left child of B，即”A是B的左孩子”； A is the right child of B，即”A是B的右孩子”； A and B are on the same level，即”A和B在同一层上”。题目保证所有给定的整数都在整型范围内。 输出格式：对每句陈述，如果正确则输出Yes，否则输出No，每句占一行。 Solution：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right; TreeNode(int x): val(x), left(NULL), right(NULL)&#123;&#125; &#125;;int rootval;void insertNode(TreeNode* root, int val)&#123; if(!root) return; if(root-&gt;val &gt; val)&#123; if(root-&gt;left)&#123; insertNode(root-&gt;left,val); &#125;else&#123; TreeNode* t = new TreeNode(val); root-&gt;left = t; &#125; &#125;else if(root-&gt;val &lt; val)&#123; if(root-&gt;right)&#123; insertNode(root-&gt;right,val); &#125;else&#123; TreeNode* t = new TreeNode(val); root-&gt;right = t; &#125; &#125;&#125;bool isContainNode(TreeNode* root, int val)&#123; if(!root) return false; if(root-&gt;val == val) return true; if(root-&gt;val &gt; val) return isContainNode(root-&gt;left,val); else return isContainNode(root-&gt;right,val);&#125;void printTree(TreeNode* root)&#123; if(!root) return; cout &lt;&lt; root-&gt;val &lt;&lt;\"\"; printTree(root-&gt;left); printTree(root-&gt;right);&#125;bool isRoot(int val)&#123; return val == rootval;&#125;TreeNode* parent(TreeNode *root, int child)&#123; if(!isContainNode(root,child) || root-&gt;val == child) return NULL; TreeNode* res = NULL; while(1)&#123; if(!root) return NULL; if((root-&gt;left &amp;&amp; root-&gt;left-&gt;val == child) || (root-&gt;right &amp;&amp; root-&gt;right-&gt;val == child))&#123; res = root; break; &#125;else if(root-&gt;val &gt; child)&#123; root = root-&gt;left; &#125;else if(root-&gt;val &lt; child)&#123; root = root-&gt;right; &#125; &#125; return res;&#125;bool isSibling(TreeNode* root, int valA, int valB)&#123; if(!root) return false; if(valA == root-&gt;val || valB == root-&gt;val) return false; //找到A的父亲 TreeNode* t = parent(root, valA); if(t)&#123; if(t-&gt;left &amp;&amp; t-&gt;left-&gt;val == valA )&#123; return t-&gt;right &amp;&amp; t-&gt;right-&gt;val == valB; &#125; else if(t-&gt;right &amp;&amp; t-&gt;right-&gt;val == valA )&#123; return t-&gt;left &amp;&amp; t-&gt;left-&gt;val == valB; &#125;else&#123; return false; &#125; &#125; return false;&#125;int getDepth(TreeNode* root, int val)&#123; if(root-&gt;val == val) return 0; if(root-&gt;val &gt; val) return 1 + getDepth(root-&gt;left,val); else return 1 + getDepth(root-&gt;right,val);&#125;bool isSameLevel(TreeNode* root, int A, int B)&#123;// A != B &amp;&amp; return isContainNode(root,A) &amp;&amp; isContainNode(root,B) &amp;&amp; getDepth(root, A) == getDepth(root, B);&#125;void pirntMassage(bool info)&#123; if(info)&#123; cout &lt;&lt; \"Yes\" &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; \"No\" &lt;&lt;endl; &#125;&#125;bool isParent(TreeNode* root, int parentVal, int childVal)&#123; if(parent(root, childVal) == NULL) return false; return parentVal == parent(root, childVal)-&gt;val;&#125;bool isLeftChild(TreeNode* root, int parentVal, int leftChildVal)&#123; if(parent(root, leftChildVal) == NULL) return false; TreeNode* p = parent(root, leftChildVal); return parentVal == p-&gt;val &amp;&amp; p-&gt;left-&gt;val == leftChildVal;&#125;bool isRightChild(TreeNode* root, int parentVal, int rightChildVal)&#123; if(parent(root, rightChildVal) == NULL) return false; TreeNode* p = parent(root, rightChildVal); return parentVal == p-&gt;val &amp;&amp; p-&gt;right-&gt;val == rightChildVal;&#125;int main()&#123; int c; cin &gt;&gt; c; if(c &lt;= 0) return 0; cin &gt;&gt; rootval; TreeNode* root = new TreeNode(rootval); for(int i = 1; i &lt; c; i++)&#123; int a; cin &gt;&gt; a; insertNode(root, a); &#125; cin &gt;&gt; c; getchar(); int rootV,siblingA,siblingB, parentv, childv,leftchildv,rightchildv,samelevelA,samelevelB; for(int i = 0 ; i &lt; c; i++)&#123; char state[100]; int q = 0; char ch; while((ch = getchar()) != '\\n') state[q++] = ch; state[q] = '\\0'; if(strstr(state,\"root\"))&#123; sscanf(state,\"%d is the root\",&amp;rootV); pirntMassage(isRoot(rootV)); &#125;else if(strstr(state,\"siblings\"))&#123; sscanf(state,\"%d and %d are siblings\",&amp;siblingA,&amp;siblingB); pirntMassage(isSibling(root,siblingA,siblingB)); &#125;else if(strstr(state,\"same\"))&#123; sscanf(state,\"%d and %d are on the same level\",&amp;samelevelA,&amp;samelevelB); pirntMassage(isSameLevel(root,samelevelA,samelevelB)); &#125;else if(strstr(state,\"parent\"))&#123; sscanf(state,\"%d is the parent of %d\",&amp;parentv,&amp;childv); pirntMassage(isParent(root,parentv,childv)); &#125;else if(strstr(state,\"left\"))&#123; sscanf(state,\"%d is the left child of %d\",&amp;leftchildv,&amp;parentv); pirntMassage(isLeftChild(root,parentv,leftchildv)); &#125;else if(strstr(state,\"right\"))&#123; sscanf(state,\"%d is the right child of %d\",&amp;rightchildv,&amp;parentv); pirntMassage(isRightChild(root,parentv,rightchildv)); &#125; &#125;// pirntMassage(isRoot(2));// pirntMassage(isSibling(root,1,1));// pirntMassage(isSameLevel(root, 0,3));// pirntMassage(isParent(root, 3,0));// pirntMassage(isLeftChild(root, 2,1));// pirntMassage(isRightChild(root, 2,4)); return 0;&#125; 第一次写这么多功能的代码，很考验耐力。没什么大的难点，注意考虑代码的重用性。 第一次用sscanf，还不太熟。 有一坑：它认为 3 and 3 are on the same level。我开始写的时候，直接把这种情况否定掉了。看来盲目做条件判断也不是好事。","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://yangzebin001.github.io/tags/二叉树/"},{"name":"PAT","slug":"PAT","permalink":"https://yangzebin001.github.io/tags/PAT/"}]},{"title":"PAT《团体程序设计天梯赛-练习集》-L3-010 是否完全二叉搜索树 （30 分）","slug":"PAT《团体程序设计天梯赛-练习集》-L3-010-是否完全二叉搜索树-（30-分）","date":"2019-02-27T09:57:50.000Z","updated":"2019-02-27T10:06:09.562Z","comments":true,"path":"2019/02/27/PAT《团体程序设计天梯赛-练习集》-L3-010-是否完全二叉搜索树-（30-分）/","link":"","permalink":"https://yangzebin001.github.io/2019/02/27/PAT《团体程序设计天梯赛-练习集》-L3-010-是否完全二叉搜索树-（30-分）/","excerpt":"L3-010 是否完全二叉搜索树 （30 分） 将一系列给定数字顺序插入一个初始为空的二叉搜索树（定义为左子树键值大，右子树键值小），你需要判断最后的树是否一棵完全二叉树，并且给出其层序遍历的结果。输入格式：输入第一行给出一个不超过20的正整数N；第二行给出N个互不相同的正整数，其间以空格分隔。 输出格式：将输入的N个正整数顺序插入一个初始为空的二叉搜索树。在第一行中输出结果树的层序遍历结果，数字间以1个空格分隔，行的首尾不得有多余空格。第二行输出YES，如果该树是完全二叉树；否则输出NO。 输入样例1：12938 45 42 24 58 30 67 12 51 输出样例1：1238 45 24 58 42 30 12 67 51YES","text":"L3-010 是否完全二叉搜索树 （30 分） 将一系列给定数字顺序插入一个初始为空的二叉搜索树（定义为左子树键值大，右子树键值小），你需要判断最后的树是否一棵完全二叉树，并且给出其层序遍历的结果。输入格式：输入第一行给出一个不超过20的正整数N；第二行给出N个互不相同的正整数，其间以空格分隔。 输出格式：将输入的N个正整数顺序插入一个初始为空的二叉搜索树。在第一行中输出结果树的层序遍历结果，数字间以1个空格分隔，行的首尾不得有多余空格。第二行输出YES，如果该树是完全二叉树；否则输出NO。 输入样例1：12938 45 42 24 58 30 67 12 51 输出样例1：1238 45 24 58 42 30 12 67 51YES 输入样例2：12838 24 12 45 58 67 42 51 输出样例2：1238 45 24 58 42 12 67 51NO 一道考察二叉树插入方法例程，层序遍历，判断是否为一棵完全二叉树的综合题。 Solution：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;struct TreeNode&#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;; void insertNode(TreeNode* root, int val)&#123; if(root == NULL)&#123; return; &#125; if(root-&gt;val &lt; val)&#123; if(root-&gt;left == NULL)&#123; TreeNode* now = new TreeNode(val); root-&gt;left = now; &#125;else&#123; insertNode(root-&gt;left, val); &#125; &#125;else if(root-&gt;val &gt; val)&#123; if(root-&gt;right == NULL)&#123; TreeNode* now = new TreeNode(val); root-&gt;right = now; &#125;else&#123; insertNode(root-&gt;right, val); &#125; &#125;&#125;void levelOrder(TreeNode* root)&#123; queue&lt;TreeNode*&gt; q; q.push(root); bool isfirst = true; while(!q.empty())&#123; TreeNode* node = q.front(); q.pop(); if(isfirst)&#123; cout &lt;&lt; node-&gt;val; isfirst = false; &#125;else&#123; cout &lt;&lt; \" \" &lt;&lt; node-&gt;val; &#125; if(node-&gt;left) &#123; q.push(node-&gt;left); &#125; if(node-&gt;right) &#123; q.push(node-&gt;right); &#125; &#125;&#125;bool isCST(TreeNode* root)&#123; bool leaf = false; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; TreeNode* node = q.front(); q.pop(); if(node-&gt;right &amp;&amp; !node-&gt;left) return false; if(leaf &amp;&amp; (node-&gt;left || node-&gt;right)) return false; if(!node-&gt;right &amp;&amp; !leaf)&#123; leaf = true; &#125; if(node-&gt;left) &#123; q.push(node-&gt;left); &#125; if(node-&gt;right) &#123; q.push(node-&gt;right); &#125; &#125; return true;&#125;void printTree(TreeNode* root)&#123; if(!root) return; printTree(root-&gt;left); cout &lt;&lt; \" \" &lt;&lt; root-&gt;val; printTree(root-&gt;right);&#125;int main()&#123; int c; cin &gt;&gt; c; int rootval; cin &gt;&gt; rootval; TreeNode* root = new TreeNode(rootval); for(int i = 1; i &lt; c; i++)&#123; int nodeval; cin &gt;&gt; nodeval; insertNode(root, nodeval); &#125; levelOrder(root); cout &lt;&lt; endl; if(isCST(root))&#123; cout &lt;&lt; \"YES\" &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; \"NO\" &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://yangzebin001.github.io/tags/二叉树/"},{"name":"PAT","slug":"PAT","permalink":"https://yangzebin001.github.io/tags/PAT/"}]},{"title":"LeetCode-240. 搜索二维矩阵 II","slug":"LeetCode-240-搜索二维矩阵-II","date":"2019-02-27T09:56:12.000Z","updated":"2019-02-27T09:57:30.476Z","comments":true,"path":"2019/02/27/LeetCode-240-搜索二维矩阵-II/","link":"","permalink":"https://yangzebin001.github.io/2019/02/27/LeetCode-240-搜索二维矩阵-II/","excerpt":"240. 搜索二维矩阵 II 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 Solution：","text":"240. 搜索二维矩阵 II 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 Solution： 12345678910111213class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if(matrix.size() &lt;= 0) return false; int i = 0, j = matrix[0].size()-1; while(i &lt; matrix.size() &amp;&amp; j &gt;= 0)&#123; if(target == matrix[i][j]) return true; else if(target &gt; matrix[i][j]) i++; else if(target &lt; matrix[i][j]) j--; &#125; return false; &#125;&#125;; 思路： 从矩阵的左上角出发，如果比目标值大，向左移，如果比目标值小，向下移。出界或找到则结束。 对于一列，如果比当前值小，说明不在当前列中，列减一（缩小搜索范围）。 对于一行，如果比当前值小，则往前移动一个位置。 经过不断缩小范围（以经过的点划矩形），就可以得知目标值是否存在矩阵中。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二维矩阵","slug":"二维矩阵","permalink":"https://yangzebin001.github.io/tags/二维矩阵/"}]},{"title":"LeetCode-46. 全排列","slug":"LeetCode-46-全排列","date":"2019-02-23T10:00:09.000Z","updated":"2019-02-27T10:07:03.888Z","comments":true,"path":"2019/02/23/LeetCode-46-全排列/","link":"","permalink":"https://yangzebin001.github.io/2019/02/23/LeetCode-46-全排列/","excerpt":"46. 全排列 给定一个没有重复数字的序列，返回其所有可能的全排列。示例: 输入: [1,2,3] 输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] Solution：","text":"46. 全排列 给定一个没有重复数字的序列，返回其所有可能的全排列。示例: 输入: [1,2,3] 输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] Solution： 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); vector&lt;bool&gt; isVisit(len,false); vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; temp; DFS(nums,isVisit,res,temp); return res; &#125; void DFS(vector&lt;int&gt; &amp; nums, vector&lt;bool&gt; &amp;isVisit, vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;temp)&#123; if(temp.size() == nums.size())&#123; res.push_back(temp); return; &#125; for(int i = 0; i &lt; nums.size(); i++)&#123; if(isVisit[i]) continue; temp.push_back(nums[i]); isVisit[i] = true; DFS(nums,isVisit,res,temp); temp.pop_back(); isVisit[i] = false; &#125; &#125;&#125;; 思路：对于每一个数在一个排列中出现且仅出现一次。所以需要定义一个记录该数是否访问过的与原数组相同长度的数组——isVisit。 首先限定递归层数，当temp数组的长度已经和原数组的长度相同，就将数组保存下来。 然后开始遍历数组中的每一个数，遇到一个数，就将该数标记为已访问，并且将该数添加到temp数组中。继续下一层递归。 回溯：当每一个数访问完后，将该数从temp中pop掉，然后接着探寻下一个数是不是符合条件。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"回溯","slug":"回溯","permalink":"https://yangzebin001.github.io/tags/回溯/"},{"name":"排列","slug":"排列","permalink":"https://yangzebin001.github.io/tags/排列/"}]},{"title":"LeetCode-107. 二叉树的层次遍历 II","slug":"LeetCode-107-二叉树的层次遍历-II","date":"2019-02-23T09:59:37.000Z","updated":"2019-02-27T10:07:17.511Z","comments":true,"path":"2019/02/23/LeetCode-107-二叉树的层次遍历-II/","link":"","permalink":"https://yangzebin001.github.io/2019/02/23/LeetCode-107-二叉树的层次遍历-II/","excerpt":"107. 二叉树的层次遍历 II 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）该题为 102. 二叉树的层次遍历的进阶版。 有关102. 二叉树的层次遍历的题解，请参考429. N叉树的层序遍历，具体思路是一样的，不再赘述。 Solution1（迭代版）：","text":"107. 二叉树的层次遍历 II 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）该题为 102. 二叉树的层次遍历的进阶版。 有关102. 二叉树的层次遍历的题解，请参考429. N叉树的层序遍历，具体思路是一样的，不再赘述。 Solution1（迭代版）： 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt; &gt; res; if(!root) return res; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; int len = q.size(); vector&lt;int&gt; curLayerNodes; TreeNode* t; while(len--)&#123; t = q.front(); q.pop(); curLayerNodes.push_back(t-&gt;val); if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push(t-&gt;right); &#125; res.emplace(res.begin(),curLayerNodes); &#125; return res; &#125;&#125;; Solution2（递归版）：123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; preorder(root,1,res); return res; &#125; void preorder(TreeNode* node, int depth, vector&lt;vector&lt;int&gt;&gt; &amp;res)&#123; if(!node) return; if(res.size() &lt; depth)&#123; vector&lt;int&gt; t; t.push_back(node-&gt;val); res.emplace(res.begin(), t); &#125;else&#123; res[res.size()-depth].push_back(node-&gt;val); &#125; preorder(node-&gt;left, depth+1, res); preorder(node-&gt;right, depth+1, res); &#125;&#125;; 具体思路就是增加一层，就将该层放到头位置。 vector.emplace()配合vector.begin()实现插到头位置。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://yangzebin001.github.io/tags/二叉树/"}]},{"title":"LeetCode-199. 二叉树的右视图","slug":"LeetCode-199-二叉树的右视图","date":"2019-02-23T09:55:09.000Z","updated":"2019-02-27T10:07:38.516Z","comments":true,"path":"2019/02/23/LeetCode-199-二叉树的右视图/","link":"","permalink":"https://yangzebin001.github.io/2019/02/23/LeetCode-199-二叉树的右视图/","excerpt":"199. 二叉树的右视图 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 Solution1（迭代版）：","text":"199. 二叉树的右视图 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 Solution1（迭代版）： 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; vector&lt;int&gt; res; if(!root) return res; q.push(root); TreeNode* t = NULL; while(!q.empty())&#123; int len = q.size(); while(len)&#123; t = q.front();q.pop(); if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push(t-&gt;right); len--; &#125; res.push_back(t-&gt;val); &#125; return res; &#125;&#125;; 第一种比较符合直觉的就是使用层序遍历，将每一层的最后一个留下。 Solution2（递归版）：12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; vector&lt;int&gt; res; preorder(root, 1, res); return res; &#125; void preorder(TreeNode* node, int depth, vector&lt;int&gt; &amp; res)&#123; if(!node) return; if(res.size() &lt; depth)&#123; res.push_back(node-&gt;val); &#125;else&#123; res[depth-1] = node-&gt;val; &#125; preorder(node-&gt;left,depth+1, res); preorder(node-&gt;right,depth+1, res); &#125;&#125;; 使用前序遍历，并且传入层级信息，每到一层，就将该层的信息更新。如果该层没有数据，则新增一层。遍历到最后就会更新为正确的数据。 优化：1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; vector&lt;int&gt; res; preorder(root, 0, res); return res; &#125; void preorder(TreeNode* node, int depth, vector&lt;int&gt; &amp; res)&#123; if(!node) return; if(res.size() == depth)&#123; res.push_back(node-&gt;val); &#125; preorder(node-&gt;right,depth+1, res); preorder(node-&gt;left,depth+1, res); &#125;&#125;; 思路：仔细观察发现，并没有必要先push进去左节点，碰到右节点再将左节点覆盖掉，而是一开始就直接push进右节点。到左节点的时候就什么事情也不需要做。 每到一个结点优先遍历右节点，res的size++。在遍历左节点的时候直接会跳过。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://yangzebin001.github.io/tags/二叉树/"}]},{"title":"LeetCode-191. 位1的个数 &&  231. 2的幂","slug":"LeetCode-191-位1的个数-231-2的幂","date":"2019-02-21T10:17:36.000Z","updated":"2019-02-27T10:12:48.262Z","comments":true,"path":"2019/02/21/LeetCode-191-位1的个数-231-2的幂/","link":"","permalink":"https://yangzebin001.github.io/2019/02/21/LeetCode-191-位1的个数-231-2的幂/","excerpt":"191. 位1的个数 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。Solution1：","text":"191. 位1的个数 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。Solution1： 1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int cot = 0; while(n)&#123; cot += n&amp;1; n &gt;&gt;= 1; &#125; return cot; &#125;&#125;; 思路：将每一位移到最后一位检查是否为1，到0为止，最后返回个数。 由于是无符号整型，每次都会执行32次，所以时间复杂度是O(1)。 Solution2（优化）：1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int cot = 0; while(n)&#123; n &amp;= (n-1); cot++; &#125; return cot; &#125;&#125;; 看了官方题解，这种方法是每一次将最后一个1给消除。这样顶多执行k次，k就为1的个数。这样就又优化了一点点计算。 eg： 11010 &amp; 11001 = 11000 11000 &amp; 10111 = 10000 10000 &amp; 01111 = 0 231. 2的幂给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 有了上面的思路： 这道题就可以写成这样： 123456class Solution &#123;public: bool isPowerOfTwo(int n) &#123; return n &gt; 0 &amp;&amp; !(n &amp; (n-1)); &#125;&#125;; 2的n次方在二进制中就是只有1个位置是1，其他全是0（对于正数）。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"位运算","slug":"位运算","permalink":"https://yangzebin001.github.io/tags/位运算/"}]},{"title":"LeetCode-129. 求根到叶子节点数字之和","slug":"LeetCode-129-求根到叶子节点数字之和","date":"2019-02-21T10:17:03.000Z","updated":"2019-02-23T09:58:41.801Z","comments":true,"path":"2019/02/21/LeetCode-129-求根到叶子节点数字之和/","link":"","permalink":"https://yangzebin001.github.io/2019/02/21/LeetCode-129-求根到叶子节点数字之和/","excerpt":"129. 求根到叶子节点数字之和 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。","text":"129. 求根到叶子节点数字之和 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。 Solution：1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int sumNumbers(TreeNode* root) &#123; int sum = 0; if(!root) return 0; sumVal(root,0,sum); return sum; &#125; void sumVal(TreeNode* root, int pathsum,int&amp;sum)&#123; if(!root-&gt;left &amp;&amp; !root-&gt;right)&#123; sum += pathsum*10 + root-&gt;val; return; &#125; if(root-&gt;left) sumVal(root-&gt;left, pathsum*10 + root-&gt;val, sum); if(root-&gt;right) sumVal(root-&gt;right, pathsum*10 + root-&gt;val, sum); &#125;&#125;; 这道题由于是到叶子节点的路径，并且要将其中走过的节点的值加起来，所以不能到空节点才停止（无法确定加值的时机），这里是到叶子节点就停止，并且把值加到sum中。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-114. 二叉树展开为链表","slug":"LeetCode-114-二叉树展开为链表","date":"2019-02-19T11:10:13.000Z","updated":"2019-02-27T10:15:03.072Z","comments":true,"path":"2019/02/19/LeetCode-114-二叉树展开为链表/","link":"","permalink":"https://yangzebin001.github.io/2019/02/19/LeetCode-114-二叉树展开为链表/","excerpt":"114. 二叉树展开为链表 给定一个二叉树，原地将它展开为链表。 Solution1：","text":"114. 二叉树展开为链表 给定一个二叉树，原地将它展开为链表。 Solution1： 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void flatten(TreeNode* root) &#123; if(!root) return; dfs(root); &#125; TreeNode* dfs(TreeNode* node)&#123; if(!node-&gt;left &amp;&amp; !node-&gt;right) return node; TreeNode* lastLeft = NULL; TreeNode* lastRight = NULL; if(node-&gt;left)&#123; lastLeft = dfs(node-&gt;left); &#125; if(node-&gt;right)&#123; lastRight = dfs(node-&gt;right); &#125; if(lastLeft)&#123; lastLeft-&gt;right = node-&gt;right; node-&gt;right = node-&gt;left; node-&gt;left = NULL; &#125; if(lastRight) return lastRight; else return lastLeft; &#125;&#125;; 思路：从叶子结点开始，向上展开。每到一层，分别获得左子树和右子树的最后节点，将左子树的最后节点与当前节点的右子树的开始节点连接，将当前节点的右节点指向左子树的开始节点，左子树置空。 接着返回当前子树的最后节点，作为上一层的相应结点做相应的处理。 优化：1234567891011121314151617181920class Solution &#123;public: void flatten(TreeNode* root) &#123; dfs(root); &#125; TreeNode* dfs(TreeNode* node)&#123; if(!node) return NULL; TreeNode* lastLeft; TreeNode* lastRight; lastLeft = dfs(node-&gt;left); lastRight = dfs(node-&gt;right); if(lastLeft)&#123; lastLeft-&gt;right = node-&gt;right; node-&gt;right = node-&gt;left; node-&gt;left = NULL; &#125; return lastRight ? lastRight : lastLeft ? lastLeft : node ; &#125;&#125;; 将空节点做一般化考虑，在返回的时候做相应的处理。 分几种情况： 有lastRight，优先返回lastRight， 没有lastRight，有lastLeft，此时由于之上的代码已经将子树展开为链表并转换到了右子树上面，这时返回lastLeft。 lastRight 和 lastLeft 都没有，这时为叶子节点，直接返回该节点即可。 Solution2（终极版）：123456789101112class Solution &#123;public: TreeNode* prev = NULL; void flatten(TreeNode* root) &#123; if(!root) return; flatten(root-&gt;right); flatten(root-&gt;left); root-&gt;right = prev; root-&gt;left = NULL; prev = root; &#125;&#125;; 看到评论区大神写的这段代码，我觉得我被虐的体无完肤。 首先，设置一个全局变量，该变量用来记录已经翻转过的开始结点。接着，递归是首先下到最右边，从最右边开始的，这就保证了只需要关心已经展开链表的头结点，尾结点没必要再关心了。每次到达一个子树，从最右的结点开始，每个节点接到全局变量上。全局变量刷新为新的展开链表的头。如此一直到达根节点。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"递归","slug":"递归","permalink":"https://yangzebin001.github.io/tags/递归/"}]},{"title":"LeetCode-110. 平衡二叉树","slug":"LeetCode-110-平衡二叉树","date":"2019-02-19T10:49:09.000Z","updated":"2019-02-19T10:56:41.935Z","comments":true,"path":"2019/02/19/LeetCode-110-平衡二叉树/","link":"","permalink":"https://yangzebin001.github.io/2019/02/19/LeetCode-110-平衡二叉树/","excerpt":"110. 平衡二叉树 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 Solution（递归版）：","text":"110. 平衡二叉树 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 Solution（递归版）： 12345678910111213141516class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; if(!root) return true; if(std::abs(depth(root-&gt;left)-depth(root-&gt;right)) &gt; 1 )&#123; return false; &#125;else&#123; return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125; &#125; int depth(TreeNode* root) &#123; if(!root) return 0; return 1 + std::max(depth(root-&gt;left),depth(root-&gt;right)); &#125;&#125;; 思路：依次向下判断每一个节点的下左右子树的高度差。如果大于1，返回false，否则继续向下判断。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-144. 二叉树的前序遍历","slug":"LeetCode-144-二叉树的前序遍历","date":"2019-02-18T04:19:45.000Z","updated":"2019-02-27T10:13:58.019Z","comments":true,"path":"2019/02/18/LeetCode-144-二叉树的前序遍历/","link":"","permalink":"https://yangzebin001.github.io/2019/02/18/LeetCode-144-二叉树的前序遍历/","excerpt":"144. 二叉树的前序遍历 给定一个二叉树，返回它的前序遍历。 Solution1（递归版）：","text":"144. 二叉树的前序遍历 给定一个二叉树，返回它的前序遍历。 Solution1（递归版）： 123456789101112131415class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; preorder(root,res); return res; &#125; void preorder(TreeNode* node, vector&lt;int&gt; &amp;res)&#123; if(!node) return; res.push_back(node-&gt;val); preorder(node-&gt;left, res); preorder(node-&gt;right, res); &#125; &#125;; Solution2（迭代版）：12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; s; TreeNode* cur = root; s.push(root); while(!s.empty())&#123; cur = s.top(); s.pop(); res.push_back(cur-&gt;val); if(cur-&gt;right) s.push(cur-&gt;right); if(cur-&gt;left) s.push(cur-&gt;left); &#125; return res; &#125;&#125;; 前序遍历的顺序为先处理当前节点，再处理左节点，最后处理右节点。 对于栈来说。首先处理当前节点。然后先把右节点压入栈中，转而处理左节点。 OR12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; toVisit; vector&lt;int&gt; result; if(root == NULL)&#123; return result; &#125; TreeNode* current = root; while(current || !toVisit.empty())&#123; if(current != NULL)&#123; result.push_back(current-&gt;val); toVisit.push(current-&gt;right); current = current-&gt;left; &#125; else &#123; current = toVisit.top(); toVisit.pop(); &#125; &#125; return result; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://yangzebin001.github.io/tags/二叉树/"}]},{"title":"LeetCode-94. 二叉树的中序遍历","slug":"LeetCode-94-二叉树的中序遍历","date":"2019-02-18T04:19:04.000Z","updated":"2019-02-27T10:15:44.253Z","comments":true,"path":"2019/02/18/LeetCode-94-二叉树的中序遍历/","link":"","permalink":"https://yangzebin001.github.io/2019/02/18/LeetCode-94-二叉树的中序遍历/","excerpt":"94. 二叉树的中序遍历 给定一个二叉树，返回它的中序遍历。 Solution1（递归版）：","text":"94. 二叉树的中序遍历 给定一个二叉树，返回它的中序遍历。 Solution1（递归版）： 123456789101112131415class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; inorder(root,res); return res; &#125; void inorder(TreeNode* node, vector&lt;int&gt; &amp;res)&#123; if(!node) return; inorder(node-&gt;left, res); res.push_back(node-&gt;val); inorder(node-&gt;right, res); &#125;&#125;; Solution2（迭代版）：1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; ss; TreeNode* cur = root; while(cur || !ss.empty())&#123; //优先把左节点push进栈。 if(cur)&#123; ss.push(cur); cur = cur-&gt;left; &#125; //该节点没有左节点，此时就该存储起来了。然后继续对右节点的操作。（自底向上的访问右节点） else&#123; cur = ss.top(); ss.pop(); res.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; &#125; return res; &#125;&#125;; 中序遍历的特点就是优先遍历左节点，之后是当前节点，最后是右节点。 所以遇到一个节点。先存储在栈内。考虑以下两点： 有左节点，继续加入栈。 没有左节点，处理该节点，并将该节点从栈中弹出，继续考虑该节点的右节点。 这里我在思考的时候，逻辑没有问题，在coding的时候，关注的是父节点与子节点的关系，这样写出来的代码很容易导致死循环（在左子节点判断玩后，无法弹出栈，下一层循环又继续进行左子节点的判断了）。看到评论是将每一个节点提出来作为观察对象。更加直接。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://yangzebin001.github.io/tags/二叉树/"}]},{"title":"LeetCode-111. 二叉树的最小深度","slug":"LeetCode-111-二叉树的最小深度","date":"2019-02-14T08:56:45.000Z","updated":"2019-02-14T09:01:00.176Z","comments":true,"path":"2019/02/14/LeetCode-111-二叉树的最小深度/","link":"","permalink":"https://yangzebin001.github.io/2019/02/14/LeetCode-111-二叉树的最小深度/","excerpt":"111. 二叉树的最小深度 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 Solution1（递归版）：","text":"111. 二叉树的最小深度 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 Solution1（递归版）： 1234567891011121314151617class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(!root) return 0; return depth(root); &#125; int depth(TreeNode* root)&#123; if(!root-&gt;left &amp;&amp; !root-&gt;right) return 1; int l = INT_MAX, r = INT_MAX; if(root-&gt;left)&#123; l = 1 + depth(root-&gt;left); &#125;if(root-&gt;right)&#123; r = 1 + depth(root-&gt;right); &#125; return min(l,r); &#125;&#125;; 递归到叶子节点就停止。 如果不是叶子结点。则向下递归，找到最小值即可。 Solution2（迭代版）：12345678910111213141516171819202122232425class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(!root) return 0; queue&lt;TreeNode*&gt; q; q.push(root); int depth = 0; while(!q.empty())&#123; int len = q.size(); depth++; while(len &gt; 0)&#123; TreeNode* t = q.front(); q.pop(); if(!t-&gt;left &amp;&amp; !t-&gt;right) &#123; return depth; &#125; if(t-&gt;left)q.push(t-&gt;left); if(t-&gt;right)q.push(t-&gt;right); len--; &#125; &#125; return depth; &#125; &#125;; 层次遍历二叉树，每次弹出一层，如果该层有叶子节点，直接返回当前记录的深度。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-74. 搜索二维矩阵","slug":"LeetCode-74-搜索二维矩阵","date":"2019-02-14T08:55:55.000Z","updated":"2019-02-27T10:16:49.354Z","comments":true,"path":"2019/02/14/LeetCode-74-搜索二维矩阵/","link":"","permalink":"https://yangzebin001.github.io/2019/02/14/LeetCode-74-搜索二维矩阵/","excerpt":"74. 搜索二维矩阵 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。","text":"74. 搜索二维矩阵 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 Solution1： 12345678910111213141516171819202122232425262728class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int j = matrix.size(); for(int i = 0; i &lt; j; i++)&#123; int k = matrix[i].size(); if(k == 0) continue; if(matrix[i][k-1] == target) return true; else if(matrix[i][k-1] &lt; target) continue; return hasNumInArray(matrix[i], target); &#125; return false; &#125; bool hasNumInArray(vector&lt;int&gt; &amp;a, int num)&#123; int i = 0, j = a.size(); while(i &lt; j)&#123; int mid = (i + j)/2; if(a[mid] == num) return true; else if(num &gt; a[mid])&#123; i = mid+1; &#125;else&#123; j = mid; &#125; &#125; return false; &#125;&#125;; 首先检查每一行的最后一个元素。如果等于直接返回，如果小于目标值，说明不在该行，继续进行下一行的检查。当上一行的最后一个元素比目标值大，当前行最后一个元素比目标值小时，就只在该行进行搜索（二分）。如果能够搜索到则返回true，找不到则说明整个矩阵内没有目标值。 待优化的点： 在进行对每一列的检查时，也可以使用二分来加速范围的选择。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二维矩阵","slug":"二维矩阵","permalink":"https://yangzebin001.github.io/tags/二维矩阵/"},{"name":"数组","slug":"数组","permalink":"https://yangzebin001.github.io/tags/数组/"}]},{"title":"LeetCode-59. 螺旋矩阵 II","slug":"LeetCode-59-螺旋矩阵-II","date":"2019-02-14T08:55:05.000Z","updated":"2019-02-27T10:17:21.081Z","comments":true,"path":"2019/02/14/LeetCode-59-螺旋矩阵-II/","link":"","permalink":"https://yangzebin001.github.io/2019/02/14/LeetCode-59-螺旋矩阵-II/","excerpt":"59. 螺旋矩阵 II 给定一个正整数 n，生成一个包含 1 到 n² 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 与54. 螺旋矩阵类似。 只需要依次给新数组中的相应元素赋值即可。 Solution：","text":"59. 螺旋矩阵 II 给定一个正整数 n，生成一个包含 1 到 n² 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 与54. 螺旋矩阵类似。 只需要依次给新数组中的相应元素赋值即可。 Solution： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt; &gt; res(n, vector&lt;int&gt;(n));; if(n &lt;= 0) return res; int k = 1; int left = 0, right = n-1, up = 0, down = n-1; while(left &lt; right &amp;&amp; up &lt; down)&#123; int i = left, j = up; while(i &lt; right)&#123; res[j][i] = k++; i++; &#125; while(j &lt; down)&#123; res[j][i] = k++; j++; &#125; while(i &gt; left)&#123; res[j][i] = k++; i--; &#125; while(j &gt; up)&#123; res[j][i] = k++; j--; &#125; left++; right--; up++; down--; &#125; //形不成圈（单列或者单行） if(up == down)&#123; while(left &lt;= right)&#123; res[up][left++] = k++; &#125; &#125;else if(left == right)&#123; while(up &lt;= down)&#123; res[up++][left] = k++; &#125; &#125; return res; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二维矩阵","slug":"二维矩阵","permalink":"https://yangzebin001.github.io/tags/二维矩阵/"},{"name":"数组","slug":"数组","permalink":"https://yangzebin001.github.io/tags/数组/"}]},{"title":"LeetCode-54. 螺旋矩阵","slug":"LeetCode-54-螺旋矩阵","date":"2019-02-14T08:54:22.000Z","updated":"2019-02-27T10:17:45.476Z","comments":true,"path":"2019/02/14/LeetCode-54-螺旋矩阵/","link":"","permalink":"https://yangzebin001.github.io/2019/02/14/LeetCode-54-螺旋矩阵/","excerpt":"54. 螺旋矩阵 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。","text":"54. 螺旋矩阵 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 Solution：12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; res; if(matrix.size() == 0) return res; int left = 0,up = 0, right = matrix[0].size()-1, down = matrix.size()-1; while(left &lt; right &amp;&amp; up &lt; down)&#123; int i = left, j = up; while(i &lt; right)&#123; res.push_back(matrix[j][i]); i++; &#125; while(j &lt; down)&#123; res.push_back(matrix[j][i]); j++; &#125; while(i &gt; left)&#123; res.push_back(matrix[j][i]); i--; &#125; while(j &gt; up)&#123; res.push_back(matrix[j][i]); j--; &#125; left++; right--; up++; down--; &#125; //形不成圈（单列或者单行） if(up == down)&#123; while(left &lt;= right)&#123; res.push_back(matrix[up][left++]); &#125; &#125;else if(left == right)&#123; while(up &lt;= down)&#123; res.push_back(matrix[up++][left]); &#125; &#125; return res; &#125;&#125;; 思路：每次将矩阵的外围当做一个圈来处理，然后缩小圈的范围。 直到形不成圈，此时要么是单行，要么是单列，要么是中心点（看做单行，单列都可行），然后单独处理即可。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二维矩阵","slug":"二维矩阵","permalink":"https://yangzebin001.github.io/tags/二维矩阵/"},{"name":"数组","slug":"数组","permalink":"https://yangzebin001.github.io/tags/数组/"}]},{"title":"LeetCode-922. 按奇偶排序数组 II","slug":"LeetCode-922-按奇偶排序数组-II","date":"2019-02-14T08:52:27.000Z","updated":"2019-02-27T10:08:32.549Z","comments":true,"path":"2019/02/14/LeetCode-922-按奇偶排序数组-II/","link":"","permalink":"https://yangzebin001.github.io/2019/02/14/LeetCode-922-按奇偶排序数组-II/","excerpt":"922. 按奇偶排序数组 II 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 Solution:","text":"922. 按奇偶排序数组 II 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 Solution: 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt;&amp; A) &#123; int i = 0; int len = A.size(); int j = 1; while(1)&#123; while(i &lt; len &amp;&amp; (A[i] &amp; 1) == 0) i+=2; while(j &lt; len &amp;&amp; (A[j] &amp; 1) != 0) j+=2; if(i &gt;= len || j &gt;= len) break; std::swap(A[i],A[j]); i+=2; j+=2; &#125; return A; &#125; &#125;; 思路：设置两个指针。一个指针只走奇数下标，一个指针只走偶数下标。当碰到不符合条件（奇数下标的值不是奇数，偶数下标的值不是偶数）就停下并交换两个值，之后接着走，直到指针越界为止。 看评论有人用栈或者另外准备两个数组的，速度比原地交换还快，不知道为什么。实现也比较简单，就不赘述了。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"双指针","slug":"双指针","permalink":"https://yangzebin001.github.io/tags/双指针/"}]},{"title":"LeetCode-559. N叉树的最大深度","slug":"LeetCode-559-N叉树的最大深度","date":"2019-02-09T08:36:57.000Z","updated":"2019-02-09T08:45:59.240Z","comments":true,"path":"2019/02/09/LeetCode-559-N叉树的最大深度/","link":"","permalink":"https://yangzebin001.github.io/2019/02/09/LeetCode-559-N叉树的最大深度/","excerpt":"559. N叉树的最大深度 给定一个 N 叉树，找到其最大深度。 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。","text":"559. N叉树的最大深度 给定一个 N 叉树，找到其最大深度。 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。 Solution1（递归版）：123456789101112131415161718192021222324252627282930/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123;public: int maxDepth(Node* root) &#123; return dfs(root,1); &#125; int dfs(Node* node, int m)&#123; if(!node) return 0; int max = m; for(int i = 0; i &lt; node-&gt;children.size(); i++)&#123; max = std::max(dfs(node-&gt;children[i], m+1), max); &#125; return max; &#125;&#125;; 递归版本。 我的写法为： 定义空节点的深度为0，这样在做最大值比较的时候返回的是其父节点的深度。 这样做可以在root为空的时候不用做特殊处理。直接会返回0。 评论区有人是这样写的： 123456789public int maxDepth(Node root) &#123; //DFS递归写法 if(root == null) return 0; int depth = 0; for(int i = 0;i&lt;root.children.size();i++)&#123; depth = Math.max(depth,maxDepth(root.children.get(i))); &#125; return depth+1;&#125; 由下至上来确定最大深度，但是需要额外判断根节点为空的情况。 Solution2（迭代版）：12345678910111213141516171819202122232425262728293031323334353637383940/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123; public: int maxDepth(Node* root) &#123; if(!root) return 0; int maxDep = 0; queue&lt;Node*&gt; q; q.push(root); //队列中始终保持存储的节点都为同一层。 while(!q.empty())&#123; int n = q.size(); //当前层有结点。 maxDep++; //将当前层所有元素pop掉。 for(int i = 0; i &lt; n ;i++)&#123; Node* t = q.front(); q.pop(); //将子节点push进队列。 for(int j = 0; j &lt; t-&gt;children.size(); j++)&#123; q.push(t-&gt;children[j]); &#125; &#125; &#125; return maxDep; &#125;&#125;; 迭代版利用层次遍历。 每到一层，深度加1。然后将该层的所有结点pop掉。继续将下一层的结点push进来。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-101. 对称二叉树","slug":"LeetCode-101-对称二叉树","date":"2019-02-09T08:35:51.000Z","updated":"2019-02-09T08:39:49.522Z","comments":true,"path":"2019/02/09/LeetCode-101-对称二叉树/","link":"","permalink":"https://yangzebin001.github.io/2019/02/09/LeetCode-101-对称二叉树/","excerpt":"101. 对称二叉树 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 Solution1（递归版）：","text":"101. 对称二叉树 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 Solution1（递归版）： 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; return isMirror(root, root); &#125; bool isMirror(TreeNode* t1, TreeNode* t2)&#123; //都为NULL if(!t1 &amp;&amp; !t2) return true; //有一个结点为NULL，另一个不为NULL if(!t1 || !t2) return false; return (t1-&gt;val == t2-&gt;val) &amp;&amp; isMirror(t1-&gt;left, t2-&gt;right) &amp;&amp; isMirror(t1-&gt;right, t2-&gt;left); &#125;&#125;; 看的官方题解。 把一棵对称树分成左子树和右子树。 如果左子树和右子树对称，则该数相同。 扩展到一般概念就是： 有两棵树。 两棵树的根节点相同。 每个树的右子树都与另一个树的左子树镜像对称。 翻译为递推公式就是： 1234TreeNode* t1,t2;t1-&gt;val == t2-&gt;val;t1-&gt;left == t2-&gt;right;t1-&gt;right = t2-&gt;left; 结束条件为两棵树为空。 整理可得上述代码。 Solution2（迭代版）：123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; q.push(root); q.push(root); while(!q.empty())&#123; TreeNode* t1 = q.front(); q.pop(); TreeNode* t2 = q.front(); q.pop(); if(!t1 &amp;&amp; !t2) continue; if(!t1 || !t2) return false; if(t1-&gt;val != t2-&gt;val) return false; q.push(t1-&gt;left); q.push(t2-&gt;right); q.push(t2-&gt;left); q.push(t1-&gt;right); &#125; return true; &#125;&#125;; 翻译为了迭代版，只不过根本的思想是一样的。都是将一棵树化为两棵树来进行判断的。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-590. N叉树的后序遍历","slug":"LeetCode-590-N叉树的后序遍历","date":"2019-02-09T08:35:15.000Z","updated":"2019-02-09T08:39:38.854Z","comments":true,"path":"2019/02/09/LeetCode-590-N叉树的后序遍历/","link":"","permalink":"https://yangzebin001.github.io/2019/02/09/LeetCode-590-N叉树的后序遍历/","excerpt":"590. N叉树的后序遍历 给定一个 N 叉树，返回其节点值的后序遍历。 与589. N叉树的前序遍历相对应。 Solution：","text":"590. N叉树的后序遍历 给定一个 N 叉树，返回其节点值的后序遍历。 与589. N叉树的前序遍历相对应。 Solution： 12345678910111213141516171819202122232425262728293031/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt; postorder(Node* root) &#123; vector&lt;int&gt; data; lastord(root,data); return data; &#125; void lastord(Node* root, vector&lt;int&gt; &amp;data)&#123; if(!root) return; for(int i = 0; i &lt; root-&gt;children.size(); i++)&#123; lastord(root-&gt;children[i], data); &#125; data.push_back(root-&gt;val); &#125;&#125;; 基础题。 先访问子节点，等全部子节点访问完毕再将该节点的信息存储起来即可。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-589. N叉树的前序遍历","slug":"LeetCode-589-N叉树的前序遍历","date":"2019-02-09T08:34:30.000Z","updated":"2019-02-09T08:39:35.953Z","comments":true,"path":"2019/02/09/LeetCode-589-N叉树的前序遍历/","link":"","permalink":"https://yangzebin001.github.io/2019/02/09/LeetCode-589-N叉树的前序遍历/","excerpt":"589. N叉树的前序遍历 给定一个 N 叉树，返回其节点值的前序遍历。","text":"589. N叉树的前序遍历 给定一个 N 叉树，返回其节点值的前序遍历。 Solution：12345678910111213141516171819202122232425262728293031/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt; preorder(Node* root) &#123; vector&lt;int&gt; data; preord(root,data); return data; &#125; void preord(Node* root, vector&lt;int&gt; &amp;data)&#123; if(!root) return; data.push_back(root-&gt;val); for(int i = 0; i &lt; root-&gt;children.size(); i++)&#123; preord(root-&gt;children[i], data); &#125; &#125;&#125;; 基础题。 在访问子节点之前将该节点的信息存储起来即可。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-429. N叉树的层序遍历","slug":"LeetCode-429-N叉树的层序遍历","date":"2019-02-09T08:33:43.000Z","updated":"2019-02-09T08:39:43.345Z","comments":true,"path":"2019/02/09/LeetCode-429-N叉树的层序遍历/","link":"","permalink":"https://yangzebin001.github.io/2019/02/09/LeetCode-429-N叉树的层序遍历/","excerpt":"429. N叉树的层序遍历 给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。","text":"429. N叉树的层序遍历 给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。 Solution1：1234567891011121314151617181920212223242526272829303132333435363738394041424344/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123; vector&lt;vector&lt;int&gt; &gt; data; if(!root) return data; queue&lt;Node*&gt; q; // 从节点开始。 q.push(root); while(!q.empty())&#123; vector&lt;int&gt; t; int len = q.size(); //遍历目前队列中的节点，将他们逐一push进数组中。 for(int i = 0; i &lt; len; i++)&#123; Node* n = q.front(); //将当前元素从队列中移除。 q.pop(); //存储数据 t.push_back(n-&gt;val); // 将每个元素下面的子节点push进队列中。 for(int j = 0; j &lt; n-&gt;children.size(); j++)&#123; q.push(n-&gt;children[j]); &#125; &#125; data.push_back(t); &#125; return data; &#125;&#125;; 使用队列进行层序遍历。 每走到一层，记录该层有多少节点。对于该层的每一个节点都做 将该节点的数据存储起来。 将该节点从队列中移除。 将该节点下的所有子节点都push进入队列中。 当一层节点操作完毕后，队列中存储的就为下一层的全部节点。队列的个数就为当前所在层的节点的个数。 Solution2：123456789101112131415161718192021222324252627282930313233343536373839/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123; vector&lt;vector&lt;int&gt; &gt; data; dfs(root, data, 0); return data; &#125; void dfs(Node* node, vector&lt;vector&lt;int&gt; &gt; &amp;data, int level)&#123; if(!node) return; //如果当前层还没有初始化。 if(data.size()&lt;= level)&#123; vector&lt;int&gt; t; t.push_back(node-&gt;val); data.push_back(t); &#125;else&#123; data[level].push_back(node-&gt;val); &#125; for(int i = 0; i &lt; node-&gt;children.size(); i++)&#123; dfs(node-&gt;children[i], data, level+1); &#125; &#125;&#125;; 递归版本。 记录当前的层数。当前节点属于哪一层就往哪一层里push元素。 初始化小技巧： 当使用双层vector时，必须先初始化每一层vector。 可以利用size巧妙的进行初始化，每走到一层，将size与当前层作比较，size总是比当前层大1。 12345 if(data.size()&lt;= level)&#123; vector&lt;int&gt; t; t.push_back(node-&gt;val); data.push_back(t);&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-236. 二叉树的最近公共祖先","slug":"LeetCode-236-二叉树的最近公共祖先","date":"2019-02-02T08:00:23.000Z","updated":"2019-02-02T08:05:05.051Z","comments":true,"path":"2019/02/02/LeetCode-236-二叉树的最近公共祖先/","link":"","permalink":"https://yangzebin001.github.io/2019/02/02/LeetCode-236-二叉树的最近公共祖先/","excerpt":"236. 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”","text":"236. 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” Solution1：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */static int flag = 0;class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; // 1.找到从根节点到某一结点的路径。存储在栈内。 stack&lt;TreeNode*&gt; a; stack&lt;TreeNode*&gt; b; flag = 0; path(root,p,a); flag = 0; path(root,q,b); // 2.比较两个栈的栈顶，一样，返回，不一样，弹出较长的那个。如果长度一样，同时弹出。 TreeNode* t = NULL; while(1)&#123; if(a.top() == b.top())&#123; t = a.top(); break; &#125; if(a.size() &gt; b.size())&#123; a.pop(); &#125;else if(a.size() &lt; b.size())&#123; b.pop(); &#125;else&#123; a.pop(); b.pop(); &#125; &#125; return t; &#125; void path(TreeNode* root, TreeNode* p, stack&lt;TreeNode*&gt; &amp;a)&#123; if(!root || flag == 1) return; a.push(root); if(root == p)&#123; flag = 1; &#125; path(root-&gt;left,p,a); path(root-&gt;right,p,a); if(flag != 1)&#123; a.pop(); &#125; &#125;&#125;; 先寻找从根节点到给定结点的路径，并存储在栈中。再将两栈比较，找到第一个相同结点即为最近公共祖先。由于需要找最近相同的结点。所以在遍历二叉树时，要使用前序遍历，先将结点保存在栈中，再考虑其子节点。得到两个存储路径的栈（根节点在栈底）。 由于路径与层有关，路径越长的结点，所在的层也越低。所以寻找公共结点首先把较大的栈缩小到与较小的栈长度一致，然后比较栈顶，当遇到相同结点时，就为最近公共祖先。 Solution2：12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; // 找到最近符合条件的结点。 if(!root || root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left,p,q); TreeNode* right = lowestCommonAncestor(root-&gt;right,p,q); // 如果找到了两个结点，不在一个位置。返回该结点（该结点是两个结点的公共祖先）。 if(left &amp;&amp; right) return root; //如果在该结点的下面，只找到了一个，先将该结点返回，交给上一级处理。（为了递归） if(left) return left; else return right; &#125;&#125;; 递归版本。 看了评论区大神写的。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-226. 翻转二叉树","slug":"LeetCode-226-翻转二叉树","date":"2019-02-02T07:59:44.000Z","updated":"2019-02-02T08:05:11.341Z","comments":true,"path":"2019/02/02/LeetCode-226-翻转二叉树/","link":"","permalink":"https://yangzebin001.github.io/2019/02/02/LeetCode-226-翻转二叉树/","excerpt":"226. 翻转二叉树 翻转一棵二叉树。","text":"226. 翻转二叉树 翻转一棵二叉树。 Solution1（递归版）：12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root) return NULL; if(root-&gt;left) invertTree(root-&gt;left); if(root-&gt;right) invertTree(root-&gt;right); TreeNode* temp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = temp; return root; &#125;&#125;; 依次从叶子结点向上翻转。 Solution2（层次遍历版）：123456789101112131415161718class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root) return NULL; queue&lt;TreeNode*&gt; que; que.push(root); while(!que.empty())&#123; TreeNode* node = que.front(); que.pop(); TreeNode* nodeleft = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = nodeleft; if(node-&gt;left) que.push(node-&gt;left); if(node-&gt;right) que.push(node-&gt;right); &#125; return root; &#125;&#125;; 层次遍历，每到一个结点，就讲该结点下的子结点交换。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-98. 验证二叉搜索树","slug":"98-验证二叉搜索树","date":"2019-01-27T14:31:33.000Z","updated":"2019-02-27T10:21:28.884Z","comments":true,"path":"2019/01/27/98-验证二叉搜索树/","link":"","permalink":"https://yangzebin001.github.io/2019/01/27/98-验证二叉搜索树/","excerpt":"98. 验证二叉搜索树 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。","text":"98. 验证二叉搜索树 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 Solution1：1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; vector&lt;TreeNode*&gt; v; inorder(root,v); for(int i = 1; i &lt; v.size(); i++)&#123; if(v[i-1]-&gt;val &gt;= v[i]-&gt;val)&#123; return false; &#125; &#125; return true; &#125; void inorder(TreeNode* node, vector&lt;TreeNode*&gt; &amp;v)&#123; if(!node) return; inorder(node-&gt;left,v); v.push_back(node); inorder(node-&gt;right,v); &#125;&#125;; 利用二叉搜索树的中序遍历是升序的特性。 将每个元素push进一个vector中，如果vector中元素不是按升序排列，这该树不是二叉搜索树。 Solution2：12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; return helper(root,NULL,NULL); &#125; //返回该结点是否在指定区间内。 bool helper(TreeNode *node, TreeNode *min, TreeNode *max)&#123; if(!node) return true; if((min &amp;&amp; node-&gt;val &lt;= min-&gt;val) || (max &amp;&amp; node-&gt;val &gt;= max-&gt;val)) return false; //左子节点的值不能比当前结点的值大，右节点的值不能不当前结点小。 return helper(node-&gt;left, min, node) &amp;&amp; helper(node-&gt;right, node, max); &#125;&#125;; 根据题目给的三条性质，所有结点及其下面的所有结点均可以构成二叉搜索树， 所以对于非叶子结点，可以以当前结点为根据，划分区间，区间内的点必须比左端点大，比右端点小。 用一个递归函数来不断更新该区间，判断该结点是否在区间内即可。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://yangzebin001.github.io/tags/二叉树/"}]},{"title":"LeetCode-51. N皇后","slug":"51-N皇后","date":"2019-01-27T14:30:19.000Z","updated":"2019-02-27T10:22:08.751Z","comments":true,"path":"2019/01/27/51-N皇后/","link":"","permalink":"https://yangzebin001.github.io/2019/01/27/51-N皇后/","excerpt":"51. N皇后 该题为著名的n皇后问题。 Solution：","text":"51. N皇后 该题为著名的n皇后问题。 Solution： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;string&gt; mark; vector&lt;string&gt; queenposition; vector&lt;vector&lt;string&gt; &gt; map; //初始化。 string a = \"\"; for(int i = 0; i &lt; n;i++)&#123; a = a + \".\"; &#125; for(int i = 0; i &lt; n; i++)&#123; queenposition.push_back(a); mark.push_back(a); &#125; dfs(mark,queenposition,map,0,n); return map; &#125; void putOneQueen(vector&lt;string&gt; &amp;mark,int x,int y,int n)&#123; static const int dx[8] = &#123;-1,-1,-1,0,0,1,1,1&#125;; static const int dy[8] = &#123;-1,0,1,-1,1,-1,0,1&#125;; mark[x][y] = '1'; for(int i = 0; i &lt; 8; i++)&#123; int nx = x + dx[i],ny = y+dy[i]; while(0 &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; n)&#123; mark[nx][ny] = '1'; nx += dx[i]; ny += dy[i]; &#125; &#125; &#125; void dfs(vector&lt;string&gt; &amp;mark,vector&lt;string&gt; &amp;queenposition,vector&lt;vector&lt;string&gt; &gt; &amp;map,int col,int n)&#123; //出口 if(col == n)&#123; map.push_back(queenposition); return; &#125; for(int i = 0; i &lt; n;i++)&#123; if(mark[col][i] == '.')&#123;//可以放皇后 vector&lt;string&gt; temp_mark = mark;//记录回溯前的镜像。 //放皇后。 queenposition[col][i] = 'Q'; putOneQueen(mark,col,i,n); //递归调用。 dfs(mark,queenposition,map,col+1,n); //回溯 mark = temp_mark; queenposition[col][i] = '.'; &#125; &#125; &#125;&#125;; 该题考查对递归与回溯算法的掌握。 使用一个矩阵来存储是否可以放皇后的状态。每当一行放置了一个皇后后，更新其状态，并在下一行中挑选合适的位置来放置该行的皇后。 直到每一行都放置了皇后，保存状态，返回上一个递归过程。 回溯主要针对矩阵的状态和皇后放置的位置，以便利于递归返回过程中的再次使用。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"回溯","slug":"回溯","permalink":"https://yangzebin001.github.io/tags/回溯/"},{"name":"递归","slug":"递归","permalink":"https://yangzebin001.github.io/tags/递归/"}]},{"title":"LeetCode-88. 合并两个有序数组","slug":"88-合并两个有序数组","date":"2019-01-27T14:30:09.000Z","updated":"2019-02-27T10:21:41.828Z","comments":true,"path":"2019/01/27/88-合并两个有序数组/","link":"","permalink":"https://yangzebin001.github.io/2019/01/27/88-合并两个有序数组/","excerpt":"88. 合并两个有序数组 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。","text":"88. 合并两个有序数组 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 Solution:1234567891011121314151617181920class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int tail = m + n -1; int nums1tail = m-1; int nums2tail = n-1; while(nums1tail &gt;= 0 &amp;&amp; nums2tail &gt;= 0)&#123; if(nums1[nums1tail] &gt;= nums2[nums2tail])&#123; nums1[tail] = nums1[nums1tail--]; &#125;else&#123; nums1[tail] = nums2[nums2tail--]; &#125; tail--; &#125; while(nums2tail &gt;= 0) nums1[tail--] = nums2[nums2tail--]; while(nums1tail &gt;= 0) nums1[tail--] = nums1[nums1tail--]; &#125;&#125;; 与归并排序的merge代码类似，不过是从数组的末尾往前比较。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"归并","slug":"归并","permalink":"https://yangzebin001.github.io/tags/归并/"}]},{"title":"LeetCode-112. 路径总和","slug":"112-路径总和","date":"2019-01-27T14:29:57.000Z","updated":"2019-02-27T10:20:47.422Z","comments":true,"path":"2019/01/27/112-路径总和/","link":"","permalink":"https://yangzebin001.github.io/2019/01/27/112-路径总和/","excerpt":"112. 路径总和 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。","text":"112. 路径总和 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 Solution1: 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(!root) return false; return dfs(root,0,sum); &#125; bool dfs(TreeNode* node,int currentsum, int sum)&#123; currentsum += node-&gt;val; if(node &amp;&amp; !node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; currentsum == sum) return true; bool a = false,b = false; if(node-&gt;left)&#123; a = dfs(node-&gt;left,currentsum,sum); &#125; if(node-&gt;right)&#123; b = dfs(node-&gt;right,currentsum,sum); &#125; return a || b; &#125;&#125;; 递归终止条件为叶子节点。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://yangzebin001.github.io/tags/二叉树/"},{"name":"递归","slug":"递归","permalink":"https://yangzebin001.github.io/tags/递归/"}]},{"title":"LeetCode-113. 路径总和 II","slug":"113-路径总和-II","date":"2019-01-27T14:29:33.000Z","updated":"2019-02-27T10:20:28.812Z","comments":true,"path":"2019/01/27/113-路径总和-II/","link":"","permalink":"https://yangzebin001.github.io/2019/01/27/113-路径总和-II/","excerpt":"113. 路径总和 II 该题为112. 路径总和的升级版 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。","text":"113. 路径总和 II 该题为112. 路径总和的升级版 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 Solution1： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt; &gt; result; if(root)&#123; dfs(root,0,sum,path,result); &#125; return result; &#125; void dfs(TreeNode* node,int currentsum, int sum,vector&lt;int&gt; &amp;path,vector&lt;vector&lt;int&gt; &gt; &amp;result)&#123; currentsum += node-&gt;val; path.push_back(node-&gt;val); //当到达叶子结点，并且路径之和与sum相同 if(node &amp;&amp; !node-&gt;left &amp;&amp; !node-&gt;right )&#123; if(currentsum == sum) result.push_back(path); return; &#125; if(node-&gt;left)&#123; dfs(node-&gt;left,currentsum,sum,path,result); //回溯，还原状态 path.pop_back(); &#125; if(node-&gt;right)&#123; dfs(node-&gt;right,currentsum,sum,path,result); //回溯，还原状态 path.pop_back(); &#125; &#125;&#125;; Solution2：12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt; &gt; result; preorder(root,0,sum,path,result); return result; &#125; void preorder(TreeNode* node, int currentsum, int sum, vector&lt;int&gt; &amp;path, vector&lt;vector&lt;int&gt; &gt; &amp;result)&#123; if(!node) return; currentsum += node-&gt;val; path.push_back(node-&gt;val); if(!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; currentsum == sum)&#123; result.push_back(path); &#125; preorder(node-&gt;left,currentsum,sum,path,result); preorder(node-&gt;right,currentsum,sum,path,result); //该步可有可无，因为只会递归到叶子节点才返回，又每次递归都在栈中保留了原来该值的副本。 // currentsum -= node-&gt;val; path.pop_back(); &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://yangzebin001.github.io/tags/二叉树/"},{"name":"回溯","slug":"回溯","permalink":"https://yangzebin001.github.io/tags/回溯/"}]},{"title":"LeetCode-190. 颠倒二进制位","slug":"190-颠倒二进制位","date":"2019-01-24T14:02:27.000Z","updated":"2019-02-27T10:19:50.198Z","comments":true,"path":"2019/01/24/190-颠倒二进制位/","link":"","permalink":"https://yangzebin001.github.io/2019/01/24/190-颠倒二进制位/","excerpt":"190. 颠倒二进制位 颠倒给定的 32 位无符号整数的二进制位。","text":"190. 颠倒二进制位 颠倒给定的 32 位无符号整数的二进制位。 示例 1： 输入: 00000010100101000001111010011100 输出: 00111001011110000010100101000000 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 ###Solution：1234567891011121314151617class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; uint32_t t = 0; int i = 32; while(i--)&#123; t &lt;&lt;= 1; //获得原数第一位的状态。 int a = n&amp;1; //将该状态赋给该数第一位。 t |= a; //原数右移。 n &gt;&gt;= 1; &#125; return t; &#125;&#125;; 思路： 初始化一个全位置为0的数，将原数的最后一位赋给该数的最后一位，原数右移，该数左移，如此32次。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"位运算","slug":"位运算","permalink":"https://yangzebin001.github.io/tags/位运算/"}]},{"title":"LeetCode-389. 找不同","slug":"389-找不同","date":"2019-01-24T13:41:26.000Z","updated":"2019-02-27T10:19:36.789Z","comments":true,"path":"2019/01/24/389-找不同/","link":"","permalink":"https://yangzebin001.github.io/2019/01/24/389-找不同/","excerpt":"389. 找不同 给定两个字符串 s 和 t，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。","text":"389. 找不同 给定两个字符串 s 和 t，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。 示例: 输入：s = “abcd”t = “abcde” 输出：e 解释：‘e’ 是那个被添加的字母。 ###Solution:123456789class Solution &#123;public: char findTheDifference(string s, string t) &#123; char e = 0; for(int i = 0; i &lt; s.size(); i++) e ^= s[i]; for(int i = 0; i &lt; t.size(); i++) e ^= t[i]; return e; &#125;&#125;; 与136. 只出现一次的数字一样的思路，考察异或的使用。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"位运算","slug":"位运算","permalink":"https://yangzebin001.github.io/tags/位运算/"}]},{"title":"LeetCode-136. 只出现一次的数字","slug":"136-只出现一次的数字","date":"2019-01-24T13:40:16.000Z","updated":"2019-02-27T10:20:02.799Z","comments":true,"path":"2019/01/24/136-只出现一次的数字/","link":"","permalink":"https://yangzebin001.github.io/2019/01/24/136-只出现一次的数字/","excerpt":"136. 只出现一次的数字 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？","text":"136. 只出现一次的数字 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1]输出: 1 Solution： 12345678910class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int a = 0; for(int i = 0; i &lt; nums.size(); i++)&#123; a = a ^ nums[i]; &#125; return a; &#125;&#125;; 使用异或来消除相同的元素。异或：两数相同，异或为0；两数不同，异或为1； a ^ a = 0; a ^ 0 = a;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"位运算","slug":"位运算","permalink":"https://yangzebin001.github.io/tags/位运算/"}]},{"title":"LeetCode-693. 交替位二进制数","slug":"693-交替位二进制数","date":"2019-01-24T12:46:07.000Z","updated":"2019-02-27T10:18:59.668Z","comments":true,"path":"2019/01/24/693-交替位二进制数/","link":"","permalink":"https://yangzebin001.github.io/2019/01/24/693-交替位二进制数/","excerpt":"693. 交替位二进制数 给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。 示例 1: 输入: 5 输出: True 解释: 5的二进制数是: 101","text":"693. 交替位二进制数 给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。 示例 1: 输入: 5 输出: True 解释: 5的二进制数是: 101 ###Solution：123456789class Solution &#123;public: bool hasAlternatingBits(int n) &#123; //如果是奇偶交替，则n ^ (n &gt;&gt; 1) 会使有效位全为1， int temp = n ^ (n &gt;&gt; 1); //有效位全为1 再加1， 得到有效位前面为1，后面全为0，再与该数与，则全部清零。 return (temp &amp; (temp+1)) == 0; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"位运算","slug":"位运算","permalink":"https://yangzebin001.github.io/tags/位运算/"}]},{"title":"LeetCode-476. 数字的补数","slug":"476-数字的补数","date":"2019-01-24T12:33:41.000Z","updated":"2019-02-27T10:19:18.099Z","comments":true,"path":"2019/01/24/476-数字的补数/","link":"","permalink":"https://yangzebin001.github.io/2019/01/24/476-数字的补数/","excerpt":"476. 数字的补数 给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。","text":"476. 数字的补数 给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。 注意: 给定的整数保证在32位带符号整数的范围内。 你可以假定二进制数不包含前导零位。示例 1: 输入: 5 输出: 2 解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。 ###Solution： 1234567891011121314class Solution &#123;public: int findComplement(int num) &#123; int cot = 0; int temp = num; while(1)&#123; if(num == 0) break; num = num &gt;&gt; 1; cot++; &#125; int mark = 0xffffffff; return ~temp ^ (mark &lt;&lt; cot); &#125;&#125;; 首先找到该数是从哪一位开始才算有效（即不包含前面零的位置。）再将该数所有位取反，然后用全位置的1左移cot次，与值异或即可。 异或：不同为一，相同为零，所以当前面的零取反后成为一后，相应位置与1异或，会恢复成为0，之后的有效位还保持不变。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"位运算","slug":"位运算","permalink":"https://yangzebin001.github.io/tags/位运算/"}]},{"title":"LeetCode-40. 组合总和 II","slug":"40-组合总和-II","date":"2019-01-24T08:40:41.000Z","updated":"2019-02-27T10:22:41.448Z","comments":true,"path":"2019/01/24/40-组合总和-II/","link":"","permalink":"https://yangzebin001.github.io/2019/01/24/40-组合总和-II/","excerpt":"40. 组合总和 II 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。","text":"40. 组合总和 II 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]] 该题为90. 子集 II的升级版 与上题相同的是，都要保证元素的非重复性，所以与上题使用set部分的代码是一致的。 区别在于在进行递归的过程中，需要随时对条件进行判断，只有满足等于target，才往result中添加。 并且在剪枝的时候，如果元素之和已经比target大，就没有必要进行下去了，直接退出即可。 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt; &gt; result; vector&lt;int&gt; item; //去重所使用的集合 set&lt;vector&lt;int&gt;&gt; item_set; //对nums进行排序。 sort(candidates.begin(),candidates.end()); putitem(0, candidates, result, item, item_set,target, 0); return result; &#125; void putitem(int i, vector&lt;int&gt;&amp; nums,vector&lt;vector&lt;int&gt; &gt; &amp;result, vector&lt;int&gt; &amp;item, set&lt;vector&lt;int&gt;&gt; &amp;item_set,int target, int sum)&#123; if(i &gt;= nums.size() || sum &gt; target) return; sum += nums[i]; item.push_back(nums[i]); //如果没有重复，就加入到最终的集合里。 if(sum == target &amp;&amp; item_set.find(item) == item_set.end())&#123; result.push_back(item); //加入去重集合中。 item_set.insert(item); &#125; putitem(i+1, nums, result, item, item_set, target, sum); sum -= nums[i]; item.pop_back(); putitem(i+1, nums, result, item, item_set, target, sum); &#125; &#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"回溯","slug":"回溯","permalink":"https://yangzebin001.github.io/tags/回溯/"},{"name":"递归","slug":"递归","permalink":"https://yangzebin001.github.io/tags/递归/"}]},{"title":"LeetCode-22. 括号生成","slug":"22-括号生成","date":"2019-01-24T08:40:02.000Z","updated":"2019-02-27T10:22:57.475Z","comments":true,"path":"2019/01/24/22-括号生成/","link":"","permalink":"https://yangzebin001.github.io/2019/01/24/22-括号生成/","excerpt":"22. 括号生成 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。例如，给出 n = 3，生成结果为：","text":"22. 括号生成 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。例如，给出 n = 3，生成结果为： [ “((()))”, “(()())”, “(())()”, “()(())”, “()()()”] Solution：12345678910111213141516171819202122class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; result; putone(\"\",n,n,result); return result; &#125; void putone(string item, int left, int right, vector&lt;string&gt; &amp;result)&#123; if(left == 0 &amp;&amp; right == 0)&#123; result.push_back(item); return; &#125; //只要left还能放。 if(left &gt; 0)&#123; putone(item+ \"(\",left-1,right,result); &#125; //left放的比right多， if(left &lt; right)&#123; putone(item+ \")\",left,right-1,result); &#125; &#125;&#125;; 使用递归+回溯来解决。 该题主要是要找放括号的时机。 首先要先放左括号。 第二，只要放左括号的个数比右括号多，就可以放右括号。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"回溯","slug":"回溯","permalink":"https://yangzebin001.github.io/tags/回溯/"},{"name":"递归","slug":"递归","permalink":"https://yangzebin001.github.io/tags/递归/"}]},{"title":"LeetCode-90. 子集 II","slug":"90-子集-II","date":"2019-01-24T08:39:22.000Z","updated":"2019-02-27T10:21:36.644Z","comments":true,"path":"2019/01/24/90-子集-II/","link":"","permalink":"https://yangzebin001.github.io/2019/01/24/90-子集-II/","excerpt":"90. 子集 II 该题为78. 子集的升级版 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。","text":"90. 子集 II 该题为78. 子集的升级版 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: [1,2,2]输出:[ [2], [1], [1,2,2], [2,2], [1,2], []] Solution1：123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; result; vector&lt;int&gt; item; result.push_back(item); //去重所使用的集合 set&lt;vector&lt;int&gt;&gt; item_set; //对nums进行排序。 sort(nums.begin(),nums.end()); putitem(0, nums, result, item, item_set); return result; &#125; void putitem(int i, vector&lt;int&gt;&amp; nums,vector&lt;vector&lt;int&gt; &gt; &amp;result, vector&lt;int&gt; &amp;item, set&lt;vector&lt;int&gt;&gt; &amp;item_set)&#123; if(i &gt;= nums.size()) return; item.push_back(nums[i]); //如果没有重复，就加入到最终的集合里。 if(item_set.find(item) == item_set.end())&#123; result.push_back(item); //加入去重集合中。 item_set.insert(item); &#125; putitem(i+1, nums, result, item, item_set); item.pop_back(); putitem(i+1, nums, result, item, item_set); &#125; &#125;; 使用一个set来先存储集合。每当在添加的时候，先检查set中是否已经包含，再决定放入。 由于该题中有重复元素，为了避免形如[2,3,3,2]与[3,2,2,3]，先进行排序插入","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"排列","slug":"排列","permalink":"https://yangzebin001.github.io/tags/排列/"}]},{"title":"LeetCode-78. 子集","slug":"78-子集","date":"2019-01-24T08:36:18.000Z","updated":"2019-02-27T10:21:56.601Z","comments":true,"path":"2019/01/24/78-子集/","link":"","permalink":"https://yangzebin001.github.io/2019/01/24/78-子集/","excerpt":"78. 子集 Solution1：对于每一项相对每个子集来说，都有放与不放两种选择。 创建一个放元素的递归函数，该函数的作用为将一项放和不放两种选择进行描述。","text":"78. 子集 Solution1：对于每一项相对每个子集来说，都有放与不放两种选择。 创建一个放元素的递归函数，该函数的作用为将一项放和不放两种选择进行描述。 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; result; vector&lt;int&gt; item; result.push_back(item); putitem(0, nums, item, result); return result; &#125; //把一项放进result中。 void putitem(int i, vector&lt;int&gt;&amp; nums,vector&lt;int&gt; item, vector&lt;vector&lt;int&gt; &gt; &amp;result)&#123; if(i == nums.size())&#123; return; &#125; //每个元素都有放和不放两种选择。 //放 item.push_back(nums[i]); result.push_back(item); putitem(i+1, nums, item, result); //不放 item.pop_back(); putitem(i+1, nums, item, result); &#125;&#125;; Solution2：遍历，遇到一个数就把所有子集加上该数组成新的子集，遍历完毕即是所有子集12345678910111213141516class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; result; vector&lt;int&gt; item; result.push_back(item); for(int i =0; i &lt; nums.size(); i++)&#123; int s = result.size(); for(int j = 0; j &lt; s;j++)&#123; result.push_back(result[j]); result[j].push_back(nums[i]); &#125; &#125; return result; &#125;&#125;; Solution3（位运算）：12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; result; //子集一共有2的n次方种，使用位运算来解。 //每一位代表一个元素。 //如，100 代表[3]、011代表[2,1]。 int all_set = 1 &lt;&lt; nums.size();//2的n次方种； for(int i = 0; i &lt; all_set; i++)&#123; vector&lt;int&gt; item; for(int j = 0; j &lt; nums.size(); j++)&#123; //如果i的第j位为1，说明，有这一位所代表的元素。 // （1 &lt;&lt; j）第j位为1，其他位为0。 // i &amp; (1 &lt;&lt; j)， i 这个数中，j这一位是不是为1。（i中是否包含这个元素） if(i &amp; (1 &lt;&lt; j))&#123; item.push_back(nums[j]); &#125; &#125; //将该子集放入集合中。 result.push_back(item); item.clear(); &#125; return result; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"排列","slug":"排列","permalink":"https://yangzebin001.github.io/tags/排列/"}]},{"title":"LeetCode 452. 用最少数量的箭引爆气球","slug":"LeetCode-452-用最少数量的箭引爆气球","date":"2019-01-17T09:46:09.000Z","updated":"2019-02-27T10:08:02.700Z","comments":true,"path":"2019/01/17/LeetCode-452-用最少数量的箭引爆气球/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-452-用最少数量的箭引爆气球/","excerpt":"452. 用最少数量的箭引爆气球 维护一个射击区间。如果下一个区间的开始位置比当前区间的开始位置大，则需要更新。同理，结束位置也一样。 也是就是说，保持在这个射击区间内，每一个气球都能被射中（求射击区间内所有球的交集）。","text":"452. 用最少数量的箭引爆气球 维护一个射击区间。如果下一个区间的开始位置比当前区间的开始位置大，则需要更新。同理，结束位置也一样。 也是就是说，保持在这个射击区间内，每一个气球都能被射中（求射击区间内所有球的交集）。 如果气球不再能被这个射击区间所容纳，则在增加一个射击区间。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int findMinArrowShots(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) &#123; if(points.size() == 0)&#123; return 0; &#125; //对气球从左端点开始排序。 sort(points.begin(),points.end()); int arrow = 1; int startindex = points[0].first; int endindex = points[0].second; for(int i = 1; i &lt; points.size(); i++)&#123; //更新最小区间。 if(points[i].first &gt; startindex &amp;&amp; points[i].first &lt;= endindex)&#123; startindex = points[i].first; &#125; if(points[i].second &lt; endindex &amp;&amp; points[i].second &gt;= startindex)&#123; endindex = points[i].second; &#125; //继续下一轮。 else if(points[i].first &gt; startindex)&#123; startindex = points[i].first; endindex = points[i].second; arrow++; &#125; &#125; return arrow; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"贪心","slug":"贪心","permalink":"https://yangzebin001.github.io/tags/贪心/"}]},{"title":"LeetCode-45- 跳跃游戏 II","slug":"LeetCode-45-跳跃游戏-II","date":"2019-01-17T09:45:06.000Z","updated":"2019-02-27T10:17:58.904Z","comments":true,"path":"2019/01/17/LeetCode-45-跳跃游戏-II/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-45-跳跃游戏-II/","excerpt":"45. 跳跃游戏 II 此题55. 跳跃游戏的进阶版 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。","text":"45. 跳跃游戏 II 此题55. 跳跃游戏的进阶版 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 按照前面题的思路，依然是从后往前搜索。每次搜索能跳到当前位置的最远位置。 123456789101112131415161718192021222324class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; // 选择当前能跳到当前点的最远的距离。 int max_index = nums.size()-1; int current_max_index = max_index; int step = 0; //当没有到达开头位置，进行循环。 while(max_index &gt; 0)&#123; //记录能跳到当前数组的最前面的点。 for(int i = max_index-1; i &gt;= 0; i--)&#123; if(i + nums[i] &gt;= max_index)&#123; current_max_index = i; &#125; &#125; //更新能跳的最远的点。 max_index = current_max_index; //步数更新 step++; &#125; return step; &#125; &#125;; 用了两层循环，发现能ac，但是又排在了末名。 看了大神的代码，写出了下面的代码： 123456789101112131415161718192021222324252627class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt; 2)&#123; return 0; &#125; //当前可到达的最远距离。 int current_max_index = nums[0]; //遍历各个位置中，可到达的最远距离。 int pre_max_max_index = nums[0]; int jump = 1; for(int i = 1; i &lt; nums.size(); i++)&#123; //更新当前可达到的最远距离。 if(i &gt; current_max_index)&#123; jump++; current_max_index = pre_max_max_index; &#125; if(pre_max_max_index &lt; nums[i] + i)&#123; //更新 pre_max_max_index = nums[i] + i; &#125; &#125; return jump; &#125; &#125;; 跳到当前所能跳到的最远的位置所在的位置中。 记录当前位置所能到达的最远的位置。 如果做到了该最远位置，更新一下。继续走。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"贪心","slug":"贪心","permalink":"https://yangzebin001.github.io/tags/贪心/"}]},{"title":"LeetCode-402-移掉K位数字","slug":"LeetCode-402-移掉K位数字","date":"2019-01-17T09:44:04.000Z","updated":"2019-02-27T10:10:52.391Z","comments":true,"path":"2019/01/17/LeetCode-402-移掉K位数字/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-402-移掉K位数字/","excerpt":"402. 移掉K位数字 给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。在保持顺序的情况下，尽可能让较小的数充当较高位。 用一个栈来计较。如果要进的数字比栈顶要大，并且可以删。直接将该数字丢弃。","text":"402. 移掉K位数字 给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。在保持顺序的情况下，尽可能让较小的数充当较高位。 用一个栈来计较。如果要进的数字比栈顶要大，并且可以删。直接将该数字丢弃。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string removeKdigits(string num, int k) &#123; //在保持顺序的情况下，尽可能让较小的数充当较高位。 std::vector&lt;int&gt; S; std::string result = \"\"; for(int i = 0; i &lt; num.length(); i++)&#123; int number = num[i]-'0'; //比当前栈顶元素大，并且能删除（k&gt;0）,直接丢弃。 while(S.size() != 0 &amp;&amp; S[S.size()-1] &gt; number &amp;&amp; k &gt; 0)&#123; S.pop_back(); k--; &#125; //0 不能在第一个位置。即不允许“0132” if(number != 0 || S.size()!= 0)&#123; S.push_back(number); &#125; &#125; // 处理“123456789”的情况。 while(S.size() != 0 &amp;&amp; k &gt; 0)&#123; S.pop_back(); k--; &#125; for(int i = 0; i &lt; S.size(); i++)&#123; result.append(1,'0'+S[i]); &#125; if(result == \"\") return \"0\"; return result; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"贪心","slug":"贪心","permalink":"https://yangzebin001.github.io/tags/贪心/"}]},{"title":"LeeCode-455-分发饼干","slug":"LeetCode-455-分发饼干","date":"2019-01-17T09:42:46.000Z","updated":"2019-02-27T10:08:14.333Z","comments":true,"path":"2019/01/17/LeetCode-455-分发饼干/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-455-分发饼干/","excerpt":"455. 分发饼干","text":"455. 分发饼干 输入: [1,2,3], [1,1] 输出: 1 解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 尽量让胃口小的孩子分到尽量少的饼干。 先排序。在饼干的循环中，如果孩子的胃口大于等于饼干，孩子加一。 ###Solution:12345678910111213141516171819class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; //先将两组数据排序。 std::sort(g.begin(),g.end()); std::sort(s.begin(),s.end()); //记录被满足的孩子和饼干 int child = 0; int cookie = 0; while(cookie &lt; s.size() &amp;&amp; child &lt; g.size())&#123; //饼干可以满足该孩子。 if(g[child] &lt;= s[cookie])&#123; child++; &#125; cookie++; &#125; return child; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"贪心","slug":"贪心","permalink":"https://yangzebin001.github.io/tags/贪心/"}]},{"title":"LeetCode-295-数据流的中位数","slug":"LeetCode-295-数据流的中位数","date":"2019-01-17T09:41:23.000Z","updated":"2019-02-27T10:11:26.981Z","comments":true,"path":"2019/01/17/LeetCode-295-数据流的中位数/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-295-数据流的中位数/","excerpt":"295. 数据流的中位数 利用堆的堆顶可以随时保持最大（小）元素的特性。使用两个堆来存储数据。 由于需要取中位数。要保持两个堆堆顶为中间的元素。所以：","text":"295. 数据流的中位数 利用堆的堆顶可以随时保持最大（小）元素的特性。使用两个堆来存储数据。 由于需要取中位数。要保持两个堆堆顶为中间的元素。所以： 构建一个最小堆用来存放较大的数。 构建一个最大堆用来存放较小的数。 （比较绕，需要用心思考一下） 要随时保持两个堆的高度平衡。 这时，两堆堆顶就是数据中的中位数了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class MedianFinder &#123; public: /** initialize your data structure here. */ MedianFinder() &#123; &#125; void addNum(int num) &#123; if(smallNums.empty())&#123; //往存放小元素的最大堆添加数据。 smallNums.push(num); return; &#125; //如果两个堆的高度相同。优先push进当前堆顶元素更大的那一个。 if(largeNums.size() == smallNums.size())&#123; if(smallNums.top() &gt; num)&#123; smallNums.push(num); &#125;else&#123; largeNums.push(num); &#125; &#125; //为了保持两个堆的平衡 。如果两堆高度不一致，分两种情况讨论 //1.存放较大元素的最小堆的高度大于存放较小元素的最大堆的高度达。 else if(largeNums.size() &gt; smallNums.size())&#123; // 该数比存放较大元素的最小堆的堆顶要大。 // 首先将该堆堆顶元素push进存放较小元素的最大堆中。 // 再将该数push进存放较大元素的最小堆 if(num &gt; largeNums.top())&#123; smallNums.push(largeNums.top()); largeNums.pop(); largeNums.push(num); &#125; // 该数比存放较大元素的最小堆的堆顶要小。 // 直接push进存放较小元素的最大堆。 else&#123; smallNums.push(num); &#125; &#125; //2.存放较大元素的最小堆的高度小于存放较小元素的最大堆的高度达。 else if(largeNums.size() &lt; smallNums.size())&#123; // 该数比存放较小元素的最大堆的堆顶要小。（该数一定要进该堆） // 首先将该堆堆顶元素push进存放较大元素的最小堆中。 // 再将该数push进存放较小元素的最大堆中。 if(num &lt; smallNums.top())&#123; largeNums.push(smallNums.top()); smallNums.pop(); smallNums.push(num); &#125; // 该数比存放较小元素的最大堆的堆顶要大。 // 直接push进存放较大元素的最小堆。 else&#123; largeNums.push(num); &#125; &#125; &#125; double findMedian() &#123; // 两堆平衡，取中位数。 if(smallNums.size() == largeNums.size())&#123; return (((double)smallNums.top() + largeNums.top())/2 ); &#125; // 不平衡，谁高取谁的堆顶。 else if(smallNums.size() &gt; largeNums.size())&#123; return smallNums.top(); &#125; return largeNums.top(); &#125; private: // 存放较大元素的最小堆 std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; largeNums; // 存放较小元素的最大堆 std::priority_queue&lt;int&gt; smallNums;&#125;;/** * Your MedianFinder object will be instantiated and called as such: * MedianFinder obj = new MedianFinder(); * obj.addNum(num); * double param_2 = obj.findMedian(); */","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"堆","slug":"堆","permalink":"https://yangzebin001.github.io/tags/堆/"}]},{"title":"LeetCode-55- 跳跃游戏","slug":"LeetCode-55-跳跃游戏","date":"2019-01-17T09:40:08.000Z","updated":"2019-02-27T10:17:31.752Z","comments":true,"path":"2019/01/17/LeetCode-55-跳跃游戏/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-55-跳跃游戏/","excerpt":"55. 跳跃游戏 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。示例 1:","text":"55. 跳跃游戏 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。示例 1: 输入: [2,3,1,1,4]输出: true解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。 示例 2: 输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 首先想到的是将所有能达到的步数全部跑一遍，如果能到达返回true。结果TLE。 然后分析，在大部分情况下都做的是重复操作。需要剪枝。用了一个辅助表。用于记录该点能否到达的了最后一个位置。不能就标记一下，查找的时候先从表里查找。如果标记过，就不需要再进行遍历了。 代码如下 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: bool jump(vector&lt;int&gt;&amp; nums, int index,vector&lt;int&gt;&amp; q)&#123; //可以达到最后一个位置，返回true if (index &gt;= nums.size() - 1) &#123; return true; &#125; //在表中能查到，说明该点不能达到。 else if (q[index] == -1) &#123; return false; &#125; //从该点开始，到该点所能到达的最后一个元素，依次搜索。 for (int i = nums[index]; i &gt; 0; i--) &#123; if (jump(nums, index + i,q)) &#123; return true; &#125; //不能达到，在表中标记。 else if(index + i &lt; q.size())&#123; q[index + i] = -1; &#125; &#125; return false; &#125; bool canJump(vector&lt;int&gt;&amp; nums) &#123; //建一个辅助表 vector&lt;int &gt; q; for (int i = 0; i &lt; nums.size(); i++) &#123; q.push_back(0); &#125; return jump(nums,0,q); &#125; &#125;; 结果能通过。但是排在了最后。 然后看了小象学院的视频。思路是先记录下每一步能跳的最大距离， 遍历这个表。用一个变量记录步数，一个变量记录能走到的最大位置。当步数小于这个最大位置，并且该步数不是最后一个位置时，说明这个数组中不能到达最后一个位置。返回false。 如果步数能走到数组的末尾，说明能走到。返回true。 12345678910111213141516171819202122232425class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; //存储该位置能跳到哪个位置（下标）。 vector&lt;int&gt; index; for(int i = 0; i &lt; nums.size(); i++)&#123; index.push_back(i + nums[i]); &#125; //能够跳跃的位置。 int jump = 0; //当前最远的位置。 int max_index = index[0]; while(jump &lt; index.size() &amp;&amp; jump &lt;= max_index)&#123; //更新最远位置 if(max_index &lt; index[jump])&#123; max_index = index[jump]; &#125; //前进一步 jump++; &#125; //走到了数组末尾。 if(jump == index.size()) return true; return false; &#125;&#125;; 看了评论区大神的代码。发现是从后往前开始判断的，依次判断是否能到达最远的距离。如果能到达，把最远的距离更新为现在所在位置。于是写出了如下代码。 12345678910111213141516171819class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; //能到达最远位置坐标 int n = nums.size()-1; for(int i = nums.size()-2; i &gt;= 0; i--)&#123; //从该点可以达到终点坐标，则将最远位置的坐标更新为该点的坐标。 if(nums[i] + i &gt;= n)&#123; n = i; &#125; &#125; //能够到达头部。 if(n == 0)&#123; return true; &#125;else &#123; return false; &#125; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"贪心","slug":"贪心","permalink":"https://yangzebin001.github.io/tags/贪心/"}]},{"title":"LeetCode-215-数组中的第K个最大元素","slug":"LeetCode-215-数组中的第K个最大元素","date":"2019-01-17T09:38:26.000Z","updated":"2019-02-27T10:12:33.607Z","comments":true,"path":"2019/01/17/LeetCode-215-数组中的第K个最大元素/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-215-数组中的第K个最大元素/","excerpt":"215. 数组中的第K个最大元素 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。Solution1：","text":"215. 数组中的第K个最大元素 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。Solution1： 1234567class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; std::sort(nums.begin(),nums.end()); return nums[nums.size()-k]; &#125;&#125;; 思路：直接使用sort()函数。将倒数第K的元素直接返回。这样做的复杂度就为sort函数的复杂度。 Solution2：1234567891011121314151617#include &lt;vector&gt;#include &lt;queue&gt;class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; Q; for(int i = 0; i &lt; nums.size(); i++)&#123; if(Q.size() &lt; k)&#123; Q.push(nums[i]); &#125;else if(Q.top() &lt; nums[i])&#123; Q.pop(); Q.push(nums[i]); &#125; &#125; return Q.top(); &#125;&#125;; 思路：使用最小堆。 维护一个K大小的最小堆。最小堆的堆顶始终为最小元素。当有比堆顶更大的时候，让更大的元素进堆，堆顶的元素出堆。这样遍历一遍后。第K大的元素就到了堆顶。直接弹出即可。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"堆","slug":"堆","permalink":"https://yangzebin001.github.io/tags/堆/"}]},{"title":"LeetCode 224. 基本计算器","slug":"LeetCode-224-基本计算器","date":"2019-01-05T12:19:14.000Z","updated":"2019-02-27T10:12:08.959Z","comments":true,"path":"2019/01/05/LeetCode-224-基本计算器/","link":"","permalink":"https://yangzebin001.github.io/2019/01/05/LeetCode-224-基本计算器/","excerpt":"224. 基本计算器 实现一个基本的计算器来计算一个简单的字符串表达式的值。字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格。","text":"224. 基本计算器 实现一个基本的计算器来计算一个简单的字符串表达式的值。字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格。 Solution：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution &#123;public: void compute(std::stack&lt;int&gt; &amp;number_stack, std::stack&lt;char&gt; &amp;operation_stack)&#123; if(number_stack.size() &lt; 2)&#123; return; &#125; int num2 = number_stack.top(); number_stack.pop(); int num1 = number_stack.top(); number_stack.pop(); if(operation_stack.top() == '+')&#123; number_stack.push(num1 + num2); &#125;else if(operation_stack.top() == '-')&#123; number_stack.push(num1 - num2); &#125; operation_stack.pop(); &#125; int calculate(string s) &#123; static const int STATE_BEGIN = 0; static const int NUMBER_STATE = 1; static const int OPERATION_STATE = 2; std::stack&lt;int&gt; number_stack; std::stack&lt;char&gt; operation_stack; int number = 0; int STATE = STATE_BEGIN; int compuate_flag = 0; for(int i = 0; i &lt; s.length(); i++)&#123; if(s[i] == ' ')&#123; continue; &#125; switch(STATE)&#123; case STATE_BEGIN: if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9')&#123; STATE = NUMBER_STATE; &#125;else&#123; STATE = OPERATION_STATE; &#125; i--; break; case NUMBER_STATE: if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9')&#123; number = number * 10 + s[i] - '0'; &#125;else&#123; number_stack.push(number); if(compuate_flag == 1)&#123; compute(number_stack,operation_stack); &#125; number = 0; i--; STATE = OPERATION_STATE; &#125; break; case OPERATION_STATE: if(s[i] == '+' || s[i] == '-')&#123; operation_stack.push(s[i]); compuate_flag = 1; &#125;else if(s[i] == '(')&#123; STATE = NUMBER_STATE; compuate_flag = 0; &#125;else if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9')&#123; STATE = NUMBER_STATE; i--; &#125;else if(s[i] == ')')&#123; compute(number_stack,operation_stack); &#125; break; &#125; &#125; if(number != 0)&#123; number_stack.push(number); compute(number_stack,operation_stack); &#125; if(number == 0 &amp;&amp; number_stack.empty())&#123; return 0; &#125; return number_stack.top(); &#125;&#125;; 首先，数据用两个栈来存储。一个存数字，一个存操作符。 其次，建立一个状态机，来描述指针的走向状态。根据状态来做相应的操作。 刚开始有一个开始状态。检测下一个字符是数字还是字母。然后转换为相应的状态。 我们先讨论数字与操作符的存储时机： 当指针指向数字时，先将数字暂存起来，继续检查下一位置，还是数字，继续与暂存的数字融合。当指针指向的不是数字时，这时就需要把这个数字存起来。 字符的存储时机就为该位置为+、-时进行存储。 接下来讨论计算的时机。 首先是检测操作符，如果操作符后面是数字，则在该数字进行存储完成之后立马进行计算。 如果操作符之后是” ( “ 就要等下一个相应的” ) “出现。之后再进行计算。 所以设置一个计算标志。如果检测到操作符，把计算标志置为可计算，接着继续下一位的检测，如果是数字，就在存储后进行计算。如果是” ( “，就需要取消计算标志。 一定要注意退格操作！！！ 退格发生在下一位置不再是数字或者在操作符之后的检测是不是数字的时候。 最后就是将描述翻译成代码的工作了。 这里注意，在表达式的最后通常是数字，这时也需要将数字存储起来再进行一次运算。 如果表达式正确，存储数字的栈的长度一定是1，直接返回栈顶。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"状态机","slug":"状态机","permalink":"https://yangzebin001.github.io/tags/状态机/"}]},{"title":"LeetCode 232. 用栈实现队列","slug":"LeetCode-232-用栈实现队列","date":"2019-01-02T12:30:00.000Z","updated":"2019-01-31T10:12:30.984Z","comments":true,"path":"2019/01/02/LeetCode-232-用栈实现队列/","link":"","permalink":"https://yangzebin001.github.io/2019/01/02/LeetCode-232-用栈实现队列/","excerpt":"232. 用栈实现队列 使用栈实现队列的下列操作： push(x) – 将一个元素放入队列的尾部。 pop() – 从队列首部移除元素。 peek() – 返回队列首部的元素。 empty() – 返回队列是否为空。","text":"232. 用栈实现队列 使用栈实现队列的下列操作： push(x) – 将一个元素放入队列的尾部。 pop() – 从队列首部移除元素。 peek() – 返回队列首部的元素。 empty() – 返回队列是否为空。 Solution:1234567891011121314151617181920212223242526272829303132333435363738class MyQueue &#123;public: /** Initialize your data structure here. */ MyQueue() &#123; &#125; /** push all element of _s1 to _s2*/ void pushTos2()&#123; if(_s1.empty()) return; while(!_s1.empty())&#123; _s2.push(_s1.top()); _s1.pop(); &#125; &#125; /** Push element x to the back of queue. */ void push(int x) &#123; return _s1.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; if(_s2.empty()) pushTos2(); int a = _s2.top(); _s2.pop(); return a; &#125; /** Get the front element. */ int peek() &#123; if(_s2.empty()) pushTos2(); return _s2.top(); &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return _s1.empty() &amp;&amp; _s2.empty(); &#125; private: std::stack&lt;int&gt; _s1; std::stack&lt;int&gt; _s2;&#125;; 使用两个栈来实现堆。 在做push操作的时候，直接push进第一个栈。 当要pop时，先检查第二栈是否为空，如果为空，就把第一个栈的元素全push进第二个栈，这是原本在第一个栈栈底的元素，就到了第二个栈的栈顶（相当于翻了个个)。这时就可以pop出去了。 下面的函数实现的就是专门将第一个栈的元素全部push进第二栈的功能。12345678/** push all element of _s1 to _s2*/ void pushTos2()&#123; if(_s1.empty()) return; while(!_s1.empty())&#123; _s2.push(_s1.top()); _s1.pop(); &#125; &#125; 当peek时，如果第二个栈已经没有元素。 也需要把第一个栈的元素“倒”进来，再进行peek(); empty：当两个栈都没有元素才算空。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 225. 用队列实现栈","slug":"LeetCode-225-用队列实现栈","date":"2019-01-02T12:29:14.000Z","updated":"2019-01-31T10:12:21.866Z","comments":true,"path":"2019/01/02/LeetCode-225-用队列实现栈/","link":"","permalink":"https://yangzebin001.github.io/2019/01/02/LeetCode-225-用队列实现栈/","excerpt":"225. 用队列实现栈 使用队列实现栈的下列操作： push(x) – 元素 x 入栈 pop() – 移除栈顶元素 top() – 获取栈顶元素 empty() – 返回栈是否为空 Solution：","text":"225. 用队列实现栈 使用队列实现栈的下列操作： push(x) – 元素 x 入栈 pop() – 移除栈顶元素 top() – 获取栈顶元素 empty() – 返回栈是否为空 Solution： 1234567891011121314151617181920212223242526272829303132333435363738394041class MyStack &#123;public: /** Initialize your data structure here. */ MyStack() &#123; &#125; /** Push element x onto stack. */ void push(int x) &#123; std::queue&lt;int&gt; temp_queue; temp_queue.push(x); while(!data_queue.empty())&#123; temp_queue.push(data_queue.front()); data_queue.pop(); &#125; while(!temp_queue.empty())&#123; data_queue.push(temp_queue.front()); temp_queue.pop(); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int x = data_queue.front(); data_queue.pop(); return x; &#125; /** Get the top element. */ int top() &#123; return data_queue.front(); &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return data_queue.empty(); &#125; private: std::queue&lt;int&gt; data_queue;&#125;; 核心思想：让新进来的元素始终在队列的头位置。所以需要一个临时的队列。先让push进来的元素进去临时队列里。再让原来的队列的元素全进去临时队列，这样就保证了队列的头位置始终是新进来的元素。再将临时队列的所有元素push回原队列。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 61. 旋转链表","slug":"LeetCode-61-旋转链表","date":"2019-01-01T14:40:48.000Z","updated":"2019-02-27T10:17:12.203Z","comments":true,"path":"2019/01/01/LeetCode-61-旋转链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-61-旋转链表/","excerpt":"61. 旋转链表 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。Example: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL","text":"61. 旋转链表 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。Example: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 123456789101112131415161718192021222324252627282930int getListNodeLength(struct ListNode * head)&#123; struct ListNode * head1 = head; int len = 0; while(head1)&#123; len++; head1 = head1-&gt;next; &#125; return len;&#125;struct ListNode* getPosition(struct ListNode* head, int index)&#123; if(index &lt; 0) return NULL; struct ListNode * head1 = head; while(index)&#123; head1 = head1-&gt;next; index--; &#125; return head1;&#125;struct ListNode* rotateRight(struct ListNode* head, int k) &#123; int len = getListNodeLength(head); if(len &lt;=1 || (k %= len) &lt; 1) return head; int position = len-k-1; struct ListNode* oldlast = getPosition(head,len-1); struct ListNode* newhead = getPosition(head,position+1); struct ListNode* newlast = getPosition(head,position); oldlast-&gt;next = head; newlast-&gt;next = NULL; return newhead;&#125; 思路:该题看似是循环n次，实则将后K个元素移至头结点的位置。 直接找到最后一个元素，将它指向开始的位置。将倒数第k+1个元素指向NULL。 k可以大于链表的长度，所以要对链表长度取模。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"链表","slug":"链表","permalink":"https://yangzebin001.github.io/tags/链表/"}]},{"title":"LeetCode 24. 两两交换链表中的节点","slug":"LeetCode-24-两两交换链表中的节点","date":"2019-01-01T14:39:50.000Z","updated":"2019-02-27T10:18:38.313Z","comments":true,"path":"2019/01/01/LeetCode-24-两两交换链表中的节点/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-24-两两交换链表中的节点/","excerpt":"24. 两两交换链表中的节点 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。Example：给定 1-&gt;2-&gt;3-&gt;4，你应该返回 2-&gt;1-&gt;4-&gt;3。","text":"24. 两两交换链表中的节点 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。Example：给定 1-&gt;2-&gt;3-&gt;4，你应该返回 2-&gt;1-&gt;4-&gt;3。 1234567891011121314151617181920struct ListNode* swapPairs(struct ListNode* head) &#123; //设置头结点 struct ListNode* first = (struct ListNode*)malloc(sizeof(struct ListNode)); first-&gt;next = head; //备份 struct ListNode* first1 = first; // 如果头结点后有两个结点 while(first-&gt;next &amp;&amp; first-&gt;next-&gt;next)&#123; //两个结点 struct ListNode* one = first-&gt;next; struct ListNode* two = first-&gt;next-&gt;next; //交换两个结点。 one-&gt;next = two-&gt;next; first-&gt;next = two; two-&gt;next = one; first = one; &#125; //返回 return first1-&gt;next;&#125; 思路：用一个指针从开始读，如果可以读到该节点与下个节点，就将这两个结点交换位置，这时需要注意与前后的结点连接。 为了方便，用一个头结点来完成这个连接的工作。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"链表","slug":"链表","permalink":"https://yangzebin001.github.io/tags/链表/"}]},{"title":"LeetCode 86. 分隔链表","slug":"LeetCode-86-分隔链表","date":"2019-01-01T14:38:47.000Z","updated":"2019-01-31T10:11:39.065Z","comments":true,"path":"2019/01/01/LeetCode-86-分隔链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-86-分隔链表/","excerpt":"86. 分隔链表 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。你应当保留两个分区中每个节点的初始相对位置。Example：给定 head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2， x = 3。 你应该返回 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5。","text":"86. 分隔链表 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。你应当保留两个分区中每个节点的初始相对位置。Example：给定 head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2， x = 3。 你应该返回 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5。 Solution1：1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; //创建两个头结点 ListNode less_head(0); ListNode more_head(0); ListNode *less_ptr = &amp;less_head; ListNode *more_ptr = &amp;more_head; while(head)&#123; //将val小于x的分进less_ptr，大于等于的分进more_ptr; if(head-&gt;val &lt; x)&#123; less_ptr-&gt;next = head; less_ptr = less_ptr-&gt;next; &#125;else&#123; more_ptr-&gt;next = head; more_ptr = more_ptr-&gt;next; &#125; head = head-&gt;next; &#125; //连接两个指针。 less_ptr-&gt;next = more_head.next; more_ptr-&gt;next = NULL; return less_head.next; &#125;&#125;; 思路：用双指针。创建两个头结点。比x小的划到第一个里面，否则划到第二个里面，最后将两个链表链接返回。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 138. 复制带随机指针的链表","slug":"LeetCode-138-复制带随机指针的链表","date":"2019-01-01T14:36:49.000Z","updated":"2019-02-11T14:29:37.638Z","comments":true,"path":"2019/01/01/LeetCode-138-复制带随机指针的链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-138-复制带随机指针的链表/","excerpt":"138. 复制带随机指针的链表 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深度拷贝。","text":"138. 复制带随机指针的链表 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深度拷贝。 12345678/** * Definition for singly-linked list with a random pointer. * struct RandomListNode &#123; * int label; * RandomListNode *next, *random; * RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125; * &#125;; */ Solution: 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode *head) &#123; //建立结点与当前位置的映射 std::map&lt;RandomListNode *, int&gt; node_map; //存放copy了的所有结点。按位置。 std::vector&lt;RandomListNode *&gt; node_vec; RandomListNode *ptr = head; int i = 0; while(ptr)&#123; //创建与旧链表相等的结点。copy其中的值。 node_vec.push_back(new RandomListNode(ptr-&gt;label)); // 建立结点与当前位置的映射。 node_map[ptr] = i; ptr = ptr-&gt;next; i++; &#125; //push尾结点 node_vec.push_back(0); ptr = head; i = 0; while(ptr)&#123; //将依次排列的结点的next相连接。 node_vec[i]-&gt;next = node_vec[i+1]; if(ptr-&gt;random)&#123; //找到该结点对应所指向的random所映射的位置。然后赋给当前结点。 int id = node_map[ptr-&gt;random]; node_vec[i]-&gt;random = node_vec[id]; &#125; ptr = ptr-&gt;next; i++; &#125; //返回首结点 return node_vec[0]; &#125;&#125;; 思路:如果没有random域，copy链表只要依次创建结点，并将当前结点的next指向下一个结点就完成了。 有random域会比较麻烦一些。需要通过建立一张结点与其位置的表来完成。 当需要填充random指向时，通过原链表的random域在表中的位置来将vector中这一位置的结点地址赋给random域。 Solution2：1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode *head) &#123; //为每个节点添加一个副本，链接在当前节点之后。 RandomListNode* cur = head; while(cur)&#123; RandomListNode* next = cur-&gt;next; cur-&gt;next = new RandomListNode(cur-&gt;label); cur-&gt;next-&gt;next = next; cur = cur-&gt;next-&gt;next; &#125; //copy随机指针 cur = head; while(cur)&#123; RandomListNode* random = cur-&gt;random; //如果随机指针不为空 if(random) cur-&gt;next-&gt;random = random-&gt;next; cur = cur-&gt;next-&gt;next; &#125; cur = head; // 新链表的头节点 RandomListNode* copyhead = new RandomListNode(0); RandomListNode* copyhead1 = copyhead; //split为两个链表 while(cur)&#123; copyhead-&gt;next = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; copyhead = copyhead-&gt;next; cur = cur-&gt;next; &#125; copyhead-&gt;next = NULL; return copyhead1-&gt;next; &#125;&#125;; 思路： 第一遍遍历：将每个节点copy出来之后连接到该结点的后面。这样得到了两倍原本链表长度的链表。 第二遍遍历：将每个原节点的random域复制到它之后的copy节点。 第三遍遍历：将两个链表分离。原节点重新相链接，copy后的结点相链接。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 23. 合并K个排序链表","slug":"LeetCode-23-合并K个排序链表","date":"2019-01-01T14:35:08.000Z","updated":"2019-02-27T10:18:48.774Z","comments":true,"path":"2019/01/01/LeetCode-23-合并K个排序链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-23-合并K个排序链表/","excerpt":"23. 合并K个排序链表 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。Solution1：","text":"23. 合并K个排序链表 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。Solution1： 1234567891011121314151617181920212223242526272829bool cmp(const ListNode* a,const ListNode *b)&#123; return a-&gt;val &lt; b-&gt;val;&#125;class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; std::vector&lt;ListNode*&gt; node_vec; //将每个结点push到vec中。 for(int i = 0; i &lt; lists.size(); i++)&#123; ListNode* head = lists[i]; while(head)&#123; node_vec.push_back(head); head = head-&gt;next; &#125; &#125; if(node_vec.size() == 0)&#123; return NULL; &#125; //将vec中的元素按val域排序。 std::sort(node_vec.begin(),node_vec.end(),cmp); //链接各个结点。 for(int i = 1;i &lt; node_vec.size();i++)&#123; node_vec[i-1]-&gt;next = node_vec[i]; &#125; //最后一个结点指向NULL node_vec[node_vec.size()-1]-&gt;next = NULL; return node_vec[0]; &#125;&#125;; 该方法比较粗暴。将所有的结点存入一个vector中，按结点中的值排序，然后依次将每个结点链接，最后返回。 Solution2：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode p0 = ListNode(0); ListNode* p = &amp;p0; ListNode* p1 = p; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; p-&gt;next = new ListNode(l1-&gt;val); p = p-&gt;next; l1 = l1-&gt;next; &#125;else&#123; new ListNode(l2-&gt;val); p-&gt;next = new ListNode(l2-&gt;val); p = p-&gt;next; l2 = l2-&gt;next; &#125; &#125; p-&gt;next = (l1!=NULL) ? l1 :(l2!=NULL) ? l2 : NULL; return p1-&gt;next; &#125; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; //两个终止条件。 if(lists.size() == 0)&#123; return NULL; &#125; if(lists.size() == 1)&#123; return lists[0]; &#125; //将lists拆分成两个子lists; int mid = lists.size()/2; std::vector&lt;ListNode*&gt; sub1_lists; std::vector&lt;ListNode*&gt; sub2_lists; for(int i = 0; i &lt; mid; i++)&#123; sub1_lists.push_back(lists[i]); &#125; for(int i = mid; i &lt; lists.size(); i++)&#123; sub2_lists.push_back(lists[i]); &#125; //递归调用 ListNode *l1 = mergeKLists(sub1_lists); ListNode *l2 = mergeKLists(sub2_lists); //返回两个链表合并的结果。 return mergeTwoLists(l1,l2); &#125;&#125;; 思路:（归并思想）递归算法。将k个链表分割为独立的链表，再向上两两合并。 合并两个有序链表的子问题参照：21. 合并两个排序链表","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"归并","slug":"归并","permalink":"https://yangzebin001.github.io/tags/归并/"}]},{"title":"LeetCode 155. 最小栈","slug":"LeetCode-155-最小栈","date":"2019-01-01T14:33:56.000Z","updated":"2019-02-27T10:13:39.038Z","comments":true,"path":"2019/01/01/LeetCode-155-最小栈/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-155-最小栈/","excerpt":"155. 最小栈 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。 pop() – 删除栈顶的元素。 top() – 获取栈顶元素。 getMin() – 检索栈中的最小元素。 Solution：","text":"155. 最小栈 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。 pop() – 删除栈顶的元素。 top() – 获取栈顶元素。 getMin() – 检索栈中的最小元素。 Solution： 123456789101112131415161718192021222324252627282930class MinStack &#123; public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; _data.push(x); // 更新当前的最小值状态。 if(_min.empty() || _min.top() &gt;= x )&#123; _min.push(x); &#125; &#125; void pop() &#123; //如果是要弹出当前的最小值。将min中的值也一并弹出。 if(_data.top() == _min.top())&#123; _min.pop(); &#125; _data.pop(); &#125; int top() &#123; return _data.top(); &#125; int getMin() &#123; //返回最小栈的栈顶 return _min.top(); &#125; private: std::stack&lt;int&gt; _data; std::stack&lt;int&gt; _min;&#125;; 思路:原来想用一个变量来记录最小值，这在push的时候没什么问题，但是当执行pop操作的时候，就不知道怎么更新了。 所以需要将每次一更新最小值都记录下来。 使用另一个栈记录最小值的变更状态。 每插入一个值，与之比较最小栈的栈顶的元素，如果比栈顶的元素小，就更新其状态，如果与栈顶元素相等，也需要插入。 当出栈的时候，如果与最小栈栈顶元素相等，最小栈也出栈。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"设计，栈","slug":"设计，栈","permalink":"https://yangzebin001.github.io/tags/设计，栈/"}]},{"title":"LeetCode 92. 反转链表 II","slug":"LeetCode-92-反转链表-II","date":"2019-01-01T14:32:44.000Z","updated":"2019-02-27T10:16:23.057Z","comments":true,"path":"2019/01/01/LeetCode-92-反转链表-II/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-92-反转链表-II/","excerpt":"92. 反转链表 II 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 ###Solution：","text":"92. 反转链表 II 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 ###Solution： 1234567891011121314151617181920212223242526272829struct ListNode* reverseBetween(struct ListNode* head, int m, int n) &#123; int chang_len = n-m+1;//逆置的结点个数。 struct ListNode* prevHead = NULL;//记录开始逆置结点的前驱。 struct ListNode* result = head;//用于最后返回。 while(head &amp;&amp; --m)&#123; //到达开始逆置的位置。 prevHead = head; head = head-&gt;next; &#125; struct ListNode * modify_list_tail = head;//将该结点之前当前开始逆置的结点。 struct ListNode * newHead = NULL;//用于逆置结点。 while(head &amp;&amp; chang_len)&#123; struct ListNode * next = head-&gt;next; head-&gt;next = newHead; newHead = head; head = next; chang_len--; &#125; //此时head就到了n处，modify_list_tail就到了逆置段的最后一个结点。 //将modify_list_tail 与 head连接。 modify_list_tail-&gt;next = head; if(prevHead)&#123; //如果prevHead不为空，说明不是从第一个几点开始逆置的。 m &gt; 1。 prevHead-&gt;next = newHead; &#125;else&#123; result = newHead; //如果prevHead为空， 则说明是从第一个就开始逆置，直接将逆置后的头结点赋值给res，m=1。 &#125; return result;&#125; 思路：解决这个问题主要是要找关键节点。 这个题的关键节点为： 要逆置的结点的前一个结点（prevHead）。 要逆置的第一个结点。（直接用head来探测）。 要逆置的最后一个结点。（此结点为逆置前的第一个结点，逆置后就变为了最后一个结点） 要逆置的最后一个结点的后一个结点。（在用head逆置后，head就到了逆置后的这个结点。） 找到前两个结点。 从m开始，到n，一共需要n-m+1个结点需要逆置。所以要逆置n-m+1次。 将逆置后的尾结点 与 逆置段后面一个结点相连。 如果结点是从开始逆置，将逆置后的头结点返回。否则，将前面的结点与逆置后的头结点链接返回。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"链表","slug":"链表","permalink":"https://yangzebin001.github.io/tags/链表/"}]},{"title":"LeetCode 160. 相交链表","slug":"LeetCode-160-相交链表","date":"2019-01-01T14:26:20.000Z","updated":"2019-02-27T10:13:25.774Z","comments":true,"path":"2019/01/01/LeetCode-160-相交链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-160-相交链表/","excerpt":"160. 相交链表 Solution1：","text":"160. 相交链表 Solution1： 1234567891011121314151617class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; std::set&lt;ListNode*&gt; node_set; while(headA)&#123; node_set.insert(headA); headA = headA-&gt;next; &#125; while(headB)&#123; if(node_set.find(headB)!=node_set.end())&#123; return headB; &#125; headB = headB-&gt;next; &#125; return NULL; &#125;&#125;; 思路：这种思路很简单。就是先将链表A的每个元素存入set中，在链表B的元素逐个去set中查找。找到就返回。缺点：使用了O(n)的空间。 Solution2：1234567891011121314151617181920212223242526272829303132333435363738394041//获得链表的长度。int get_list_length(ListNode * head)&#123; int len = 0; while(head)&#123; head = head-&gt;next; len++; &#125; return len;&#125;//将长的链表移动多余的步数；以致两个链表到了相等的长度。ListNode* forward_long_list(int long_len, int short_len, ListNode* head)&#123; int step = long_len-short_len; while(head &amp;&amp; step)&#123; head = head-&gt;next; step--; &#125; return head;&#125;class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; int headA_len = get_list_length(headA); int headB_len = get_list_length(headB); //先移动较长的链表至两个链表的长度相等。 if(headA_len&gt;headB_len)&#123; headA = forward_long_list(headA_len,headB_len,headA); &#125;else&#123; headB = forward_long_list(headB_len,headA_len,headB); &#125; //再同时开始移动。如果这两个结点相等了，就找到了 while(headA &amp;&amp; headB)&#123; if(headA == headB)&#123; return headA; &#125; headA = headA-&gt;next; headB = headB-&gt;next; &#125; return NULL; &#125;&#125;; 思路：由于后面的结点是两个链表共享的，所以链表在相交结点之前有可能长度不相等。 我们先将长的链表移动到与短链表相同的长度，然后两个链表同时移动，当两个结点变得相同时，就得到了相同结点。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"双指针","slug":"双指针","permalink":"https://yangzebin001.github.io/tags/双指针/"}]},{"title":"LeetCode 141. 环形链表","slug":"LeetCode-141-环形链表","date":"2018-12-30T07:55:13.000Z","updated":"2019-02-27T10:14:29.891Z","comments":true,"path":"2018/12/30/LeetCode-141-环形链表/","link":"","permalink":"https://yangzebin001.github.io/2018/12/30/LeetCode-141-环形链表/","excerpt":"141. 环形链表 题目描述：给定一个链表，判断链表中是否有环。Solution1:","text":"141. 环形链表 题目描述：给定一个链表，判断链表中是否有环。Solution1: 123456789101112131415class Solution &#123;public: bool hasCycle(ListNode *head) &#123; std::set&lt;ListNode*&gt; node_set; while(head)&#123; if(node_set.find(head) == node_set.end())&#123; node_set.insert(head); &#125;else&#123; return true; &#125; head = head-&gt;next; &#125; return false; &#125;&#125;; 思路：使用set。将每一个结点在set中检查，如果没有，就插入该结点。如果找到了，就说明有环。如果到头了，说明没环，返回false； 该方法由于使用了set，所以空间复杂度为O(n); Solution2：1234567891011121314151617bool hasCycle(struct ListNode *head) &#123; struct ListNode *slow = head; struct ListNode *fast = head; while(fast)&#123; slow = slow-&gt;next; fast = fast-&gt;next; if(fast)&#123; fast = fast-&gt;next; &#125;else&#123; return false; &#125; if(slow == fast)&#123; return true; &#125; &#125; return false;&#125; 思路：使用双指针。用两个移动速度快慢不相同的指针来判断是否有环。如果有环，两个指针终会相遇，返回true。 由于快指针一定在慢指针的前面，所以在移动指针时，只要判断快指针是否为空，如果是，就说明没有环。返回false；","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"双指针","slug":"双指针","permalink":"https://yangzebin001.github.io/tags/双指针/"}]},{"title":"LeetCode 234.回文链表","slug":"leetcode-234-回文链表","date":"2018-12-30T07:44:12.000Z","updated":"2019-02-27T10:11:46.966Z","comments":true,"path":"2018/12/30/leetcode-234-回文链表/","link":"","permalink":"https://yangzebin001.github.io/2018/12/30/leetcode-234-回文链表/","excerpt":"234.回文链表 请判断一个链表是否为回文链表。Solution1：","text":"234.回文链表 请判断一个链表是否为回文链表。Solution1： 1234567891011121314151617181920212223242526272829303132333435//获得链表长度int getListLength(ListNode* head)&#123; int len = 0; while(head)&#123; head = head-&gt;next; len++; &#125; return len;&#125;class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; ListNode* head1 = head; int listlen = getListLength(head1); if(listlen &lt;= 1) return true; int mid = listlen/2; std::stack&lt;int&gt; s; while(mid &amp;&amp; head)&#123; s.push(head-&gt;val); head = head-&gt;next; mid--; &#125; if(listlen%2 != 0)&#123; head = head-&gt;next; &#125; while(head)&#123; if(head-&gt;val != s.top())&#123; return false; &#125; s.pop(); head = head-&gt;next; &#125; return true; &#125;&#125;; 思路:借助stack。 将mid之前的元素值都push进stack中，然后到mid之后，将每个元素与栈顶值比较。不相等退出，相等继续下一轮。 Solution2：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//获得链表长度int getListLength(ListNode* head)&#123; int len = 0; while(head)&#123; head = head-&gt;next; len++; &#125; return len;&#125;//根据位置与所给链表，向后移动position步。ListNode* getNodeByPosition(ListNode* head,int position)&#123; while(position&gt;0)&#123; head = head-&gt;next; position--; &#125; return head;&#125;class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; //存储头结点。 ListNode* first = head; ListNode* head1 = head; int listlen = getListLength(head); int midposition = listlen/2; //如果链表长度&lt;=1，直接返回true; if(listlen &lt;= 1) return true; //到达需要翻转的长度，对于偶数，为（listlen/2）+1，对于奇数，为listlen/2; ListNode* mid = getNodeByPosition(head1,midposition); //翻转mid之后的指针。 ListNode * newHead = NULL; int position = listlen-midposition; while(mid &amp;&amp; position)&#123; ListNode* next = mid-&gt;next; mid-&gt;next = newHead; newHead = mid; mid = next; position--; &#125; //将翻转之后的链表与开头的链表的内容比较，向后比较listlen/2; //如果是偶数，则元素都会比较到，如果是奇数，最后一个元素不会比较到。他在原来的链表中就处于中心位置，不必比较。 while(first &amp;&amp; newHead &amp;&amp; midposition)&#123; //只要不相等，就为false; if(first-&gt;val != newHead-&gt;val) return false; first = first-&gt;next; newHead = newHead-&gt;next; midposition--; &#125; return true; &#125;&#125;; 思路：将链表的后半段翻转，从翻转位置开始与从头结点开始，依次比较（listlen/2次）。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"双指针","slug":"双指针","permalink":"https://yangzebin001.github.io/tags/双指针/"}]},{"title":"LeetCode 142. 环形链表 II","slug":"leetcode-142-环形链表-II","date":"2018-12-30T07:27:57.000Z","updated":"2019-02-27T10:14:16.940Z","comments":true,"path":"2018/12/30/leetcode-142-环形链表-II/","link":"","permalink":"https://yangzebin001.github.io/2018/12/30/leetcode-142-环形链表-II/","excerpt":"142. 环形链表 II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。","text":"142. 环形链表 II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 Solution1:123456789101112131415class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; std::set&lt;ListNode*&gt; node_set; while(head)&#123; if(node_set.find(head) == node_set.end())&#123; node_set.insert(head); &#125;else&#123; return head; &#125; head = head-&gt;next; &#125; return NULL; &#125;&#125;; 与141号问题的Solutions1一个思路，直接使用set。只不过返回的是结点不是boolean值罢了。 Solutions2:123456789101112131415161718192021222324252627282930313233class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; ListNode * head1 = head; ListNode * slow = head; ListNode * fast = head; //fast走一步，slow走两步 while(fast)&#123; slow = slow-&gt;next; fast = fast-&gt;next; if(fast)&#123; fast = fast-&gt;next; &#125;else&#123; //没有环退出 return NULL; &#125; //有环退出循环 if(fast == slow)&#123; break; &#125; &#125; //说明有环 while(head1 &amp;&amp; fast)&#123; if(head1 == fast)&#123; return fast; &#125; head1 = head1-&gt;next; fast = fast-&gt;next; &#125; //不会走到这步，只是为了保证函数正常运行 return NULL; &#125;&#125;; 思路：这种方法只会使用O(1)的空间。 该方法的思路需要一点数学基础： 在一个有环的链表中，slow指针与fast指针相遇，从该相遇的位置开始，与链表的头位置开始，两者走同样的步数，如果两者相交，就走到了环的开始位置。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"双指针","slug":"双指针","permalink":"https://yangzebin001.github.io/tags/双指针/"}]},{"title":"读书简录","slug":"reading-note","date":"2018-12-02T08:44:00.000Z","updated":"2018-12-02T01:27:53.823Z","comments":true,"path":"2018/12/02/reading-note/","link":"","permalink":"https://yangzebin001.github.io/2018/12/02/reading-note/","excerpt":"2017/09/01 《挪威的森林》《如何高效学习》《极简主义》","text":"2017/09/01 《挪威的森林》《如何高效学习》《极简主义》 《潜规则》 吴思《旋元佑进阶文法》2017/10/20 《遇见未知的自己》2017/11/10 《响应式WEB设计》《HTML5与CSS3基础教程》2017/12/12 《JavasrciptDOM编程艺术》2017/12/25 《Javascript高级程序设计》（第三版）2018/01/18 《明朝那些事》2018/01/21 《版式设计原理与应用》2018/03/28 《给青年的十二封信》朱光潜2018/04/28 《富爸爸穷爸爸》2018/06/22 《计算机学科概论》2018/07/09 《烟火人间》老舍2018/07/26 《C程序设计（第四版）》谭浩强2018/09/13 《算法图解》《浪潮之巅》2018/10/13 《数学之美》2018/10/25 《黑客与画家》2018/11/15 《c指针》2018/11/23 《沉默的大多数》王小波2018/11/25","categories":[],"tags":[{"name":"读书","slug":"读书","permalink":"https://yangzebin001.github.io/tags/读书/"}]},{"title":"一文学会Git","slug":"一文学会git","date":"2018-10-03T08:44:00.000Z","updated":"2018-10-05T14:10:57.810Z","comments":true,"path":"2018/10/03/一文学会git/","link":"","permalink":"https://yangzebin001.github.io/2018/10/03/一文学会git/","excerpt":"一、GIT下载、安装与配置1.下载与安装下载git只需要直接在官网下载就可以了，它会自动下载适合你电脑配置的版本。 官网 安装就一直下一步就可以了。","text":"一、GIT下载、安装与配置1.下载与安装下载git只需要直接在官网下载就可以了，它会自动下载适合你电脑配置的版本。 官网 安装就一直下一步就可以了。 2.配置安装完成之后右键菜单就会自动添加两个选项： Git GUI Git Bash 在任意目录下右键点击 Git Bash 打开Git 命令行，输入一下两条命令： 123git config --global user.name &quot;USERNAME&quot;git config --global user.email &quot;xxx@xx.com&quot; “USERNAME”填写你的用户名“xxx@xx.com”填写你的邮箱 这样配置完后你之后所创建的仓库都会默认创建在你的名下。 查看你的配置，输入下面的命令： 1git config --list 其中有两条条目为user.name和user.email即为你所配置的。 二、Git基本操作1、新建仓库进入一个你要进行Git的目录（通常是你的工程目录）然后在右键菜单中进入Git Bash，键入命令： 1git init 它会在当前目录下创建一个.git的隐藏文件夹用来保存与git操作有关的相关信息。 2、向仓库暂存区里添加文件1git add FILENAME 命令可以将文件添加到你所创建的仓库的暂存区中。 关于add命令有俩点需要注意： 1.add现在还没有真正添加到仓库中，而是作为预备项来决定是否最终添加到仓库中。 2.这里的添加文件并不是你所在仓库的文件有了这个文件就可以了。仓库创建好后并不等于你所在文件夹中的所有文件也同样包含于仓库中，你需要手动告诉Git你要添加当前目录下的哪些文件到它的仓库中。 你可以用以下命令来将所在文件夹下属的所有文件或者文件夹添加到暂存区中：123git add --all/-Aorgit add * 3、向仓库中提交文件我们已经把文件添加到了暂存区，那么怎样让文件真正进去仓库呢？用commit命令： 1git commit -m &quot;you need to record something&quot; 这个命令可以让你将暂存区中的文件添加到仓库中。 -m 选项是必选项，它需要你在提交时给他一下信息用于记录你的提交的原因。当然我们也提倡这样做。 4、一次性从工作区提交到仓库中有时候修改完文件要提交仓库中，要先添加到暂存区后再提交，很麻烦怎么办？给 git commit 加上 -a 选项： 1git commit -a -m &quot;say something&quot; 5、查看git状态不知道你的文件现在处于未跟踪状态还是处在暂存区，或者是一提交状态？用status命令： 1git status 它会告诉你当前文件夹中的文件的状态和分支情况。 6、从暂存区或仓库中移除文件如果你想删除一个文件，但是已经将它放入了暂存区中，如何去删除暂存区中的文件呢？先将本地文件删除，再使用下面的命令：1git rm FILENAME 就可以将暂存区中的文件移除了。当然，直接一同删除本地文件和暂存区文件也可以，添加 -f 选项。 那如果已经提交到仓库中了怎么办？从仓库中删除文件可以在上条命令的基础上添加–cached选项。 注意：如果之前你的本地目录中有该文件，从仓库中删除并不会把本地文件一并删除，所删除的文件在本地中会重新变为未跟踪状态。 那么我不想删除本地文件，又不想把它提交到仓库中，该怎么办呢？ 7、添加忽略列表可以在本地目录中添加一个名为 .gitignore 的文件，用来记录哪些文件需要被忽略。直接在.gitignore文件中添加你不想被跟踪的文件即可。 github上有一个项目列举了各种忽略列表：ignore 8、重命名文件你可以中暂存区和仓库中修改文件的名字。使用下面的命令： 1git mv FILE_FROM FILE_TO 实际上，git并不会直接将名字修改，mv命令相当于下面三条命令： 123mv README.md READMEgit rm README.mdgit add README 9、查看提交历史在提交了若干更新，又或者克隆了某个项目之后，如果查看提交历史呢？使用下面的命令：1git log 它会按照时间线（由近及远）列出你的提交历史，包括SHA-1 校验、日期、提交者以及提交说明。 log命令有很多选项，他可以满足你的各种查看需求： -p，用来显示每次提交的内容差异。 你也可以加上 -NUMBER 来仅显示最近两次提交：例如：1git log -p -2 来查看近俩次提交之间的差异。 –stat选项可以看到每次提交的简略的统计信息。 –pretty选项可以指定不同的显示格式。 其下有各种子选项：short、oneline、full、fuller、format等。 使用如下：1git log --pretty=oneline 会将每次提交在各自独自的一行中显示。 pretty选项中的format选项可以自定义选项格式：例如：1git log --pretty=format:&quot;%h - %an, %ar : %s&quot; 完成的选项如下图： 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 –date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者（committer）的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 –graph 显示 ASCII 图形表示的分支合并历史。 下面列举了一些常见的log下的选项： 选项 说明 -p 按补丁格式显示每个更新之间的差异。 –stat 显示每次更新的文件修改统计信息。 –shortstat 只显示 –stat 中最后的行数修改添加移除统计。 –name-only 仅在提交信息后显示已修改的文件清单。 –name-status 显示新增、修改、删除的文件清单。 –abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 –relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。 –graph 显示 ASCII 图形表示的分支合并历史。 –pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 你还可以限制输出的长度，包括按条目个数、时间和提交者等。这里就不一一列举了，需要的时候查一下即可。 10、回滚版本接下来我们学习git最核心的操作————回滚。我们学会了通过git log 来查看提交信息，会发现每次commit之后都有一串数字和字母的组合，而这串字符串是系统自动生成的唯一的代表了这次提交请求的一个ID，我们可以通过这串字符串来任意回滚到之前某一次提交上去。例如：1git checkout 9643a881f 将回退到这串字符串所代表的那次提交的状态上。 回滚的时候，并不需要将整个字符串都复制下来，从开头的一部分去截取也是可以的。 11、撤销操作（1）撤销提交后的操作当我们提交到了仓库文件以后，发现有一些文件漏添加了，或者提交信息写错了，这时就需要撤销操作。 先将你需要的文件添加到暂存区，然后使用下面的命令：1git commit --amend -m &quot;say something&quot; 来覆盖你之前的那次提交，之前的那次提交不会出现在你提交的历史中。也就是说最终你只用最后一次的提交结果。 （2）撤销暂存区中的操作如果不小心把不想放入暂存区的文件放入了暂存区，那么如何来撤销暂存区中的记录呢？使用下面的命令：1git reset HEAD FILENAME 执行之后你会发现原本在暂存区中的文件，已经变成 了未跟踪状态。 （3）撤销已修改文件的操作如果你修改了文件，却想撤回。此时文件并没有放入暂存区中，只是单纯的在工作环境中做了修改，那该怎么撤销呢？ 其实git status命令已经告诉你了： 123Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) 我们来使用下： 1git checkout --FIIENAME 这时你发现原本修改过的操作变成了之前未更改的状态。 12、给Git起别名如果不想使用Git本身的起名方式，那么可以通过起别名的方式来替换到Git默认的命令：1git config --global alias.ci commit 会将commit命令替换为ci，下次提交时，只要输入git ci就ok了。 当然，你也可以将常用的组合命令替换为一个命令：1git config --global alias.last &apos;log -1 HEAD&apos; 输入git last将会看到最后一次提交。 三、标签管理Git可以给历史中的某一次提交打上一个标签，用来标识这次提交，它相当于那次提交的引用，同样可以使用标签来回滚到所代表的提交。 1、创建标签如何在当前提交上打标签呢？使用下面的命令： 1git tag -a v1.9 -m &quot;some message&quot; -a选项表示创建一个新的标签。 -m和commit命令中的一样，为必填项，为标签添加一些注释。 还有一种轻量打标签的方式：1git tag v1.1.1 这种不需要选项而直接给当前的提交打上标签。 4、查看标签使用下面的命令来查看所有标签：1git tag 当然，在log命令中，你打的标签也会出现在提交的右边。 你也可以加-l 来进行特定的模式查找标签：1git tag -l v1.* 将列出tags中以v1.开头的标签。 你也可以查看某一标签所代表的提交，使用下面的命令： 1git show v1.1 将显示打标签者，标签信息，时间和哪一次提交。 5、给之前的提交打标签如何给之前的提交打标签呢？只要看一下那次提交的ID字符串就可以了：1git tag -a v1.2 9fceb02 将会给那次提交打上一个标签。 6、给远程仓库打标签由于默认情况下，git push命令不会将标签传输到远程仓库，你需要显示的将标签传送到远程仓库中：1git push origin TAGNAME 当然如果想传送的标签很多，可以使用带有–tags选项将所有标签全部传送到远程仓库中。 四、使用远程仓库我相信有相当大的一部分人，是想学习github的使用，之后才了解到了Git。这两者不是一种东西，git和github的关系，相当于球与球场的关系。git创建的是本地仓库，而github上存放了好多远程的仓库。这些仓库都是用户将自己的仓库上传到服务器上，让github来托管这些仓库。那么如何建立远程仓库以及让本地仓库与远程仓库关联起来呢？ 1、","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://yangzebin001.github.io/tags/Git/"}]},{"title":"makedown","slug":"2018-01-26-fjlskadjfgla","date":"2018-01-26T09:56:16.000Z","updated":"2018-01-26T10:11:45.499Z","comments":true,"path":"2018/01/26/2018-01-26-fjlskadjfgla/","link":"","permalink":"https://yangzebin001.github.io/2018/01/26/2018-01-26-fjlskadjfgla/","excerpt":"欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：","text":"欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://yangzebin001.github.io/tags/html/"},{"name":"JS","slug":"JS","permalink":"https://yangzebin001.github.io/tags/JS/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-25T11:15:35.791Z","updated":"2019-01-31T10:06:59.298Z","comments":true,"path":"2018/01/25/hello-world/","link":"","permalink":"https://yangzebin001.github.io/2018/01/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}