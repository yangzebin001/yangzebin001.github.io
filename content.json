{"meta":{"title":"BeckoninGshy's Blog","subtitle":null,"description":"Welcome to BeckoninGshy's Blog.","author":"yangzebin","url":"https://yangzebin001.github.io"},"pages":[{"title":"about","date":"2019-01-31T10:14:50.000Z","updated":"2019-01-31T11:00:04.413Z","comments":true,"path":"about/index.html","permalink":"https://yangzebin001.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-31T10:14:34.000Z","updated":"2019-01-31T10:15:23.630Z","comments":true,"path":"tags/index.html","permalink":"https://yangzebin001.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode-236. 二叉树的最近公共祖先","slug":"LeetCode-236-二叉树的最近公共祖先","date":"2019-02-02T08:00:23.000Z","updated":"2019-02-02T08:01:20.533Z","comments":true,"path":"2019/02/02/LeetCode-236-二叉树的最近公共祖先/","link":"","permalink":"https://yangzebin001.github.io/2019/02/02/LeetCode-236-二叉树的最近公共祖先/","excerpt":"236. 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”","text":"236. 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” Solution1：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */static int flag = 0;class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; // 1.找到从根节点到某一结点的路径。存储在栈内。 stack&lt;TreeNode*&gt; a; stack&lt;TreeNode*&gt; b; flag = 0; path(root,p,a); flag = 0; path(root,q,b); // 2.比较两个栈的栈顶，一样，返回，不一样，弹出较长的那个。如果长度一样，同时弹出。 TreeNode* t = NULL; while(1)&#123; if(a.top() == b.top())&#123; t = a.top(); break; &#125; if(a.size() &gt; b.size())&#123; a.pop(); &#125;else if(a.size() &lt; b.size())&#123; b.pop(); &#125;else&#123; a.pop(); b.pop(); &#125; &#125; return t; &#125; void path(TreeNode* root, TreeNode* p, stack&lt;TreeNode*&gt; &amp;a)&#123; if(!root || flag == 1) return; a.push(root); if(root == p)&#123; flag = 1; &#125; path(root-&gt;left,p,a); path(root-&gt;right,p,a); if(flag != 1)&#123; a.pop(); &#125; &#125;&#125;; 先寻找从根节点到给定结点的路径，并存储在栈中。再将两栈比较，找到第一个相同结点即为最近公共祖先。由于需要找最近相同的结点。所以在遍历二叉树时，要使用前序遍历，先将结点保存在栈中，再考虑其子节点。得到两个存储路径的栈（根节点在栈底）。 由于路径与层有关，路径越长的结点，所在的层也越低。所以寻找公共结点首先把较大的栈缩小到与较小的栈长度一致，然后比较栈顶，当遇到相同结点时，就为最近公共祖先。 Solution2：12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; // 找到最近符合条件的结点。 if(!root || root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left,p,q); TreeNode* right = lowestCommonAncestor(root-&gt;right,p,q); // 如果找到了两个结点，不在一个位置。返回该结点（该结点是两个结点的公共祖先）。 if(left &amp;&amp; right) return root; //如果在该结点的下面，只找到了一个，先将该结点返回，交给上一级处理。（为了递归） if(left) return left; else return right; &#125;&#125;; 递归版本。 看了评论区大神写的。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-226. 翻转二叉树","slug":"LeetCode-226-翻转二叉树","date":"2019-02-02T07:59:44.000Z","updated":"2019-02-02T08:01:23.883Z","comments":true,"path":"2019/02/02/LeetCode-226-翻转二叉树/","link":"","permalink":"https://yangzebin001.github.io/2019/02/02/LeetCode-226-翻转二叉树/","excerpt":"226. 翻转二叉树 翻转一棵二叉树。","text":"226. 翻转二叉树 翻转一棵二叉树。 Solution1（递归版）：12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root) return NULL; if(root-&gt;left) invertTree(root-&gt;left); if(root-&gt;right) invertTree(root-&gt;right); TreeNode* temp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = temp; return root; &#125;&#125;; 依次从叶子结点向上翻转。 Solution2（层次遍历版）：123456789101112131415161718class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root) return NULL; queue&lt;TreeNode*&gt; que; que.push(root); while(!que.empty())&#123; TreeNode* node = que.front(); que.pop(); TreeNode* nodeleft = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = nodeleft; if(node-&gt;left) que.push(node-&gt;left); if(node-&gt;right) que.push(node-&gt;right); &#125; return root; &#125;&#125;; 层次遍历，每到一个结点，就讲该结点下的子结点交换。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-98. 验证二叉搜索树","slug":"98-验证二叉搜索树","date":"2019-01-27T14:31:33.000Z","updated":"2019-02-02T07:58:52.199Z","comments":true,"path":"2019/01/27/98-验证二叉搜索树/","link":"","permalink":"https://yangzebin001.github.io/2019/01/27/98-验证二叉搜索树/","excerpt":"98. 验证二叉搜索树 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。","text":"98. 验证二叉搜索树 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 Solution1：1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; vector&lt;TreeNode*&gt; v; inorder(root,v); for(int i = 1; i &lt; v.size(); i++)&#123; if(v[i-1]-&gt;val &gt;= v[i]-&gt;val)&#123; return false; &#125; &#125; return true; &#125; void inorder(TreeNode* node, vector&lt;TreeNode*&gt; &amp;v)&#123; if(!node) return; inorder(node-&gt;left,v); v.push_back(node); inorder(node-&gt;right,v); &#125;&#125;; 利用二叉搜索树的中序遍历是升序的特性。 将每个元素push进一个vector中，如果vector中元素不是按升序排列，这该树不是二叉搜索树。 Solution2：12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; return helper(root,NULL,NULL); &#125; //返回该结点是否在指定区间内。 bool helper(TreeNode *node, TreeNode *min, TreeNode *max)&#123; if(!node) return true; if((min &amp;&amp; node-&gt;val &lt;= min-&gt;val) || (max &amp;&amp; node-&gt;val &gt;= max-&gt;val)) return false; //左子节点的值不能比当前结点的值大，右节点的值不能不当前结点小。 return helper(node-&gt;left, min, node) &amp;&amp; helper(node-&gt;right, node, max); &#125;&#125;; 根据题目给的三条性质，所有结点及其下面的所有结点均可以构成二叉搜索树， 所以对于非叶子结点，可以以当前结点为根据，划分区间，区间内的点必须比左端点大，比右端点小。 用一个递归函数来不断更新该区间，判断该结点是否在区间内即可。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-51. N皇后","slug":"51-N皇后","date":"2019-01-27T14:30:19.000Z","updated":"2019-02-02T07:59:08.644Z","comments":true,"path":"2019/01/27/51-N皇后/","link":"","permalink":"https://yangzebin001.github.io/2019/01/27/51-N皇后/","excerpt":"51. N皇后 该题为著名的n皇后问题。 Solution：","text":"51. N皇后 该题为著名的n皇后问题。 Solution： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;string&gt; mark; vector&lt;string&gt; queenposition; vector&lt;vector&lt;string&gt; &gt; map; //初始化。 string a = \"\"; for(int i = 0; i &lt; n;i++)&#123; a = a + \".\"; &#125; for(int i = 0; i &lt; n; i++)&#123; queenposition.push_back(a); mark.push_back(a); &#125; dfs(mark,queenposition,map,0,n); return map; &#125; void putOneQueen(vector&lt;string&gt; &amp;mark,int x,int y,int n)&#123; static const int dx[8] = &#123;-1,-1,-1,0,0,1,1,1&#125;; static const int dy[8] = &#123;-1,0,1,-1,1,-1,0,1&#125;; mark[x][y] = '1'; for(int i = 0; i &lt; 8; i++)&#123; int nx = x + dx[i],ny = y+dy[i]; while(0 &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; n)&#123; mark[nx][ny] = '1'; nx += dx[i]; ny += dy[i]; &#125; &#125; &#125; void dfs(vector&lt;string&gt; &amp;mark,vector&lt;string&gt; &amp;queenposition,vector&lt;vector&lt;string&gt; &gt; &amp;map,int col,int n)&#123; //出口 if(col == n)&#123; map.push_back(queenposition); return; &#125; for(int i = 0; i &lt; n;i++)&#123; if(mark[col][i] == '.')&#123;//可以放皇后 vector&lt;string&gt; temp_mark = mark;//记录回溯前的镜像。 //放皇后。 queenposition[col][i] = 'Q'; putOneQueen(mark,col,i,n); //递归调用。 dfs(mark,queenposition,map,col+1,n); //回溯 mark = temp_mark; queenposition[col][i] = '.'; &#125; &#125; &#125;&#125;; 该题考查对递归与回溯算法的掌握。 使用一个矩阵来存储是否可以放皇后的状态。每当一行放置了一个皇后后，更新其状态，并在下一行中挑选合适的位置来放置该行的皇后。 直到每一行都放置了皇后，保存状态，返回上一个递归过程。 回溯主要针对矩阵的状态和皇后放置的位置，以便利于递归返回过程中的再次使用。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-88. 合并两个有序数组","slug":"88-合并两个有序数组","date":"2019-01-27T14:30:09.000Z","updated":"2019-02-02T07:58:59.838Z","comments":true,"path":"2019/01/27/88-合并两个有序数组/","link":"","permalink":"https://yangzebin001.github.io/2019/01/27/88-合并两个有序数组/","excerpt":"88. 合并两个有序数组 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。","text":"88. 合并两个有序数组 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 Solution:1234567891011121314151617181920class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int tail = m + n -1; int nums1tail = m-1; int nums2tail = n-1; while(nums1tail &gt;= 0 &amp;&amp; nums2tail &gt;= 0)&#123; if(nums1[nums1tail] &gt;= nums2[nums2tail])&#123; nums1[tail] = nums1[nums1tail--]; &#125;else&#123; nums1[tail] = nums2[nums2tail--]; &#125; tail--; &#125; while(nums2tail &gt;= 0) nums1[tail--] = nums2[nums2tail--]; while(nums1tail &gt;= 0) nums1[tail--] = nums1[nums1tail--]; &#125;&#125;; 与归并排序的merge代码类似，不过是从数组的末尾往前比较。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-112. 路径总和","slug":"112-路径总和","date":"2019-01-27T14:29:57.000Z","updated":"2019-02-02T07:58:48.259Z","comments":true,"path":"2019/01/27/112-路径总和/","link":"","permalink":"https://yangzebin001.github.io/2019/01/27/112-路径总和/","excerpt":"112. 路径总和 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。","text":"112. 路径总和 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 Solution1: 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(!root) return false; return dfs(root,0,sum); &#125; bool dfs(TreeNode* node,int currentsum, int sum)&#123; currentsum += node-&gt;val; if(node &amp;&amp; !node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; currentsum == sum) return true; bool a = false,b = false; if(node-&gt;left)&#123; a = dfs(node-&gt;left,currentsum,sum); &#125; if(node-&gt;right)&#123; b = dfs(node-&gt;right,currentsum,sum); &#125; return a || b; &#125;&#125;; 递归终止条件为叶子节点。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-113. 路径总和 II","slug":"113-路径总和-II","date":"2019-01-27T14:29:33.000Z","updated":"2019-02-02T07:58:44.765Z","comments":true,"path":"2019/01/27/113-路径总和-II/","link":"","permalink":"https://yangzebin001.github.io/2019/01/27/113-路径总和-II/","excerpt":"113. 路径总和 II 该题为112. 路径总和的升级版 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。","text":"113. 路径总和 II 该题为112. 路径总和的升级版 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 Solution1： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt; &gt; result; if(root)&#123; dfs(root,0,sum,path,result); &#125; return result; &#125; void dfs(TreeNode* node,int currentsum, int sum,vector&lt;int&gt; &amp;path,vector&lt;vector&lt;int&gt; &gt; &amp;result)&#123; currentsum += node-&gt;val; path.push_back(node-&gt;val); //当到达叶子结点，并且路径之和与sum相同 if(node &amp;&amp; !node-&gt;left &amp;&amp; !node-&gt;right )&#123; if(currentsum == sum) result.push_back(path); return; &#125; if(node-&gt;left)&#123; dfs(node-&gt;left,currentsum,sum,path,result); //回溯，还原状态 path.pop_back(); &#125; if(node-&gt;right)&#123; dfs(node-&gt;right,currentsum,sum,path,result); //回溯，还原状态 path.pop_back(); &#125; &#125;&#125;; Solution2：12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt; &gt; result; preorder(root,0,sum,path,result); return result; &#125; void preorder(TreeNode* node, int currentsum, int sum, vector&lt;int&gt; &amp;path, vector&lt;vector&lt;int&gt; &gt; &amp;result)&#123; if(!node) return; currentsum += node-&gt;val; path.push_back(node-&gt;val); if(!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; currentsum == sum)&#123; result.push_back(path); &#125; preorder(node-&gt;left,currentsum,sum,path,result); preorder(node-&gt;right,currentsum,sum,path,result); //该步可有可无，因为只会递归到叶子节点才返回，又每次递归都在栈中保留了原来该值的副本。 // currentsum -= node-&gt;val; path.pop_back(); &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-190. 颠倒二进制位","slug":"190-颠倒二进制位","date":"2019-01-24T14:02:27.000Z","updated":"2019-02-02T07:58:35.396Z","comments":true,"path":"2019/01/24/190-颠倒二进制位/","link":"","permalink":"https://yangzebin001.github.io/2019/01/24/190-颠倒二进制位/","excerpt":"190. 颠倒二进制位 颠倒给定的 32 位无符号整数的二进制位。","text":"190. 颠倒二进制位 颠倒给定的 32 位无符号整数的二进制位。 示例 1： 输入: 00000010100101000001111010011100 输出: 00111001011110000010100101000000 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 ###Solution：1234567891011121314151617class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; uint32_t t = 0; int i = 32; while(i--)&#123; t &lt;&lt;= 1; //获得原数第一位的状态。 int a = n&amp;1; //将该状态赋给该数第一位。 t |= a; //原数右移。 n &gt;&gt;= 1; &#125; return t; &#125;&#125;; 思路： 初始化一个全位置为0的数，将原数的最后一位赋给该数的最后一位，原数右移，该数左移，如此32次。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-389. 找不同","slug":"389-找不同","date":"2019-01-24T13:41:26.000Z","updated":"2019-02-02T07:58:31.982Z","comments":true,"path":"2019/01/24/389-找不同/","link":"","permalink":"https://yangzebin001.github.io/2019/01/24/389-找不同/","excerpt":"389. 找不同 给定两个字符串 s 和 t，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。","text":"389. 找不同 给定两个字符串 s 和 t，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。 示例: 输入：s = “abcd”t = “abcde” 输出：e 解释：‘e’ 是那个被添加的字母。 ###Solution:123456789class Solution &#123;public: char findTheDifference(string s, string t) &#123; char e = 0; for(int i = 0; i &lt; s.size(); i++) e ^= s[i]; for(int i = 0; i &lt; t.size(); i++) e ^= t[i]; return e; &#125;&#125;; 与136. 只出现一次的数字一样的思路，考察异或的使用。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-136. 只出现一次的数字","slug":"136-只出现一次的数字","date":"2019-01-24T13:40:16.000Z","updated":"2019-02-02T07:58:39.297Z","comments":true,"path":"2019/01/24/136-只出现一次的数字/","link":"","permalink":"https://yangzebin001.github.io/2019/01/24/136-只出现一次的数字/","excerpt":"136. 只出现一次的数字 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？","text":"136. 只出现一次的数字 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1]输出: 1 Solution： 12345678910class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int a = 0; for(int i = 0; i &lt; nums.size(); i++)&#123; a = a ^ nums[i]; &#125; return a; &#125;&#125;; 使用异或来消除相同的元素。异或：两数相同，异或为0；两数不同，异或为1； a ^ a = 0; a ^ 0 = a;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-693. 交替位二进制数","slug":"693-交替位二进制数","date":"2019-01-24T12:46:07.000Z","updated":"2019-02-02T07:58:14.789Z","comments":true,"path":"2019/01/24/693-交替位二进制数/","link":"","permalink":"https://yangzebin001.github.io/2019/01/24/693-交替位二进制数/","excerpt":"693. 交替位二进制数 给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。 示例 1: 输入: 5 输出: True 解释: 5的二进制数是: 101","text":"693. 交替位二进制数 给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。 示例 1: 输入: 5 输出: True 解释: 5的二进制数是: 101 ###Solution：123456789class Solution &#123;public: bool hasAlternatingBits(int n) &#123; //如果是奇偶交替，则n ^ (n &gt;&gt; 1) 会使有效位全为1， int temp = n ^ (n &gt;&gt; 1); //有效位全为1 再加1， 得到有效位前面为1，后面全为0，再与该数与，则全部清零。 return (temp &amp; (temp+1)) == 0; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-476. 数字的补数","slug":"476-数字的补数","date":"2019-01-24T12:33:41.000Z","updated":"2019-02-02T07:58:25.218Z","comments":true,"path":"2019/01/24/476-数字的补数/","link":"","permalink":"https://yangzebin001.github.io/2019/01/24/476-数字的补数/","excerpt":"476. 数字的补数 给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。","text":"476. 数字的补数 给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。 注意: 给定的整数保证在32位带符号整数的范围内。 你可以假定二进制数不包含前导零位。示例 1: 输入: 5 输出: 2 解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。 ###Solution： 1234567891011121314class Solution &#123;public: int findComplement(int num) &#123; int cot = 0; int temp = num; while(1)&#123; if(num == 0) break; num = num &gt;&gt; 1; cot++; &#125; int mark = 0xffffffff; return ~temp ^ (mark &lt;&lt; cot); &#125;&#125;; 首先找到该数是从哪一位开始才算有效（即不包含前面零的位置。）再将该数所有位取反，然后用全位置的1左移cot次，与值异或即可。 异或：不同为一，相同为零，所以当前面的零取反后成为一后，相应位置与1异或，会恢复成为0，之后的有效位还保持不变。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-40. 组合总和 II","slug":"40-组合总和-II","date":"2019-01-24T08:40:41.000Z","updated":"2019-02-02T07:59:11.393Z","comments":true,"path":"2019/01/24/40-组合总和-II/","link":"","permalink":"https://yangzebin001.github.io/2019/01/24/40-组合总和-II/","excerpt":"40. 组合总和 II 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。","text":"40. 组合总和 II 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]] 该题为90. 子集 II的升级版 与上题相同的是，都要保证元素的非重复性，所以与上题使用set部分的代码是一致的。 区别在于在进行递归的过程中，需要随时对条件进行判断，只有满足等于target，才往result中添加。 并且在剪枝的时候，如果元素之和已经比target大，就没有必要进行下去了，直接退出即可。 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt; &gt; result; vector&lt;int&gt; item; //去重所使用的集合 set&lt;vector&lt;int&gt;&gt; item_set; //对nums进行排序。 sort(candidates.begin(),candidates.end()); putitem(0, candidates, result, item, item_set,target, 0); return result; &#125; void putitem(int i, vector&lt;int&gt;&amp; nums,vector&lt;vector&lt;int&gt; &gt; &amp;result, vector&lt;int&gt; &amp;item, set&lt;vector&lt;int&gt;&gt; &amp;item_set,int target, int sum)&#123; if(i &gt;= nums.size() || sum &gt; target) return; sum += nums[i]; item.push_back(nums[i]); //如果没有重复，就加入到最终的集合里。 if(sum == target &amp;&amp; item_set.find(item) == item_set.end())&#123; result.push_back(item); //加入去重集合中。 item_set.insert(item); &#125; putitem(i+1, nums, result, item, item_set, target, sum); sum -= nums[i]; item.pop_back(); putitem(i+1, nums, result, item, item_set, target, sum); &#125; &#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-22. 括号生成","slug":"22-括号生成","date":"2019-01-24T08:40:02.000Z","updated":"2019-02-02T08:02:33.965Z","comments":true,"path":"2019/01/24/22-括号生成/","link":"","permalink":"https://yangzebin001.github.io/2019/01/24/22-括号生成/","excerpt":"22. 括号生成 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。例如，给出 n = 3，生成结果为：","text":"22. 括号生成 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。例如，给出 n = 3，生成结果为： [ “((()))”, “(()())”, “(())()”, “()(())”, “()()()”] Solution：12345678910111213141516171819202122class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; result; putone(\"\",n,n,result); return result; &#125; void putone(string item, int left, int right, vector&lt;string&gt; &amp;result)&#123; if(left == 0 &amp;&amp; right == 0)&#123; result.push_back(item); return; &#125; //只要left还能放。 if(left &gt; 0)&#123; putone(item+ \"(\",left-1,right,result); &#125; //left放的比right多， if(left &lt; right)&#123; putone(item+ \")\",left,right-1,result); &#125; &#125;&#125;; 使用递归+回溯来解决。 该题主要是要找放括号的时机。 首先要先放左括号。 第二，只要放左括号的个数比右括号多，就可以放右括号。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-90. 子集 II","slug":"90-子集-II","date":"2019-01-24T08:39:22.000Z","updated":"2019-02-02T07:58:55.845Z","comments":true,"path":"2019/01/24/90-子集-II/","link":"","permalink":"https://yangzebin001.github.io/2019/01/24/90-子集-II/","excerpt":"90. 子集 II 该题为78. 子集的升级版 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。","text":"90. 子集 II 该题为78. 子集的升级版 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: [1,2,2]输出:[ [2], [1], [1,2,2], [2,2], [1,2], []] Solution1：123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; result; vector&lt;int&gt; item; result.push_back(item); //去重所使用的集合 set&lt;vector&lt;int&gt;&gt; item_set; //对nums进行排序。 sort(nums.begin(),nums.end()); putitem(0, nums, result, item, item_set); return result; &#125; void putitem(int i, vector&lt;int&gt;&amp; nums,vector&lt;vector&lt;int&gt; &gt; &amp;result, vector&lt;int&gt; &amp;item, set&lt;vector&lt;int&gt;&gt; &amp;item_set)&#123; if(i &gt;= nums.size()) return; item.push_back(nums[i]); //如果没有重复，就加入到最终的集合里。 if(item_set.find(item) == item_set.end())&#123; result.push_back(item); //加入去重集合中。 item_set.insert(item); &#125; putitem(i+1, nums, result, item, item_set); item.pop_back(); putitem(i+1, nums, result, item, item_set); &#125; &#125;; 使用一个set来先存储集合。每当在添加的时候，先检查set中是否已经包含，再决定放入。 由于该题中有重复元素，为了避免形如[2,3,3,2]与[3,2,2,3]，先进行排序插入","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-78. 子集","slug":"78-子集","date":"2019-01-24T08:36:18.000Z","updated":"2019-02-02T07:59:04.528Z","comments":true,"path":"2019/01/24/78-子集/","link":"","permalink":"https://yangzebin001.github.io/2019/01/24/78-子集/","excerpt":"78. 子集 Solution1：对于每一项相对每个子集来说，都有放与不放两种选择。 创建一个放元素的递归函数，该函数的作用为将一项放和不放两种选择进行描述。","text":"78. 子集 Solution1：对于每一项相对每个子集来说，都有放与不放两种选择。 创建一个放元素的递归函数，该函数的作用为将一项放和不放两种选择进行描述。 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; result; vector&lt;int&gt; item; result.push_back(item); putitem(0, nums, item, result); return result; &#125; //把一项放进result中。 void putitem(int i, vector&lt;int&gt;&amp; nums,vector&lt;int&gt; item, vector&lt;vector&lt;int&gt; &gt; &amp;result)&#123; if(i == nums.size())&#123; return; &#125; //每个元素都有放和不放两种选择。 //放 item.push_back(nums[i]); result.push_back(item); putitem(i+1, nums, item, result); //不放 item.pop_back(); putitem(i+1, nums, item, result); &#125;&#125;; Solution2：遍历，遇到一个数就把所有子集加上该数组成新的子集，遍历完毕即是所有子集12345678910111213141516class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; result; vector&lt;int&gt; item; result.push_back(item); for(int i =0; i &lt; nums.size(); i++)&#123; int s = result.size(); for(int j = 0; j &lt; s;j++)&#123; result.push_back(result[j]); result[j].push_back(nums[i]); &#125; &#125; return result; &#125;&#125;; Solution3（位运算）：12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; result; //子集一共有2的n次方种，使用位运算来解。 //每一位代表一个元素。 //如，100 代表[3]、011代表[2,1]。 int all_set = 1 &lt;&lt; nums.size();//2的n次方种； for(int i = 0; i &lt; all_set; i++)&#123; vector&lt;int&gt; item; for(int j = 0; j &lt; nums.size(); j++)&#123; //如果i的第j位为1，说明，有这一位所代表的元素。 // （1 &lt;&lt; j）第j位为1，其他位为0。 // i &amp; (1 &lt;&lt; j)， i 这个数中，j这一位是不是为1。（i中是否包含这个元素） if(i &amp; (1 &lt;&lt; j))&#123; item.push_back(nums[j]); &#125; &#125; //将该子集放入集合中。 result.push_back(item); item.clear(); &#125; return result; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 452. 用最少数量的箭引爆气球","slug":"LeetCode-452-用最少数量的箭引爆气球","date":"2019-01-17T09:46:09.000Z","updated":"2019-01-31T10:12:50.483Z","comments":true,"path":"2019/01/17/LeetCode-452-用最少数量的箭引爆气球/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-452-用最少数量的箭引爆气球/","excerpt":"452. 用最少数量的箭引爆气球 维护一个射击区间。如果下一个区间的开始位置比当前区间的开始位置大，则需要更新。同理，结束位置也一样。 也是就是说，保持在这个射击区间内，每一个气球都能被射中（求射击区间内所有球的交集）。","text":"452. 用最少数量的箭引爆气球 维护一个射击区间。如果下一个区间的开始位置比当前区间的开始位置大，则需要更新。同理，结束位置也一样。 也是就是说，保持在这个射击区间内，每一个气球都能被射中（求射击区间内所有球的交集）。 如果气球不再能被这个射击区间所容纳，则在增加一个射击区间。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int findMinArrowShots(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) &#123; if(points.size() == 0)&#123; return 0; &#125; //对气球从左端点开始排序。 sort(points.begin(),points.end()); int arrow = 1; int startindex = points[0].first; int endindex = points[0].second; for(int i = 1; i &lt; points.size(); i++)&#123; //更新最小区间。 if(points[i].first &gt; startindex &amp;&amp; points[i].first &lt;= endindex)&#123; startindex = points[i].first; &#125; if(points[i].second &lt; endindex &amp;&amp; points[i].second &gt;= startindex)&#123; endindex = points[i].second; &#125; //继续下一轮。 else if(points[i].first &gt; startindex)&#123; startindex = points[i].first; endindex = points[i].second; arrow++; &#125; &#125; return arrow; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-45- 跳跃游戏 II","slug":"LeetCode-45-跳跃游戏-II","date":"2019-01-17T09:45:06.000Z","updated":"2019-01-31T10:11:21.452Z","comments":true,"path":"2019/01/17/LeetCode-45-跳跃游戏-II/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-45-跳跃游戏-II/","excerpt":"45. 跳跃游戏 II 此题55. 跳跃游戏的进阶版 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。","text":"45. 跳跃游戏 II 此题55. 跳跃游戏的进阶版 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 按照前面题的思路，依然是从后往前搜索。每次搜索能跳到当前位置的最远位置。 123456789101112131415161718192021222324class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; // 选择当前能跳到当前点的最远的距离。 int max_index = nums.size()-1; int current_max_index = max_index; int step = 0; //当没有到达开头位置，进行循环。 while(max_index &gt; 0)&#123; //记录能跳到当前数组的最前面的点。 for(int i = max_index-1; i &gt;= 0; i--)&#123; if(i + nums[i] &gt;= max_index)&#123; current_max_index = i; &#125; &#125; //更新能跳的最远的点。 max_index = current_max_index; //步数更新 step++; &#125; return step; &#125; &#125;; 用了两层循环，发现能ac，但是又排在了末名。 看了大神的代码，写出了下面的代码： 123456789101112131415161718192021222324252627class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt; 2)&#123; return 0; &#125; //当前可到达的最远距离。 int current_max_index = nums[0]; //遍历各个位置中，可到达的最远距离。 int pre_max_max_index = nums[0]; int jump = 1; for(int i = 1; i &lt; nums.size(); i++)&#123; //更新当前可达到的最远距离。 if(i &gt; current_max_index)&#123; jump++; current_max_index = pre_max_max_index; &#125; if(pre_max_max_index &lt; nums[i] + i)&#123; //更新 pre_max_max_index = nums[i] + i; &#125; &#125; return jump; &#125; &#125;; 跳到当前所能跳到的最远的位置所在的位置中。 记录当前位置所能到达的最远的位置。 如果做到了该最远位置，更新一下。继续走。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-402-移掉K位数字","slug":"LeetCode-402-移掉K位数字","date":"2019-01-17T09:44:04.000Z","updated":"2019-01-31T10:12:47.035Z","comments":true,"path":"2019/01/17/LeetCode-402-移掉K位数字/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-402-移掉K位数字/","excerpt":"402. 移掉K位数字 给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。在保持顺序的情况下，尽可能让较小的数充当较高位。 用一个栈来计较。如果要进的数字比栈顶要大，并且可以删。直接将该数字丢弃。","text":"402. 移掉K位数字 给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。在保持顺序的情况下，尽可能让较小的数充当较高位。 用一个栈来计较。如果要进的数字比栈顶要大，并且可以删。直接将该数字丢弃。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string removeKdigits(string num, int k) &#123; //在保持顺序的情况下，尽可能让较小的数充当较高位。 std::vector&lt;int&gt; S; std::string result = \"\"; for(int i = 0; i &lt; num.length(); i++)&#123; int number = num[i]-'0'; //比当前栈顶元素大，并且能删除（k&gt;0）,直接丢弃。 while(S.size() != 0 &amp;&amp; S[S.size()-1] &gt; number &amp;&amp; k &gt; 0)&#123; S.pop_back(); k--; &#125; //0 不能在第一个位置。即不允许“0132” if(number != 0 || S.size()!= 0)&#123; S.push_back(number); &#125; &#125; // 处理“123456789”的情况。 while(S.size() != 0 &amp;&amp; k &gt; 0)&#123; S.pop_back(); k--; &#125; for(int i = 0; i &lt; S.size(); i++)&#123; result.append(1,'0'+S[i]); &#125; if(result == \"\") return \"0\"; return result; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeeCode-455-分发饼干","slug":"LeeCode-455-分发饼干","date":"2019-01-17T09:42:46.000Z","updated":"2019-01-31T10:11:09.784Z","comments":true,"path":"2019/01/17/LeeCode-455-分发饼干/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeeCode-455-分发饼干/","excerpt":"455. 分发饼干","text":"455. 分发饼干 输入: [1,2,3], [1,1] 输出: 1 解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 尽量让胃口小的孩子分到尽量少的饼干。 先排序。在饼干的循环中，如果孩子的胃口大于等于饼干，孩子加一。 ###Solution:12345678910111213141516171819class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; //先将两组数据排序。 std::sort(g.begin(),g.end()); std::sort(s.begin(),s.end()); //记录被满足的孩子和饼干 int child = 0; int cookie = 0; while(cookie &lt; s.size() &amp;&amp; child &lt; g.size())&#123; //饼干可以满足该孩子。 if(g[child] &lt;= s[cookie])&#123; child++; &#125; cookie++; &#125; return child; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-295-数据流的中位数","slug":"LeetCode-295-数据流的中位数","date":"2019-01-17T09:41:23.000Z","updated":"2019-01-31T10:12:44.465Z","comments":true,"path":"2019/01/17/LeetCode-295-数据流的中位数/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-295-数据流的中位数/","excerpt":"295. 数据流的中位数 利用堆的堆顶可以随时保持最大（小）元素的特性。使用两个堆来存储数据。 由于需要取中位数。要保持两个堆堆顶为中间的元素。所以：","text":"295. 数据流的中位数 利用堆的堆顶可以随时保持最大（小）元素的特性。使用两个堆来存储数据。 由于需要取中位数。要保持两个堆堆顶为中间的元素。所以： 构建一个最小堆用来存放较大的数。 构建一个最大堆用来存放较小的数。 （比较绕，需要用心思考一下） 要随时保持两个堆的高度平衡。 这时，两堆堆顶就是数据中的中位数了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class MedianFinder &#123; public: /** initialize your data structure here. */ MedianFinder() &#123; &#125; void addNum(int num) &#123; if(smallNums.empty())&#123; //往存放小元素的最大堆添加数据。 smallNums.push(num); return; &#125; //如果两个堆的高度相同。优先push进当前堆顶元素更大的那一个。 if(largeNums.size() == smallNums.size())&#123; if(smallNums.top() &gt; num)&#123; smallNums.push(num); &#125;else&#123; largeNums.push(num); &#125; &#125; //为了保持两个堆的平衡 。如果两堆高度不一致，分两种情况讨论 //1.存放较大元素的最小堆的高度大于存放较小元素的最大堆的高度达。 else if(largeNums.size() &gt; smallNums.size())&#123; // 该数比存放较大元素的最小堆的堆顶要大。 // 首先将该堆堆顶元素push进存放较小元素的最大堆中。 // 再将该数push进存放较大元素的最小堆 if(num &gt; largeNums.top())&#123; smallNums.push(largeNums.top()); largeNums.pop(); largeNums.push(num); &#125; // 该数比存放较大元素的最小堆的堆顶要小。 // 直接push进存放较小元素的最大堆。 else&#123; smallNums.push(num); &#125; &#125; //2.存放较大元素的最小堆的高度小于存放较小元素的最大堆的高度达。 else if(largeNums.size() &lt; smallNums.size())&#123; // 该数比存放较小元素的最大堆的堆顶要小。（该数一定要进该堆） // 首先将该堆堆顶元素push进存放较大元素的最小堆中。 // 再将该数push进存放较小元素的最大堆中。 if(num &lt; smallNums.top())&#123; largeNums.push(smallNums.top()); smallNums.pop(); smallNums.push(num); &#125; // 该数比存放较小元素的最大堆的堆顶要大。 // 直接push进存放较大元素的最小堆。 else&#123; largeNums.push(num); &#125; &#125; &#125; double findMedian() &#123; // 两堆平衡，取中位数。 if(smallNums.size() == largeNums.size())&#123; return (((double)smallNums.top() + largeNums.top())/2 ); &#125; // 不平衡，谁高取谁的堆顶。 else if(smallNums.size() &gt; largeNums.size())&#123; return smallNums.top(); &#125; return largeNums.top(); &#125; private: // 存放较大元素的最小堆 std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; largeNums; // 存放较小元素的最大堆 std::priority_queue&lt;int&gt; smallNums;&#125;;/** * Your MedianFinder object will be instantiated and called as such: * MedianFinder obj = new MedianFinder(); * obj.addNum(num); * double param_2 = obj.findMedian(); */","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-55- 跳跃游戏","slug":"LeetCode-55-跳跃游戏","date":"2019-01-17T09:40:08.000Z","updated":"2019-01-31T10:11:30.219Z","comments":true,"path":"2019/01/17/LeetCode-55-跳跃游戏/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-55-跳跃游戏/","excerpt":"55. 跳跃游戏 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。示例 1:","text":"55. 跳跃游戏 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。示例 1: 输入: [2,3,1,1,4]输出: true解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。 示例 2: 输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 首先想到的是将所有能达到的步数全部跑一遍，如果能到达返回true。结果TLE。 然后分析，在大部分情况下都做的是重复操作。需要剪枝。用了一个辅助表。用于记录该点能否到达的了最后一个位置。不能就标记一下，查找的时候先从表里查找。如果标记过，就不需要再进行遍历了。 代码如下 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: bool jump(vector&lt;int&gt;&amp; nums, int index,vector&lt;int&gt;&amp; q)&#123; //可以达到最后一个位置，返回true if (index &gt;= nums.size() - 1) &#123; return true; &#125; //在表中能查到，说明该点不能达到。 else if (q[index] == -1) &#123; return false; &#125; //从该点开始，到该点所能到达的最后一个元素，依次搜索。 for (int i = nums[index]; i &gt; 0; i--) &#123; if (jump(nums, index + i,q)) &#123; return true; &#125; //不能达到，在表中标记。 else if(index + i &lt; q.size())&#123; q[index + i] = -1; &#125; &#125; return false; &#125; bool canJump(vector&lt;int&gt;&amp; nums) &#123; //建一个辅助表 vector&lt;int &gt; q; for (int i = 0; i &lt; nums.size(); i++) &#123; q.push_back(0); &#125; return jump(nums,0,q); &#125; &#125;; 结果能通过。但是排在了最后。 然后看了小象学院的视频。思路是先记录下每一步能跳的最大距离， 遍历这个表。用一个变量记录步数，一个变量记录能走到的最大位置。当步数小于这个最大位置，并且该步数不是最后一个位置时，说明这个数组中不能到达最后一个位置。返回false。 如果步数能走到数组的末尾，说明能走到。返回true。 12345678910111213141516171819202122232425class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; //存储该位置能跳到哪个位置（下标）。 vector&lt;int&gt; index; for(int i = 0; i &lt; nums.size(); i++)&#123; index.push_back(i + nums[i]); &#125; //能够跳跃的位置。 int jump = 0; //当前最远的位置。 int max_index = index[0]; while(jump &lt; index.size() &amp;&amp; jump &lt;= max_index)&#123; //更新最远位置 if(max_index &lt; index[jump])&#123; max_index = index[jump]; &#125; //前进一步 jump++; &#125; //走到了数组末尾。 if(jump == index.size()) return true; return false; &#125;&#125;; 看了评论区大神的代码。发现是从后往前开始判断的，依次判断是否能到达最远的距离。如果能到达，把最远的距离更新为现在所在位置。于是写出了如下代码。 12345678910111213141516171819class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; //能到达最远位置坐标 int n = nums.size()-1; for(int i = nums.size()-2; i &gt;= 0; i--)&#123; //从该点可以达到终点坐标，则将最远位置的坐标更新为该点的坐标。 if(nums[i] + i &gt;= n)&#123; n = i; &#125; &#125; //能够到达头部。 if(n == 0)&#123; return true; &#125;else &#123; return false; &#125; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-215-数组中的第K个最大元素","slug":"LeetCode-215-数组中的第K个最大元素","date":"2019-01-17T09:38:26.000Z","updated":"2019-01-31T10:12:14.176Z","comments":true,"path":"2019/01/17/LeetCode-215-数组中的第K个最大元素/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-215-数组中的第K个最大元素/","excerpt":"215. 数组中的第K个最大元素 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。Solution1：","text":"215. 数组中的第K个最大元素 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。Solution1： 1234567class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; std::sort(nums.begin(),nums.end()); return nums[nums.size()-k]; &#125;&#125;; 思路：直接使用sort()函数。将倒数第K的元素直接返回。这样做的复杂度就为sort函数的复杂度。 Solution2：1234567891011121314151617#include &lt;vector&gt;#include &lt;queue&gt;class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; Q; for(int i = 0; i &lt; nums.size(); i++)&#123; if(Q.size() &lt; k)&#123; Q.push(nums[i]); &#125;else if(Q.top() &lt; nums[i])&#123; Q.pop(); Q.push(nums[i]); &#125; &#125; return Q.top(); &#125;&#125;; 思路：使用最小堆。 维护一个K大小的最小堆。最小堆的堆顶始终为最小元素。当有比堆顶更大的时候，让更大的元素进堆，堆顶的元素出堆。这样遍历一遍后。第K大的元素就到了堆顶。直接弹出即可。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 224. 基本计算器","slug":"LeetCode-224-基本计算器","date":"2019-01-05T12:19:14.000Z","updated":"2019-01-31T10:12:17.751Z","comments":true,"path":"2019/01/05/LeetCode-224-基本计算器/","link":"","permalink":"https://yangzebin001.github.io/2019/01/05/LeetCode-224-基本计算器/","excerpt":"224. 基本计算器 实现一个基本的计算器来计算一个简单的字符串表达式的值。字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格。","text":"224. 基本计算器 实现一个基本的计算器来计算一个简单的字符串表达式的值。字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格。 Solution：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution &#123;public: void compute(std::stack&lt;int&gt; &amp;number_stack, std::stack&lt;char&gt; &amp;operation_stack)&#123; if(number_stack.size() &lt; 2)&#123; return; &#125; int num2 = number_stack.top(); number_stack.pop(); int num1 = number_stack.top(); number_stack.pop(); if(operation_stack.top() == '+')&#123; number_stack.push(num1 + num2); &#125;else if(operation_stack.top() == '-')&#123; number_stack.push(num1 - num2); &#125; operation_stack.pop(); &#125; int calculate(string s) &#123; static const int STATE_BEGIN = 0; static const int NUMBER_STATE = 1; static const int OPERATION_STATE = 2; std::stack&lt;int&gt; number_stack; std::stack&lt;char&gt; operation_stack; int number = 0; int STATE = STATE_BEGIN; int compuate_flag = 0; for(int i = 0; i &lt; s.length(); i++)&#123; if(s[i] == ' ')&#123; continue; &#125; switch(STATE)&#123; case STATE_BEGIN: if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9')&#123; STATE = NUMBER_STATE; &#125;else&#123; STATE = OPERATION_STATE; &#125; i--; break; case NUMBER_STATE: if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9')&#123; number = number * 10 + s[i] - '0'; &#125;else&#123; number_stack.push(number); if(compuate_flag == 1)&#123; compute(number_stack,operation_stack); &#125; number = 0; i--; STATE = OPERATION_STATE; &#125; break; case OPERATION_STATE: if(s[i] == '+' || s[i] == '-')&#123; operation_stack.push(s[i]); compuate_flag = 1; &#125;else if(s[i] == '(')&#123; STATE = NUMBER_STATE; compuate_flag = 0; &#125;else if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9')&#123; STATE = NUMBER_STATE; i--; &#125;else if(s[i] == ')')&#123; compute(number_stack,operation_stack); &#125; break; &#125; &#125; if(number != 0)&#123; number_stack.push(number); compute(number_stack,operation_stack); &#125; if(number == 0 &amp;&amp; number_stack.empty())&#123; return 0; &#125; return number_stack.top(); &#125;&#125;; 首先，数据用两个栈来存储。一个存数字，一个存操作符。 其次，建立一个状态机，来描述指针的走向状态。根据状态来做相应的操作。 刚开始有一个开始状态。检测下一个字符是数字还是字母。然后转换为相应的状态。 我们先讨论数字与操作符的存储时机： 当指针指向数字时，先将数字暂存起来，继续检查下一位置，还是数字，继续与暂存的数字融合。当指针指向的不是数字时，这时就需要把这个数字存起来。 字符的存储时机就为该位置为+、-时进行存储。 接下来讨论计算的时机。 首先是检测操作符，如果操作符后面是数字，则在该数字进行存储完成之后立马进行计算。 如果操作符之后是” ( “ 就要等下一个相应的” ) “出现。之后再进行计算。 所以设置一个计算标志。如果检测到操作符，把计算标志置为可计算，接着继续下一位的检测，如果是数字，就在存储后进行计算。如果是” ( “，就需要取消计算标志。 一定要注意退格操作！！！ 退格发生在下一位置不再是数字或者在操作符之后的检测是不是数字的时候。 最后就是将描述翻译成代码的工作了。 这里注意，在表达式的最后通常是数字，这时也需要将数字存储起来再进行一次运算。 如果表达式正确，存储数字的栈的长度一定是1，直接返回栈顶。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 232. 用栈实现队列","slug":"LeetCode-232-用栈实现队列","date":"2019-01-02T12:30:00.000Z","updated":"2019-01-31T10:12:30.984Z","comments":true,"path":"2019/01/02/LeetCode-232-用栈实现队列/","link":"","permalink":"https://yangzebin001.github.io/2019/01/02/LeetCode-232-用栈实现队列/","excerpt":"232. 用栈实现队列 使用栈实现队列的下列操作： push(x) – 将一个元素放入队列的尾部。 pop() – 从队列首部移除元素。 peek() – 返回队列首部的元素。 empty() – 返回队列是否为空。","text":"232. 用栈实现队列 使用栈实现队列的下列操作： push(x) – 将一个元素放入队列的尾部。 pop() – 从队列首部移除元素。 peek() – 返回队列首部的元素。 empty() – 返回队列是否为空。 Solution:1234567891011121314151617181920212223242526272829303132333435363738class MyQueue &#123;public: /** Initialize your data structure here. */ MyQueue() &#123; &#125; /** push all element of _s1 to _s2*/ void pushTos2()&#123; if(_s1.empty()) return; while(!_s1.empty())&#123; _s2.push(_s1.top()); _s1.pop(); &#125; &#125; /** Push element x to the back of queue. */ void push(int x) &#123; return _s1.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; if(_s2.empty()) pushTos2(); int a = _s2.top(); _s2.pop(); return a; &#125; /** Get the front element. */ int peek() &#123; if(_s2.empty()) pushTos2(); return _s2.top(); &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return _s1.empty() &amp;&amp; _s2.empty(); &#125; private: std::stack&lt;int&gt; _s1; std::stack&lt;int&gt; _s2;&#125;; 使用两个栈来实现堆。 在做push操作的时候，直接push进第一个栈。 当要pop时，先检查第二栈是否为空，如果为空，就把第一个栈的元素全push进第二个栈，这是原本在第一个栈栈底的元素，就到了第二个栈的栈顶（相当于翻了个个)。这时就可以pop出去了。 下面的函数实现的就是专门将第一个栈的元素全部push进第二栈的功能。12345678/** push all element of _s1 to _s2*/ void pushTos2()&#123; if(_s1.empty()) return; while(!_s1.empty())&#123; _s2.push(_s1.top()); _s1.pop(); &#125; &#125; 当peek时，如果第二个栈已经没有元素。 也需要把第一个栈的元素“倒”进来，再进行peek(); empty：当两个栈都没有元素才算空。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 225. 用队列实现栈","slug":"LeetCode-225-用队列实现栈","date":"2019-01-02T12:29:14.000Z","updated":"2019-01-31T10:12:21.866Z","comments":true,"path":"2019/01/02/LeetCode-225-用队列实现栈/","link":"","permalink":"https://yangzebin001.github.io/2019/01/02/LeetCode-225-用队列实现栈/","excerpt":"225. 用队列实现栈 使用队列实现栈的下列操作： push(x) – 元素 x 入栈 pop() – 移除栈顶元素 top() – 获取栈顶元素 empty() – 返回栈是否为空 Solution：","text":"225. 用队列实现栈 使用队列实现栈的下列操作： push(x) – 元素 x 入栈 pop() – 移除栈顶元素 top() – 获取栈顶元素 empty() – 返回栈是否为空 Solution： 1234567891011121314151617181920212223242526272829303132333435363738394041class MyStack &#123;public: /** Initialize your data structure here. */ MyStack() &#123; &#125; /** Push element x onto stack. */ void push(int x) &#123; std::queue&lt;int&gt; temp_queue; temp_queue.push(x); while(!data_queue.empty())&#123; temp_queue.push(data_queue.front()); data_queue.pop(); &#125; while(!temp_queue.empty())&#123; data_queue.push(temp_queue.front()); temp_queue.pop(); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int x = data_queue.front(); data_queue.pop(); return x; &#125; /** Get the top element. */ int top() &#123; return data_queue.front(); &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return data_queue.empty(); &#125; private: std::queue&lt;int&gt; data_queue;&#125;; 核心思想：让新进来的元素始终在队列的头位置。所以需要一个临时的队列。先让push进来的元素进去临时队列里。再让原来的队列的元素全进去临时队列，这样就保证了队列的头位置始终是新进来的元素。再将临时队列的所有元素push回原队列。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 61. 旋转链表","slug":"LeetCode-61-旋转链表","date":"2019-01-01T14:40:48.000Z","updated":"2019-01-31T10:11:33.731Z","comments":true,"path":"2019/01/01/LeetCode-61-旋转链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-61-旋转链表/","excerpt":"61. 旋转链表 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。Example: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL","text":"61. 旋转链表 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。Example: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 123456789101112131415161718192021222324252627282930int getListNodeLength(struct ListNode * head)&#123; struct ListNode * head1 = head; int len = 0; while(head1)&#123; len++; head1 = head1-&gt;next; &#125; return len;&#125;struct ListNode* getPosition(struct ListNode* head, int index)&#123; if(index &lt; 0) return NULL; struct ListNode * head1 = head; while(index)&#123; head1 = head1-&gt;next; index--; &#125; return head1;&#125;struct ListNode* rotateRight(struct ListNode* head, int k) &#123; int len = getListNodeLength(head); if(len &lt;=1 || (k %= len) &lt; 1) return head; int position = len-k-1; struct ListNode* oldlast = getPosition(head,len-1); struct ListNode* newhead = getPosition(head,position+1); struct ListNode* newlast = getPosition(head,position); oldlast-&gt;next = head; newlast-&gt;next = NULL; return newhead;&#125; 思路:该题看似是循环n次，实则将后K个元素移至头结点的位置。 直接找到最后一个元素，将它指向开始的位置。将倒数第k+1个元素指向NULL。 k可以大于链表的长度，所以要对链表长度取模。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 24. 两两交换链表中的节点","slug":"LeetCode-24-两两交换链表中的节点","date":"2019-01-01T14:39:50.000Z","updated":"2019-01-31T10:11:17.831Z","comments":true,"path":"2019/01/01/LeetCode-24-两两交换链表中的节点/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-24-两两交换链表中的节点/","excerpt":"24. 两两交换链表中的节点 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。Example：给定 1-&gt;2-&gt;3-&gt;4，你应该返回 2-&gt;1-&gt;4-&gt;3。","text":"24. 两两交换链表中的节点 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。Example：给定 1-&gt;2-&gt;3-&gt;4，你应该返回 2-&gt;1-&gt;4-&gt;3。 1234567891011121314151617181920struct ListNode* swapPairs(struct ListNode* head) &#123; //设置头结点 struct ListNode* first = (struct ListNode*)malloc(sizeof(struct ListNode)); first-&gt;next = head; //备份 struct ListNode* first1 = first; // 如果头结点后有两个结点 while(first-&gt;next &amp;&amp; first-&gt;next-&gt;next)&#123; //两个结点 struct ListNode* one = first-&gt;next; struct ListNode* two = first-&gt;next-&gt;next; //交换两个结点。 one-&gt;next = two-&gt;next; first-&gt;next = two; two-&gt;next = one; first = one; &#125; //返回 return first1-&gt;next;&#125; 思路：用一个指针从开始读，如果可以读到该节点与下个节点，就将这两个结点交换位置，这时需要注意与前后的结点连接。 为了方便，用一个头结点来完成这个连接的工作。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 86. 分隔链表","slug":"LeetCode-86-分隔链表","date":"2019-01-01T14:38:47.000Z","updated":"2019-01-31T10:11:39.065Z","comments":true,"path":"2019/01/01/LeetCode-86-分隔链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-86-分隔链表/","excerpt":"86. 分隔链表 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。你应当保留两个分区中每个节点的初始相对位置。Example：给定 head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2， x = 3。 你应该返回 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5。","text":"86. 分隔链表 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。你应当保留两个分区中每个节点的初始相对位置。Example：给定 head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2， x = 3。 你应该返回 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5。 Solution1：1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; //创建两个头结点 ListNode less_head(0); ListNode more_head(0); ListNode *less_ptr = &amp;less_head; ListNode *more_ptr = &amp;more_head; while(head)&#123; //将val小于x的分进less_ptr，大于等于的分进more_ptr; if(head-&gt;val &lt; x)&#123; less_ptr-&gt;next = head; less_ptr = less_ptr-&gt;next; &#125;else&#123; more_ptr-&gt;next = head; more_ptr = more_ptr-&gt;next; &#125; head = head-&gt;next; &#125; //连接两个指针。 less_ptr-&gt;next = more_head.next; more_ptr-&gt;next = NULL; return less_head.next; &#125;&#125;; 思路：用双指针。创建两个头结点。比x小的划到第一个里面，否则划到第二个里面，最后将两个链表链接返回。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 138. 复制带随机指针的链表","slug":"LeetCode-138-复制带随机指针的链表","date":"2019-01-01T14:36:49.000Z","updated":"2019-01-31T10:11:46.598Z","comments":true,"path":"2019/01/01/LeetCode-138-复制带随机指针的链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-138-复制带随机指针的链表/","excerpt":"138. 复制带随机指针的链表 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深度拷贝。","text":"138. 复制带随机指针的链表 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深度拷贝。 12345678/** * Definition for singly-linked list with a random pointer. * struct RandomListNode &#123; * int label; * RandomListNode *next, *random; * RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125; * &#125;; */ Solution: 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode *head) &#123; //建立结点与当前位置的映射 std::map&lt;RandomListNode *, int&gt; node_map; //存放copy了的所有结点。按位置。 std::vector&lt;RandomListNode *&gt; node_vec; RandomListNode *ptr = head; int i = 0; while(ptr)&#123; //创建与旧链表相等的结点。copy其中的值。 node_vec.push_back(new RandomListNode(ptr-&gt;label)); // 建立结点与当前位置的映射。 node_map[ptr] = i; ptr = ptr-&gt;next; i++; &#125; //push尾结点 node_vec.push_back(0); ptr = head; i = 0; while(ptr)&#123; //将依次排列的结点的next相连接。 node_vec[i]-&gt;next = node_vec[i+1]; if(ptr-&gt;random)&#123; //找到该结点对应所指向的random所映射的位置。然后赋给当前结点。 int id = node_map[ptr-&gt;random]; node_vec[i]-&gt;random = node_vec[id]; &#125; ptr = ptr-&gt;next; i++; &#125; //返回首结点 return node_vec[0]; &#125;&#125;; 思路:如果没有random域，copy链表只要依次创建结点，并将当前结点的next指向下一个结点就完成了。 有random域会比较麻烦一些。需要通过建立一张结点与其位置的表来完成。 当需要填充random指向时，通过原链表的random域在表中的位置来将vector中这一位置的结点地址赋给random域。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 23. 合并K个排序链表","slug":"LeetCode-23-合并K个排序链表","date":"2019-01-01T14:35:08.000Z","updated":"2019-01-31T10:11:14.513Z","comments":true,"path":"2019/01/01/LeetCode-23-合并K个排序链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-23-合并K个排序链表/","excerpt":"23. 合并K个排序链表 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。Solution1：","text":"23. 合并K个排序链表 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。Solution1： 1234567891011121314151617181920212223242526272829bool cmp(const ListNode* a,const ListNode *b)&#123; return a-&gt;val &lt; b-&gt;val;&#125;class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; std::vector&lt;ListNode*&gt; node_vec; //将每个结点push到vec中。 for(int i = 0; i &lt; lists.size(); i++)&#123; ListNode* head = lists[i]; while(head)&#123; node_vec.push_back(head); head = head-&gt;next; &#125; &#125; if(node_vec.size() == 0)&#123; return NULL; &#125; //将vec中的元素按val域排序。 std::sort(node_vec.begin(),node_vec.end(),cmp); //链接各个结点。 for(int i = 1;i &lt; node_vec.size();i++)&#123; node_vec[i-1]-&gt;next = node_vec[i]; &#125; //最后一个结点指向NULL node_vec[node_vec.size()-1]-&gt;next = NULL; return node_vec[0]; &#125;&#125;; 该方法比较粗暴。将所有的结点存入一个vector中，按结点中的值排序，然后依次将每个结点链接，最后返回。 Solution2：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode p0 = ListNode(0); ListNode* p = &amp;p0; ListNode* p1 = p; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; p-&gt;next = new ListNode(l1-&gt;val); p = p-&gt;next; l1 = l1-&gt;next; &#125;else&#123; new ListNode(l2-&gt;val); p-&gt;next = new ListNode(l2-&gt;val); p = p-&gt;next; l2 = l2-&gt;next; &#125; &#125; p-&gt;next = (l1!=NULL) ? l1 :(l2!=NULL) ? l2 : NULL; return p1-&gt;next; &#125; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; //两个终止条件。 if(lists.size() == 0)&#123; return NULL; &#125; if(lists.size() == 1)&#123; return lists[0]; &#125; //将lists拆分成两个子lists; int mid = lists.size()/2; std::vector&lt;ListNode*&gt; sub1_lists; std::vector&lt;ListNode*&gt; sub2_lists; for(int i = 0; i &lt; mid; i++)&#123; sub1_lists.push_back(lists[i]); &#125; for(int i = mid; i &lt; lists.size(); i++)&#123; sub2_lists.push_back(lists[i]); &#125; //递归调用 ListNode *l1 = mergeKLists(sub1_lists); ListNode *l2 = mergeKLists(sub2_lists); //返回两个链表合并的结果。 return mergeTwoLists(l1,l2); &#125;&#125;; 思路:（归并思想）递归算法。将k个链表分割为独立的链表，再向上两两合并。 合并两个有序链表的子问题参照：21. 合并两个排序链表","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 155. 最小栈","slug":"LeetCode-155-最小栈","date":"2019-01-01T14:33:56.000Z","updated":"2019-01-31T10:11:59.610Z","comments":true,"path":"2019/01/01/LeetCode-155-最小栈/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-155-最小栈/","excerpt":"155. 最小栈 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。 pop() – 删除栈顶的元素。 top() – 获取栈顶元素。 getMin() – 检索栈中的最小元素。 Solution：","text":"155. 最小栈 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。 pop() – 删除栈顶的元素。 top() – 获取栈顶元素。 getMin() – 检索栈中的最小元素。 Solution： 123456789101112131415161718192021222324252627282930class MinStack &#123; public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; _data.push(x); // 更新当前的最小值状态。 if(_min.empty() || _min.top() &gt;= x )&#123; _min.push(x); &#125; &#125; void pop() &#123; //如果是要弹出当前的最小值。将min中的值也一并弹出。 if(_data.top() == _min.top())&#123; _min.pop(); &#125; _data.pop(); &#125; int top() &#123; return _data.top(); &#125; int getMin() &#123; //返回最小栈的栈顶 return _min.top(); &#125; private: std::stack&lt;int&gt; _data; std::stack&lt;int&gt; _min;&#125;; 思路:原来想用一个变量来记录最小值，这在push的时候没什么问题，但是当执行pop操作的时候，就不知道怎么更新了。 所以需要将每次一更新最小值都记录下来。 使用另一个栈记录最小值的变更状态。 每插入一个值，与之比较最小栈的栈顶的元素，如果比栈顶的元素小，就更新其状态，如果与栈顶元素相等，也需要插入。 当出栈的时候，如果与最小栈栈顶元素相等，最小栈也出栈。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 92. 反转链表 II","slug":"LeetCode-92-反转链表-II","date":"2019-01-01T14:32:44.000Z","updated":"2019-01-31T10:11:42.563Z","comments":true,"path":"2019/01/01/LeetCode-92-反转链表-II/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-92-反转链表-II/","excerpt":"92. 反转链表 II 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 ###Solution：","text":"92. 反转链表 II 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 ###Solution： 1234567891011121314151617181920212223242526272829struct ListNode* reverseBetween(struct ListNode* head, int m, int n) &#123; int chang_len = n-m+1;//逆置的结点个数。 struct ListNode* prevHead = NULL;//记录开始逆置结点的前驱。 struct ListNode* result = head;//用于最后返回。 while(head &amp;&amp; --m)&#123; //到达开始逆置的位置。 prevHead = head; head = head-&gt;next; &#125; struct ListNode * modify_list_tail = head;//将该结点之前当前开始逆置的结点。 struct ListNode * newHead = NULL;//用于逆置结点。 while(head &amp;&amp; chang_len)&#123; struct ListNode * next = head-&gt;next; head-&gt;next = newHead; newHead = head; head = next; chang_len--; &#125; //此时head就到了n处，modify_list_tail就到了逆置段的最后一个结点。 //将modify_list_tail 与 head连接。 modify_list_tail-&gt;next = head; if(prevHead)&#123; //如果prevHead不为空，说明不是从第一个几点开始逆置的。 m &gt; 1。 prevHead-&gt;next = newHead; &#125;else&#123; result = newHead; //如果prevHead为空， 则说明是从第一个就开始逆置，直接将逆置后的头结点赋值给res，m=1。 &#125; return result;&#125; 思路：解决这个问题主要是要找关键节点。 这个题的关键节点为： 要逆置的结点的前一个结点（prevHead）。 要逆置的第一个结点。（直接用head来探测）。 要逆置的最后一个结点。（此结点为逆置前的第一个结点，逆置后就变为了最后一个结点） 要逆置的最后一个结点的后一个结点。（在用head逆置后，head就到了逆置后的这个结点。） 找到前两个结点。 从m开始，到n，一共需要n-m+1个结点需要逆置。所以要逆置n-m+1次。 将逆置后的尾结点 与 逆置段后面一个结点相连。 如果结点是从开始逆置，将逆置后的头结点返回。否则，将前面的结点与逆置后的头结点链接返回。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 160. 相交链表","slug":"LeetCode-160-相交链表","date":"2019-01-01T14:26:20.000Z","updated":"2019-01-31T10:12:07.827Z","comments":true,"path":"2019/01/01/LeetCode-160-相交链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-160-相交链表/","excerpt":"160. 相交链表 Solution1：","text":"160. 相交链表 Solution1： 1234567891011121314151617class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; std::set&lt;ListNode*&gt; node_set; while(headA)&#123; node_set.insert(headA); headA = headA-&gt;next; &#125; while(headB)&#123; if(node_set.find(headB)!=node_set.end())&#123; return headB; &#125; headB = headB-&gt;next; &#125; return NULL; &#125;&#125;; 思路：这种思路很简单。就是先将链表A的每个元素存入set中，在链表B的元素逐个去set中查找。找到就返回。缺点：使用了O(n)的空间。 Solution2：1234567891011121314151617181920212223242526272829303132333435363738394041//获得链表的长度。int get_list_length(ListNode * head)&#123; int len = 0; while(head)&#123; head = head-&gt;next; len++; &#125; return len;&#125;//将长的链表移动多余的步数；以致两个链表到了相等的长度。ListNode* forward_long_list(int long_len, int short_len, ListNode* head)&#123; int step = long_len-short_len; while(head &amp;&amp; step)&#123; head = head-&gt;next; step--; &#125; return head;&#125;class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; int headA_len = get_list_length(headA); int headB_len = get_list_length(headB); //先移动较长的链表至两个链表的长度相等。 if(headA_len&gt;headB_len)&#123; headA = forward_long_list(headA_len,headB_len,headA); &#125;else&#123; headB = forward_long_list(headB_len,headA_len,headB); &#125; //再同时开始移动。如果这两个结点相等了，就找到了 while(headA &amp;&amp; headB)&#123; if(headA == headB)&#123; return headA; &#125; headA = headA-&gt;next; headB = headB-&gt;next; &#125; return NULL; &#125;&#125;; 思路：由于后面的结点是两个链表共享的，所以链表在相交结点之前有可能长度不相等。 我们先将长的链表移动到与短链表相同的长度，然后两个链表同时移动，当两个结点变得相同时，就得到了相同结点。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 141. 环形链表","slug":"LeetCode-141-环形链表","date":"2018-12-30T07:55:13.000Z","updated":"2019-01-31T10:11:52.376Z","comments":true,"path":"2018/12/30/LeetCode-141-环形链表/","link":"","permalink":"https://yangzebin001.github.io/2018/12/30/LeetCode-141-环形链表/","excerpt":"141. 环形链表 题目描述：给定一个链表，判断链表中是否有环。Solution1:","text":"141. 环形链表 题目描述：给定一个链表，判断链表中是否有环。Solution1: 123456789101112131415class Solution &#123;public: bool hasCycle(ListNode *head) &#123; std::set&lt;ListNode*&gt; node_set; while(head)&#123; if(node_set.find(head) == node_set.end())&#123; node_set.insert(head); &#125;else&#123; return true; &#125; head = head-&gt;next; &#125; return false; &#125;&#125;; 思路：使用set。将每一个结点在set中检查，如果没有，就插入该结点。如果找到了，就说明有环。如果到头了，说明没环，返回false； 该方法由于使用了set，所以空间复杂度为O(n); Solution2：1234567891011121314151617bool hasCycle(struct ListNode *head) &#123; struct ListNode *slow = head; struct ListNode *fast = head; while(fast)&#123; slow = slow-&gt;next; fast = fast-&gt;next; if(fast)&#123; fast = fast-&gt;next; &#125;else&#123; return false; &#125; if(slow == fast)&#123; return true; &#125; &#125; return false;&#125; 思路：使用双指针。用两个移动速度快慢不相同的指针来判断是否有环。如果有环，两个指针终会相遇，返回true。 由于快指针一定在慢指针的前面，所以在移动指针时，只要判断快指针是否为空，如果是，就说明没有环。返回false；","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 234.回文链表","slug":"leetcode-234-回文链表","date":"2018-12-30T07:44:12.000Z","updated":"2019-01-31T10:12:40.293Z","comments":true,"path":"2018/12/30/leetcode-234-回文链表/","link":"","permalink":"https://yangzebin001.github.io/2018/12/30/leetcode-234-回文链表/","excerpt":"234.回文链表 请判断一个链表是否为回文链表。Solution1：","text":"234.回文链表 请判断一个链表是否为回文链表。Solution1： 1234567891011121314151617181920212223242526272829303132333435//获得链表长度int getListLength(ListNode* head)&#123; int len = 0; while(head)&#123; head = head-&gt;next; len++; &#125; return len;&#125;class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; ListNode* head1 = head; int listlen = getListLength(head1); if(listlen &lt;= 1) return true; int mid = listlen/2; std::stack&lt;int&gt; s; while(mid &amp;&amp; head)&#123; s.push(head-&gt;val); head = head-&gt;next; mid--; &#125; if(listlen%2 != 0)&#123; head = head-&gt;next; &#125; while(head)&#123; if(head-&gt;val != s.top())&#123; return false; &#125; s.pop(); head = head-&gt;next; &#125; return true; &#125;&#125;; 思路:借助stack。 将mid之前的元素值都push进stack中，然后到mid之后，将每个元素与栈顶值比较。不相等退出，相等继续下一轮。 Solution2：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//获得链表长度int getListLength(ListNode* head)&#123; int len = 0; while(head)&#123; head = head-&gt;next; len++; &#125; return len;&#125;//根据位置与所给链表，向后移动position步。ListNode* getNodeByPosition(ListNode* head,int position)&#123; while(position&gt;0)&#123; head = head-&gt;next; position--; &#125; return head;&#125;class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; //存储头结点。 ListNode* first = head; ListNode* head1 = head; int listlen = getListLength(head); int midposition = listlen/2; //如果链表长度&lt;=1，直接返回true; if(listlen &lt;= 1) return true; //到达需要翻转的长度，对于偶数，为（listlen/2）+1，对于奇数，为listlen/2; ListNode* mid = getNodeByPosition(head1,midposition); //翻转mid之后的指针。 ListNode * newHead = NULL; int position = listlen-midposition; while(mid &amp;&amp; position)&#123; ListNode* next = mid-&gt;next; mid-&gt;next = newHead; newHead = mid; mid = next; position--; &#125; //将翻转之后的链表与开头的链表的内容比较，向后比较listlen/2; //如果是偶数，则元素都会比较到，如果是奇数，最后一个元素不会比较到。他在原来的链表中就处于中心位置，不必比较。 while(first &amp;&amp; newHead &amp;&amp; midposition)&#123; //只要不相等，就为false; if(first-&gt;val != newHead-&gt;val) return false; first = first-&gt;next; newHead = newHead-&gt;next; midposition--; &#125; return true; &#125;&#125;; 思路：将链表的后半段翻转，从翻转位置开始与从头结点开始，依次比较（listlen/2次）。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 142. 环形链表 II","slug":"leetcode-142-环形链表-II","date":"2018-12-30T07:27:57.000Z","updated":"2019-01-31T10:11:55.859Z","comments":true,"path":"2018/12/30/leetcode-142-环形链表-II/","link":"","permalink":"https://yangzebin001.github.io/2018/12/30/leetcode-142-环形链表-II/","excerpt":"142. 环形链表 II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。","text":"142. 环形链表 II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 Solution1:123456789101112131415class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; std::set&lt;ListNode*&gt; node_set; while(head)&#123; if(node_set.find(head) == node_set.end())&#123; node_set.insert(head); &#125;else&#123; return head; &#125; head = head-&gt;next; &#125; return NULL; &#125;&#125;; 与141号问题的Solutions1一个思路，直接使用set。只不过返回的是结点不是boolean值罢了。 Solutions2:123456789101112131415161718192021222324252627282930313233class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; ListNode * head1 = head; ListNode * slow = head; ListNode * fast = head; //fast走一步，slow走两步 while(fast)&#123; slow = slow-&gt;next; fast = fast-&gt;next; if(fast)&#123; fast = fast-&gt;next; &#125;else&#123; //没有环退出 return NULL; &#125; //有环退出循环 if(fast == slow)&#123; break; &#125; &#125; //说明有环 while(head1 &amp;&amp; fast)&#123; if(head1 == fast)&#123; return fast; &#125; head1 = head1-&gt;next; fast = fast-&gt;next; &#125; //不会走到这步，只是为了保证函数正常运行 return NULL; &#125;&#125;; 思路：这种方法只会使用O(1)的空间。 该方法的思路需要一点数学基础： 在一个有环的链表中，slow指针与fast指针相遇，从该相遇的位置开始，与链表的头位置开始，两者走同样的步数，如果两者相交，就走到了环的开始位置。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"读书简录","slug":"reading-note","date":"2018-12-02T08:44:00.000Z","updated":"2018-12-02T01:27:53.823Z","comments":true,"path":"2018/12/02/reading-note/","link":"","permalink":"https://yangzebin001.github.io/2018/12/02/reading-note/","excerpt":"2017/09/01 《挪威的森林》《如何高效学习》《极简主义》","text":"2017/09/01 《挪威的森林》《如何高效学习》《极简主义》 《潜规则》 吴思《旋元佑进阶文法》2017/10/20 《遇见未知的自己》2017/11/10 《响应式WEB设计》《HTML5与CSS3基础教程》2017/12/12 《JavasrciptDOM编程艺术》2017/12/25 《Javascript高级程序设计》（第三版）2018/01/18 《明朝那些事》2018/01/21 《版式设计原理与应用》2018/03/28 《给青年的十二封信》朱光潜2018/04/28 《富爸爸穷爸爸》2018/06/22 《计算机学科概论》2018/07/09 《烟火人间》老舍2018/07/26 《C程序设计（第四版）》谭浩强2018/09/13 《算法图解》《浪潮之巅》2018/10/13 《数学之美》2018/10/25 《黑客与画家》2018/11/15 《c指针》2018/11/23 《沉默的大多数》王小波2018/11/25","categories":[],"tags":[{"name":"读书","slug":"读书","permalink":"https://yangzebin001.github.io/tags/读书/"}]},{"title":"一文学会Git","slug":"一文学会git","date":"2018-10-03T08:44:00.000Z","updated":"2018-10-05T14:10:57.810Z","comments":true,"path":"2018/10/03/一文学会git/","link":"","permalink":"https://yangzebin001.github.io/2018/10/03/一文学会git/","excerpt":"一、GIT下载、安装与配置1.下载与安装下载git只需要直接在官网下载就可以了，它会自动下载适合你电脑配置的版本。 官网 安装就一直下一步就可以了。","text":"一、GIT下载、安装与配置1.下载与安装下载git只需要直接在官网下载就可以了，它会自动下载适合你电脑配置的版本。 官网 安装就一直下一步就可以了。 2.配置安装完成之后右键菜单就会自动添加两个选项： Git GUI Git Bash 在任意目录下右键点击 Git Bash 打开Git 命令行，输入一下两条命令： 123git config --global user.name &quot;USERNAME&quot;git config --global user.email &quot;xxx@xx.com&quot; “USERNAME”填写你的用户名“xxx@xx.com”填写你的邮箱 这样配置完后你之后所创建的仓库都会默认创建在你的名下。 查看你的配置，输入下面的命令： 1git config --list 其中有两条条目为user.name和user.email即为你所配置的。 二、Git基本操作1、新建仓库进入一个你要进行Git的目录（通常是你的工程目录）然后在右键菜单中进入Git Bash，键入命令： 1git init 它会在当前目录下创建一个.git的隐藏文件夹用来保存与git操作有关的相关信息。 2、向仓库暂存区里添加文件1git add FILENAME 命令可以将文件添加到你所创建的仓库的暂存区中。 关于add命令有俩点需要注意： 1.add现在还没有真正添加到仓库中，而是作为预备项来决定是否最终添加到仓库中。 2.这里的添加文件并不是你所在仓库的文件有了这个文件就可以了。仓库创建好后并不等于你所在文件夹中的所有文件也同样包含于仓库中，你需要手动告诉Git你要添加当前目录下的哪些文件到它的仓库中。 你可以用以下命令来将所在文件夹下属的所有文件或者文件夹添加到暂存区中：123git add --all/-Aorgit add * 3、向仓库中提交文件我们已经把文件添加到了暂存区，那么怎样让文件真正进去仓库呢？用commit命令： 1git commit -m &quot;you need to record something&quot; 这个命令可以让你将暂存区中的文件添加到仓库中。 -m 选项是必选项，它需要你在提交时给他一下信息用于记录你的提交的原因。当然我们也提倡这样做。 4、一次性从工作区提交到仓库中有时候修改完文件要提交仓库中，要先添加到暂存区后再提交，很麻烦怎么办？给 git commit 加上 -a 选项： 1git commit -a -m &quot;say something&quot; 5、查看git状态不知道你的文件现在处于未跟踪状态还是处在暂存区，或者是一提交状态？用status命令： 1git status 它会告诉你当前文件夹中的文件的状态和分支情况。 6、从暂存区或仓库中移除文件如果你想删除一个文件，但是已经将它放入了暂存区中，如何去删除暂存区中的文件呢？先将本地文件删除，再使用下面的命令：1git rm FILENAME 就可以将暂存区中的文件移除了。当然，直接一同删除本地文件和暂存区文件也可以，添加 -f 选项。 那如果已经提交到仓库中了怎么办？从仓库中删除文件可以在上条命令的基础上添加–cached选项。 注意：如果之前你的本地目录中有该文件，从仓库中删除并不会把本地文件一并删除，所删除的文件在本地中会重新变为未跟踪状态。 那么我不想删除本地文件，又不想把它提交到仓库中，该怎么办呢？ 7、添加忽略列表可以在本地目录中添加一个名为 .gitignore 的文件，用来记录哪些文件需要被忽略。直接在.gitignore文件中添加你不想被跟踪的文件即可。 github上有一个项目列举了各种忽略列表：ignore 8、重命名文件你可以中暂存区和仓库中修改文件的名字。使用下面的命令： 1git mv FILE_FROM FILE_TO 实际上，git并不会直接将名字修改，mv命令相当于下面三条命令： 123mv README.md READMEgit rm README.mdgit add README 9、查看提交历史在提交了若干更新，又或者克隆了某个项目之后，如果查看提交历史呢？使用下面的命令：1git log 它会按照时间线（由近及远）列出你的提交历史，包括SHA-1 校验、日期、提交者以及提交说明。 log命令有很多选项，他可以满足你的各种查看需求： -p，用来显示每次提交的内容差异。 你也可以加上 -NUMBER 来仅显示最近两次提交：例如：1git log -p -2 来查看近俩次提交之间的差异。 –stat选项可以看到每次提交的简略的统计信息。 –pretty选项可以指定不同的显示格式。 其下有各种子选项：short、oneline、full、fuller、format等。 使用如下：1git log --pretty=oneline 会将每次提交在各自独自的一行中显示。 pretty选项中的format选项可以自定义选项格式：例如：1git log --pretty=format:&quot;%h - %an, %ar : %s&quot; 完成的选项如下图： 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 –date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者（committer）的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 –graph 显示 ASCII 图形表示的分支合并历史。 下面列举了一些常见的log下的选项： 选项 说明 -p 按补丁格式显示每个更新之间的差异。 –stat 显示每次更新的文件修改统计信息。 –shortstat 只显示 –stat 中最后的行数修改添加移除统计。 –name-only 仅在提交信息后显示已修改的文件清单。 –name-status 显示新增、修改、删除的文件清单。 –abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 –relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。 –graph 显示 ASCII 图形表示的分支合并历史。 –pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 你还可以限制输出的长度，包括按条目个数、时间和提交者等。这里就不一一列举了，需要的时候查一下即可。 10、回滚版本接下来我们学习git最核心的操作————回滚。我们学会了通过git log 来查看提交信息，会发现每次commit之后都有一串数字和字母的组合，而这串字符串是系统自动生成的唯一的代表了这次提交请求的一个ID，我们可以通过这串字符串来任意回滚到之前某一次提交上去。例如：1git checkout 9643a881f 将回退到这串字符串所代表的那次提交的状态上。 回滚的时候，并不需要将整个字符串都复制下来，从开头的一部分去截取也是可以的。 11、撤销操作（1）撤销提交后的操作当我们提交到了仓库文件以后，发现有一些文件漏添加了，或者提交信息写错了，这时就需要撤销操作。 先将你需要的文件添加到暂存区，然后使用下面的命令：1git commit --amend -m &quot;say something&quot; 来覆盖你之前的那次提交，之前的那次提交不会出现在你提交的历史中。也就是说最终你只用最后一次的提交结果。 （2）撤销暂存区中的操作如果不小心把不想放入暂存区的文件放入了暂存区，那么如何来撤销暂存区中的记录呢？使用下面的命令：1git reset HEAD FILENAME 执行之后你会发现原本在暂存区中的文件，已经变成 了未跟踪状态。 （3）撤销已修改文件的操作如果你修改了文件，却想撤回。此时文件并没有放入暂存区中，只是单纯的在工作环境中做了修改，那该怎么撤销呢？ 其实git status命令已经告诉你了： 123Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) 我们来使用下： 1git checkout --FIIENAME 这时你发现原本修改过的操作变成了之前未更改的状态。 12、给Git起别名如果不想使用Git本身的起名方式，那么可以通过起别名的方式来替换到Git默认的命令：1git config --global alias.ci commit 会将commit命令替换为ci，下次提交时，只要输入git ci就ok了。 当然，你也可以将常用的组合命令替换为一个命令：1git config --global alias.last &apos;log -1 HEAD&apos; 输入git last将会看到最后一次提交。 三、标签管理Git可以给历史中的某一次提交打上一个标签，用来标识这次提交，它相当于那次提交的引用，同样可以使用标签来回滚到所代表的提交。 1、创建标签如何在当前提交上打标签呢？使用下面的命令： 1git tag -a v1.9 -m &quot;some message&quot; -a选项表示创建一个新的标签。 -m和commit命令中的一样，为必填项，为标签添加一些注释。 还有一种轻量打标签的方式：1git tag v1.1.1 这种不需要选项而直接给当前的提交打上标签。 4、查看标签使用下面的命令来查看所有标签：1git tag 当然，在log命令中，你打的标签也会出现在提交的右边。 你也可以加-l 来进行特定的模式查找标签：1git tag -l v1.* 将列出tags中以v1.开头的标签。 你也可以查看某一标签所代表的提交，使用下面的命令： 1git show v1.1 将显示打标签者，标签信息，时间和哪一次提交。 5、给之前的提交打标签如何给之前的提交打标签呢？只要看一下那次提交的ID字符串就可以了：1git tag -a v1.2 9fceb02 将会给那次提交打上一个标签。 6、给远程仓库打标签由于默认情况下，git push命令不会将标签传输到远程仓库，你需要显示的将标签传送到远程仓库中：1git push origin TAGNAME 当然如果想传送的标签很多，可以使用带有–tags选项将所有标签全部传送到远程仓库中。 四、使用远程仓库我相信有相当大的一部分人，是想学习github的使用，之后才了解到了Git。这两者不是一种东西，git和github的关系，相当于球与球场的关系。git创建的是本地仓库，而github上存放了好多远程的仓库。这些仓库都是用户将自己的仓库上传到服务器上，让github来托管这些仓库。那么如何建立远程仓库以及让本地仓库与远程仓库关联起来呢？ 1、","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://yangzebin001.github.io/tags/Git/"}]},{"title":"makedown","slug":"2018-01-26-fjlskadjfgla","date":"2018-01-26T09:56:16.000Z","updated":"2018-01-26T10:11:45.499Z","comments":true,"path":"2018/01/26/2018-01-26-fjlskadjfgla/","link":"","permalink":"https://yangzebin001.github.io/2018/01/26/2018-01-26-fjlskadjfgla/","excerpt":"欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：","text":"欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://yangzebin001.github.io/tags/html/"},{"name":"JS","slug":"JS","permalink":"https://yangzebin001.github.io/tags/JS/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-25T11:15:35.791Z","updated":"2019-01-31T10:06:59.298Z","comments":true,"path":"2018/01/25/hello-world/","link":"","permalink":"https://yangzebin001.github.io/2018/01/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}