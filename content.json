{"meta":{"title":"BeckoninGshy's Blog","subtitle":null,"description":"Welcome to BeckoninGshy's Blog.","author":"yangzebin","url":"https://yangzebin001.github.io"},"pages":[],"posts":[{"title":"leetcode 234.回文链表","slug":"leetcode-234-回文链表","date":"2018-12-30T07:44:12.000Z","updated":"2018-12-30T07:45:47.782Z","comments":true,"path":"2018/12/30/leetcode-234-回文链表/","link":"","permalink":"https://yangzebin001.github.io/2018/12/30/leetcode-234-回文链表/","excerpt":"234.回文链表 请判断一个链表是否为回文链表。Solution1：","text":"234.回文链表 请判断一个链表是否为回文链表。Solution1： 1234567891011121314151617181920212223242526272829303132333435//获得链表长度int getListLength(ListNode* head)&#123; int len = 0; while(head)&#123; head = head-&gt;next; len++; &#125; return len;&#125;class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; ListNode* head1 = head; int listlen = getListLength(head1); if(listlen &lt;= 1) return true; int mid = listlen/2; std::stack&lt;int&gt; s; while(mid &amp;&amp; head)&#123; s.push(head-&gt;val); head = head-&gt;next; mid--; &#125; if(listlen%2 != 0)&#123; head = head-&gt;next; &#125; while(head)&#123; if(head-&gt;val != s.top())&#123; return false; &#125; s.pop(); head = head-&gt;next; &#125; return true; &#125;&#125;; 思路:借助stack。 将mid之前的元素值都push进stack中，然后到mid之后，将每个元素与栈顶值比较。不相等退出，相等继续下一轮。 Solution2：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//获得链表长度int getListLength(ListNode* head)&#123; int len = 0; while(head)&#123; head = head-&gt;next; len++; &#125; return len;&#125;//根据位置与所给链表，向后移动position步。ListNode* getNodeByPosition(ListNode* head,int position)&#123; while(position&gt;0)&#123; head = head-&gt;next; position--; &#125; return head;&#125;class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; //存储头结点。 ListNode* first = head; ListNode* head1 = head; int listlen = getListLength(head); int midposition = listlen/2; //如果链表长度&lt;=1，直接返回true; if(listlen &lt;= 1) return true; //到达需要翻转的长度，对于偶数，为（listlen/2）+1，对于奇数，为listlen/2; ListNode* mid = getNodeByPosition(head1,midposition); //翻转mid之后的指针。 ListNode * newHead = NULL; int position = listlen-midposition; while(mid &amp;&amp; position)&#123; ListNode* next = mid-&gt;next; mid-&gt;next = newHead; newHead = mid; mid = next; position--; &#125; //将翻转之后的链表与开头的链表的内容比较，向后比较listlen/2; //如果是偶数，则元素都会比较到，如果是奇数，最后一个元素不会比较到。他在原来的链表中就处于中心位置，不必比较。 while(first &amp;&amp; newHead &amp;&amp; midposition)&#123; //只要不相等，就为false; if(first-&gt;val != newHead-&gt;val) return false; first = first-&gt;next; newHead = newHead-&gt;next; midposition--; &#125; return true; &#125;&#125;; 思路：将链表的后半段翻转，从翻转位置开始与从头结点开始，依次比较（listlen/2次）。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 142. 环形链表 II","slug":"leetcode-142-环形链表-II","date":"2018-12-30T07:27:57.000Z","updated":"2018-12-30T07:44:41.534Z","comments":true,"path":"2018/12/30/leetcode-142-环形链表-II/","link":"","permalink":"https://yangzebin001.github.io/2018/12/30/leetcode-142-环形链表-II/","excerpt":"142. 环形链表 II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。","text":"142. 环形链表 II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 Solution1:123456789101112131415class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; std::set&lt;ListNode*&gt; node_set; while(head)&#123; if(node_set.find(head) == node_set.end())&#123; node_set.insert(head); &#125;else&#123; return head; &#125; head = head-&gt;next; &#125; return NULL; &#125;&#125;; 与141号问题的Solutions1一个思路，直接使用set。只不过返回的是结点不是boolean值罢了。 Solutions2:123456789101112131415161718192021222324252627282930313233class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; ListNode * head1 = head; ListNode * slow = head; ListNode * fast = head; //fast走一步，slow走两步 while(fast)&#123; slow = slow-&gt;next; fast = fast-&gt;next; if(fast)&#123; fast = fast-&gt;next; &#125;else&#123; //没有环退出 return NULL; &#125; //有环退出循环 if(fast == slow)&#123; break; &#125; &#125; //说明有环 while(head1 &amp;&amp; fast)&#123; if(head1 == fast)&#123; return fast; &#125; head1 = head1-&gt;next; fast = fast-&gt;next; &#125; //不会走到这步，只是为了保证函数正常运行 return NULL; &#125;&#125;; 思路：这种方法只会使用O(1)的空间。 该方法的思路需要一点数学基础： 在一个有环的链表中，slow指针与fast指针相遇，从该相遇的位置开始，与链表的头位置开始，两者走同样的步数，如果两者相交，就走到了环的开始位置。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"读书简录","slug":"reading-note","date":"2018-12-02T08:44:00.000Z","updated":"2018-12-02T01:27:53.823Z","comments":true,"path":"2018/12/02/reading-note/","link":"","permalink":"https://yangzebin001.github.io/2018/12/02/reading-note/","excerpt":"2017/09/01 《挪威的森林》《如何高效学习》《极简主义》","text":"2017/09/01 《挪威的森林》《如何高效学习》《极简主义》 《潜规则》 吴思《旋元佑进阶文法》2017/10/20 《遇见未知的自己》2017/11/10 《响应式WEB设计》《HTML5与CSS3基础教程》2017/12/12 《JavasrciptDOM编程艺术》2017/12/25 《Javascript高级程序设计》（第三版）2018/01/18 《明朝那些事》2018/01/21 《版式设计原理与应用》2018/03/28 《给青年的十二封信》朱光潜2018/04/28 《富爸爸穷爸爸》2018/06/22 《计算机学科概论》2018/07/09 《烟火人间》老舍2018/07/26 《C程序设计（第四版）》谭浩强2018/09/13 《算法图解》《浪潮之巅》2018/10/13 《数学之美》2018/10/25 《黑客与画家》2018/11/15 《c指针》2018/11/23 《沉默的大多数》王小波2018/11/25","categories":[],"tags":[{"name":"读书","slug":"读书","permalink":"https://yangzebin001.github.io/tags/读书/"}]},{"title":"一文学会Git","slug":"一文学会git","date":"2018-10-03T08:44:00.000Z","updated":"2018-10-05T14:10:57.810Z","comments":true,"path":"2018/10/03/一文学会git/","link":"","permalink":"https://yangzebin001.github.io/2018/10/03/一文学会git/","excerpt":"一、GIT下载、安装与配置1.下载与安装下载git只需要直接在官网下载就可以了，它会自动下载适合你电脑配置的版本。 官网 安装就一直下一步就可以了。","text":"一、GIT下载、安装与配置1.下载与安装下载git只需要直接在官网下载就可以了，它会自动下载适合你电脑配置的版本。 官网 安装就一直下一步就可以了。 2.配置安装完成之后右键菜单就会自动添加两个选项： Git GUI Git Bash 在任意目录下右键点击 Git Bash 打开Git 命令行，输入一下两条命令： 123git config --global user.name &quot;USERNAME&quot;git config --global user.email &quot;xxx@xx.com&quot; “USERNAME”填写你的用户名“xxx@xx.com”填写你的邮箱 这样配置完后你之后所创建的仓库都会默认创建在你的名下。 查看你的配置，输入下面的命令： 1git config --list 其中有两条条目为user.name和user.email即为你所配置的。 二、Git基本操作1、新建仓库进入一个你要进行Git的目录（通常是你的工程目录）然后在右键菜单中进入Git Bash，键入命令： 1git init 它会在当前目录下创建一个.git的隐藏文件夹用来保存与git操作有关的相关信息。 2、向仓库暂存区里添加文件1git add FILENAME 命令可以将文件添加到你所创建的仓库的暂存区中。 关于add命令有俩点需要注意： 1.add现在还没有真正添加到仓库中，而是作为预备项来决定是否最终添加到仓库中。 2.这里的添加文件并不是你所在仓库的文件有了这个文件就可以了。仓库创建好后并不等于你所在文件夹中的所有文件也同样包含于仓库中，你需要手动告诉Git你要添加当前目录下的哪些文件到它的仓库中。 你可以用以下命令来将所在文件夹下属的所有文件或者文件夹添加到暂存区中：123git add --all/-Aorgit add * 3、向仓库中提交文件我们已经把文件添加到了暂存区，那么怎样让文件真正进去仓库呢？用commit命令： 1git commit -m &quot;you need to record something&quot; 这个命令可以让你将暂存区中的文件添加到仓库中。 -m 选项是必选项，它需要你在提交时给他一下信息用于记录你的提交的原因。当然我们也提倡这样做。 4、一次性从工作区提交到仓库中有时候修改完文件要提交仓库中，要先添加到暂存区后再提交，很麻烦怎么办？给 git commit 加上 -a 选项： 1git commit -a -m &quot;say something&quot; 5、查看git状态不知道你的文件现在处于未跟踪状态还是处在暂存区，或者是一提交状态？用status命令： 1git status 它会告诉你当前文件夹中的文件的状态和分支情况。 6、从暂存区或仓库中移除文件如果你想删除一个文件，但是已经将它放入了暂存区中，如何去删除暂存区中的文件呢？先将本地文件删除，再使用下面的命令：1git rm FILENAME 就可以将暂存区中的文件移除了。当然，直接一同删除本地文件和暂存区文件也可以，添加 -f 选项。 那如果已经提交到仓库中了怎么办？从仓库中删除文件可以在上条命令的基础上添加–cached选项。 注意：如果之前你的本地目录中有该文件，从仓库中删除并不会把本地文件一并删除，所删除的文件在本地中会重新变为未跟踪状态。 那么我不想删除本地文件，又不想把它提交到仓库中，该怎么办呢？ 7、添加忽略列表可以在本地目录中添加一个名为 .gitignore 的文件，用来记录哪些文件需要被忽略。直接在.gitignore文件中添加你不想被跟踪的文件即可。 github上有一个项目列举了各种忽略列表：ignore 8、重命名文件你可以中暂存区和仓库中修改文件的名字。使用下面的命令： 1git mv FILE_FROM FILE_TO 实际上，git并不会直接将名字修改，mv命令相当于下面三条命令： 123mv README.md READMEgit rm README.mdgit add README 9、查看提交历史在提交了若干更新，又或者克隆了某个项目之后，如果查看提交历史呢？使用下面的命令：1git log 它会按照时间线（由近及远）列出你的提交历史，包括SHA-1 校验、日期、提交者以及提交说明。 log命令有很多选项，他可以满足你的各种查看需求： -p，用来显示每次提交的内容差异。 你也可以加上 -NUMBER 来仅显示最近两次提交：例如：1git log -p -2 来查看近俩次提交之间的差异。 –stat选项可以看到每次提交的简略的统计信息。 –pretty选项可以指定不同的显示格式。 其下有各种子选项：short、oneline、full、fuller、format等。 使用如下：1git log --pretty=oneline 会将每次提交在各自独自的一行中显示。 pretty选项中的format选项可以自定义选项格式：例如：1git log --pretty=format:&quot;%h - %an, %ar : %s&quot; 完成的选项如下图： 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 –date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者（committer）的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 –graph 显示 ASCII 图形表示的分支合并历史。 下面列举了一些常见的log下的选项： 选项 说明 -p 按补丁格式显示每个更新之间的差异。 –stat 显示每次更新的文件修改统计信息。 –shortstat 只显示 –stat 中最后的行数修改添加移除统计。 –name-only 仅在提交信息后显示已修改的文件清单。 –name-status 显示新增、修改、删除的文件清单。 –abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 –relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。 –graph 显示 ASCII 图形表示的分支合并历史。 –pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 你还可以限制输出的长度，包括按条目个数、时间和提交者等。这里就不一一列举了，需要的时候查一下即可。 10、回滚版本接下来我们学习git最核心的操作————回滚。我们学会了通过git log 来查看提交信息，会发现每次commit之后都有一串数字和字母的组合，而这串字符串是系统自动生成的唯一的代表了这次提交请求的一个ID，我们可以通过这串字符串来任意回滚到之前某一次提交上去。例如：1git checkout 9643a881f 将回退到这串字符串所代表的那次提交的状态上。 回滚的时候，并不需要将整个字符串都复制下来，从开头的一部分去截取也是可以的。 11、撤销操作（1）撤销提交后的操作当我们提交到了仓库文件以后，发现有一些文件漏添加了，或者提交信息写错了，这时就需要撤销操作。 先将你需要的文件添加到暂存区，然后使用下面的命令：1git commit --amend -m &quot;say something&quot; 来覆盖你之前的那次提交，之前的那次提交不会出现在你提交的历史中。也就是说最终你只用最后一次的提交结果。 （2）撤销暂存区中的操作如果不小心把不想放入暂存区的文件放入了暂存区，那么如何来撤销暂存区中的记录呢？使用下面的命令：1git reset HEAD FILENAME 执行之后你会发现原本在暂存区中的文件，已经变成 了未跟踪状态。 （3）撤销已修改文件的操作如果你修改了文件，却想撤回。此时文件并没有放入暂存区中，只是单纯的在工作环境中做了修改，那该怎么撤销呢？ 其实git status命令已经告诉你了： 123Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) 我们来使用下： 1git checkout --FIIENAME 这时你发现原本修改过的操作变成了之前未更改的状态。 12、给Git起别名如果不想使用Git本身的起名方式，那么可以通过起别名的方式来替换到Git默认的命令：1git config --global alias.ci commit 会将commit命令替换为ci，下次提交时，只要输入git ci就ok了。 当然，你也可以将常用的组合命令替换为一个命令：1git config --global alias.last &apos;log -1 HEAD&apos; 输入git last将会看到最后一次提交。 三、标签管理Git可以给历史中的某一次提交打上一个标签，用来标识这次提交，它相当于那次提交的引用，同样可以使用标签来回滚到所代表的提交。 1、创建标签如何在当前提交上打标签呢？使用下面的命令： 1git tag -a v1.9 -m &quot;some message&quot; -a选项表示创建一个新的标签。 -m和commit命令中的一样，为必填项，为标签添加一些注释。 还有一种轻量打标签的方式：1git tag v1.1.1 这种不需要选项而直接给当前的提交打上标签。 4、查看标签使用下面的命令来查看所有标签：1git tag 当然，在log命令中，你打的标签也会出现在提交的右边。 你也可以加-l 来进行特定的模式查找标签：1git tag -l v1.* 将列出tags中以v1.开头的标签。 你也可以查看某一标签所代表的提交，使用下面的命令： 1git show v1.1 将显示打标签者，标签信息，时间和哪一次提交。 5、给之前的提交打标签如何给之前的提交打标签呢？只要看一下那次提交的ID字符串就可以了：1git tag -a v1.2 9fceb02 将会给那次提交打上一个标签。 6、给远程仓库打标签由于默认情况下，git push命令不会将标签传输到远程仓库，你需要显示的将标签传送到远程仓库中：1git push origin TAGNAME 当然如果想传送的标签很多，可以使用带有–tags选项将所有标签全部传送到远程仓库中。 四、使用远程仓库我相信有相当大的一部分人，是想学习github的使用，之后才了解到了Git。这两者不是一种东西，git和github的关系，相当于球与球场的关系。git创建的是本地仓库，而github上存放了好多远程的仓库。这些仓库都是用户将自己的仓库上传到服务器上，让github来托管这些仓库。那么如何建立远程仓库以及让本地仓库与远程仓库关联起来呢？ 1、","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://yangzebin001.github.io/tags/Git/"}]},{"title":"makedown","slug":"2018-01-26-fjlskadjfgla","date":"2018-01-26T09:56:16.000Z","updated":"2018-01-26T10:11:45.499Z","comments":true,"path":"2018/01/26/2018-01-26-fjlskadjfgla/","link":"","permalink":"https://yangzebin001.github.io/2018/01/26/2018-01-26-fjlskadjfgla/","excerpt":"欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：","text":"欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://yangzebin001.github.io/tags/html/"},{"name":"JS","slug":"JS","permalink":"https://yangzebin001.github.io/tags/JS/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-25T11:15:35.791Z","updated":"2018-10-03T08:41:19.276Z","comments":true,"path":"2018/01/25/hello-world/","link":"","permalink":"https://yangzebin001.github.io/2018/01/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}