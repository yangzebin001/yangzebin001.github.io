{"meta":{"title":"BeckoninGshy's Blog","subtitle":null,"description":"Welcome to BeckoninGshy's Blog.","author":"yangzebin","url":"https://yangzebin001.github.io"},"pages":[{"title":"about","date":"2019-01-31T10:14:50.000Z","updated":"2019-01-31T11:00:04.413Z","comments":true,"path":"about/index.html","permalink":"https://yangzebin001.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-31T10:14:34.000Z","updated":"2019-01-31T10:15:23.630Z","comments":true,"path":"tags/index.html","permalink":"https://yangzebin001.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode-10-正则表达式匹配","slug":"LeetCode-10-正则表达式匹配","date":"2020-01-30T08:34:00.000Z","updated":"2020-08-27T15:06:24.686Z","comments":true,"path":"2020/01/30/LeetCode-10-正则表达式匹配/","link":"","permalink":"https://yangzebin001.github.io/2020/01/30/LeetCode-10-正则表达式匹配/","excerpt":"","text":"10. 正则表达式匹配 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。 12&apos;.&apos; 匹配任意单个字符&apos;*&apos; 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。示例 1: 12345输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 示例 2:12345输入:s = &quot;aa&quot;p = &quot;a*&quot;输出: true解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。 示例 3:12345输入:s = &quot;ab&quot;p = &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。 示例 4:12345输入:s = &quot;aab&quot;p = &quot;c*a*b&quot;输出: true解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。 示例 5:1234输入:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;输出: false 思路：可以使用动态规划来解此题。 首先定义状态，有过求LCS和LIC的经验，我们很轻易类似的写出该题的状态定义： 1dp[i][j] 串S以i结尾，串P以j结尾是否能够匹配。 我们考虑状态转移方程：先分类考虑： s[i] != p[j] &amp;&amp; p[j] != ‘.’ &amp;&amp; p[j] != ‘*’ s[i] == p[j] p[j] == ‘.’ p[j] == ‘*’ 第一种情况显然是false。 第二种情况是说明可以匹配，所以由S前i-1，P前j-1匹配的情况决定。 第三种情况把’.’看做s[i]可以和第二种情况合并 重点是第四种情况，p[j]为’*’ 的情况： 单独一个‘ ’是不构成语义的，所以出现‘ ’就要看前一个字符，而前面有可能出现的又有‘.’和字母两种情况。前面说过了，我们遇见‘.’直接把他当作与s[i]相等的字符即可。不需要做特殊处理。 所以就只剩下了‘*’ 前面是字母的而分成的两种情况： ‘*’前面的字母和s[i-1]不匹配。 ‘*’前面的字母和s[i-1]匹配。 第一种情况由于’*’可以代表零个之前的字符。例如： 12aabcad*abc 是可以匹配的。所以我们遇到’*’前面的字母和s[i-1]不匹配就可以跳过这两个字符。即 1dp[i][j] = dp[i][j-2] 最后’*’前面的字母和s[i-1]匹配： 那么就有按照‘*’的语义，又需要划分三种情况： *加上前面的字符不与s[i-1]匹配。 加上前面的字符只与s[i-1]匹配 即 作废。 *加上前面的字符可以与多个s[i-1]匹配。 前两种情况其实与我们之前分析的不加‘*’的情况基本一致。那么与多个字符匹配怎么转移呢？ 我们确定匹配多个字符可以一个一个来，只要dp[i-1][j]可以匹配。那么只要[j]是，则dp[i][j]一定可以匹配上。（别忘了，我们的前提条件是 和之前的字母匹配） 12345678###b###b* 匹配。###bb###b*一定能匹配。 至此我们就将所有情况分析完毕。 代码： 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: bool isMatch(string s, string p) &#123; int n = s.size(), m = p.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(m+1)); dp[0][0] = 1; //处理 aa 和c*c*c*aa 匹配的情况。前缀可以忽略。 for(int i = 1; i &lt;= m; i++)&#123; if(i-2 &gt;= 0 &amp;&amp; dp[0][i-2] &amp;&amp; p[i-1] == &apos;*&apos;) dp[0][i] = 1; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; //单个字符匹配。 if(s[i-1] == p[j-1] || (p[j-1] == &apos;.&apos;))&#123; dp[i][j] = dp[i-1][j-1]; //单个字符不匹配 &#125;else if(p[j-1] == &apos;*&apos;)&#123; // baa bc*aa 形式 if(p[j-2] != s[i-1] &amp;&amp; p[j-2] != &apos;.&apos;)&#123; dp[i][j] = dp[i][j-2]; &#125;else&#123; // 否则是前一个字符可以匹配 // 三种情况， // 忽略这个匹配的字符，dp[i][j] = dp[i][j-2]; // 只匹配这个字符 dp[i][j] = dp[i][j-1]; // 匹配多个字符，即看i之前的字符和当前能不能匹配上，dp[i][j] = dp[i-1][j]; // ###b 和 ###b* 如果能匹配上， ###bb 和 ###b* 也能匹配上。 dp[i][j] = (dp[i][j-2] || dp[i][j-1] || dp[i-1][j]); &#125; &#125; &#125; &#125; return dp[n][m]; &#125;&#125;; 这里有一个点必须初始化，因为下标是从1开始的，无法访问到0，当遇到处理 aa 和c c c* aa 匹配的情况时，是需要访问到0的位置的，所以需要预处理。前缀可以为空的情况。","categories":[],"tags":[]},{"title":"HDOJ102-Ma-Su-Plu-Plus","slug":"HDOJ102-Ma-Su-Plu-Plus","date":"2020-01-25T04:16:00.000Z","updated":"2020-08-27T15:06:24.684Z","comments":true,"path":"2020/01/25/HDOJ102-Ma-Su-Plu-Plus/","link":"","permalink":"https://yangzebin001.github.io/2020/01/25/HDOJ102-Ma-Su-Plu-Plus/","excerpt":"","text":"Max Sum Plus Plus 题目描述Now I think you have got an AC in Ignatius.L’s “Max Sum” problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem. Given a consecutive number sequence S1, S2, S3, S4 … Sx, … Sn (1 ≤ x ≤ n ≤ 1,000,000, -32768 ≤ Sx ≤ 32767). We define a function sum(i, j) = Si + … + Sj (1 ≤ i ≤ j ≤ n). Now given an integer m (m &gt; 0), your task is to find m pairs of i and j which make sum(i1, j1) + sum(i2, j2) + sum(i3, j3) + … + sum(im, jm) maximal (ix ≤ iy ≤ jx or ix ≤ jy ≤ jx is not allowed). But I`m lazy, I don’t want to write a special-judge module, so you don’t have to output m pairs of i and j, just output the maximal summation of sum(ix, jx)(1 ≤ x ≤ m) instead. ^_^ 输入Each test case will begin with two integers m and n, followed by n integers S1, S2, S3 … Sn.Process to the end of file. 输出Output the maximal summation described above in one line. 输入示例1 3 1 2 32 6 -1 4 -2 3 -2 3 输出示例68 Hint Huge input, scanf and dynamic programming is recommended. 题目大意：给定n个数，让其划分为k个不重叠的区间（不要求连续），求其中的最大值。 思路：因为给定一个区间，它的最大值是确定的，所以具有无后效性，所以我们考虑使用dp来解此题。 我们首先定义状态表示，很自然的想到： 1dp[i][j] = dp[i][j] 表示将前i个数字分成j段的最大子段和。 接下来考虑状态转移方程： 我们将状态转移分为： 与前面划分的区间不合并，即自成一组。 与前面划分的区间合并为一组。 第二种转移方程比较好考虑： 1dp[i][j] = dp[i-1][j] + v[i]; 自成一组需要找上一组从哪里转移。由于不需要保证连续性，所以就需要从第一段一直到j-1段都要考虑到。 1dp[i][j] = max&#123;dp[k][j-1](1 &lt;= k &lt; i)&#125; 由于只有k个长度的字符才能分成k段。所以这里取值范围应该改为: 1dp[i][j] = max&#123;dp[k][j-1](j-1 &lt;= k &lt; i)&#125; + v[i] 综合一下就是： 1dp[i][j] =max( dp[i-1][j], max&#123;dp[k][j-1](j-1 &lt;= k &lt; i)&#125; ) + v[i] 分析工作准备完毕，我们准备写代码时发现，这个数组范围比较大，会O（n2）的算法会超时，所以要优化。 第二种转移方程没什么好优化的，我们转移到第一种上，它在转移上依赖了他之上的好多行的数组，列却只依赖一列。这里想象为二维数组，我们把行，列的含义互换，想象这个二维数组逆时针旋转了90度。就得到了如下的转移方程： 1dp[i][j] = dp[i][j] 表示将前j个数字分成i段的最大子段和。 1dp[i][j] =max( dp[i][j-1], max&#123;dp[i-1][k](i-1 &lt;= k &lt; j)&#125; ) + v[j] 我们可以将 max{dp[i-1]k} 这个O(n)的时间，在上一层的d[i-1][j]计算结果时用一个变量来记录，使其优化为O(1)。 具体编程还是有些难度，需要好好思考。 12345678910111213141516171819202122232425262728293031323334353637/* * @Date: 2020-01-24 10:42:12 * @LastEditors : BeckoninGshy * @LastEditTime : 2020-01-25 11:37:00 */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN =1e6+10;int dp[MAXN],v[MAXN],numax[MAXN]; //保存上一层dp的最大值。int main()&#123; int k,n; while(cin &gt;&gt; k &gt;&gt; n)&#123; for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; v[i]; dp[i] = numax[i] = 0; &#125; dp[0] = numax[0] = 0; int lastmax = INT_MIN; for(int i = 1; i &lt;= k; i++)&#123; lastmax = INT_MIN; //保存上一层dp的最大值 for(int j = i; j &lt;= n; j++)&#123; //先利用之前的上一层最大值更新当前状态， dp[j] = max(dp[j-1],numax[j-1]) + v[j]; //再将j-1的最大值更新到上一层的最大值数组中， 将在i+1层循环中使用，当前循环不使用 numax[j-1] = lastmax; //存储当前层的最大值 lastmax = max(lastmax,dp[j]); &#125; &#125; cout &lt;&lt; lastmax &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"HDOJ102-Ma-Su-Plu-Plus","slug":"JVM OOM异常种类测试和解决方案总结","date":"2020-01-25T04:16:00.000Z","updated":"2020-08-27T15:31:22.911Z","comments":true,"path":"2020/01/25/JVM OOM异常种类测试和解决方案总结/","link":"","permalink":"https://yangzebin001.github.io/2020/01/25/JVM OOM异常种类测试和解决方案总结/","excerpt":"本文为学习《深入理解java虚拟机》书中2.4节实战部分的整理总结。 jvm中能引起Out of memory Error 的运行时内存存储区域大致可以分为： java堆区溢出 java虚拟机栈和本地方法栈溢出 方法区和运行时常量池溢出 本机直接内存溢出","text":"本文为学习《深入理解java虚拟机》书中2.4节实战部分的整理总结。 jvm中能引起Out of memory Error 的运行时内存存储区域大致可以分为： java堆区溢出 java虚拟机栈和本地方法栈溢出 方法区和运行时常量池溢出 本机直接内存溢出 下面通过示例代码来观察各个区域出错的状况。 一、java堆区溢出12345678910111213141516171819import java.util.ArrayList;import java.util.List;/** * @author yzb * VM args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError */public class HeapTest &#123; // 声明一个静态内部类 static class OOMObject&#123;&#125; public static void main(String[] args) &#123; List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;(); // 不断向list中添加新创建的对象，对象实例会存储在堆中，所以会引起heap space OOM， 错误信息也能证明这一点。 while (true) &#123; list.add(new OOMObject()); &#125; &#125;&#125; 出错信息：1234567891011java.lang.OutOfMemoryError: **Java heap space**Dumping heap to java_pid5472.hprof ...Heap dump file created [28155685 bytes in 0.209 secs]Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3210) at java.util.Arrays.copyOf(Arrays.java:3181) at java.util.ArrayList.grow(ArrayList.java:265) at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:239) at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:231) at java.util.ArrayList.add(ArrayList.java:462) at com.yzb.HeapTest.main(HeapTest.java:17) 基本思路：java中的对象实例都是储存在堆区中，所以我们通过参数-Xms20m -Xmx20m固定好java堆的大小，并且保证有可达路径来避免GC回收对象，就可以很快将堆区占满，从而发生内存溢出异常，异常信息中的Java heap space也可以证明这一点。 另一个参数-XX:+HeapDumpOnOutOfMemoryError可以在堆溢出时dump出当前内存堆转储快照，我们用Jprofiler打开快照文件查看内存占用情况： Name Instance Count Size com.yzb.HeapTest$OOMObject 810,326 12,965 kB char[ ] 2,294 313 kB java.lang.String 2,145 51,480 bytes java.util.TreeMap$Entry 791 31,640 bytes java.lang.Object[ ] 583 3,274 kB java.lang.Class 546 174 kB 可以看到 com.yzb.HeapTest$OOMObject 占用了绝大部分的内存，从而定位出是OOMObject对象实例过多的缘故。 解决方案：通过内存分析工具分析造成堆溢出的情况。如果是内存泄漏，找到泄漏对象的引用路径，定位对象创建和造成泄漏的位置。如果是内存溢出，检查虚拟机的堆参数-Xmx -Xms 是否还有上调的空间，再从代码上检查是否对象生命周期过长，设计不合理等情况，避免过多的内存消耗。 二、java虚拟机栈和本地方法栈溢出关于栈溢出，我们可以有两种方法测试： 缩小栈内存容量 增加栈帧长度 我们先看第一种： 1234567891011121314151617181920212223package com.yzb;/** * @author yzb * VM args： -Xss128k */public class StackOverFlowTest &#123; private int stackLength = 1; private void stackLeak() &#123; stackLength++; stackLeak(); &#125; public static void main(String[] args) throws Throwable&#123; StackOverFlowTest soft = new StackOverFlowTest(); try &#123; soft.stackLeak(); &#125; catch (Throwable e)&#123; System.out.println(\"stack length: \" + soft.stackLength); throw e; &#125; &#125;&#125; 错误信息：1234stack length: 983Exception in thread &quot;main&quot; java.lang.StackOverflowError at com.yzb.StackOverFlowTest.stackLeak(StackOverFlowTest.java:8) at com.yzb.StackOverFlowTest.stackLeak(StackOverFlowTest.java:9) 我们通过缩小栈容量，和无止境的递归调用来触发Stack Overflow异常。这里可以看到，我们在128k的栈容量下，对于stackLeak方法，允许983次递归调用的深度。 再来试试第二种： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.yzb;public class StackOverFlowTest2 &#123; private int stackLength = 0; private void test()&#123; long unused1, unused2, unused3, unused4, unused5, unused6, unused7, unused8, unused9, unused10, unused11, unused12, unused13, unused14, unused15, unused16, unused17, unused18, unused19, unused20, unused21, unused22, unused23, unused24, unused25, unused26, unused27, unused28, unused29, unused30, unused31, unused32, unused33, unused34, unused35, unused36, unused37, unused38, unused39, unused40, unused41, unused42, unused43, unused44, unused45, unused46, unused47, unused48, unused49, unused50, unused51, unused52, unused53, unused54, unused55, unused56, unused57, unused58, unused59, unused60, unused61, unused62, unused63, unused64, unused65, unused66, unused67, unused68, unused69, unused70, unused71, unused72, unused73, unused74, unused75, unused76, unused77, unused78, unused79, unused80, unused81, unused82, unused83, unused84, unused85, unused86, unused87, unused88, unused89, unused90, unused91, unused92, unused93, unused94, unused95, unused96, unused97, unused98, unused99; stackLength++; test(); unused1 = unused2 = unused3 = unused4 = unused5 = unused6 = unused7 = unused8 = unused9 = unused10 = unused11 = unused12 = unused13 = unused14 = unused15 = unused16 = unused17 = unused18 = unused19 = unused20 = unused21 = unused22 = unused23 = unused24 = unused25 = unused26 = unused27 = unused28 = unused29 = unused30 = unused31 = unused32 = unused33 = unused34 = unused35 = unused36 = unused37 = unused38 = unused39 = unused40 = unused41 = unused42 = unused43 = unused44 = unused45 = unused46 = unused47 = unused48 = unused49 = unused50 = unused51 = unused52 = unused53 = unused54 = unused55 = unused56 = unused57 = unused58 = unused59 = unused60 = unused61 = unused62 = unused63 = unused64 = unused65 = unused66 = unused67 = unused68 = unused69 = unused70 = unused71 = unused72 = unused73 = unused74 = unused75 = unused76 = unused77 = unused78 = unused79 = unused80 = unused81 = unused82 = unused83 = unused84 = unused85 = unused86 = unused87 = unused88 = unused89 = unused90 = unused91 = unused92 = unused93 = unused94 = unused95 = unused96 = unused97 = unused98 = unused99 = 100; &#125; public static void main(String[] args) &#123; StackOverFlowTest2 soft2 = new StackOverFlowTest2(); try &#123; soft2.test(); &#125; catch (Error e) &#123; System.out.println(\"stack length: \" + soft2.stackLength); throw e; &#125; &#125;&#125; 错误信息：1234stack length: 5209Exception in thread &quot;main&quot; java.lang.StackOverflowError at com.yzb.StackOverFlowTest2.test(StackOverFlowTest2.java:27) at com.yzb.StackOverFlowTest2.test(StackOverFlowTest2.java:27) 现在使用jvm默认的栈大小，并且在方法内定义了100个本地变量来增加每个方法的调用栈帧。 我们看到该方法的调用深度为5209，并且报了StackOverflowError。 解决方案：对于StackOverflowError， 通常可以设置增加栈容量或者试着将其栈帧变大的方法内部进行削减本地变量，当然更多时候，栈溢出是递归过深造成的，试着减少递归深度或者改写成迭代形式。 三、方法区和运行时常量池溢出测试运行时常量池溢出，我们立马会想到String，但由于JDK7之后已经将字符串常量池移到了java堆区，所以只能通过限制堆区容量来观察错误信息，而JDK6之前可以通过限制永久代容量来看到错误情况。 12345678910111213141516171819package com.yzb;import java.util.HashSet;import java.util.Set;/** * @author yzb * VM args1: -XX:PermSize=6m -XX:MaxPermSize=6m JDK 6 and before is work. * VM arg2: -Xms20m -Xmx20m JDK 7 and after is work. */public class RuntimeContantPoolTest &#123; public static void main(String[] args) &#123; Set&lt;String&gt; s = new HashSet&lt;&gt;(); int i = 0; while (true) &#123; s.add(String.valueOf(i++).intern()); &#125; &#125;&#125; JDK7 的报错信息：123456Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.HashMap.resize(HashMap.java:704) at java.util.HashMap.putVal(HashMap.java:663) at java.util.HashMap.put(HashMap.java:612) at java.util.HashSet.add(HashSet.java:220) at com.yzb.RuntimeContantPoolTest.main(RuntimeContantPoolTest.java:16) JDK8之后，元空间替代了永久代，如果到达了元空间初始空间大小，会触发垃圾收集进行类型卸载，并调整空间大小。 四、本机直接内存溢出通过反射获取Unsafe实例不断进行内存分配来导致本机直接的内存溢出。 12345678910111213141516171819202122232425262728package com.yzb;import sun.misc.Unsafe;import java.lang.reflect.Field;/** * @author yzb */public class DirectMemoryTest &#123; private static final int _1MB = 1024*1024; public static void main(String[] args) throws Throwable &#123; int cnt = 0; Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); try&#123; while (true) &#123; cnt++; unsafe.allocateMemory(_1MB); &#125; &#125; catch (Error e) &#123; System.out.println(\"allocated \" + cnt +\"MB memory.\"); throw e; &#125; &#125;&#125; 报错信息：1234allocated 13630MB memory.Exception in thread &quot;main&quot; java.lang.OutOfMemoryError at sun.misc.Unsafe.allocateMemory(Native Method) at com.yzb.DirectMemoryTest.main(DirectMemoryTest.java:22) 可以看到在我的机器上申请了13GB的内存后出现了OutOfMemoryError。","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://yangzebin001.github.io/tags/JVM/"}]},{"title":"LeetCode-1320-二指输入的的最小距离","slug":"LeetCode-1320-二指输入的的最小距离","date":"2020-01-20T06:13:00.000Z","updated":"2020-08-27T15:06:24.681Z","comments":true,"path":"2020/01/20/LeetCode-1320-二指输入的的最小距离/","link":"","permalink":"https://yangzebin001.github.io/2020/01/20/LeetCode-1320-二指输入的的最小距离/","excerpt":"","text":"1320. 二指输入的的最小距离 二指输入法定制键盘在 XY 平面上的布局如上图所示，其中每个大写英文字母都位于某个坐标处，例如字母 A 位于坐标 (0,0)，字母 B 位于坐标 (0,1)，字母 P 位于坐标 (2,3) 且字母 Z 位于坐标 (4,1)。 给你一个待输入字符串 word，请你计算并返回在仅使用两根手指的情况下，键入该字符串需要的最小移动总距离。坐标 (x1,y1) 和 (x2,y2) 之间的距离是 |x1 - x2| + |y1 - y2|。 注意，两根手指的起始位置是零代价的，不计入移动总距离。你的两根手指的起始位置也不必从首字母或者前两个字母开始。 示例 1：12输入：word = &quot;CAKE&quot;输出：3 解释：使用两根手指输入 “CAKE” 的最佳方案之一是：手指 1 在字母 ‘C’ 上 -&gt; 移动距离 = 0手指 1 在字母 ‘A’ 上 -&gt; 移动距离 = 从字母 ‘C’ 到字母 ‘A’ 的距离 = 2手指 2 在字母 ‘K’ 上 -&gt; 移动距离 = 0手指 2 在字母 ‘E’ 上 -&gt; 移动距离 = 从字母 ‘K’ 到字母 ‘E’ 的距离 = 1总距离 = 3 示例 2： 12输入：word = &quot;HAPPY&quot;输出：6 解释：使用两根手指输入 “HAPPY” 的最佳方案之一是：手指 1 在字母 ‘H’ 上 -&gt; 移动距离 = 0手指 1 在字母 ‘A’ 上 -&gt; 移动距离 = 从字母 ‘H’ 到字母 ‘A’ 的距离 = 2手指 2 在字母 ‘P’ 上 -&gt; 移动距离 = 0手指 2 在字母 ‘P’ 上 -&gt; 移动距离 = 从字母 ‘P’ 到字母 ‘P’ 的距离 = 0手指 1 在字母 ‘Y’ 上 -&gt; 移动距离 = 从字母 ‘A’ 到字母 ‘Y’ 的距离 = 4总距离 = 6 示例 3： 12输入：word = &quot;NEW&quot;输出：3 示例 4：12输入：word = &quot;YEAR&quot;输出：7 提示：2 &lt;= word.length &lt;= 300每个 word[i]。都是一个大写英文字母。 Solution1（记忆化）：我们首先要定义一个递归方程，思考后发现有两类主要元素：第一类是要记录到哪个字符，第二类是两个手指当前的位置。 然后发现“记录到哪个字符”这个状态不太好与两个手指进行关联（只能和一个手指进行绑定），所以我们转化一下思路，将记录到哪个字符转变为从第i个字符起，到字符串的末尾这整个区间，然后记录两个手指的状态。这样就得到了如下的递归函数参数： 1234// i: [i:w.size()]区间内花费的最小距离，// l: 上一个第一个手指的位置。// r: 上一个第二个手指的位置dfs(int i, int l, int r) 转移方程为： 1dfs(i,l,c) = min(dfs(i+1,l,c)+cost(r,c),dfs(i+1,c,r)+cost(l,c)); 然后添加记忆化数组，整理就得到了下面的解决方案： 123456789101112131415161718192021222324class Solution &#123;public: int mem[310][27][27]; int cost(int i, int j)&#123; if(i == 26 || j == 26) return 0; return abs(i/6-j/6)+abs(i%6-j%6); &#125; string w; // i: [i:w.size()]区间内花费的最小距离， // l: 上一个第一个手指的位置。 // r: 上一个第二个手指的位置。 int dfs(int i, int l, int r)&#123; if(i == w.size()) return 0; if(mem[i][l][r]) return mem[i][l][r]; int c = w[i]-&apos;A&apos;; return mem[i][l][r] = min(dfs(i+1,l,c)+cost(r,c),dfs(i+1,c,r)+cost(l,c)); &#125; int minimumDistance(string word) &#123; w = word; //计算整个字符串的区间，初始两指从悬空状态开始。 return dfs(0,26,26); &#125;&#125;; Solution2（DP）：我们可以试着将记忆化搜索转化为dp求解，很明显，状态表示和递归函数的状态是一致的，都是三维表示。 1int dp[i][j][k]; //第一个手指一动到i，第二个手指移动到j，已经移动了k个字符的最小代价。 这里与记忆化搜索定义的字符区间范围正好相反，递归中用的是从i到n的区间，而这里由于天然的记忆化过程，可以直接表示从0到k。 接着写状态转移方程： 1234//从上一个字符移动到当前字符使用第一个手指，计算的最小价值。dp[c][j][k] = min(dp[c][j][k],dp[i][j][k-1] + cost);//从上一个字符移动到当前字符使用第二个手指，计算的最小价值。dp[i][c][k] = min(dp[i][c][k],dp[i][j][k-1] + cost); 最后我们查看手指停在任何字符上的代价取最小即为答案。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int Cost(int i, int j)&#123; //悬空状态，代价为0 if(i == 26 || j == 26) return 0; return abs(i/6-j/6)+abs(i%6-j%6); &#125; int dp[27][27][301]; //第一个手指一动到i，第二个手指移动到j，已经移动了k个字符的最小代价。 int minimumDistance(string word) &#123; memset(dp,0x3f3f3f3f,sizeof(dp)); // 初始化悬空状态 dp[26][26][0] = 0; int n = word.size(); for(int k = 1; k &lt;= n; k++)&#123; int c = word[k-1]-&apos;A&apos;; //a int cost = 0; for(int i = 0; i &lt;= 26; i++)&#123; for(int j = 0; j &lt;= 26; j++)&#123; cost = Cost(i,c); //从上一个字符移动到当前字符使用第一个手指，计算的最小价值。 dp[c][j][k] = min(dp[c][j][k],dp[i][j][k-1] + cost); cost = Cost(j,c); //从上一个字符移动到当前字符使用第二个手指，计算的最小价值。 dp[i][c][k] = min(dp[i][c][k],dp[i][j][k-1] + cost); &#125; &#125; &#125; int ans = 0x3f3f3f3f; for(int i = 0; i &lt;= 26; i++)&#123; for(int j = 0; j &lt;= 26; j++)&#123; ans = min(ans,dp[i][j][n]); &#125; &#125; return ans; &#125;&#125;;","categories":[],"tags":[]},{"title":"LeetCode-89-格雷编码","slug":"LeetCode-89-格雷编码","date":"2020-01-14T09:04:00.000Z","updated":"2020-08-27T15:06:24.677Z","comments":true,"path":"2020/01/14/LeetCode-89-格雷编码/","link":"","permalink":"https://yangzebin001.github.io/2020/01/14/LeetCode-89-格雷编码/","excerpt":"","text":"89. 格雷编码 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。 示例 1:1234567输入: 2输出: [0,1,3,2]解释:00 - 001 - 111 - 310 - 2 对于给定的 n，其格雷编码序列并不唯一。例如，[0,2,3,1] 也是一个有效的格雷编码序列。 123400 - 010 - 211 - 301 - 1 示例 2:12345输入: 0输出: [0]解释: 我们定义格雷编码序列必须以 0 开头。 给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。 因此，当 n = 0 时，其格雷编码序列为 [0]。 Solution1动态规划法： 格雷码可以通过在当前的部分格雷码通过复制这一部分上下翻转次序后，使翻转后的部分通过新增加的最高位都转换为1来得到。 例如当前的部分序列为：120001 翻转后为120100 往每个数字前面增加一位前导零组合成新的部分格雷码：1234000001001000 将翻转后的数字的前导零置为1：1234000001101100 这一新的序列也是格雷码序列。 通过翻转n次，将得到长度为n全部的格雷码序列。 1234567891011121314class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; ans; ans.push_back(0); for(int k = 0; k &lt; n; k++)&#123; int c = ans.size(); for(int j = c, i = 1; j &lt; 2*c; j++, i++)&#123; ans.push_back(ans[c-i]|(1&lt;&lt;k)); &#125; &#125; return ans; &#125;&#125;; Solution2：直接构造法： 维基百科中生成格雷码的步骤为： 以二进制为 0 值的格雷码为第零项，第一项改变最右边的位元，第二项改变右起第一个为1的位元的左边位元，第三、四项方法同第一、二项，如此反复，即可排列出n个位元的格雷码。 以3为例： 12345678000 初始值001 改变右起第一项011 改变右起第一个为1的位元的左边位元010 改变右起第一项110 改变右起第一个为1的位元的左边位元111 改变右起第一项101 改变右起第一个为1的位元的左边位元100 改变右起第一项 代码：1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; ans; ans.push_back(0); for(int k = 1; k &lt; 1&lt;&lt;n; k++)&#123; // 改变右起第一项。 if(k%2) ans.push_back(ans[k-1]^1); // 改变右起第一个为1的位元的左边位元 else&#123; int c = 0; int pre = ans[k-1]; while(((pre&gt;&gt;c) &amp; 1) == 0) c++; c++; ans.push_back(pre^(1&lt;&lt;c)); &#125; &#125; return ans; &#125;&#125;; Solution3：公式法： 当前第i项的二进制数的最高位保留，其它位是当前位和它的高一位进行异或操作。 123456789101112class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; ans; for(int k = 0; k &lt; 1&lt;&lt;n; k++)&#123; //每一项与当前数右移后异或得到。 ans.push_back(k^(k&gt;&gt;1)); &#125; return ans; &#125;&#125;;","categories":[],"tags":[]},{"title":"LeetCode-394-字符串解码","slug":"LeetCode-394-字符串解码","date":"2019-12-26T13:11:00.000Z","updated":"2020-08-27T15:06:24.675Z","comments":true,"path":"2019/12/26/LeetCode-394-字符串解码/","link":"","permalink":"https://yangzebin001.github.io/2019/12/26/LeetCode-394-字符串解码/","excerpt":"","text":"394. 字符串解码 给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例:123s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;. Solution1（递归法）：12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: string decodeString(string s) &#123; int i = 0; string ans = &quot;&quot;; while(i &lt; s.size())&#123; ans += dfs(s,i); &#125; return ans; &#125; string dfs(string s, int &amp;i)&#123; int num = 0,flag = 0; string t = &quot;&quot;, tt = &quot;&quot;; while(i &lt; s.size() &amp;&amp; s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;)&#123; num = num * 10 + (s[i]-&apos;0&apos;); i++; &#125; if(i &lt; s.size() &amp;&amp; s[i] == &apos;[&apos;) flag = 1, i++; while(i &lt; s.size() &amp;&amp; s[i] != &apos;]&apos;)&#123; if(s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;)&#123; t += dfs(s,i); continue; &#125; t += s[i]; i++; &#125; if(t.size() &gt; 0)&#123; tt = t; while(--num &gt; 0) tt += t; &#125; if(i &lt; s.size() &amp;&amp; s[i] == &apos;]&apos;) i++; return tt; &#125;&#125;; 思路：很正常的思路就是递归，每遇到数字就递归到下一层，等下一层的结束后，返回到当前层接着处理，在遇到’]’或者走到最后时，结束这一层的处理。 Solution2（栈）：1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string decodeString(string s) &#123; stack&lt;int&gt; numstk; stack&lt;string&gt; strstk; int num = 0; string cur = &quot;&quot;; //当前层可以形成的串 for(int i = 0; i &lt; s.size(); i++)&#123; if(s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;)&#123; num = num * 10 + (s[i]-&apos;0&apos;); &#125;else if(s[i] == &apos;[&apos;)&#123; //模拟递归，该去下一层了。 numstk.push(num); strstk.push(cur); num = 0; cur = &quot;&quot;; &#125;else if(s[i] == &apos;]&apos;)&#123; //这一层已经完成处理 for(int j = 0; j &lt; numstk.top(); j++)&#123; strstk.top() += cur; &#125; //返回上一层 cur = strstk.top(); strstk.pop(); numstk.pop(); &#125;else&#123; cur += s[i]; &#125; &#125; return cur; &#125;&#125;; 思路：使用栈就是为了能保留当前层的信息，这里的进入下一层的时机和递归版略有差别，在到达’[‘的时候才进入下一层，主要是为了确定num的值和保存之前正处理的串的信息，在’]’的时候要处理完当前层，并且返回上一层。","categories":[],"tags":[]},{"title":"LeetCode-117-填充每个节点的下一个右侧节点指-II","slug":"LeetCode-117-填充每个节点的下一个右侧节点指-II","date":"2019-12-02T09:46:00.000Z","updated":"2020-08-27T15:06:24.673Z","comments":true,"path":"2019/12/02/LeetCode-117-填充每个节点的下一个右侧节点指-II/","link":"","permalink":"https://yangzebin001.github.io/2019/12/02/LeetCode-117-填充每个节点的下一个右侧节点指-II/","excerpt":"","text":"117. 填充每个节点的下一个右侧节点指针 II 此题为116. 填充每个节点的下一个右侧节点指针的进阶版本。 给定一个二叉树 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 进阶： 你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 示例：12输入：root = [1,2,3,4,5,null,7]输出：[1,#,2,3,#,4,5,7,#] 提示： 树中的节点数小于 6000 100 &lt;= node.val &lt;= 100 Solution1（迭代版）：1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: Node* connect(Node* root) &#123; if(!root) return NULL; Node* head = root; Node* pre = NULL; while(root)&#123; Node* sub = NULL; while(pre)&#123; if(pre-&gt;left)&#123; if(sub) sub-&gt;next = pre-&gt;left; sub = pre-&gt;left; &#125; if(pre-&gt;right)&#123; if(sub) sub-&gt;next = pre-&gt;right; sub = pre-&gt;right; &#125; pre = pre-&gt;next; &#125; pre = root; while(root)&#123; if(root-&gt;left)&#123; root = root-&gt;left; break; &#125; else if(root-&gt;right)&#123; root = root-&gt;right; break; &#125; else &#123; root = root-&gt;next; &#125; &#125; &#125; return head; &#125;&#125;; 思路：与上一题类似，先设置下父指针，找到父指针下所有存在的结点相连接，然后找到下一层的第一个结点，将其继续当做父节点。 Solution2（递归版）：1234567891011121314151617181920class Solution &#123;public: Node* connect(Node* root) &#123; if(!root || (!root-&gt;left &amp;&amp; !root-&gt;right)) return root; //先把当前结点连接 if(root-&gt;left &amp;&amp; root-&gt;right) root-&gt;left-&gt;next = root-&gt;right; Node* sub = root-&gt;right ? root-&gt;right : root-&gt;left; //跳过没有子节点的节点 Node* head = root-&gt;next; while(head &amp;&amp; !head-&gt;left &amp;&amp; !head-&gt;right)&#123; head = head-&gt;next; &#125; sub-&gt;next = head ? (head-&gt;left ? head-&gt;left : head-&gt;right) : NULL; connect(root-&gt;right); connect(root-&gt;left); return root; &#125;&#125;; 思路：如果是叶子节点或空节点，则直接返回。如果有两个子节点，先把两节点之间连接，把右节点当做下一层要操作的节点。如果只有一个子节点，把该节点当做下一层要操作的节点。 将下一层的节点连接（寻找当前层的非叶子结点，将它的子节点与该结点的下一层节点连接）。 这里注意一定要先构建右子树，再构建左子树，因为寻找父节点的兄弟节点是从左到右遍历的，如果右子树未构建好就遍历，则会出错。","categories":[],"tags":[]},{"title":"LeetCode-116-填充每个节点的下一个右侧节点指针","slug":"LeetCode-116-填充每个节点的下一个右侧节点指针","date":"2019-11-25T11:50:00.000Z","updated":"2020-08-27T15:06:24.672Z","comments":true,"path":"2019/11/25/LeetCode-116-填充每个节点的下一个右侧节点指针/","link":"","permalink":"https://yangzebin001.github.io/2019/11/25/LeetCode-116-填充每个节点的下一个右侧节点指针/","excerpt":"","text":"给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 Solution1（递归版）：12345678910111213141516class Solution &#123;public: Node* connect(Node* root) &#123; if(!root) return NULL; Node* l = root-&gt;left; Node* r = root-&gt;right; while(l)&#123; l-&gt;next = r; l = l-&gt;right; r = r-&gt;left; &#125; connect(root-&gt;left); connect(root-&gt;right); return root; &#125;&#125;; Solution2（迭代版）：一层一层的考虑，由于每个结点往后连需要用到其父节点的信息，所以我们可以在下一层结点的next指针连接完毕后，在往下一层移动时，父结点就可以利用已经连接好的next指针进行平滑的向右移动了。这样直到最后一层结束。 1234567891011121314151617181920212223/*// Definition for a Node.class Solution &#123;public: Node* connect(Node* root) &#123; if(!root) return root; Node* pre = NULL; Node* cur = root; while(cur)&#123; while(pre)&#123; pre-&gt;left-&gt;next = pre-&gt;right; if(pre-&gt;next)&#123; pre-&gt;right-&gt;next = pre-&gt;next-&gt;left; &#125; pre = pre-&gt;next; &#125; pre = cur; cur = cur-&gt;left; &#125; return root; &#125;&#125;;","categories":[],"tags":[]},{"title":"01背包问题详解","slug":"01背包问题详解","date":"2019-11-25T03:46:00.000Z","updated":"2020-08-27T15:31:15.465Z","comments":true,"path":"2019/11/25/01背包问题详解/","link":"","permalink":"https://yangzebin001.github.io/2019/11/25/01背包问题详解/","excerpt":"01背包题目描述：有 N 件物品和一个容量是 V的背包。每件物品只能使用一次。 第 i件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。","text":"01背包题目描述：有 N 件物品和一个容量是 V的背包。每件物品只能使用一次。 第 i件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 思路：拿到这道题目，我们在不用动态规划的情况下，可以枚举这N件物品，每件物品都有选和不选两种情况，所以总的复杂度为O（2^n）。并且在计算过程中，我们发现有很多的重复计算。最直接优化的方法当然是记忆化，将搜到的状态保存下来，以便之后重复调用时直接取值，避免重复计算。 第二种优化方法就是动态规划了。我们对每一次的决策都保留最优解。最终得到问题的最优解。 构建动态规划的关键在于定义状态转移方程。定义状态转移方程要符合两个条件： 最优子结构 无后效性 我们回到01背包问题具体来看： 由于只有当所有的背包全部考察完，我们才能得到最终的方案，并且对于每一层的背包我都可以选择拿或不拿，这一层的决策不会影响到之前已经得到的结论，所以很自然的要定义一个维度，用来指名当前要考察的背包。 又由于要限制条件为背包的容量，大于背包容量的我们自然永远都不会考虑，但是背包的容量会随着每个背包的选或不选能有变化，所以我们还需要一维信息，由来记录背包的容量变化。所以我们得出来一个二维数组用来记录状态: 1dp[i][j] //i是前i个背包，j是容量，dp[i][j]是当前前i个背包，容量是j时，可获得的最大价值。 我们思考下转移方程：在每个背包被考察时，我们先考虑不选当前背包，则方程为: 1dp[i][j] = dp[i-1][j] 然后考虑选择当前背包： 在选择了背包后容量肯定会变大，对照我们定义的状态，所以会有: 1dp[i+1][j+w] = dp[i][j]+v; //这时w,v分别代表第i+1个背包的质量和价值。 转换一下就是： 1dp[i][j] = dp[i-1][j-wi]+vi;//这时w,v分别代表第i个背包的质量和价值。 我们要保持当前状态为最大的价值。所以综合起来，方程就变为了： 1dp[i][j] = max(dp[i-1][j],dp[i-1][j-wi]+vi); 整理成代码： 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN = 1010;int n,m;//前i个物体，总体积是j 的最大总价值int f[MAXN][MAXN];int V[MAXN],W[MAXN];int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i = 1; i &lt;= n; i++) cin &gt;&gt; V[i] &gt;&gt; W[i]; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 0; j &lt;= m; j++)&#123; //要么不选 f[i][j] = f[i-1][j]; if(j &gt;= V[i])&#123; //要么选择该背包，从f[i-1][j-v[i]]过来。 f[i][j] = max(f[i][j],f[i-1][j-V[i]]+W[i]); &#125; &#125; &#125; int ans = 0; //在前n个物体中，选价值最大的一个 for(int i = 0; i &lt;= m; i++)&#123; ans = max(ans,f[n][i]); &#125; printf(&quot;%d&quot;,ans); return 0;&#125; 优化：我们再看一下转移方程： 1dp[i][j] = max(dp[i-1][j],dp[i-1][j-wi]+vi); 当前考察背包只会利用到上一个背包计算后的结果。所以我们考虑优化到一维，但是循环的顺序需要变一下，从后往前计算，只有这样我们不会改变了之前的值，而导致计算出错。 一维数组优化12345678910111213141516171819#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN = 1010;int f[MAXN];int N,M;int V[MAXN],W[MAXN];int main()&#123; scanf(&quot;%d%d&quot;,&amp;N,&amp;M); for(int i = 1; i &lt;= N; i++) scanf(&quot;%d%d&quot;,&amp;V[i],&amp;W[i]); for(int i = 1; i &lt;= N; i++) //从后往前推，保留i-1的状态 for(int j = M; j &gt;= V[i]; j--)&#123; f[j] = max(f[j],f[j-V[i]]+W[i]); &#125; printf(&quot;%d&quot;,f[M]); return 0;&#125; 这样，01背包问题就完美的解决了。","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"https://yangzebin001.github.io/tags/DP/"},{"name":"背包问题","slug":"背包问题","permalink":"https://yangzebin001.github.io/tags/背包问题/"}]},{"title":"01背包问题详解","slug":"背包九讲","date":"2019-11-25T03:46:00.000Z","updated":"2020-08-27T15:31:09.689Z","comments":true,"path":"2019/11/25/背包九讲/","link":"","permalink":"https://yangzebin001.github.io/2019/11/25/背包九讲/","excerpt":"01背包有 N 件物品和一个容量是 V的背包。每件物品只能使用一次。 第 i件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。","text":"01背包有 N 件物品和一个容量是 V的背包。每件物品只能使用一次。 第 i件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN = 1010;int n,m;//前i个物体，总体积是j 的最大总价值int f[MAXN][MAXN];int V[MAXN],W[MAXN];int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i = 1; i &lt;= n; i++) cin &gt;&gt; V[i] &gt;&gt; W[i]; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 0; j &lt;= m; j++)&#123; //要么不选 f[i][j] = f[i-1][j]; if(j &gt;= V[i])&#123; //要么选择该背包，从f[i-1][j-v[i]]过来。 f[i][j] = max(f[i][j],f[i-1][j-V[i]]+W[i]); &#125; &#125; &#125; int ans = 0; //在前n个物体中，选价值最大的一个 for(int i = 0; i &lt;= m; i++)&#123; ans = max(ans,f[n][i]); &#125; printf(&quot;%d&quot;,ans); return 0;&#125; 一维数组优化12345678910111213141516171819#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN = 1010;int f[MAXN];int N,M;int V[MAXN],W[MAXN];int main()&#123; scanf(&quot;%d%d&quot;,&amp;N,&amp;M); for(int i = 1; i &lt;= N; i++) scanf(&quot;%d%d&quot;,&amp;V[i],&amp;W[i]); for(int i = 1; i &lt;= N; i++) //从后往前推，保留i-1的状态 for(int j = M; j &gt;= V[i]; j--)&#123; f[j] = max(f[j],f[j-V[i]]+W[i]); &#125; printf(&quot;%d&quot;,f[M]); return 0;&#125; 完全背包有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。 第 i 种物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int N,M;const int MAXN = 1010;int f[MAXN][MAXN],V[MAXN],W[MAXN];//转移方程，f[i][j] = max&#123;f[i-1][j-k*V[i]+k*W[i]&#125;//含义：可以在之前选完后，选择当前的[M/V[i]]个，取价值最大的那个。int main()&#123; scanf(&quot;%d%d&quot;,&amp;N,&amp;M); for(int i = 1; i &lt;= N; i++)&#123; scanf(&quot;%d%d&quot;,&amp;V[i],&amp;W[i]); &#125; for(int i = 1; i &lt;= N; i++)&#123; for(int j = 1; j &lt;= M; j++)&#123; for(int k = 0; k * V[i] &lt;= j; k++)&#123; f[i][j] = max(f[i][j],f[i-1][j-k*V[i]]+k*W[i]); &#125; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= M; i++)&#123; ans = max(ans,f[N][i]); &#125; printf(&quot;%d&quot;,ans); return 0;&#125; 一维数组优化：1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN = 1010;int f[MAXN];int N,M;int main()&#123; scanf(&quot;%d%d&quot;,&amp;N,&amp;M); for(int i = 1; i &lt;= N; i++)&#123; int v,w; scanf(&quot;%d%d&quot;,&amp;v,&amp;w); //每一层考虑--&gt;尽可能选取多的第i个背包后，最大的价值，所以直接从当前层的状态转移，表示选择0,1,...,k个的背包之后的价值。 for(int j = v; j &lt;= M; j++)&#123; f[j] = max(f[j],f[j-v]+w); &#125; &#125; printf(&quot;%d&quot;,f[M]); return 0;&#125; 多重背包：有 N 种物品和一个容量是 V 的背包。 第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN = 110;int dp[MAXN],N,M;int main()&#123; scanf(&quot;%d%d&quot;,&amp;N,&amp;M); for(int i = 1; i &lt;= N; i++)&#123; int v,w,s; scanf(&quot;%d%d%d&quot;,&amp;v,&amp;w,&amp;s); for(int j = M; j &gt;= v; j--)&#123; //从1到s个背包都试着选一下。 for(int k = 1; k &lt;= s &amp;&amp; k*v &lt;= j; k++)&#123; dp[j] = max(dp[j],dp[j-k*v]+k*w); &#125; &#125; &#125; printf(&quot;%d&quot;,dp[M]); return 0;&#125; 二进制思想优化： 因为每个背包可选s个，我们试着将其转化为0/1背包问题，把每个背包划分0~s种，去做0/1背包，发现问题的复杂度没有变，我们考虑每个物品都有选和不选两种情况，我们知道每一个数都可以有相应的二进制对应位作为2的幂相乘得到，所以我们将s拆分成二进制数位相乘。这样每一层做0/1背包，之前的结果没有浪费掉，是可以接着相加，并且最后得到s个，做到了从O(n)到O(logn)的优化。 这里有一个问题就是在log(s)时，如果s不是二的整数次幂，会计算到大于s的第一个整数次幂，这样结果就不对了，成了计算到了大于s的第一个整数次幂个数量。我们必须要将加到的数最大只会到s，这里有一个做法：先加到小于s的最大的二的整数次幂x，然后加上 s-x 就可以表示为 0~s这么多种方案了。举例： 12345610 = 0+ 1 + 2 + 4 + 30 ~ 7 = (0,1,2,4)的任意组合8 = 5+3 //(0~7中的5)9 = 6+3 //(0~7中的6)10 = 7+3 //(0~7中的7)并且求和只能取到10 所以该方法成立。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN = 2e6+10;int dp[2020],V[MAXN],W[MAXN];int main()&#123; int t = 0; int n,m; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++)&#123; int v,w,s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; for(int k = 1; k &lt;= s; k *= 2)&#123; V[t] = v*k; W[t++] = w*k; s -= k; &#125; if(s &gt; 0) &#123; V[t] = v*s; W[t++] = w*s; &#125; &#125; for(int i = 0; i &lt; t ; i++)&#123; for(int j = m; j &gt;= V[i]; j--)&#123; dp[j] = max(dp[j],dp[j-V[i]]+W[i]); &#125; &#125; cout &lt;&lt; dp[m]; return 0;&#125; 混合背包有 N 种物品和一个容量是 V 的背包。 物品一共有三类： 第一类物品只能用1次（01背包）；第二类物品可以用无限次（完全背包）；第三类物品最多只能用 si 次（多重背包）；每种体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 输入格式第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。 si=−1 表示第 i 种物品只能用1次； si=0 表示第 i 种物品可以用无限次； si&gt;0 表示第 i 种物品可以使用 si 次； 输出格式输出一个整数，表示最大价值。 思路：其实只是0-1背包（多重背包）和完全背包的组合版每件物品该用完全背包解就用完全背包解，该用01背包解就用01背包解，当然多重背包可以用二进制优化分解成01背包。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;int dp[1010];struct thing&#123; int kind,v,w;&#125;;vector&lt;thing&gt; things;int main()&#123; int n,m; cin &gt;&gt; n &gt;&gt; m; for(int i = 0;i &lt; n; i++)&#123; int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; if(s == -1) things.push_back(&#123;-1,v,w&#125;); else if(s == 0) things.push_back(&#123;0,v,w&#125;); else&#123; for(int k = 1; k &lt;= s; k*=2)&#123; s -= k; things.push_back(&#123;-1,v*k,w*k&#125;); &#125; if(s &gt; 0) things.push_back(&#123;-1,v*s,w*s&#125;); &#125; &#125; for(auto thing : things)&#123; if(thing.kind == -1)&#123; for(int j = m; j &gt;= thing.v; j--)&#123; dp[j] = max(dp[j],dp[j-thing.v]+thing.w); &#125; &#125;else&#123; for(int j = thing.v; j &lt;= m; j++)&#123; dp[j] = max(dp[j],dp[j-thing.v]+thing.w); &#125; &#125; &#125; cout &lt;&lt; dp[m]; return 0;&#125;","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"https://yangzebin001.github.io/tags/DP/"},{"name":"背包问题","slug":"背包问题","permalink":"https://yangzebin001.github.io/tags/背包问题/"}]},{"title":"01背包问题详解","slug":"Pinning a thread —— 如何让线程运行在特定的CPU上","date":"2019-11-25T03:46:00.000Z","updated":"2020-08-27T15:33:11.584Z","comments":true,"path":"2019/11/25/Pinning a thread —— 如何让线程运行在特定的CPU上/","link":"","permalink":"https://yangzebin001.github.io/2019/11/25/Pinning a thread —— 如何让线程运行在特定的CPU上/","excerpt":"在看OSTEP的TLB部分时，作业中有一个问题是：如何让线程运行在特定的CPU上，觉得挺有趣的问题，随后通过STFW找到了答案。 主要用到两个 pthread_setaffinity_np 和 pthread_getaffinity_np api。 通过 RTFM1man pthread_setaffinity_np","text":"在看OSTEP的TLB部分时，作业中有一个问题是：如何让线程运行在特定的CPU上，觉得挺有趣的问题，随后通过STFW找到了答案。 主要用到两个 pthread_setaffinity_np 和 pthread_getaffinity_np api。 通过 RTFM1man pthread_setaffinity_np 有一段示例： 123456789101112131415161718192021222324252627282930313233343536373839404142#define _GNU_SOURCE#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#define handle_error_en(en, msg) \\ do &#123; errno = en; perror(msg); exit(EXIT_FAILURE); &#125; while (0)intmain(int argc, char *argv[])&#123; int s, j; cpu_set_t cpuset; pthread_t thread; thread = pthread_self(); // 获取当前运行的线程数据结构 /* Set affinity mask to include CPUs 0 to 7 */ CPU_ZERO(&amp;cpuset); // 将cpuset结构清零 // 将0-7号CPU全部加入cpuset中（如果只想指定特定的cpu，运行循环中那一行即可） // 例如将线程运行在3号cpu上：CPU_SET(3, &amp;cpuset); for (j = 0; j &lt; 8; j++) CPU_SET(j, &amp;cpuset); // 设置j号cpu到cpuset中。 // set CPU affinity of a thread s = pthread_setaffinity_np(thread, sizeof(cpu_set_t), &amp;cpuset); if (s != 0) handle_error_en(s, \"pthread_setaffinity_np\"); /* Check the actual affinity mask assigned to the thread */ s = pthread_getaffinity_np(thread, sizeof(cpu_set_t), &amp;cpuset); if (s != 0) handle_error_en(s, \"pthread_getaffinity_np\"); printf(\"Set returned by pthread_getaffinity_np() contained:\\n\"); for (j = 0; j &lt; CPU_SETSIZE; j++) if (CPU_ISSET(j, &amp;cpuset)) printf(\" CPU %d\\n\", j); exit(EXIT_SUCCESS);&#125; 如果gcc无法通过编译：undefined reference to pthread_setaffinity_np 在编译时加 -lpthread 参数即可。 stackoverflow: pinning-a-thread-to-a-core-in-a-cpuset-through-c","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://yangzebin001.github.io/tags/Linux/"},{"name":"线程","slug":"线程","permalink":"https://yangzebin001.github.io/tags/线程/"},{"name":"cpu","slug":"cpu","permalink":"https://yangzebin001.github.io/tags/cpu/"}]},{"title":"POJ-3614-Sunscreen","slug":"POJ-3614-Sunscreen","date":"2019-10-26T05:11:00.000Z","updated":"2020-08-27T15:06:24.669Z","comments":true,"path":"2019/10/26/POJ-3614-Sunscreen/","link":"","permalink":"https://yangzebin001.github.io/2019/10/26/POJ-3614-Sunscreen/","excerpt":"","text":"POJ-3614-Sunscreen 题目描述：To avoid unsightly burns while tanning, each of the C (1 ≤ C ≤ 2500) cows must cover her hide with sunscreen when they’re at the beach. Cow i has a minimum and maximum SPF rating (1 ≤ minSPFi ≤ 1,000; minSPFi ≤ maxSPFi ≤ 1,000) that will work. If the SPF rating is too low, the cow suffers sunburn; if the SPF rating is too high, the cow doesn’t tan at all…….. The cows have a picnic basket with L (1 ≤ L ≤ 2500) bottles of sunscreen lotion, each bottle i with an SPF rating SPFi (1 ≤ SPFi ≤ 1,000). Lotion bottle i can cover coveri cows with lotion. A cow may lotion from only one bottle. What is the maximum number of cows that can protect themselves while tanning given the available lotions? 输入： Line 1: Two space-separated integers: C and L Lines 2..C+1: Line i describes cow i’s lotion requires with two integers: minSPFi and maxSPFi Lines C+2..C+L+1: Line i+C+1 describes a sunscreen lotion bottle i with space-separated integers: SPFi and coveri 输出：A single line with an integer that is the maximum number of cows that can be protected while tanning 输入示例：1234563 23 102 51 56 24 1 输出示例：12 题目大意：有C头牛，每个牛Ci在一个给定的区间上需要涂防晒霜，有L种防晒霜，给出每个防晒霜适合的数值SPF[i]和个数cover[i]，求能最多满足牛的个数。 贪心策略：按区间的开始位置递减排序，依次考虑每头牛。对于每头牛，选取满足在此区间内最大的防晒霜。 Solution1（暴力版）：123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;utility&gt;#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int MAXN = 5000+10;int C,L;PII p[MAXN];PII q[MAXN];int main()&#123; int ans = 0; scanf(&quot;%d%d&quot;,&amp;C,&amp;L); for(int i = 0; i &lt; C; i++)&#123; scanf(&quot;%d%d&quot;,&amp;p[i].first,&amp;p[i].second); &#125; sort(p,p+C); for(int i = 0; i &lt; L; i++)&#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); q[i].first = a; q[i].second = b; &#125; sort(q,q+L); //从开始位置大到小考察每头牛。 for(int i = C-1; i &gt;= 0; i--)&#123; //同样，对于每头牛，考察在该牛区间内最右的防晒霜。 for(int j = L-1; j &gt;= 0; j--)&#123; if(q[j].second &gt; 0 &amp;&amp; q[j].first &gt;= p[i].first &amp;&amp; q[j].first &lt;= p[i].second)&#123; ans++; q[j].second--; break; &#125; &#125; &#125; printf(&quot;%d&quot;,ans); return 0;&#125; Solution2（平衡树版）：12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN = 2510;typedef pair&lt;int,int&gt; PII;int N,M;PII cows[MAXN];int main()&#123; cin &gt;&gt; N &gt;&gt;M; for(int i = 0; i &lt; N; i++)&#123; cin &gt;&gt; cows[i].first &gt;&gt; cows[i].second; &#125; sort(cows,cows+N); map&lt;int,int&gt; spfa; for(int i = 0; i &lt; M; i++)&#123; int spa,cover; cin &gt;&gt; spa &gt;&gt; cover; spfa[spa] += cover; &#125; spfa[0] = spfa[1001] = N; int ans = 0; for(int i = N-1; i &gt;= 0; i--)&#123; map&lt;int,int&gt;::iterator it = spfa.upper_bound(cows[i].second); --it; if(cows[i].first &lt;= it-&gt;first &amp;&amp; cows[i].second &gt;= it-&gt;first)&#123; ans++; if(-- it-&gt;second == 0) spfa.erase(it); &#125; &#125; cout &lt;&lt; ans; return 0;&#125;","categories":[],"tags":[]},{"title":"AcWin-135-最大子序和","slug":"AcWin-135-最大子序和","date":"2019-10-26T04:51:00.000Z","updated":"2020-08-27T15:06:24.668Z","comments":true,"path":"2019/10/26/AcWin-135-最大子序和/","link":"","permalink":"https://yangzebin001.github.io/2019/10/26/AcWin-135-最大子序和/","excerpt":"","text":"AcWing 135. 最大子序和 题目描述输入一个长度为n的整数序列，从中找出一段长度不超过m的连续子序列，使得子序列中所有数的和最大。 输入格式第一行输入两个整数n,m。 第二行输入n个数，代表长度为n的整数序列。 同一行数之间用空格隔开。 输出格式输出一个整数，代表该序列的最大子序和。 数据范围1≤n,m≤300000 样例12345输入样例：6 41 -3 5 1 -2 3输出样例：7 思路：求一个区间长度为M的序列和可以用前缀和相减的形式来得到： 1k = sum[i]- sum[i-M] 而要求当前区间P内的最大值，可以找到该区间（sum[i-1]–sum[i-m]）内的最小值，用sum[i]减去该值，得到以sum[i]为终点的区间的最大值，对于每个区间，都求得一个最大值，再到这些之内取最大即为答案。 所以现在的问题变为：给定一个区间，如何找出给区间内的最小值。 如果暴力求，会使总的复杂度为O(N2)，不符合要求。再看一下要解决的问题，我们想到使用单调队列，可以在线求出一组序列的最值，所以我们使用一个大小为M的队列来维护最值。 这样总的复杂度就为线性的了。 C++ 代码1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;deque&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN = 1e6+10;long long a[MAXN],sum[MAXN],ans = -1e10;int main()&#123; deque&lt;int&gt; q; int N,M; cin &gt;&gt; N &gt;&gt; M; for(int i = 0; i &lt; N; i++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= N; i++) sum[i] = sum[i-1] + a[i-1]; //前缀和 for(int i = 1; i &lt;= N; i++)&#123; while(q.size() &amp;&amp; q.front() &lt; i - M) q.pop_front(); //超出窗口范围，清除 ans = max(ans, sum[i]-sum[q.front()]); //更新值 while(q.size() &amp;&amp; sum[q.back()] &gt; sum[i]) q.pop_back(); //维护单调性质 q.push_back(i); &#125; cout &lt;&lt; ans; return 0;&#125;","categories":[],"tags":[]},{"title":"POJ-Telephon-Lines(二分+最短路)","slug":"POJ-Telephon-Lines(二分+最短路)","date":"2019-10-09T11:59:00.000Z","updated":"2020-08-27T15:06:24.666Z","comments":true,"path":"2019/10/09/POJ-Telephon-Lines(二分+最短路)/","link":"","permalink":"https://yangzebin001.github.io/2019/10/09/POJ-Telephon-Lines(二分+最短路)/","excerpt":"","text":"POJ-Telephone Lines 题目描述：Farmer John wants to set up a telephone line at his farm. Unfortunately, the phone company is uncooperative, so he needs to pay for some of the cables required to connect his farm to the phone system. There are N (1 ≤ N ≤ 1,000) forlorn telephone poles conveniently numbered 1..N that are scattered around Farmer John’s property; no cables connect any them. A total of P (1 ≤ P ≤ 10,000) pairs of poles can be connected by a cable; the rest are too far apart. The i-th cable can connect the two distinct poles Ai and Bi, with length Li (1 ≤ Li ≤ 1,000,000) units if used. The input data set never names any {Ai, Bi} pair more than once. Pole 1 is already connected to the phone system, and pole N is at the farm. Poles 1 and N need to be connected by a path of cables; the rest of the poles might be used or might not be used. As it turns out, the phone company is willing to provide Farmer John with K (0 ≤ K &lt; N) lengths of cable for free. Beyond that he will have to pay a price equal to the length of the longest remaining cable he requires (each pair of poles is connected with a separate cable), or 0 if he does not need any additional cables. Determine the minimum amount that Farmer John must pay. 输入： Line 1: Three space-separated integers: N, P, and K Lines 2..P+1: Line i+1 contains the three space-separated integers: Ai, Bi, and Li 输出： Line 1: A single integer, the minimum amount Farmer John can pay. If it is impossible to connect the farm to the phone company, print -1. 输入示例：123456785 7 11 2 53 1 42 4 83 2 35 2 93 4 74 5 6 输出示例：14 题目大意：一电话公司要链接编号1和N的电话，中间可能需要架设多条电话线，线缆厂商可以免费给电话公司铺设k条电缆，超过k条之后，要按其余的线缆中最长的进行相应收费费用与长度相同，求电话公司需要付的最小费用。 思路：其实就是求无向图中，从1到N中，使最多可以“宽恕”k条最长边之后最长的边的长度尽可能小的路径。 单独求这样一个问题好像很复杂，我们稍加分析发现，答案一定在给定的边长、零或者不存在这样的路径这三种情况中，我们先假定一个答案，用这个答案去试探从1-N的路径有没有符合条件的。 具体的判断就是求一条大于答案的边长数最小的一条路径。可以使用最短路来求，松弛条件根据到当前边的超过答案的数量中选择更小的一条边。我们最后判断到达N后其数量是否超过k，就能判断这是否是一条符合条件的边。 然后将存放所有可能是答案的数组排序后进行二分。 这里求“最短路”用了两个最短路模板： Solution1（Dijkstra）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* * @Date: 2019-10-07 18:55:30 * @LastEditors: BeckoninGshy * @LastEditTime: 2019-10-08 22:59:49 */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;const int MAXN = 10000+10;const int INF = 0x3f3f3f3f;int n,p,k;struct node&#123; int b,ca; node(int _b,int _ca):b(_b),ca(_ca)&#123;&#125; node()&#123;&#125; bool operator&lt;(const node &amp;q)const&#123; return ca &gt; q.ca; &#125;&#125;;vector&lt;node&gt; V[MAXN];int dis[MAXN]; //dis存超过目标值x的电话线条数。int vis[MAXN];int cost[MAXN];int Dijkstra(int x)&#123; memset(dis,INF,sizeof(dis)); memset(vis,0,sizeof(vis)); dis[1] = 0; priority_queue&lt;node&gt; q; q.push(node(1,dis[1])); node temp; while(!q.empty())&#123; temp = q.top(); q.pop(); int u = temp.b; if(vis[u])continue; vis[u] = 1; for(int i = 0; i &lt; V[u].size(); i++)&#123; int v = V[u][i].b; int c = V[u][i].ca; c = c &gt; x ? 1 : 0; //更新到当前结点的超过x的条数 if(!vis[v] &amp;&amp; dis[v] &gt; dis[u] + c)&#123; dis[v] = dis[u] + c; q.push(node(v,dis[v])); &#125; &#125; &#125; //是 return dis[n]&lt;= k;&#125;int main()&#123; freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;p,&amp;k); for(int i = 0; i &lt; p; i++)&#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); V[a].push_back(node(b,c)); V[b].push_back(node(a,c)); cost[i+1] = c; &#125; //按长度进行二分，根据超过该长度的个数是否超过k来确定边界。 sort(cost+1,cost+1+p); if(!Dijkstra(cost[p]))&#123; printf(&quot;-1\\\\n&quot;); return 0; &#125; //答案有可能是0，所以从0开始。 int l = 0, r = p-1; while(l &lt; r)&#123; int mid = l+r&gt;&gt;1; if(Dijkstra(cost[mid])) r = mid; else l = mid+1; &#125; printf(&quot;%d&quot;,cost[l]); return 0;&#125; Solution2（SPFA）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* * @Date: 2019-10-07 18:55:30 * @LastEditors: BeckoninGshy * @LastEditTime: 2019-10-09 19:32:17 */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;const int MAXN = 10000+10;const int INF = 0x3f3f3f3f;int n,p,k;struct node&#123; int b,ca; node(int _b,int _ca):b(_b),ca(_ca)&#123;&#125; node()&#123;&#125; bool operator&lt;(const node &amp;q)const&#123; return ca &gt; q.ca; &#125;&#125;;vector&lt;node&gt; V[MAXN];int dis[MAXN]; //dis存超过目标值x的电话线条数。int vis[MAXN];int inq[MAXN];int cost[MAXN];int SPFA(int x)&#123; memset(dis,INF,sizeof(dis)); memset(vis,0,sizeof(vis)); memset(inq,0,sizeof(inq)); dis[1] = 0; queue&lt;int&gt; q; q.push(1); node temp; inq[1] = 1; while(!q.empty())&#123; int u = q.front(); q.pop(); inq[u] = false; for(int i = 0; i &lt; V[u].size(); i++)&#123; int v = V[u][i].b; int c = V[u][i].ca; c = c &gt; x ? 1 : 0; //更新到当前结点的超过x的条数 if(dis[v] &gt; dis[u] + c)&#123; dis[v] = dis[u] + c; if(!inq[v])&#123; q.push(v); inq[v] = 1; &#125; &#125; &#125; &#125; //是 return dis[n]&lt;= k;&#125;int main()&#123; freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;p,&amp;k); for(int i = 0; i &lt; p; i++)&#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); V[a].push_back(node(b,c)); V[b].push_back(node(a,c)); cost[i+1] = c; &#125; //按长度进行二分，根据超过该长度的个数是否超过k来确定边界。 sort(cost+1,cost+1+p); if(!SPFA(cost[p]))&#123; printf(&quot;-1\\\\n&quot;); return 0; &#125; //答案有可能是0，所以从0开始。 int l = 0, r = p-1; while(l &lt; r)&#123; int mid = l+r&gt;&gt;1; if(SPFA(cost[mid])) r = mid; else l = mid+1; &#125; printf(&quot;%d&quot;,cost[l]); return 0;&#125;","categories":[],"tags":[]},{"title":"POJ-2010-Mo-Universit--Financia-Aid（优先队列或二分）","slug":"POJ-2010-Mo-Universit--Financia-Aid（优先队列或二分）","date":"2019-10-07T09:47:00.000Z","updated":"2020-08-27T15:06:24.665Z","comments":true,"path":"2019/10/07/POJ-2010-Mo-Universit--Financia-Aid（优先队列或二分）/","link":"","permalink":"https://yangzebin001.github.io/2019/10/07/POJ-2010-Mo-Universit--Financia-Aid（优先队列或二分）/","excerpt":"","text":"POJ-2010-Moo University - Financial Aid 题目描述：Bessie noted that although humans have many universities they can attend, cows have none. To remedy this problem, she and her fellow cows formed a new university called The University of Wisconsin-Farmside,”Moo U” for short. Not wishing to admit dumber-than-average cows, the founders created an incredibly precise admission exam called the Cow Scholastic Aptitude Test (CSAT) that yields scores in the range 1..2,000,000,000. Moo U is very expensive to attend; not all calves can afford it.In fact, most calves need some sort of financial aid (0 &lt;= aid &lt;=100,000). The government does not provide scholarships to calves,so all the money must come from the university’s limited fund (whose total money is F, 0 &lt;= F &lt;= 2,000,000,000). Worse still, Moo U only has classrooms for an odd number N (1 &lt;= N &lt;= 19,999) of the C (N &lt;= C &lt;= 100,000) calves who have applied.Bessie wants to admit exactly N calves in order to maximize educational opportunity. She still wants the median CSAT score of the admitted calves to be as high as possible. Recall that the median of a set of integers whose size is odd is the middle value when they are sorted. For example, the median of the set {3, 8, 9, 7, 5} is 7, as there are exactly two values above 7 and exactly two values below it. Given the score and required financial aid for each calf that applies, the total number of calves to accept, and the total amount of money Bessie has for financial aid, determine the maximum median score Bessie can obtain by carefully admitting an optimal set of calves. 输入： Line 1: Three space-separated integers N, C, and F Lines 2..C+1: Two space-separated integers per line. The first is the calf’s CSAT score; the second integer is the required amount of financial aid the calf needs 输出： Line 1: A single integer, the maximum median score that Bessie can achieve. If there is insufficient money to admit N calves,output -1. 输入示例：1234563 5 7030 2550 2120 205 1835 30 输出示例：135 提示：Sample output:If Bessie accepts the calves with CSAT scores of 5, 35, and 50, the median is 35. The total financial aid required is 18 + 30 + 21 = 69 &lt;= 70. 题目大意：奶牛大学招收N名学生（奇数），有C名候选学生，该大学可以承受最多F的贷款，求能招收的学生中，中位数尽可能的大，如果没有满足条件的学生，输出-1。 思路1（优先队列）：以学生成绩排序，然后以每个学生为中位数，寻找比他成绩低的学生中尽可能贷款少的N/2个学生，和比他成绩高的学生中尽可能贷款少的N/2个学生。结果就是满足: 1aid：cur_i+lower_i+upper_i &lt;= F 中最大的那个。 难度就是如何保持尽可能少的贷款。 这里选择维持一个长度始终为N/2长度的优先队列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* * @Date: 2019-10-06 17:36:17 * @LastEditors: BeckoninGshy * @LastEditTime: 2019-10-07 16:04:57 */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;utility&gt;using namespace std;const int MAXN = 1e5+10;const int INF = 0x3f3f3f3f;typedef pair&lt;int,int&gt; PII;PII arr[MAXN];int M,N,S;int lowa[MAXN],upa[MAXN];int main()&#123; freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d%d&quot;,&amp;M,&amp;N,&amp;S); for(int i = 0; i &lt; N; i++)&#123; scanf(&quot;%d%d&quot;,&amp;arr[i].first,&amp;arr[i].second); &#125; int half = M/2; sort(arr,arr+N); memset(lowa,INF,sizeof(lowa)); memset(upa,INF,sizeof(upa)); priority_queue&lt;int&gt; q; //确定以每个人为中位数， 比自己分数低的人的最小aid总和 int total = 0; for(int i = 0; i &lt; N; i++)&#123; if(q.size() == half) lowa[i] = total; total += arr[i].second; q.push(arr[i].second); if(q.size() &gt; half)&#123; total -= q.top(); q.pop(); &#125; &#125; while(q.size()) q.pop(); total = 0; //确定以每个人为中位数， 比自己分数高的人的最小aid总和 for(int i = N-1; i &gt;= 0; i--)&#123; if(q.size() == half) upa[i] = total; q.push(arr[i].second); total += arr[i].second; if(q.size() &gt; half)&#123; total -= q.top(); q.pop(); &#125; &#125; int ans = -1; //从后往前寻找第一个满足条件的 for(int i = N-1; i &gt;= 0; i--)&#123; if(arr[i].second + lowa[i] + upa[i] &lt;= S) &#123;ans = arr[i].first;break;&#125; &#125; printf(&quot;%d\\\\n&quot;,ans); return 0;&#125; 思路2（二分）：先对成绩排序，按成绩进行二分，对是否满足是中位数和sum &lt;= F两个性质进行判断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* * @Date: 2019-10-06 17:36:17 * @LastEditors: BeckoninGshy * @LastEditTime: 2019-10-07 17:18:16 */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;utility&gt;using namespace std;const int MAXN = 1e5+10;const int INF = 0x3f3f3f3f;typedef pair&lt;int,int&gt; PII;struct cow&#123; int csat,aid; bool operator &lt;(const cow &amp;q)const&#123; if(csat == q.csat) return aid &lt; q.aid; return csat &lt; q.csat; &#125;&#125;cows[MAXN];struct n&#123; int index,aid; bool operator &lt;(const n &amp;q)const&#123; return aid &lt; q.aid; &#125;&#125;node[MAXN];int M,N,S,half,ans = -1;int aid[MAXN];int check(int x)&#123; int l = 0, r = 0, sum = cows[x].aid; for(int i = 0; i &lt; N; i++)&#123; //在原位置的左边，且符合规定 if(l &lt; half &amp;&amp; node[i].index &lt; x &amp;&amp; sum + node[i].aid &lt;= S)&#123; l++; sum += node[i].aid; //在原位置的右边，且符合规定 &#125;else if(r &lt; half &amp;&amp; node[i].index &gt; x &amp;&amp; sum + node[i].aid &lt;= S)&#123; r++; sum += node[i].aid; &#125; &#125; //都到不了half，说明无法满足小于等于S。 if(l &lt; half &amp;&amp; r &lt; half) return -1; if(l &lt; half) return 1; else if(r &lt; half) return 0; //l = r = half 找到了一个符合条件的，更新答案，继续寻找后面。 ans = cows[x].csat; return 1; &#125;int main()&#123; freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d%d&quot;,&amp;M,&amp;N,&amp;S); for(int i = 0; i &lt; N; i++)&#123; scanf(&quot;%d%d&quot;,&amp;cows[i].csat,&amp;cows[i].aid); &#125; half = M/2; sort(cows,cows+N);//先按分数排序 for(int i = 0; i &lt; N; i++)&#123; node[i].index = i; //记录位置关系 node[i].aid = cows[i].aid; &#125; sort(node,node+N); //排序是为了寻找尽可能小的aid int l = 0, r = N-1; while(l &lt; r)&#123; int mid = l+r+1&gt;&gt;1; //试探中位数。 int f = check(mid); if(f == 1) l = mid; else if(f == 0) r = mid-1; else break; &#125; printf(&quot;%d\\\\n&quot;,ans); return 0;&#125;","categories":[],"tags":[]},{"title":"POJ-3579-Median(二分套二分)","slug":"POJ-3579-Median(二分套二分)","date":"2019-10-05T07:19:00.000Z","updated":"2020-08-27T15:06:24.663Z","comments":true,"path":"2019/10/05/POJ-3579-Median(二分套二分)/","link":"","permalink":"https://yangzebin001.github.io/2019/10/05/POJ-3579-Median(二分套二分)/","excerpt":"","text":"POJ-3579-Median 题目描述：Given N numbers, X1, X2, … , XN, let us calculate the difference of every pair of numbers: ∣Xi - Xj∣ (1 ≤ i ＜ j ≤ N). We can get C(N,2) differences through this work, and now your task is to find the median of the differences as quickly as you can! Note in this problem, the median is defined as the (m/2)-th smallest number if m,the amount of the differences, is even. For example, you have to find the third smallest one in the case of m = 6. 输入：The input consists of several test cases.In each test case, N will be given in the first line. Then N numbers are given, representing X1, X2, … , XN, ( Xi ≤ 1,000,000,000 3 ≤ N ≤ 1,00,000 ) 输出：For each test case, output the median in a separate line. 输入示例：123441 3 2 431 10 2 输出示例：1218 题目大意：给定N个数，求每两个数的差的绝对值一共C(N,2)个，排序后的中位数。 思路：首先对于差的绝对值，我们只需要预先对数组进行排序，作后面对前面的差就不会出现负数。 我们考虑二分来解决该问题。答案是排序后的中位数，具有单调性，所以可以使用二分。我们先找到一个目标值，用这个目标值去判断是否为要求的中位数。 如何判断该数是否满足条件呢？如果枚举全部这C(N,2)个数需要O(N2)的复杂度，超出了题目的要求，所以要寻找新的方案。我们已经将原数组排好序了，以每一项开始到数组最后，我们二分的寻找这里的所有的关系（i与i+1,i+2,…,N-1）中，满足： 1arr[j] - arr[i] &lt;= x 的一共有几项。 统计出项数与中位数作比较，就可以判断目标值是否满足条件。 Solution：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* * @Date: 2019-10-05 13:59:05 * @LastEditors: BeckoninGshy * @LastEditTime: 2019-10-05 14:48:00 */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int MAXN = 1e5+10;int N;int arr[MAXN];bool check(int x)&#123; int cnt = 0; int M = N*(N-1)/2; M = (M+1)/2; for(int i = 0; i &lt; N; i++)&#123; int l = i, r = N-1; while(l &lt; r)&#123; int mid = l + r + 1 &gt;&gt; 1; if(arr[mid] - arr[i] &lt;= x) l = mid; else r = mid-1; &#125; cnt += l-i; // arr[mid] - arr[i] &lt;= x -----&gt; arr[mid] &lt;= arr[i]+x // 所以找arr[i]+x 的 upper_bound。 // (upper_bound(arr,arr+N,arr[i]+x)-arr)-1 长度 // (upper_bound(arr,arr+N,arr[i]+x)-arr)-i-1 //减去偏移量 // cnt += (upper_bound(arr,arr+N,arr[i]+x)-arr)-i-1; &#125; return cnt &gt;= M;&#125;int main()&#123; freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); while(scanf(&quot;%d&quot;,&amp;N)!=EOF &amp;&amp; N)&#123; for(int i = 0; i &lt; N; i++)&#123; scanf(&quot;%d&quot;,&amp;arr[i]); &#125; sort(arr,arr+N); int l = 0, r = arr[N-1]; //对结果进行二分 while(l &lt; r)&#123; int mid = l+r&gt;&gt;1; // 检查该结果是否大于等于总数的一半， if(check(mid)) r = mid; else l = mid+1; &#125; printf(&quot;%d\\\\n&quot;,l); &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"POJ-2976-Droppin-tests","slug":"POJ-2976-Droppin-tests","date":"2019-09-29T10:27:00.000Z","updated":"2020-08-27T15:06:24.662Z","comments":true,"path":"2019/09/29/POJ-2976-Droppin-tests/","link":"","permalink":"https://yangzebin001.github.io/2019/09/29/POJ-2976-Droppin-tests/","excerpt":"","text":"POJ-2976-Dropping tests 题目描述：In a certain course, you take n tests. If you get ai out of bi questions correct on test i, your cumulative average is defined to be Given your test scores and a positive integer k, determine how high you can make your cumulative average if you are allowed to drop any k of your test scores. Suppose you take 3 tests with scores of 5/5, 0/1, and 2/6. Without dropping any tests, your cumulative average is However, if you drop the third test, your cumulative average becomes 输入：The input test file will contain multiple test cases, each containing exactly three lines. The first line contains two integers, 1 ≤ n ≤ 1000 and 0 ≤ k &lt; n. The second line contains n integers indicating ai for all i. The third line contains n positive integers indicating bi for all i. It is guaranteed that 0 ≤ ai ≤ bi ≤ 1, 000, 000, 000. The end-of-file is marked by a test case with n = k = 0 and should not be processed. 输出：For each test case, write a single line with the highest cumulative average possible after dropping k of the given test scores. The average should be rounded to the nearest integer. 输入示例：12345673 15 0 25 1 64 21 2 7 95 6 7 90 0 输出示例：1283100 提示：To avoid ambiguities due to rounding errors, the judge tests have been constructed so that all answers are at least 0.001 away from a decision boundary (i.e., you can assume that the average is never 83.4997). 题目大意：有N个考试，每个考试有ai和bi两个值，最后成绩由上面的公式求得。幸运的是，可以放弃K个科目，求最大化最后的成绩。(输出乘100后四舍五入的结果) 思路：由题意可知当，当n-k个科目组成最优解时，再增加别的科目，解一定不如原来的解，放弃掉k个科目是最好的方案。 于是，题目就变成了最小化平均值的问题，另外在注意下取整时的四舍五入就好了。 最小化平均值:有n个物品的重量和价值分别为wi和vi，从中选择k个物品使得单位重量的价值最大。 对于这个问题，我们可以用二分搜索解决，先来看看判断条件：设最大值为x，则需要满足 ∑vi / ∑wi &gt;=x，把不等式进行变形，就得到了 ∑ ( vi - x wi )&gt;=0，于是判断就成了，对 vi-xwi 的值进行排序之后贪心进行选择，判断前n-k个的和是否不小于0。判断的复杂度是O（nlogn）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * @Date: 2019-09-28 16:40:15 * @LastEditors: BeckoninGshy * @LastEditTime: 2019-09-29 18:14:27 */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN = 1000+10;int n,k;struct node&#123; int a,b;&#125;num[MAXN];double f[MAXN];bool check(double x)&#123; for(int i = 0; i &lt; n; i++) f[i] = num[i].a - x*num[i].b; sort(f,f+n); double sum = 0; for(int i = 0; i &lt;n-k; i++) sum += f[n-1-i]; return sum &gt;= 0;&#125;int main()&#123; freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); while(scanf(&quot;%d%d&quot;,&amp;n,&amp;k)!= EOF &amp;&amp; n+k)&#123; for(int i = 0; i &lt; n; i++)&#123; scanf(&quot;%d&quot;,&amp;num[i].a); &#125; for(int i = 0; i &lt; n; i++)&#123; scanf(&quot;%d&quot;,&amp;num[i].b); &#125; double l = 0, r = 1e9; for(int i = 0; i &lt; 100; i++)&#123; double mid = (l+r)/2; if(check(mid)) l = mid; else r = mid; &#125; printf(&quot;%d\\\\n&quot;, int(l*100+0.5)); // int ans = 100 * (l+0.005); // printf(&quot;%d\\\\n&quot;, ans); &#125;&#125;","categories":[],"tags":[]},{"title":"POJ-3045-Co-Acrobats","slug":"POJ-3045-Co-Acrobats","date":"2019-09-28T03:46:00.000Z","updated":"2020-08-27T15:06:24.660Z","comments":true,"path":"2019/09/28/POJ-3045-Co-Acrobats/","link":"","permalink":"https://yangzebin001.github.io/2019/09/28/POJ-3045-Co-Acrobats/","excerpt":"","text":"Cow Acrobats 题目描述：Farmer John’s N (1 &lt;= N &lt;= 50,000) cows (numbered 1..N) are planning to run away and join the circus. Their hoofed feet prevent them from tightrope walking and swinging from the trapeze (and their last attempt at firing a cow out of a cannon met with a dismal failure). Thus, they have decided to practice performing acrobatic stunts. The cows aren’t terribly creative and have only come up with one acrobatic stunt: standing on top of each other to form a vertical stack of some height. The cows are trying to figure out the order in which they should arrange themselves ithin this stack. Each of the N cows has an associated weight (1 &lt;= W_i &lt;= 10,000) and strength (1 &lt;= S_i &lt;= 1,000,000,000). The risk of a cow collapsing is equal to the combined weight of all cows on top of her (not including her own weight, of course) minus her strength (so that a stronger cow has a lower risk). Your task is to determine an ordering of the cows that minimizes the greatest risk of collapse for any of the cows. 输入： Line 1: A single line with the integer N. Lines 2..N+1: Line i+1 describes cow i with two space-separated integers, W_i and S_i. 输出： Line 1: A single integer, giving the largest risk of all the cows in any optimal ordering that minimizes the risk. 输入示例：1234310 32 53 3 输出示例：12 提示：OUTPUT DETAILS: Put the cow with weight 10 on the bottom. She will carry the other two cows, so the risk of her collapsing is 2+3-3=2. The other cows have lower risk of collapsing. 题目大意：有N头牛，每个牛有一定的重量w和力量s，将这N头牛叠罗汉，每头牛有一个风险值，为它背上所有牛的重量减去他的力量。求最大风险值，并要求最大风险值尽可能小。 思路：该题就是要找到一个最优排列，让最大风险值尽可能小，显然的，重的牛应该尽可能的安排在下方，同样，力气大的牛也应该尽可能安排在下方。 结论:将力量与重量之和从小到大排列。证明一：对于每头牛而言，将它与它上面的牛作为一个整体，总的重量为sum_w，则该牛的风险值为: 1(sum_w-w-s)=(sum_w-(w+s)) 我们要想取到最优解，就要sum_w-(w+s)的值最小，w+s就应该最大，所以w+s越大越应该在下面。 证明二：假设当前的排列是最优的。任意位置上有第一头牛和第二头牛，第一头牛在第二头牛的上面，第一头牛上面的重量总和为sum，第一头牛和第二头牛的重量和力量分别为w1、s1、w2、s2，可以知道两头牛的危险值分别为 a = sum-s1, b = sum+w1-s2。现在调换两头牛的位置，则a1 = sum+w1-s1, b1 = sum-s2。因为之前是最优解，可得： 12sum+w2-s1 &gt;= sum+w1-s2w2-s1 &gt;= w1-s2 移项可得： 1w2+s2 &gt;= w1+s1 所以重量与力量和越大越在下方。 Solution：12345678910111213141516171819202122232425262728293031323334353637383940/* * @Date: 2019-09-27 23:11:05 * @LastEditors: BeckoninGshy * @LastEditTime: 2019-09-28 11:43:09 */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN = 5e4+10;int N;struct node&#123; int w,s;&#125;a[MAXN];bool cmp(node a, node b)&#123; return a.s+a.w &gt; b.s+b.w;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;N); long long sum = 0; for(int i = 0; i &lt; N; i++)&#123; scanf(&quot;%d%d&quot;,&amp;a[i].w,&amp;a[i].s); sum += a[i].w; &#125; sort(a,a+N,cmp); long long ans = -0x3f3f3f; for(int i = 0; i &lt; N; i++)&#123; sum -= a[i].w; ans = max(ans,sum-a[i].s); &#125; printf(&quot;%lld\\\\n&quot;,ans); return 0;&#125;","categories":[],"tags":[]},{"title":"POJ-3276-Fac-Th-Righ-Way","slug":"POJ-3276-Fac-Th-Righ-Way","date":"2019-09-17T11:59:00.000Z","updated":"2020-08-27T15:06:24.659Z","comments":true,"path":"2019/09/17/POJ-3276-Fac-Th-Righ-Way/","link":"","permalink":"https://yangzebin001.github.io/2019/09/17/POJ-3276-Fac-Th-Righ-Way/","excerpt":"","text":"POJ-3276-Face The Right Way 题目描述：Farmer John has arranged his N (1 ≤ N ≤ 5,000) cows in a row and many of them are facing forward, like good cows. Some of them are facing backward, though, and he needs them all to face forward to make his life perfect. Fortunately, FJ recently bought an automatic cow turning machine. Since he purchased the discount model, it must be irrevocably preset to turn K (1 ≤ K ≤ N) cows at once, and it can only turn cows that are all standing next to each other in line. Each time the machine is used, it reverses the facing direction of a contiguous group of K cows in the line (one cannot use it on fewer than K cows, e.g., at the either end of the line of cows). Each cow remains in the same location as before, but ends up facing the opposite direction. A cow that starts out facing forward will be turned backward by the machine and vice-versa. Because FJ must pick a single, never-changing value of K, please help him determine the minimum value of K that minimizes the number of operations required by the machine to make all the cows face forward. Also determine M, the minimum number of machine operations required to get all the cows facing forward using that value of K. 输入：Line 1: A single integer: NLines 2..N+1: Line i+1 contains a single character, F or B, indicating whether cow i is facing forward or backward. 输出：Line 1: Two space-separated integers: K and M 输入示例：123456787BBFBFBB 输出示例：13 3 暗示：For K = 3, the machine must be operated three times: turn cows (1,2,3), (3,4,5), and finally (5,6,7) 题目大意：有N头牛，牛要么朝前要么朝后，一次操作只可以翻转区间内的所有牛，问最小的翻转次数和相应最小的翻转区间。 思路：首先，这是一个开关问题，一般性的开关问题具有两个性质： 切换状态的顺序对结果不影响。 一个开关按偶数次等于不按。 解决这个问题光有这两性质还不够，我们先求如果知道了区间长度K，如何求最小翻转次数M。 我们先选择考虑最左端的牛，如果该牛朝向前，则不需要翻转，所以范围可以缩减1，如果该牛朝向后，则必须翻转该区间了。我们贪心的翻转遇到的第一个朝向后的牛，就可以求出来最少的翻转次数了。 这样我们枚举K,并且每个K都需要检查N-K+1个区间，每个区间的检查又需要O(N)的时间，所以总的时间为O(N^3)。达不到题目要求的时限。 优化：我们的目标是将所有的朝向后面的牛翻转，所以牛朝向决定了该区间是否发生翻转。我们将关注点移动到每个具体的牛与之前已经翻转的次数的关系上。 对于每个牛，与所在区间的已翻转次数有下列四种情况： 当前牛朝向前，已经翻转了偶数次。 当前牛朝向后，已经翻转了奇数次。 当前牛朝向前，已经翻转了奇数次。 房钱牛朝向后，已经翻转了偶数次。 我们结合前面开关问题的第二条性质发现：前两种情况不需要进行任何操作。后两种情况则需要进行一次翻转。所以结论就是： 如果朝向前为0，朝向后为1，则 当前牛的朝向 + 之前已经翻转的次数 = 奇数的时候则说明该翻转了。 这样，可以在常数时间内知道每个区间的翻转次数。优化到了O(N^2)，能在时限内解决了。 Solution：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* * @Date: 2019-09-17 17:05:23 * @LastEditors: BeckoninGshy * @LastEditTime: 2019-09-17 18:13:33 */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int N,K,M;const int MAXN = 1e5+10;int dir[MAXN];int f[MAXN];int cal(int k)&#123; // 表示区间[i, i+k-1] 是否翻转 memset(f,0,sizeof(f)); int sum = 0;//区间内翻转的次数 int res = 0; for(int i = 0; i + k-1 &lt; N; i++)&#123; //当牛的朝向与之前已翻转的次数。 if((dir[i] + sum) % 2 != 0)&#123; res++; f[i] = 1; &#125; //更新翻转次数 sum += f[i]; //固定区间 if(i - k + 1 &gt;= 0)&#123; sum -= f[i-k+1]; &#125; &#125; //由于前n-k+1个 已经翻转到正面了，只有当后面的牛都不用翻转才合法。 for(int i = N-k+1; i &lt; N; i++)&#123; if((dir[i] + sum) % 2 != 0) return -1; //固定区间 if(i - k + 1 &gt;= 0) sum -= f[i-k+1]; &#125; return res;&#125;int main()&#123; freopen(\"in.txt\",\"r\",stdin); scanf(\"%d\",&amp;N); K = 1, M = N; char c[3]; for(int i = 0; i &lt; N; i++)&#123; scanf(\"%s\",c); if(c[0] == 'B') dir[i] = 1; &#125; //枚举K for(int k = 1; k &lt;= N; k++)&#123; int m = cal(k); if(m &gt;= 0 &amp;&amp; m &lt; M)&#123; M = m; K = k; &#125; &#125; printf(\"%d %d\",K,M);&#125;","categories":[],"tags":[]},{"title":"LeetCode-42-接雨水","slug":"LeetCode-42-接雨水","date":"2019-09-07T07:46:00.000Z","updated":"2020-08-27T15:06:24.658Z","comments":true,"path":"2019/09/07/LeetCode-42-接雨水/","link":"","permalink":"https://yangzebin001.github.io/2019/09/07/LeetCode-42-接雨水/","excerpt":"","text":"42. 接雨水 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例:123输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 Solution1（直观解法）:我们可以稍稍使用减法，接水的区域正好是最好的柱子乘以整个宽度，再减去从左到制高点和从右到制高点每个单调上升的柱子到两边的距离乘以前柱子的高度差。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); //小于等于两个是蓄不住水的。 if(n &lt;= 2) return 0; int ans = 0; int Max = -1; int k = -1; //找到至高点。 for(int i = 0; i &lt; n; i++)&#123; //先减去柱子本身高度 ans -= height[i]; if(Max &lt; height[i]) Max = height[i], k = i; &#125; //加上整个图的面积 ans += n*Max; //从前到最高点，每次减去从开始到每个更高柱子高度的面积。 int cur = height[0]; int i = 1; while(i &lt;= k)&#123; //i为从开始到当前柱子距离。height[i]-cur为高度差。 if(height[i] &gt; cur) ans -= i * (height[i]-cur),cur = height[i]; i++; &#125; cur = height[n-1]; i = height.size()-2; while(i&gt;=k)&#123; //i最后到当前柱子的距离。height[i]-cur为高度差。 if(height[i] &gt; cur) ans -= (n-i-1) * (height[i]-cur),cur = height[i]; i--; &#125; return ans; &#125;&#125;; Solution2（单调栈）：使用单调栈的原因是我们发现如果把每个柱子当作最低点，则接雨水的区域是左右第一个比当前柱子高的柱子所形成的区域乘以两者之间较小的柱子与当前柱子的高度差。所以我们进行单调栈寻找左右最近的比当前元素高的位置，来计算结果。 从直观来看，这样很像一层层的往里接水。（当然计算的时候不一定只是一层） 123456789101112131415161718192021class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); stack&lt;int&gt; s; int ans = 0; for(int i = 0; i &lt; n; i++)&#123; //找每个元素右边最近的大于他的值。//单调递减栈 while(s.size() &amp;&amp; height[i] &gt; height[s.top()])&#123; int top = s.top(); s.pop(); if(s.empty())break; //由于维持的是单调递减栈，所以当前栈顶是目前已知的最小一个元素，将栈顶取出，而新的栈顶元素与新发现的比它大的元素，一定能就组成边界，使得以目前最小元素为底，至左右边界中小的那一个，可以接到雨水。形象点就是一层一层的接。 int dis = i-s.top()-1; ans += dis * (min(height[i],height[s.top()])-height[top]); &#125; s.push(i); &#125; return ans; &#125;&#125;; Solution3（双指针）：我们写第一种解法时发现，并没有必要去进行那么多减法，每次直接观察当前柱子高度与之前记录的最高柱子的高度关系，如果没有之前最高柱子高就说明可以接住雨水（因为我们每次寻找的是更高的柱子，直到全图最高柱子出现为止），这样可以直接计算该柱子之上可以接住的雨水。由于左右都是到了最高柱子就会停止，所以使用双指针来优化，每次选较小的柱子来计算，直到制高点。 12345678910111213141516171819202122232425262728class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); int l = 0, r = n-1; int lm = -1,rm = -1; int ans = 0; while(l &lt; r)&#123; //从小的一方开始 if(height[l] &lt; height[r])&#123; if(height[l] &gt; lm)&#123; lm = height[l]; &#125;else&#123; ans += lm-height[l]; &#125; l++; &#125;else&#123; if(height[r] &gt; rm)&#123; rm = height[r]; &#125;else&#123; ans += rm-height[r]; &#125; r--; &#125; &#125; return ans; &#125;&#125;;","categories":[],"tags":[]},{"title":"单调栈详解","slug":"单调栈详解","date":"2019-09-06T14:24:00.000Z","updated":"2020-08-27T15:06:24.657Z","comments":true,"path":"2019/09/06/单调栈详解/","link":"","permalink":"https://yangzebin001.github.io/2019/09/06/单调栈详解/","excerpt":"","text":"单调栈一、概述：单调栈是一种特殊的栈结构，他要维持栈内元素保持一种单调性，从而能很快速的在线判断当前元素与后进来的元素大小关系。 二、单调性质为了维持单调性，在进栈时需要做元素的检查工作。以单调递增栈来说，如果发现要进栈的元素比目前栈顶元素小，如果此时将该元素进栈，必然会破坏单调性，所以需要对栈内元素进行调整工作：即如果该元素比栈顶元素小，则一定要将栈顶元素弹出，直到该元素不再比栈顶元素大或者栈为空时，可将该元素进栈。 三、功能用途在进行调整工作时，由于栈内元素时刻保持单调性，所以在遇见要进栈的元素比栈顶元素小时，对于当前栈顶元素，这个要进栈的元素是它第一次见到的比它小的元素。利用这一性质，我们就发现了单调栈的一个主要用途：求一个元素左/右边第一个比它大/小的元素。 四、具体做法对于具体怎么求比它大的元素还是比它小的元素，可以通过分析发现，求值的时机是在要进栈的元素破坏了当前栈所保持的单调性，即与当前栈保持的单调性相反。所以我们可以说： 如果求比当前元素大的元素的位置，可以建立单调递减栈。 如果求比当前元素小的元素的位置，可以建立单调递增栈。 那如何求左边的或者右边的目标元素位置呢？我们稍加分析就会知道：无论求哪个方向的元素，目标元素都一定要在当前元素之后进栈。所以可以得到： 求当前元素左边的比该元素大/小的元素，要从右向左依次添加。 求当前元素右边的比该元素大/小的元素，要从左向右依次添加。 由于我们需要求得每个元素的目标元素位置，但在一轮循环完毕后，栈中还存在符合单调性但没出栈的元素。也就是说当前栈内的每个元素都是没有与之相匹配的目标元素位置的。这时就要根据情况单独进行处理。 通常的处理方式是在循环操作结束时，再往栈内添加一个违反单调性的并且比所有的元素都要大的最值，迫使栈中的所有元素弹出。 核心代码：123456789101112//例：单调递减栈。 找当前数的左边的第一个比当前数大的值的位置。arr[0] = 2000000100;//最后位置添加一个最值。for(int i = N; i &gt;= 0; i--)&#123; //找到了比当前栈顶大的数，更新值 while(stk.size() &amp;&amp; arr[i] &gt; arr[stk.top()])&#123; 对该stk.top()进行需求操作。 stk.pop(); &#125; stk.push(i);&#125;//将最后一个元素弹出。stk.pop();","categories":[],"tags":[]},{"title":"POJ-2796-FeelGood","slug":"POJ-2796-FeelGood","date":"2019-09-06T14:17:00.000Z","updated":"2020-08-27T15:06:24.655Z","comments":true,"path":"2019/09/06/POJ-2796-FeelGood/","link":"","permalink":"https://yangzebin001.github.io/2019/09/06/POJ-2796-FeelGood/","excerpt":"","text":"POJ-2796-FeelGood 题目描述：Bill is developing a new mathematical theory for human emotions. His recent investigations are dedicated to studying how good or bad days influent people’s memories about some period of life. A new idea Bill has recently developed assigns a non-negative integer value to each day of human life. Bill calls this value the emotional value of the day. The greater the emotional value is, the better the daywas. Bill suggests that the value of some period of human life is proportional to the sum of the emotional values of the days in the given period, multiplied by the smallest emotional value of the day in it. This schema reflects that good on average period can be greatly spoiled by one very bad day. Now Bill is planning to investigate his own life and find the period of his life that had the greatest value. Help him to do so. 输入：The first line of the input contains n - the number of days of Bill’s life he is planning to investigate(1 &lt;= n &lt;= 100 000). The rest of the file contains n integer numbers a1, a2, … an ranging from 0 to 106 - the emotional values of the days. Numbers are separated by spaces and/or line breaks. 输出：Print the greatest value of some period of Bill’s life in the first line. And on the second line print two numbers l and r such that the period from l-th to r-th day of Bill’s life(inclusive) has the greatest possible value. If there are multiple periods with the greatest possible value,then print any one of them. 输入示例：1263 1 6 4 5 2 输出示例：12603 5 题目大意：给定一串数字，求一区间，使得区间内的每个数之和乘以区间内最小值最大，并求出区间范围。 思路：初次看，只能暴力枚举每一个区间，复杂度为O(n2)。 然后我们思考对于每个数，如果把它当做最小数，我们看他能向左右延伸到的最长区间范围，然后在这些区间内选一个符合条件最大的即可。 这就将问题转化为求每一个数左/右边尽可能远的大于等于该数的数的位置，进一步转化为求每个数的左右边遇到的第一个小于该数的位置，再往延伸的反方向退一格。这明显是单调栈问题。所以可以将复杂度降到O(n)。 Solution：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* * @Date: 2019-09-04 17:29:23 * @LastEditors: BeckoninGshy * @LastEditTime: 2019-09-06 22:01:01 */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;using namespace std;const int MAXN = 100010;int a[MAXN],R[MAXN],L[MAXN],ll,rr;long long sum[MAXN],ans = -1;int N;stack&lt;int&gt; s;int main()&#123; //思路：将枚举区间转化为以每个点为最低点，求向左和向右最多可以延长的长度。再转化一下就是求每个数左边或者右边第一个比它小的元素后 再往回退一格（L+1,R-1)。然后求区间内的最大值。 //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d&quot;,&amp;N); a[0] = -1; a[N+1] = -1; for(int i = 1; i &lt;= N; i++) scanf(&quot;%d&quot;,&amp;a[i]),sum[i] = sum[i-1] + a[i]; //求每个元素的左边第一个比它小的元素，加一 ----&gt; 找大于等于该数的最前一个数的位置。 //从右到左 单调递增栈 for(int i = N; i &gt;= 0; i--)&#123; while(s.size() &amp;&amp; a[i] &lt; a[s.top()]) &#123; L[s.top()] = i+1; s.pop(); &#125; s.push(i); &#125; s.pop(); //求每个元素的右边第一个比它小的元素 减一 ----&gt; 大于等于该数的最后一个数的位置 //从左到右，单调递增栈 for(int i = 1; i &lt;= N+1; i++)&#123; while(s.size() &amp;&amp; a[i] &lt; a[s.top()])&#123; R[s.top()] = i-1; s.pop(); &#125; s.push(i); &#125; for(int i = 1; i &lt;= N; i++)&#123; if((sum[R[i]] - sum[L[i]-1])*a[i] &gt; ans)&#123; ans = (sum[R[i]] - sum[L[i]-1])*a[i]; ll = L[i]; rr = R[i]; &#125; &#125; printf(&quot;%lld\\\\n%d %d\\\\n&quot;,ans,ll,rr); return 0;&#125; 这里由于是单调递增栈，所以在循环最后给他压进一个最小值，让栈内元素都弹出，做到代码简化。","categories":[],"tags":[]},{"title":"POJ-3250-Ba-Hai-Day（单调栈入门）","slug":"POJ-3250-Ba-Hai-Day（单调栈入门）","date":"2019-09-06T13:55:00.000Z","updated":"2020-08-27T15:06:24.654Z","comments":true,"path":"2019/09/06/POJ-3250-Ba-Hai-Day（单调栈入门）/","link":"","permalink":"https://yangzebin001.github.io/2019/09/06/POJ-3250-Ba-Hai-Day（单调栈入门）/","excerpt":"","text":"POJ-3250-Bad Hair Day 题目描述：Some of Farmer John’s N cows (1 ≤ N ≤ 80,000) are having a bad hair day! Since each cow is self-conscious about her messy hairstyle, FJ wants to count the number of other cows that can see the top of other cows’ heads. Each cow i has a specified height hi (1 ≤ hi ≤ 1,000,000,000) and is standing in a line of cows all facing east (to the right in our diagrams). Therefore, cow i can see the tops of the heads of cows in front of her (namely cows i+1, i+2, and so on), for as long as these cows are strictly shorter than cow i. Consider this example: 1234567== == - = Cows facing right --&gt;= = == - = = == = = = = =1 2 3 4 5 6 Cow#1 can see the hairstyle of cows #2, 3, 4 Cow#2 can see no cow’s hairstyle Cow#3 can see the hairstyle of cow #4 Cow#4 can see no cow’s hairstyle Cow#5 can see the hairstyle of cow 6 Cow#6 can see no cows at all! Let ci denote the number of cows whose hairstyle is visible from cow i; please compute the sum of c1 through cN.For this example, the desired is answer 3 + 0 + 1 + 0 + 1 + 0 = 5. 输入：Line 1: The number of cows, N.Lines 2..N+1: Line i+1 contains a single integer that is the height of cow i. 输出：Line 1: A single integer that is the sum of c1 through cN. 输入示例：1234567610374122 输出示例：15 题目大意：有一排奶牛，每个奶牛可以看到它右边身高严格比它小的奶牛发型，问这一排奶牛可以看到的奶牛发型总数。 思路：这道题是单调栈模板题。 具体做法就是在当前奶牛的右边找一个大于等于（原题说要严格小于，所以等于也算边界）它身高的奶牛的位置（由于求大于等于，所以维持一个单调递减栈），然后两者位置之差再减一就是中间的奶牛数量，每一个奶牛都做此操作即可求得结果。当然有一种情况是它找不到右边身高大于等于它的奶牛。这时可以把最后一个奶牛有一个无限高的奶牛，然后用该位置去减栈中每个奶牛的位置（n+1-x-1 = n-x）。 Solution:12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* * @Date: 2019-09-04 16:39:06 * @LastEditors: BeckoninGshy * @LastEditTime: 2019-09-06 21:41:17 */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;using namespace std;struct node&#123; int a,x; node()&#123;&#125; node(int _a, int _x):x(_x),a(_a)&#123;&#125;&#125;;stack&lt;node&gt; s;int main()&#123; //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); int n; long long ans = 0; scanf(&quot;%d&quot;,&amp;n); node temp; for(int i = 1; i &lt;= n; i++)&#123; scanf(&quot;%d&quot;,&amp;temp.a); temp.x = i; //单调递减栈 //找到了第一个比当前栈顶大的值（刚读入的值）。 while(s.size() &amp;&amp; s.top().a &lt;= temp.a)&#123; //计算坐标差 ans += i-s.top().x-1; s.pop(); &#125; s.push(temp); &#125; //当前栈顶元素的右边没有比他更高的元素了，用最右边的无限高减去该元素位置。 while(s.size())&#123; ans += n-s.top().x; s.pop(); &#125; printf(&quot;%lld\\\\n&quot;,ans); return 0;&#125;","categories":[],"tags":[]},{"title":"洛谷-P1901-发射站","slug":"洛谷-P1901-发射站","date":"2019-09-05T15:30:00.000Z","updated":"2020-08-27T15:06:24.652Z","comments":true,"path":"2019/09/05/洛谷-P1901-发射站/","link":"","permalink":"https://yangzebin001.github.io/2019/09/05/洛谷-P1901-发射站/","excerpt":"","text":"P1901 发射站 题目描述：某地有 N 个能量发射站排成一行，每个发射站 i 都有不相同的高度 Hi，并能向两边（当 然两端的只能向一边）同时发射能量值为 Vi 的能量，并且发出的能量只被两边最近的且比 它高的发射站接收。 显然，每个发射站发来的能量有可能被 0 或 1 或 2 个其他发射站所接受，特别是为了安 全，每个发射站接收到的能量总和是我们很关心的问题。由于数据很多，现只需要你帮忙计 算出接收最多能量的发射站接收的能量是多少。 输入格式：第 1 行：一个整数 N; 第 2 到 N+1 行：第 i+1 行有两个整数 Hi 和 Vi，表示第 i 个人发射站的高度和发射的能量值。 输出格式：输出仅一行，表示接收最多能量的发射站接收到的能量值，答案不超过 longint。 输入样例：123434 2 3 5 6 10 输出样例：17 说明/提示：对于 40%的数据，1&lt;=N&lt;=5000；1&lt;=Hi&lt;=100000；1&lt;=Vi&lt;=10000; 对于 70%的数据，1&lt;=N&lt;=100000；1&lt;=Hi&lt;=2,000,000,000；1&lt;=Vi&lt;=10000; 对于 100%的数据，1&lt;=N&lt;=1000000;1&lt;=Hi&lt;=2,000,000,000；1&lt;=Vi&lt;=10000。 题目解析：题目中有一句至关重要的话：发出的能量只被两边最近的且比 它高的发射站接收。 这句话揭露了解法：使用单调栈。 将题目精简下，留其核心就是要分别求每个数左边和右边碰到的第一个比它大的数的位置。 这是经典的单调栈可以解决的问题，所以直接写两个单调栈：一个求左边的位置，一个求右边的位置，找到位置后将其能量值存起来，在其中找一个最大值即可。 Solution：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * @Date: 2019-09-05 21:32:02 * @LastEditors: BeckoninGshy * @LastEditTime: 2019-09-05 23:10:34 */#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;using namespace std;typedef long long LL;const int MAXN = 1000010;LL arr[MAXN],s[MAXN],sum[MAXN],N,ans = -1;stack&lt;LL&gt; stk;int main()&#123; //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%lld&quot;,&amp;N); arr[0] = 2000000100; arr[N+1] = 2000000100; for(int i = 1; i &lt;= N; i++)&#123; scanf(&quot;%lld%lld&quot;,&amp;arr[i],&amp;s[i]); &#125; //找一个数左右两边离该数最近的并且比该数大的数的位置 //单调递减栈。 找当前数的右边目标数 for(int i = 1; i &lt;= N+1; i++)&#123; //找到了比当前栈顶大的数，更新值 while(stk.size() &amp;&amp; arr[i] &gt; arr[stk.top()])&#123; sum[i] += s[stk.top()]; stk.pop(); &#125; stk.push(i); &#125; stk.pop(); //单调递减栈。 找当前数的左边目标数 for(int i = N; i &gt;= 0; i--)&#123; //找到了比当前栈顶大的数，更新值 while(stk.size() &amp;&amp; arr[i] &gt; arr[stk.top()])&#123; sum[i] += s[stk.top()]; stk.pop(); &#125; stk.push(i); &#125; stk.pop(); for(int i = 1; i &lt;= N; i++) ans = max(ans,sum[i]); printf(&quot;%lld&quot;,ans); return 0;&#125;","categories":[],"tags":[]},{"title":"最小生成树相关算法学习总结","slug":"最小生成树相关算法学习总结","date":"2019-08-30T12:42:00.000Z","updated":"2020-08-27T15:06:24.650Z","comments":true,"path":"2019/08/30/最小生成树相关算法学习总结/","link":"","permalink":"https://yangzebin001.github.io/2019/08/30/最小生成树相关算法学习总结/","excerpt":"","text":"概念：最小生成树是一副连通加权无向图中一棵权值最小的生成树。 在现实生活中，经常要求在类似网络的复杂关系中，既要面面俱到（任意两个结点之间都可以访问到），又要使所用成本尽可能的小。最小生成树就是解决相关问题的。 一个连通图可能有多个不同的最小生成树，但是其权值之和一定相等。一棵最小生成树一定有N个顶点，N-1条边。通过对生成树关注的角度不同，有相应两种不同但同样常用的算法。 一、Prim算法：prim算法是按每一步为一棵生长中的树添加一条边，该数最开始只有一个顶点，然后会添加v-1条边。 每次总是选择一条与生长中的树和图中与该树相连的部分所形成的具有最小权值的横切边添加到该生成树中。 12345678910111213141516171819202122232425262728293031323334353637383940int G[MAXN][MAXN];//权值矩阵int vis[MAXN];//记录访问int lowc[MAXN];//记录与树连接的边的权重memset(G,INF,sizeof(G));memset(vis,false,sizeof(vis));memset(lowc,INF,sizeof(lowc));//标号0-n-1，返回最小生成树的权值，返回-1表示不连通int Prim(int n)&#123; int ans = 0; //从0节点开始 vis[0] = true; //首先更新与0结点直接相连的边的权值。 for(int i = 1; i &lt; n; i++) lowc[i] = G[0][i]; //循环n-1次 for(int i = 1; i &lt; n; i++)&#123; int minc = INF; int p = -1; //找到与当前树相连并且权值最小的边。 for(int j = 0; j &lt; n; j++)&#123; if(!vis[j]&amp;&amp;minc &gt; lowc[j])&#123; minc = lowc[j]; p = j; &#125; &#125; //不连通 if(minc == INF) return -1; //更新树的权值 ans += minc; vis[p] = true; //继续更新新树的最小权值数组。 for(int j = 0; j &lt; n; j++)&#123; if(!vis[j]&amp;&amp;lowc[j] &gt; G[p][j]) lowc[j] = G[p][j]; &#125; &#125; return ans;&#125; 二、 Kruskal算法算法流程： 新建图G，G中拥有原图中相同的节点，但没有边。 将原图中所有的边按权值从小到大排序 从权值最小的边开始，如果这条边连接的两个结点与图G中不在同一个连通分量重，则添加这条边到图G中。 重复3，直至图G中所有的结点都在同一个连通分量中。一共需要合并n-1次。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const int MAXN = 1010;//最大点数 const int MAXM = 10000;//最大边数 int F[MAXN]; //并查集使用//存储边的信息，起点，终点，权值struct Edge&#123; int u,v,w;&#125;edge[MAXM]; int tol = 0;//边数，加边前赋值为0//加边函数void addedge(int u,int v,int w)&#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125; //比较函数，排序用bool cmp(Edge a,Edge b)&#123; return a.w &lt; b.w;&#125; //查找元素所属集合。路径压缩版int find(int x)&#123; return F[x] == -1 ? x : F[x] = find(F[x]);&#125;//传入点数，返回最小生成树的权值，如果不连通返回-1int Kruskal(int n)&#123; memset(F,-1,sizeof(F)); //先对边排序 sort(edge,edge+tol,cmp); int cnt = 0; //计算加入的边数。 int ans = 0; //最多循环tol次 for(int i = 0; i &lt; tol; i++)&#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); //如果属于不同集合，合并 if(t1 != t2)&#123; ans+= w; F[t1] = t2; cnt++; &#125; //共需合并n-1次，已经完成，可提前结束 if(cnt == n-1) break; &#125; if(cnt &lt; n-1) return -1;//不连通 return ans; &#125; 对于稀疏图，选择Kruskal算法较优，而对于稠密图，Prim算法会更高效。 此外还有最大生成树，其实只要将图中的权值取反一下，就可以求得最大生成树，或者在kruskal算法，按从大到小排序之后再合并，得出来的也是最大生成树。","categories":[],"tags":[]},{"title":"POJ-3660-Co-Contest","slug":"POJ-3660-Co-Contest","date":"2019-08-30T01:54:00.000Z","updated":"2020-08-27T15:06:24.648Z","comments":true,"path":"2019/08/30/POJ-3660-Co-Contest/","link":"","permalink":"https://yangzebin001.github.io/2019/08/30/POJ-3660-Co-Contest/","excerpt":"","text":"POJ-3660-Cow Contest 题目描述：N (1 ≤ N ≤ 100) cows, conveniently numbered 1..N, are participating in a programming contest. As we all know, some cows code better than others. Each cow has a certain constant skill rating that is unique among the competitors. The contest is conducted in several head-to-head rounds, each between two cows. If cow A has a greater skill level than cow B (1 ≤ A ≤ N; 1 ≤ B ≤ N; A ≠ B), then cow A will always beat cow B. Farmer John is trying to rank the cows by skill level. Given a list the results of M (1 ≤ M ≤ 4,500) two-cow rounds, determine the number of cows whose ranks can be precisely determined from the results. It is guaranteed that the results of the rounds will not be contradictory. 输入： Line 1: Two space-separated integers: N and M Lines 2..M+1: Each line contains two space-separated integers that describe the competitors and results (the first integer, A, is the winner) of a single round of competition: A and B 输出：Line 1: A single integer representing the number of cows whose ranks can be determined 输入示例：1234565 54 34 23 21 22 5 输出示例：12 题目大意：有N头牛，现在给出M个输赢列表（第一代表赢，第二代表输），并且实力是绝对的（这句话很重要）。要求你确定谁的排名是确定的，输出确定的个数。 思路：使用传递闭包来确定赢的关系，并通过判断其中一头牛与其他牛是否都有联系（赢了别的牛，或输给了别的牛）。如果与其余N-1条牛都有联系，说明该牛的排名是确定的。 Solution：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN = 200;const int INF = 0x3f3f3f3f;int G[MAXN][MAXN];int N,M;int main()&#123; freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); memset(G,0,sizeof(G)); scanf(&quot;%d%d&quot;,&amp;N,&amp;M); for(int i = 0; i &lt; M; i++)&#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); //生成a赢b的关系图 G[a][b] = 1; &#125; for(int k = 1; k &lt;= N; k++) for(int i = 1; i &lt;= N; i++) for(int j = 1; j &lt;= N; j++) //B&gt;C，A&gt;B，说明A&gt;C if(G[i][k] &amp;&amp; G[k][j]) G[i][j] = 1; /* 只有当一个点与其他个点都有联系（或赢或输）,才可以确定该点 */ int ans = 0; for(int i = 1; i &lt;= N; i++)&#123; int sum = 0; for(int j = 1; j &lt;= N; j++)&#123; // 又因为该题有唯一的赢输判定，所以与其他各点都有联系可以直接表示为加的和为N-1 // 否则只能一一判定当前点与其他个点的关系。 sum = sum + G[i][j] + G[j][i]; &#125; if(sum == N-1) ans++; &#125; printf(&quot;%d\\\\n&quot;,ans); return 0;&#125;","categories":[],"tags":[]},{"title":"POJ-1416-Shreddin-Company","slug":"POJ-1416-Shreddin-Company","date":"2019-08-25T12:34:00.000Z","updated":"2020-08-27T15:06:24.647Z","comments":true,"path":"2019/08/25/POJ-1416-Shreddin-Company/","link":"","permalink":"https://yangzebin001.github.io/2019/08/25/POJ-1416-Shreddin-Company/","excerpt":"","text":"POJ-1416 描述：You have just been put in charge of developing a new shredder for the Shredding Company Although a “normal” shredder would just shred sheets of paper into little pieces so that the contents would become unreadable, this new shredder needs to have the following unusual basic characteristics. 1.The shredder takes as input a target number and a sheet of paper with a number written on it. 2.It shreds (or cuts) the sheet into pieces each of which has one or more digits on it. 3.The sum of the numbers written on each piece is the closest possible number to the target number, without going over it. For example, suppose that the target number is 50, and the sheet of paper has the number 12346. The shredder would cut the sheet into four pieces, where one piece has 1, another has 2, the third has 34, and the fourth has 6. This is because their sum 43 (= 1 + 2 + 34 + 6) is closest to the target number 50 of all possible combinations without going over 50. For example, a combination where the pieces are 1, 23, 4, and 6 is not valid, because the sum of this combination 34 (= 1 + 23 + 4 + 6) is less than the above combination’s 43. The combination of 12, 34, and 6 is not valid either, because the sum 52 (= 12 + 34 + 6) is greater than the target number of 50. Figure 1. Shredding a sheet of paper having the number 12346 when the target number is 50 There are also three special rules : 1.If the target number is the same as the number on the sheet of paper, then the paper is not cut. For example, if the target number is 100 and the number on the sheet of paper is also 100, then the paper is not cut. 2.If it is not possible to make any combination whose sum is less than or equal to the target number, then error is printed on a display. For example, if the target number is 1 and the number on the sheet of paper is 123, it is not possible to make any valid combination, as the combination with the smallest possible sum is 1, 2, 3. The sum for this combination is 6, which is greater than the target number, and thus error is printed. 3.If there is more than one possible combination where the sum is closest to the target number without going over it, then rejected is printed on a display. For example, if the target number is 15, and the number on the sheet of paper is 111, then there are two possible combinations with the highest possible sum of 12: (a) 1 and 11 and (b) 11 and 1; thus rejected is printed. In order to develop such a shredder, you have decided to first make a simple program that would simulate the above characteristics and rules. Given two numbers, where the first is the target number and the second is the number on the sheet of paper to be shredded, you need to figure out how the shredder should “cut up” the second number. 输入：The input consists of several test cases, each on one line, as follows : 12345tl num1t2 num2...tn numn0 0 Each test case consists of the following two positive integers, which are separated by one space : (1) the first integer (ti above) is the target number, (2) the second integer (numi above) is the number that is on the paper to be shredded. Neither integers may have a 0 as the first digit, e.g., 123 is allowed but 0123 is not. You may assume that both integers are at most 6 digits in length. A line consisting of two zeros signals the end of the input. 输出：For each test case in the input, the corresponding output takes one of the following three types : 123sum part1 part2 ...rejectederror In the first type, partj and sum have the following meaning : 1.Each partj is a number on one piece of shredded paper. The order of partj corresponds to the order of the original digits on the sheet of paper. 2.sum is the sum of the numbers after being shredded, i.e., sum = part1 + part2 +… Each number should be separated by one space.The message error is printed if it is not possible to make any combination, and rejected if there ismore than one possible combination.No extra characters including spaces are allowed at the beginning of each line, nor at the end of each line. 输入示例：1234567891050 12346376 144139927438 92743818 33129 314225 1299111 33333103 8621506 11040 0 输出示例：12345678943 1 2 34 6283 144 139927438 92743818 3 3 12error21 1 2 9 9rejected103 86 2 15 0rejected 题目大意：给你一个有n个数的纸条，一个目标值，你可以任意剪纸条，要找出剪出的数的和最接近并且小于目标数的分解方式。 如果该数可以由多个分解方式组成，则输出error；如果无论如何分解都比目标值大，则输出rejected。如果分解值和目标数相同，则直接输出。 思路：首先对于剪纸条，无论如何剪，相邻数的位置关系并不会发生变化，只是选择元素的个数会发生变化，则可以dfs枚举所有的可能————对于某一过程，可以选择从该数开始到纸条结尾，每次都选择增加一个数，然后进行下一层的dfs，即可取得所有的分解组合。 接下来要保留选择数的路径，我们使用一个数的每一位来记录当前选择了几个数（N最大为6位，所以一位足够表示）。 然后，对于大于目标数的情况，只有当最小分解方式（每一位都被分解）之和都比目标值大，则可以直接输出rejected。该步可在dfs之前判断。 对于error的情况，只要在每次更新当前值的时候，也更新其相同的次数，如果大于1，则符合该情况。 可以小小的剪枝下：当过程中的取值比目标值大的话，就可以直接剪掉。 最后就是编码的时刻了！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;vector&lt;vector&lt;int&gt; &gt; ans;int num; //目标数int npath; //最优路径int curNum; //当前数，dfs中间值int cntNum; //当前数的出现次数。/*将结果数组中的各值相加*/int getNum(vector&lt;vector&lt;int&gt; &gt; t, int n)&#123; int ans = 0; int cont = 0; for(int j = 0; j &lt; t.size(); j++)&#123; int c = 0; cont += t[j].size(); for(int k = 0; k &lt; t[j].size(); k++)&#123; c = c*10 + t[j][k]; &#125; ans +=c; &#125; return ans;&#125;/*i:当前位置n：总长度path：记录每次分割长度s：总数据t：结果数组。*/void dfs(int i,int n,int path,char s[],vector&lt;vector&lt;int&gt; &gt; t)&#123; int tt = getNum(t,n); //如果过程中已经比当前数大了，直接剪掉 if(tt &gt; num) return; if(i == n)&#123; //在当前一轮结束时更新离目标数最近并小于目标数的值、次数与路径。 if(curNum &lt; tt)&#123; cntNum = 1; curNum = tt; npath = path; &#125;else if(curNum == tt)&#123; cntNum++; &#125; return; &#125; /* dfs核心： 输入：1234 生成下列排列 1 2 3 4 1 2 34 1 23 4 1 234 12 3 4 12 34 123 4 1234 */ vector&lt;int&gt; a; for(int j = i; j &lt; n; j++)&#123; a.push_back(s[j]-&apos;0&apos;); t.push_back(a); dfs(j+1,n,path*10+j-i+1,s,t); t.pop_back(); &#125; &#125;//根据path输出各个数。void show(char s[],int path)&#123; vector&lt;int&gt; a; while(path)&#123; a.push_back(path%10); path/=10; &#125; reverse(a.begin(),a.end()); int j = 0; for(int i = 0; i &lt; a.size(); i++)&#123; printf(&quot; &quot;); for(int k = 0; k &lt; a[i]; k++)&#123; printf(&quot;%c&quot;,s[j++]); &#125; &#125;&#125;int main()&#123; //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int a; char s[1000]; while(scanf(&quot;%d%s&quot;,&amp;a,s) &amp;&amp; a)&#123; vector&lt;vector&lt;int&gt; &gt; t; num = a; curNum = 0; cntNum = 0; int sum = 0; for(int i = 0; i &lt; strlen(s); i++)&#123; sum += s[i]-&apos;0&apos;; &#125; //给定数的每一位相加都比目标数大 if(sum &gt; a)&#123; printf(&quot;error\\\\n&quot;); &#125;else&#123; dfs(0,strlen(s),0,s,t); if(cntNum &gt; 1)&#123; printf(&quot;rejected\\\\n&quot;); &#125;else&#123; printf(&quot;%d&quot;,curNum); show(s,npath); printf(&quot;\\\\n&quot;); &#125; &#125; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"POJ-3083-Childre-o-th-Cand-Corn","slug":"POJ-3083-Childre-o-th-Cand-Corn","date":"2019-08-23T13:43:00.000Z","updated":"2020-08-27T15:06:24.645Z","comments":true,"path":"2019/08/23/POJ-3083-Childre-o-th-Cand-Corn/","link":"","permalink":"https://yangzebin001.github.io/2019/08/23/POJ-3083-Childre-o-th-Cand-Corn/","excerpt":"","text":"POJ-3083 描述：The cornfield maze is a popular Halloween treat. Visitors are shown the entrance and must wander through the maze facing zombies, chainsaw-wielding psychopaths, hippies, and other terrors on their quest to find the exit. One popular maze-walking strategy guarantees that the visitor will eventually find the exit. Simply choose either the right or left wall, and follow it. Of course, there’s no guarantee which strategy (left or right) will be better, and the path taken is seldom the most efficient. (It also doesn’t work on mazes with exits that are not on the edge; those types of mazes are not represented in this problem.) As the proprieter of a cornfield that is about to be converted into a maze, you’d like to have a computer program that can determine the left and right-hand paths along with the shortest path so that you can figure out which layout has the best chance of confounding visitors. 输入：Input to this problem will begin with a line containing a single integer n indicating the number of mazes. Each maze will consist of one line with a width, w, and height, h (3 &lt;= w, h &lt;= 40), followed by h lines of w characters each that represent the maze layout. Walls are represented by hash marks (‘#’), empty space by periods (‘.’), the start by an ‘S’ and the exit by an ‘E’. Exactly one ‘S’ and one ‘E’ will be present in the maze, and they will always be located along one of the maze edges and never in a corner. The maze will be fully enclosed by walls (‘#’), with the only openings being the ‘S’ and ‘E’. The ‘S’ and ‘E’ will also be separated by at least one wall (‘#’). You may assume that the maze exit is always reachable from the start point. 输出：For each maze in the input, output on a single line the number of (not necessarily unique) squares that a person would visit (including the ‘S’ and ‘E’) for (in order) the left, right, and shortest paths, separated by a single space each. Movement from one square to another is only allowed in the horizontal or vertical direction; movement along the diagonals is not allowed. 输入示例：1234567891011121314151628 8#########......##.####.##.####.##.####.##.####.##...#..##S#E####9 5##########.#.#.#.#S.......E#.#.#.#.########## 输出示例：1237 5 517 17 9 题目大意：有一张地图，# 是墙壁，. 是路，S是点，E是终点。（S和E在地图边缘且不在四个对角） 问：优先选择左边到达终点的路径长度（目前朝向的左边为优先选边，顺时针），优先选择右边到达终点的路径长度（目前朝向的右边为优先选边，逆时针），和最短的路径长度。 思路：该题使用dfs（前两问）加bfs（后一问）来解答，由于有一个优先选择当前方向的左边或者右边位置，所以需要处理一个当前的朝向问题。比普通的dfs要复杂一点。但是根据定义的方向数组，只要知道了向左转就是当前的朝向减一个单位，右转为当前的朝向加一个单位，以此为起始探测方向，并且处理好顺逆时针关系就可以化解该题。 Solution：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int MAXN = 50;char m[MAXN][MAXN];int N,M;int sx,sy,ex,ey;int ans;int flag;struct node&#123; int x,y,d; node()&#123;&#125; node(int _x,int _y, int _d):x(_x),y(_y),d(_d)&#123;&#125;&#125;;//从左顺时针int dx[] = &#123;0,-1,0,1&#125;;int dy[] = &#123;-1,0,1,0&#125;;void dfs(int x, int y, int pos,int t,int s)&#123; // printf(&quot;%d %d %d\\\\n&quot;,x,y,d); if(flag) return; if(x == ex &amp;&amp; y == ey)&#123; flag = 1; ans = max(ans,s); return; &#125; //t = -1 表示顺时针，t = 1 表示逆时针 //pp : 当前的方向 //如果是左优先，就将当前方向-1开始顺时针， //如果是右优先，就将当前方向+1开始逆时针。 for(int i = 1,pp = (pos+t+4)%4; i &lt;= 4; i++,pp = (pp-t+4)%4)&#123; int nx = dx[pp] + x; int ny = dy[pp] + y; if(nx &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; M &amp;&amp; m[nx][ny] == &apos;.&apos;)&#123; dfs(nx,ny,pp,t,s+1); if(flag) return; &#125; &#125;&#125;void bfs(int x,int y)&#123; queue&lt;node&gt; q; q.push(node(x,y,1)); m[x][y] = &apos;#&apos;; node temp; while(q.size())&#123; temp = q.front();q.pop(); if(temp.x == ex &amp;&amp; temp.y == ey)&#123; ans = temp.d; return; &#125; for(int i = 0; i &lt; 4; i++)&#123; int nx = dx[i] + temp.x; int ny = dy[i] + temp.y; if(nx &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; M &amp;&amp; m[nx][ny] == &apos;.&apos;)&#123; m[nx][ny] = &apos;#&apos;; q.push(node(nx,ny,temp.d+1)); &#125; &#125; &#125;&#125;int main()&#123; int T; //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; int pos = 0; scanf(&quot;%d%d&quot;,&amp;M,&amp;N); // memset(m,0,sizeof(m)); for(int i = 0; i &lt; N; i++)&#123; scanf(&quot;%s&quot;,m[i]); for(int j = 0; j &lt; M; j++)&#123; if(m[i][j] == &apos;S&apos;)&#123; sx = i,sy = j; m[i][j] = &apos;.&apos;; &#125;else if(m[i][j] == &apos;E&apos;)&#123; ex = i,ey = j; m[i][j] = &apos;.&apos;; &#125; &#125; &#125; // for(int i = 0; i &lt; N; i++)&#123; // for(int j = 0; j &lt; M; j++)&#123; // printf(&quot;%c&quot;,m[i][j]); // &#125; // printf(&quot;\\\\n&quot;); // &#125; /* pos = 0 表示向上为初始方向 pos = 1 表示向右为初始方向 pos = 2 表示向下为初始方向 pos = 3 表示向左为初始方向 */ if(sx == 0) pos = 2; if(sx == N-1) pos = 0; if(sy == 0) pos = 1; if(sy == M-1) pos = 3; ans = 0; flag = 0; dfs(sx,sy,pos,-1,1); printf(&quot;%d&quot;,ans); ans = 0; flag = 0; dfs(sx,sy,pos,1,1); printf(&quot; %d&quot;,ans); ans = 0; bfs(sx,sy); printf(&quot; %d\\\\n&quot;,ans); &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"LeetCode-473-火柴拼正方形","slug":"LeetCode-473-火柴拼正方形","date":"2019-08-16T09:00:00.000Z","updated":"2020-08-27T15:06:24.643Z","comments":true,"path":"2019/08/16/LeetCode-473-火柴拼正方形/","link":"","permalink":"https://yangzebin001.github.io/2019/08/16/LeetCode-473-火柴拼正方形/","excerpt":"","text":"473. 火柴拼正方形 还记得童话《卖火柴的小女孩》吗？现在，你知道小女孩有多少根火柴，请找出一种能使用所有火柴拼成一个正方形的方法。不能折断火柴，可以把火柴连接起来，并且每根火柴都要用到。 输入为小女孩拥有火柴的数目，每根火柴用其长度表示。输出即为是否能用所有的火柴拼成正方形。 示例 1: 12输入: [1,1,2,2,2]输出: true 解释: 能拼成一个边长为2的正方形，每边两根火柴。 示例 2: 12输入: [3,3,3,3,4]输出: false 解释: 不能用所有火柴拼成一个正方形。 注意:给定的火柴长度和在 0 到 10^9之间。火柴数组的长度不超过15。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int part; vector&lt;bool&gt; vis; bool f = true; bool makesquare(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; for(int i = 0; i &lt; nums.size(); i++) sum += nums[i]; if(!sum || sum%4) return false; part = sum / 4; vis = vector&lt;bool&gt;(nums.size()); //从大到小枚举所有边 sort(nums.begin(),nums.end(),greater&lt;int&gt;()); return dfs(nums,0,0,part); &#125; //u:当前选了几个数，sum：当前的和，k:选到了第几层 bool dfs(vector&lt;int&gt; &amp;nums,int u,int cur,int length)&#123; if(cur == length) u+=1,cur=0; if(u == 4) return true; for(int i = 0; i &lt; nums.size(); i++)&#123; // if(!vis[i] &amp;&amp; cur+nums[i] &lt;= length)&#123; vis[i] = true; if(dfs(nums,u,cur+nums[i],length)) return true; vis[i] = false; //如果当前木棒拼接失败，并且是第一个，则剪掉。 if(cur == 0) return false; //如果当前木棒拼接失败，并且是最后一个，则剪掉。 if(cur + nums[i] == length) return false; //如果当前木棒拼接失败，跳过所有相同长度的木棒。 while(i+1 &lt; nums.size() &amp;&amp; nums[i] == nums[i+1]) i++; &#125; &#125; return false; &#125;&#125;; 思路：剪枝策略： 从小到大枚举所有边 每条边内部的木棒长度规定为从大到小 如果当前木棒拼接失败，则跳过接下来所有长度相同的木棒。 如果当前木棒拼接失败，且是当前边的第一个，则直接剪掉当前分支。 如果当前木棒拼接失败，且是当前边的最后一个，则直接剪掉当前分支。","categories":[],"tags":[]},{"title":"LeetCode-216-组合总-III","slug":"LeetCode-216-组合总-III","date":"2019-08-16T07:19:00.000Z","updated":"2020-08-27T15:06:24.642Z","comments":true,"path":"2019/08/16/LeetCode-216-组合总-III/","link":"","permalink":"https://yangzebin001.github.io/2019/08/16/LeetCode-216-组合总-III/","excerpt":"","text":"216. 组合总和 III 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1:12输入: k = 3, n = 7输出: [[1,2,4]] 示例 2:12输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]] Solution：1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; tmp; vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; dfs(0,1,0,k,n); return ans; &#125; //u:当前选择数的个数，a：当前可以枚举的位置，sum:当前组合数的和。 void dfs(int u,int a,int sum,int k,int n)&#123; if(u == k &amp;&amp; sum == n)&#123; ans.push_back(tmp); return; &#125; if(a == 10)&#123; return; &#125; if(sum &gt; n) return; for(int i = a; i &lt; 10; i++)&#123; tmp.push_back(i); dfs(u+1,i+1,sum+i,k,n); tmp.pop_back(); &#125; &#125;&#125;;","categories":[],"tags":[]},{"title":"LeetCode-47-全排-II","slug":"LeetCode-47-全排-II","date":"2019-08-16T02:42:00.000Z","updated":"2020-08-27T15:06:24.640Z","comments":true,"path":"2019/08/16/LeetCode-47-全排-II/","link":"","permalink":"https://yangzebin001.github.io/2019/08/16/LeetCode-47-全排-II/","excerpt":"","text":"47. 全排列 II 给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例:输入: 1[1,1,2] 输出: 12345[ [1,1,2], [1,2,1], [2,1,1]] Solution1(set去重)：123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; tmp; vector&lt;bool&gt; bt; int n; set&lt;vector&lt;int&gt;&gt; s; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; n = nums.size(); bt = vector&lt;bool&gt;(n); sort(nums.begin(),nums.end()); dfs(0,0,nums); return ans; &#125; void dfs(int u,int start,vector&lt;int&gt; &amp;nums)&#123; if(u == n)&#123; if(!s.count(tmp))&#123; ans.push_back(tmp); s.insert(tmp); &#125; return; &#125; for(int i = 0; i &lt; n; i++)&#123; if(!bt[i])&#123; bt[i] = true; tmp.push_back(nums[i]); dfs(u+1,start,nums); tmp.pop_back(); bt[i] = false; &#125; &#125; &#125;&#125;; 思路：去重问题，首先想到set，比较简单粗暴的都放到set容器里，有重复就不往答案里面去。 Solution2（排序去重）：1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; tmp; vector&lt;bool&gt; bt; int n; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; n = nums.size(); bt = vector&lt;bool&gt;(n); sort(nums.begin(),nums.end()); dfs(0,0,nums); return ans; &#125; bool judge(int i,vector&lt;int&gt; nums)&#123; for(int j = 0; j &lt; i; j++)&#123; if(nums[i] == nums[j])&#123; if(!bt[j]) return false; &#125; &#125; return true; &#125; void dfs(int u,int start,vector&lt;int&gt; &amp;nums)&#123; if(u == n)&#123; ans.push_back(tmp); return; &#125; for(int i = 0; i &lt; n; i++)&#123; //如果所选是重复数，并且前面都选过了，才能选择当前的。 if(!bt[i] &amp;&amp; (i == 0 ? 1 : nums[i-1] == nums[i] ? bt[i-1] : 1))&#123; bt[i] = true; tmp.push_back(nums[i]); dfs(u+1,start,nums); tmp.pop_back(); bt[i] = false; &#125; &#125; &#125;&#125;; 思路：选择不重复元素的全排列我们已经解决过了，现在我们研究如何去重的问题。 首先我们发现去重的原因是两个位置不同的相同的数在交换之后，整体排列不变，这样就会产生重复，为了达到去重的目的，我们人为规定，当前元素必须在所有在它之前的元素都已经被选了以后，它才能选。这样，相同元素的相对位置就固定下来，不会发生交换重复问题。所以为了方便，我们把相同的元素排在一起，这时需要先排序。","categories":[],"tags":[]},{"title":"费解的开关","slug":"费解的开关","date":"2019-08-13T13:47:00.000Z","updated":"2020-08-27T15:06:24.639Z","comments":true,"path":"2019/08/13/费解的开关/","link":"","permalink":"https://yangzebin001.github.io/2019/08/13/费解的开关/","excerpt":"","text":"费解的开关 你玩过“拉灯”游戏吗？25盏灯排成一个5x5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。 我们用数字“1”表示一盏开着的灯，用数字“0”表示关着的灯。下面这种状态 123451011101101101111000011011 在改变了最左上角的灯的状态后将变成： 123450111111101101111000011011 再改变它正中间的灯后状态将变成： 123450111111001110011010011011 给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。输入格式 第一行输入正整数n，代表数据中共有n个待解决的游戏初始状态。 以下若干行数据分为n组，每组数据有5行，每行5个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。输出格式 一共输出n行数据，每行有一个小于等于6的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。 对于某一个游戏初始状态，若6步以内无法使所有灯变亮，则输出“-1”。 数据范围：0&lt;n≤500输入样例：1234567891011121314151617183001110101110001110101110011101111011111011111111110111111111111111111111111 输出样例：12332-1 Solution1（TLE）：我们可以枚举每个开关的状态，然后查看是否全亮，每个开关两个状态（开和关），一共有25个开关，所以复杂度为O(2^25) = 33554432次。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int m;int ans = 26;void flip(int k)&#123; int i = k / 5,j = k % 5; m ^= 1 &lt;&lt; k; if(j-1 &gt;= 0) m ^= (1 &lt;&lt; (i * 5 + (j-1))); if(j+1 &lt; 5) m ^= (1 &lt;&lt; (i *5 + (j+1))); if(i-1 &gt;= 0) m ^= (1 &lt;&lt; ((i-1) *5 + j)); if(i+1 &lt; 5) m ^= (1 &lt;&lt; ((i+1) *5 + j));&#125;void dfs(int k,int d)&#123; if(m == (1&lt;&lt;25)-1)&#123; ans = min(ans,d); return; &#125; if(k &gt;= 26) return; dfs(k+1,d); flip(k); dfs(k+1,d+1); flip(k);&#125;int main()&#123; freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); int T; scanf(&quot;%d&quot;,&amp;T); getchar(); while(T--)&#123; char c[10]; m = 0; ans = 26; for(int i = 0; i &lt; 5; i++)&#123; scanf(&quot;%s&quot;,c); for(int j = 0; j &lt; 5; j++)&#123; if(c[j] == &apos;1&apos;) m |= (1 &lt;&lt; (i*5+j)); &#125; printf(&quot;%s\\\\n&quot;,c); getchar(); &#125; printf(&quot;%#x\\\\n&quot;,m); dfs(0,0); if(ans &gt; 6) ans = -1; printf(&quot;%d\\\\n&quot;,ans); &#125; return 0;&#125; Solution2：我们可以从行的角度来看：如果当前行确定了，我们要让所有的开关打开，就要选把当前行中关闭的灯的下面位置的切换状态。归纳到一般情况，当第一行的状态确定了，我们为了使所有的开关打开，去下一行改变状态，使得当前行的所有灯打开。如此4次后，由于到达了最后一行，这时，我们检查最后一行的灯是否全部亮，（前面4行已经全部亮了）。如果全亮，则当前的选择为一个可选方案，这时更新翻转的次数。 复杂度为O(n * 2^5)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int INF = 0x3f3f3f3f;char m[10][10];int ans = INF;int dx[5] = &#123;0,-1,0,1,0&#125;;int dy[5] = &#123;0,0,1,0,-1&#125;;void flip(int x,int y)&#123; for(int i = 0; i &lt;5; i++)&#123; int xi = x + dx[i]; int yi = y + dy[i]; if(xi &gt;= 0 &amp;&amp; xi &lt; 5 &amp;&amp; yi &gt;= 0 &amp;&amp; yi &lt; 5)&#123; m[xi][yi] ^= 1; &#125; &#125;&#125;void solve()&#123; char backup[10][10]; int res = 0; memcpy(backup,m,sizeof(m)); for(int i = 0; i &lt; 1 &lt;&lt; 5; i++)&#123; res = 0; for(int j = 0; j &lt; 5; j++)&#123; if(i &gt;&gt; j &amp; 1)&#123; res++; flip(0,j); &#125; &#125; for(int j = 0; j &lt; 4; j++)&#123; for(int k = 0; k &lt; 5; k++)&#123; if(m[j][k] == &apos;0&apos;)&#123; flip(j+1,k); res++; &#125; &#125; &#125; bool flag = true; for(int j = 0; j &lt; 5; j++)&#123; if(m[4][j] == &apos;0&apos;)&#123; flag = false; break; &#125; &#125; if(flag) ans = min(ans,res); memcpy(m,backup,sizeof(backup)); &#125;&#125;int main()&#123; // freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); int T; scanf(&quot;%d&quot;,&amp;T); getchar(); while(T--)&#123; ans = INF; for(int i = 0; i &lt; 5; i++)&#123; scanf(&quot;%s&quot;,m[i]); // printf(&quot;%s\\\\n&quot;,m[i]); &#125; solve(); if(ans &gt; 6) ans = -1; printf(&quot;%d\\\\n&quot;,ans); &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"POJ-1062-昂贵的聘礼","slug":"POJ-1062-昂贵的聘礼","date":"2019-08-13T13:38:00.000Z","updated":"2020-08-27T15:06:24.636Z","comments":true,"path":"2019/08/13/POJ-1062-昂贵的聘礼/","link":"","permalink":"https://yangzebin001.github.io/2019/08/13/POJ-1062-昂贵的聘礼/","excerpt":"","text":"POJ-1062 年轻的探险家来到了一个印第安部落里。在那里他和酋长的女儿相爱了，于是便向酋长去求亲。酋长要他用10000个金币作为聘礼才答应把女儿嫁给他。探险家拿不出这么多金币，便请求酋长降低要求。酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要8000金币。如果你能够弄来他的水晶球，那么只要5000金币就行了。”探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。另外他要告诉你的是，在这个部落里，等级观念十分森严。地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。他是一个外来人，所以可以不受这些限制。但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。因此你需要在考虑所有的情况以后给他提供一个最好的方案。 为了方便起见，我们把所有的物品从1开始进行编号，酋长的允诺也看作一个物品，并且编号总是1。每个物品都有对应的价格P，主人的地位等级L，以及一系列的替代品Ti和该替代品所对应的”优惠”Vi。如果两人地位等级差距超过了M，就不能”间接交易”。你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。 输入第一行是两个整数M，N（1 &lt;= N &lt;= 100），依次表示地位等级差距限制和物品的总数。接下来按照编号从小到大依次给出了N个物品的描述。每个物品的描述开头是三个非负整数P、L、X（X &lt; N），依次表示该物品的价格、主人的地位等级和替代品总数。接下来X行每行包括两个整数T和V，分别表示替代品的编号和”优惠价格”。 输出最少需要的金币数。 输入示例：1234567891 410000 3 22 80003 50001000 2 14 2003000 2 14 20050 2 0 输出示例：15250 题目大意：一开始需要n金币，每个物品都有自己的价值，你可以用其他物品来抵消一部分金币（优惠价格），而用来抵消的物品也可以由其他物品来抵消该物品的一部分，如此往复。并且主人是分等级的，要确保交换物品过程中任何两个人的等级差距都不能超过M。问最少需要的金币数量。 思路：把每个物品看成结点，B物品可以抵消A物品的一部分,表示A有一条边指向B,边权是替代品的优惠价格，点权为该物品的价值。 可以求第一个物品到其他物品的最短路，松弛操作为： 1dis[v] &gt; dis[u] + u到v的边权 这样求得的dis为每个顶点到起点的优惠价格，而到当前点的总花费为： 1dis[i] + coin[i] //优惠价格+当前物品的价格 而题目还有一层约束条件为物品交换不能超过等级差距。我们就需要检查每个点到起点的等级差了。例如起点的等级为5，等级差距为3，则要枚举的区间为 3 ~ 5、4 ~ 6、5 ~ 7 ，在每个区间中，求符合等级差距的点，并求起点到该点的最短路（这里比较绕，建议多思考下）。最后答案取一个最小值即可。 Solution：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int MAXN = 110;const int INF = 0x3f3f3f3f;struct Edge&#123; int to,cost; Edge()&#123;&#125;; Edge(int _to,int _cost)&#123; to = _to; cost = _cost; &#125;;&#125;;struct qnode&#123; int v,cost; qnode(int _v, int _cost)&#123; v = _v; cost = _cost; &#125; qnode()&#123;&#125; bool operator &lt;(const qnode &amp;b)const&#123; return cost &gt; b.cost; &#125;&#125;;vector&lt;Edge&gt; G[MAXN];int coin[MAXN]; //价值多少金币 int dis[MAXN]; //最少优惠 int vis[MAXN]; int pos[MAXN]; //等级 int M,N;int ans; void Dijkstra(int S,int N)&#123; for(int i = 1; i &lt;= N; i++)&#123; dis[i] = S== i ? 0 : INF; &#125; priority_queue&lt;qnode&gt; pq; pq.push(qnode(S,dis[S])); qnode temp; while(pq.size())&#123; temp = pq.top();pq.pop(); int u = temp.v; if(vis[u])continue; vis[u] = 1; for(int i = 0; i &lt; G[u].size(); i++)&#123; int v = G[u][i].to; int vc = G[u][i].cost; if(!vis[v] &amp;&amp; dis[v] &gt; dis[u] + vc)&#123; dis[v] = dis[u] + vc; //更新答案 ans = min(ans,dis[v] + coin[v]); pq.push(qnode(v,dis[v])); &#125; &#125; &#125;// for(int i = 1; i &lt;= N; i++)&#123;// ans = min(ans,dis[i] + coin[i]); // &#125; &#125;void init(int N)&#123; for(int i = 0; i &lt;= N; i++)&#123; G[i].clear(); &#125;&#125; int main()&#123; //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d %d&quot;,&amp;M,&amp;N); init(N); for(int i = 1; i &lt;= N; i++)&#123; int c,r,n; scanf(&quot;%d%d%d&quot;,&amp;c,&amp;r,&amp;n); coin[i] = c; pos[i] = r; for(int j = 1; j &lt;= n; j++)&#123; int t,cost; scanf(&quot;%d%d&quot;,&amp;t,&amp;cost); G[i].push_back(Edge(t,cost)); &#125; &#125; //设最大值为起始值 ans = coin[1]; for(int i = 0; i &lt;= M; i++)&#123; //更新每个点是否在当前区间内 for(int j = 1; j &lt;= N; j++)&#123; if(pos[j] &gt;= pos[1]-M+i &amp;&amp; pos[j] &lt;= pos[1]+i) vis[j] = 0; else vis[j] = 1; &#125; //求一下当前区间的最短路。 Dijkstra(1,N); &#125; printf(&quot;%d&quot;,ans); return 0;&#125;","categories":[],"tags":[]},{"title":"POJ-2965-Th-Pilot-Brothers-refrigerator","slug":"POJ-2965-Th-Pilot-Brothers-refrigerator","date":"2019-08-09T01:43:00.000Z","updated":"2020-08-27T15:06:24.629Z","comments":true,"path":"2019/08/09/POJ-2965-Th-Pilot-Brothers-refrigerator/","link":"","permalink":"https://yangzebin001.github.io/2019/08/09/POJ-2965-Th-Pilot-Brothers-refrigerator/","excerpt":"","text":"POJ-2965 题目大意：有一个4X4的冰箱阵列，当你改变一个冰箱门的状态（开或关），同行同列的冰箱门也会发生改变，给定一个序列，问从全部的冰箱门打开（“-”为开、“+”为关）到给定序列需要几步，以及具体的打开方式。 输入示例：1234-+-----------+-- 输出示例：123456761 11 31 44 14 34 4 Solution1（枚举）:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int m[4][4];int dx[16],dy[16],ans[16][2];int ansn = 40;bool isComplete()&#123; for(int i = 0; i &lt; 4; i++)&#123; for(int j = 0; j &lt; 4; j++)&#123; if(m[i][j] == 1) return false; &#125; &#125; return true;&#125;void flip(int i, int j)&#123; for(int k = 0; k &lt; 4; k++)&#123; m[k][j] = !m[k][j]; m[i][k] = !m[i][k]; &#125; //m[i][j]被翻转了两次，再翻转抵消一次。 m[i][j] = !m[i][j];&#125;//d:翻转的次数，s:要翻转的序号void dfs(int d, int s)&#123; if(isComplete())&#123; ansn = min(ansn,d); for(int i = 0; i &lt; ansn; i++)&#123; ans[i][0] = dx[i]; ans[i][1] = dy[i]; &#125; &#125; if(s &gt;= 16) return; dfs(d,s+1); flip(s/4,s%4); dx[d] = s/4; dy[d] = s%4; dfs(d+1,s+1); flip(s/4,s%4); dx[d] = 0; dy[d] = 0;&#125;int main()&#123; for(int i = 0; i &lt; 4; i++)&#123; for(int j = 0; j &lt; 4; j++)&#123; char c; scanf(&quot;%c&quot;,&amp;c); m[i][j] = c == &apos;+&apos; ? 1 : 0; &#125; getchar(); &#125; dfs(0,0); printf(&quot;%d\\\\n&quot;,ansn); for(int i = 0; i &lt; ansn; i++)&#123; printf(&quot;%d %d\\\\n&quot;,ans[i][0]+1,ans[i][1]+1); &#125; return 0;&#125; 思路：直接枚举所有的状态，每个冰箱门都有转换和不转换两种状态，一共有16个冰箱门，所以有2的16次方种状态。在所有的序列中取一个步数最小的即可。 Solution2（位运算压缩）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int dx[16],ans[16];int ansn = 40;int state;void flip(int i, int j)&#123; for(int k = 0; k &lt; 4; k++)&#123; state = state ^ (1&lt;&lt; (i*4+k)); state = state ^ (1 &lt;&lt; (k*4+j)); &#125; state = state ^ (1 &lt;&lt; (i*4+j));&#125;//d:翻转的次数，s:要翻转的序号void dfs(int d, int s)&#123; if(!state)&#123; //更新结果 ansn = min(ansn,d); for(int i = 0; i &lt; ansn; i++)&#123; ans[i] = dx[i]; &#125; &#125; if(s &gt;= 16) return; dfs(d,s+1); //翻转 flip(s/4,s%4); //保留翻转的位置 dx[d] = 1 &lt;&lt; s; dfs(d+1,s+1); //回溯 flip(s/4,s%4); dx[d] = 0;&#125;int Pos(int a)&#123; int ans = 0; while(a)&#123; ans++; a &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; for(int i = 0; i &lt; 4; i++)&#123; for(int j = 0; j &lt; 4; j++)&#123; char c; scanf(&quot;%c&quot;,&amp;c); // m[i][j] = c == &apos;+&apos; ? 1 : 0; if(c == &apos;+&apos;) state = state | (1 &lt;&lt; (i*4+j)); &#125; getchar(); &#125; dfs(0,0); printf(&quot;%d\\\\n&quot;,ansn); for(int i = 0; i &lt; ansn; i++)&#123; int a = Pos(ans[i])-1; printf(&quot;%d %d\\\\n&quot;,a/4+1,a%4+1); &#125; return 0;&#125; 思路：在上一题解的基础上，我们发现没有必要用二维数组来存储状态，可以使用一个16位的整数来存储，第几位二进制位表示第几个冰箱的状态。 记录改变冰箱的位置也同样可以使用一个16位的整数来存储。1表示该冰箱门改变了状态，所有的改变不会超过16个，使用16个整数就可以表示全部的移动的过程。 然后更新结果，并提取出来每一位即可。 Solution3（找规律）：通过找规律我们发现： 一个冰箱门状态改变两次等于不变。 在上一条的基础上，如果以某一冰箱门为基准，将该冰箱门所在的行列上所有的冰箱门都翻转一次，该冰箱门改变，其他冰箱门都不变。 所以我们只要从结果反向推，将每个关闭的冰箱门所在的行列的冰箱门都翻转，更新每个冰箱门的改变的次数，结果状态就为当所有的关闭的冰箱门都被打开后的状态。当次数为奇数说明我们需要改变，偶数则忽略。最后遍历一遍结果数组，取出次数为奇数的冰箱门的坐标即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int record[16][16];void flip(int i, int j)&#123; for(int k = 0; k &lt; 4; k++)&#123; record[i][k]++; record[k][j]++; &#125; record[i][j]--;&#125;int main()&#123; for(int i = 0; i &lt; 4; i++)&#123; for(int j = 0; j &lt; 4; j++)&#123; char c; scanf(&quot;%c&quot;,&amp;c); if(c == &apos;+&apos;) flip(i,j); &#125; getchar(); &#125; int cnt = 0; for(int i = 0; i &lt;4; i++)&#123; for(int j = 0; j &lt; 4; j++)&#123; if(record[i][j]&amp;1) cnt++; &#125; &#125; printf(&quot;%d\\\\n&quot;,cnt); for(int i = 0; i &lt; 4; i++)&#123; for(int j = 0; j &lt; 4; j++)&#123; if(record[i][j]&amp;1)&#123; printf(&quot;%d %d\\\\n&quot;,i+1,j+1); &#125; &#125; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"LeetCode-785-判断二分图","slug":"LeetCode-785-判断二分图","date":"2019-08-06T13:44:00.000Z","updated":"2020-08-27T15:06:24.624Z","comments":true,"path":"2019/08/06/LeetCode-785-判断二分图/","link":"","permalink":"https://yangzebin001.github.io/2019/08/06/LeetCode-785-判断二分图/","excerpt":"","text":"785. 判断二分图 给定一个无向图graph，当这个图为二分图时返回true。 如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。 graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。 示例 1:123456789输入: [[1,3], [0,2], [1,3], [0,2]]输出: true解释: 无向图如下:0----1| || |3----2我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;。 示例 2:12345678输入: [[1,2,3], [0,2], [0,1,3], [0,2]]输出: false解释: 无向图如下:0----1| \\ || \\ |3----2 我们不能将节点分割成两个独立的子集。 注意: graph 的长度范围为 [1, 100]。 graph[i] 中的元素的范围为 [0, graph.length - 1]。 graph[i] 不会包含 i 或者有重复的值。 图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。 一个裸二分图染色题。Solution1（DFS）：1234567891011121314151617181920class Solution &#123;public: bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; int vis[graph.size()] = &#123;false&#125;; for(int i = 0; i &lt; graph.size(); i++)&#123; for(int j = 0; j &lt; graph[i].size(); j++)&#123; if(vis[graph[i][j]] == 0 &amp;&amp; !dfs(graph,vis,graph[i][j],1)) return false; &#125; &#125; return true; &#125; bool dfs(vector&lt;vector&lt;int&gt;&gt;&amp; G,int vis[],int j, int c)&#123; vis[j] = c; for(int i = 0; i &lt; G[j].size(); i++)&#123; if(vis[G[j][i]] == c) return false; if(vis[G[j][i]] == 0 &amp;&amp; !dfs(G,vis,G[j][i],-c)) return false; &#125; return true; &#125;&#125;; 思路：二分染色题。重点在dfs函数的编写，到达当前结点，先染色，再判断与之相连的结点的颜色是否被染过，如果没有染过，则染与当前结点不同的颜色，如果染过色且与当前结点颜色相同则表示不符合要求，颜色不同则可以直接忽略。 Solution2（BFS）:123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; int vis[graph.size()] = &#123;0&#125;; queue&lt;int&gt; q; int curr = -1; while(1)&#123; if(q.size() == 0)&#123; int k; for(k = 0; k &lt; graph.size(); k++)&#123; if(vis[k] == 0)&#123; q.push(k); break; &#125; &#125; if(k == graph.size()) break; &#125; curr *= -1; int len = q.size(); for(int j = 0; j &lt; len; j++)&#123; int f = q.front(); q.pop(); vis[f] = curr; for(int i = 0; i &lt; graph[f].size(); i++)&#123; if(vis[graph[f][i]] == curr) return false; if(vis[graph[f][i]] == 0)&#123; q.push(graph[f][i]); &#125; &#125; &#125; &#125; return true; &#125;&#125;; 思路：与DFS思路相同，只不过改写为BFS版。 注意：给定的图有可能为多棵树组成的森林。所以每个树都要考虑到。","categories":[],"tags":[]},{"title":"LeetCode-207-课程表","slug":"LeetCode-207-课程表","date":"2019-08-06T13:22:00.000Z","updated":"2020-08-27T15:06:24.622Z","comments":true,"path":"2019/08/06/LeetCode-207-课程表/","link":"","permalink":"https://yangzebin001.github.io/2019/08/06/LeetCode-207-课程表/","excerpt":"","text":"207. 课程表 现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？ 示例 1: 输入: 2, [[1,0]] 输出: true 解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例 2: 输入: 2, [[1,0],[0,1]] 输出: false 解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 Solution1（DFS）:12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123; if(numCourses &lt;= 0) return true; vector&lt;int&gt; G[numCourses]; int vis[numCourses] = &#123;0&#125;; for(int i = 0; i &lt; numCourses; i++) G[i].clear(); for(int i = 0; i &lt; prerequisites.size(); i++)&#123; G[prerequisites[i][1]].push_back(prerequisites[i][0]); &#125; for(int i = 0; i &lt; numCourses; i++)&#123; if(!vis[i])&#123; if(!dfs(G,vis,i)) return false; &#125; &#125; return true; &#125; bool dfs(vector&lt;int&gt; G[], int vis[],int j)&#123; vis[j] = 2; for(int i = 0; i &lt; G[j].size(); i++)&#123; if(vis[G[j][i]] == 2) return false; if(!vis[G[j][i]])&#123; if(!dfs(G,vis,G[j][i])) return false; &#125; &#125; vis[j] = 1; return true; &#125; &#125;; 思路:把该题看做判断一个有向图是否有环的问题。进而可以看做一个染色问题： 如果该节点没有被访问过，则是白色（用0表示）。 如果该节点正在访问，但是没有访问结束，则是灰色（用2表示）。 如果该节点已经访问，则是黑色（用1表示）。 只有在DFS中维护颜色数组（我这里为vis数组）即可。 Solution2（拓扑排序）：1234567891011121314151617181920212223242526272829class Solution &#123;public: bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123; int inDegree[numCourses] = &#123;0&#125;; vector&lt;int&gt; G[numCourses]; for(int i = 0; i &lt; prerequisites.size(); i++)&#123; G[prerequisites[i][1]].push_back(prerequisites[i][0]); inDegree[prerequisites[i][0]]++; &#125; queue&lt;int&gt; q; int inqnum = 0; for(int i = 0; i &lt; numCourses; i++)&#123; if(inDegree[i] == 0)&#123; q.push(i); &#125; &#125; while(q.size())&#123; inqnum++; int f = q.front();q.pop(); for(int i = 0; i &lt; G[f].size(); i++)&#123; inDegree[G[f][i]]--; if(inDegree[G[f][i]] == 0)&#123; q.push(G[f][i]); &#125; &#125; &#125; return inqnum == numCourses; &#125;&#125;; 思路：利用拓扑排序，每次将节点入度为零所在的边删去并更新边的另一端节点的入度信息，如果在多轮“删边”之后还有结点，说明有环。","categories":[],"tags":[]},{"title":"Dijkstra算法学习总结","slug":"Dijkstra算法学习总结","date":"2019-07-31T08:19:00.000Z","updated":"2020-08-27T15:06:24.621Z","comments":true,"path":"2019/07/31/Dijkstra算法学习总结/","link":"","permalink":"https://yangzebin001.github.io/2019/07/31/Dijkstra算法学习总结/","excerpt":"","text":"单源最短路径算法 算法流程：对于图G（V，E）维护一个集合S,存放已经被访问过的顶点（准备期间只有源点s），每次从集合V-S中选择与起点s的距离最小的一个顶点（记为u），访问u并加入集合S，并令u为中介点，更新起点s与所有从u能达到的顶点v之间的最短距离。这样执行n次（n为顶点个数），直到集合S包含所有顶点。 适用范围：有向无负权图1.优先队列版 复杂度O(ElogE)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#define INF 0x3f3f3f3fstruct qnode&#123; int v,d; qnode(int _v=0,int _d=0):v(_v),d(_d)&#123;&#125; friend bool operator &lt;(const qnode &amp;r)const&#123; return d&gt;r.d; &#125;&#125;;struct Edge&#123; int v,cost; Edge(int _v=0,int _cost=0):v(_v),cost(_cost)&#123;&#125;&#125;; const int MAXN = 100010;vector&lt;Edge&gt; E[MAXN];//是否访问标志int vis[MAXN];//到源点的最短距离，准备期间设置为无穷大，表示不可及。int dis[MAXN]; //加边void add_edge(int u,int v,int w)&#123; E[u].push_back(Edge(v,w));&#125;//初始化(从0开始编号)void init(int n)&#123; for(int i=0;i&lt;n;i++)&#123; E[i].clear(); &#125;&#125;void Dijkstra(int s,int n)&#123; for(int i=0;i&lt;n;i++)vis[i] = 0; for(int i=0;i&lt;n;i++)dis[i] = (i == s ? 0 : INF); priority_queue&lt;qnode&gt; q;//声明优先队列：每次从队列中取出的是具有最高优先权的元素。 //优先队列第一个参数为比较类型，第二个为容器类型，第三个为比较函数。 //greater实现小顶堆//less 实现大顶堆（默认为大顶堆） q.push(qnode(s,dis[s]));//先将源点推进优先队列 qnode temp; while(!q.empty())&#123;//当队列空时所有边已被访问 temp = q.top();q.pop(); //当前顶点 int u = temp.v; if(vis[u])continue; vis[u] = true; //每一条与u相邻的边都要更新 for(int i=0;i&lt;E[u].size();i++)&#123; //邻点 int v = E[u][i].v; //权重 int cost = E[u][i].cost; //松弛操作，更新权重时机 if(!vis[v] &amp;&amp; dis[u] + cost &lt; dis[v])&#123; dis[v] = dis[u] + cost; //把每一个更新的长度加进队列 q.push(qnode(v,dis[v])); &#125; &#125; &#125;&#125; 2.邻接矩阵版 复杂度O(N^2) 记录路径版1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const int MAXN = 10000;const int INF = 0x3f3f3f3f;bool vis[MAXN];//访问记录int pre[MAXN];//父节点int cost[MAXN][MAXN];//权重矩阵int lowcost[MAXN];//记录最短路径//初始化矩阵为无穷。void Init(int N)&#123; for(int i = 0; i &lt; N; i++)&#123; for(int j = 0; j &lt; N; j++)&#123; cost[i][j] = INF; &#125; &#125; //如果INF是满十六进制表示。如：const int INF = 0x3f3f3f3f; //则可以使用memset(cost,INF,sizeof(cost));&#125;//cost:权重矩阵,lowcost:最短路径，n:数据范围,beg:源点void Dijkstra(int cost[][MAXN],int lowcost[],int n,int beg)&#123; //初始化各值 for(int i = 0; i &lt; n; i++)&#123; lowcost[i] = INF; vis[i] = false; pre[i] = -1; &#125; //设置源点 lowcost[beg] = 0; for(int j = 0; j &lt; n; j++)&#123; int k = -1; int Min = INF; //找到目前最短路径数组中到源点最短的节点。 for(int i = 0; i &lt; n; i++)&#123; if(!vis[i] &amp;&amp; lowcost[i] &lt; Min)&#123; Min = lowcost[i]; k = i; &#125; &#125; //找不到，说明节点都已经全部访问。 if(k == -1)break; //记录该节点。 vis[k] = true; //松弛操作。更新每条与该节点相连并且还未访问到的节点的路径。 for(int i = 0; i &lt; n; i++)&#123; if(!vis[i] &amp;&amp; lowcost[k] + cost[k][i] &lt; lowcost[i])&#123; //发现一条更短的路径，更新。 lowcost[i] = lowcost[k] + cost[k][i]; //更新父节点。 pre[i] = k; &#125; &#125; &#125;&#125; 解题通用思路做关于Dijkstra算法的题，通常不会只出一个裸的寻找最短路径，而是会给出一个或多个次级标尺。通常不会超出三个维度： 边权 点权 多少条最短路径，或该路径的长度。 通常是多个维度组合起来寻找最优解。 遇到这类问题，可通过将每条最短路径都保存下来，依次进行处理。 123456789101112131415161718192021222324252627vector&lt;int&gt; paths[MAXN];//在其松弛操作中，将路径保存for(int j = 0; j &lt; N; j++)&#123; if(!vis[j] &amp;&amp; G[k][j] != INF)&#123; if(dis[j] &gt; dis[k] + G[k][j])&#123; dis[j] = dis[k] + G[k][j]; paths[j].clear(); paths[j].push_back(k); &#125;else if(dis[j] == dis[k] + G[k][j])&#123; paths[j].push_back(k); &#125; &#125;&#125;vector&lt;vector&lt;int&gt; &gt; ans;//用于存放每一个最短路径vector&lt;int&gt; p;//计算每条路径，注意，这样的路径是反序并且不包含源点的，如需要，则单独计算。void makeMinPath(vector&lt;vector&lt;int&gt; &gt; &amp;ans,vector&lt;int&gt; p,int j)&#123; if(j == 0)&#123; ans.push_back(p); return; &#125; for(int i = 0; i &lt; paths[j].size(); i++)&#123; p.push_back(paths[j][i]); makeMinPath(ans,p,paths[j][i]); p.pop_back(); &#125;&#125; 之后就可以根据要求计算每一条路径，并挑出符合问题的解了。","categories":[],"tags":[]},{"title":"AVL树详解","slug":"AVL树详解","date":"2019-07-19T12:29:00.000Z","updated":"2020-08-27T15:06:24.619Z","comments":true,"path":"2019/07/19/AVL树详解/","link":"","permalink":"https://yangzebin001.github.io/2019/07/19/AVL树详解/","excerpt":"","text":"需求我们在学习二叉搜索树的时候，发现无论是查找还是插入元素在理想情况下都可以达到O(logN)级别，但是由于插入的顺序，数的结构也会不同，这种理想情况很难保持甚至最坏的情况会退化成链表。导致性能下降。这时就需要一个能实现高度自动平衡的树结构。就出现了平衡树，今天讲的是平衡树的一种：AVL树。 初识AVL树AVL树得名与 Adelson-Velsky和 Landis两位发明者的首字母，它是自平衡的二叉搜索树，具有二叉树搜索树的性质（左子树的结点都比当前结点小，右子树都比当前结点大），同时它又是平衡二叉树，能够自适应高度。在AVL树中，任意节点的两个子树的高度差不超过1，这也是将不平衡的子树调整为平衡子树的重要指标。 AVL树的调整策略AVL是在进行插入节点时，通过检测是否破坏了平衡条件，进而通过进行一定程度的节点旋转来达到整棵树的平衡。 简单情形我们知道一个树如果只有一个或两个时，树是平衡的。所以问题会出现在第三个节点插入的位置，如果是下图： 则是平衡的。 先来看最简单的不平衡情况： 当把根节点的右节点“提”到根节点的位置，将旧根节点当新的根节点的左子节点。就可达到平衡状态。 具体到树中，可以归结为以下四种情况： 1.左旋上述是最特殊的只有三个节点的情况，下面我们将它代入一般的二叉树来研究： 对于一个节点，当右子树的高度比左子树高一个高度的时候，此时新进来的节点也需要插入右子树。当然，如果新插入节点以后，右子树还维持原来的高度，那么这颗树就还是平衡的。问题出在当新插入节点后，右子树的高度增加了，这时破坏了平衡树两个子树的高度差不超过一的性质，就需要调整使其达到平衡状态。这时，我们首先考虑比较好处理的情况，也就是插在右子树的右边的情况。 调整的策略： 此时我们需要将当前节点的右子树“提”到当前节点的位置，当前节点“下降”为其右子树的左子树，具体操作过程如图： 调整之后变为： 到此，树变成了平衡的，由于整棵树要往左边旋转，所以左旋的操作就右子树的地位上移，根节点的地位下降。 2.右旋现在我们有了左旋的经验，很容易推出需要进行右旋操作的时机： 对于一个节点，当左子树的高度原先就比右子树的高度多一时，插入节点又使左子树的高度增加，并且插在了左子树的左边的时候，就需要调整了： 树变为平衡的。 至此，单旋转就学习完毕，下面学习双旋转。 3.右左旋前面我们学习单旋转时，插入节点都是与其子树同向的位置，这种情况由于倾斜的状况比较明显，所以只要找到中间的位置，将其“提”到“根节点”的位置，就可以达到平衡。而当其中子树失去平衡是由于所处子树往相反的方向插入，导致倾斜的状况不容易看出，所以需要经过两次旋转来达到平衡状态。如下图： 我们可以观察到，在当前的结点的右子树的倾斜情况与我们刚才介绍到的右旋的情况很相似： 所以将右子树按右旋处理，处理之后变为： 这时我们惊奇的发现它变成了我们前面介绍的左旋前时的情形。这种情况我们已经会处理了：将右子节点“提”上来，把当前“根”节点变为右子节点的左子树，最后就调整到平衡状态了。 4.左右旋同样地，左右旋也可通过先将左子树左旋，再将当前根节点右旋的调整来达到平衡状态。 先将左子树左旋： 再进行右旋： 达到平衡状态。 到此，二叉树的调整策略就介绍完了，下面上代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788typedef struct AVLNode* AVLTree;struct AVLNode&#123; int data; AVLTree left; AVLTree right; int height; AVLNode(int data):data(data)&#123; left = NULL; right = NULL; height = 0; &#125;&#125;;int Max(int a, int b)&#123; return a &gt; b ? a : b;&#125;int GetHeight(AVLTree t)&#123; if(!t) return 0; return t-&gt;height;&#125;//右旋 AVLTree SingleRightRotation(AVLTree A)&#123; //先记录左子树,将左节点的右子树变为根节点的左子树，再将根节点作为左节点的右子树。 AVLTree l = A-&gt;left; A-&gt;left = l-&gt;right; l-&gt;right = A; //更新两节点的高度。 A-&gt;height = Max(GetHeight(A-&gt;left),GetHeight(A-&gt;right))+1; l-&gt;height = Max(GetHeight(l-&gt;left),A-&gt;height) + 1; return l; &#125;//左旋 AVLTree SingleLeftRotation(AVLTree A)&#123; //先记录右子树,将右节点的左子树变为根节点的右子树，再将根节点作为右节点的左子树。 AVLTree r = A-&gt;right; A-&gt;right = r-&gt;left; r-&gt;left = A; //更新两节点的高度。 A-&gt;height = Max(GetHeight(A-&gt;left),GetHeight(A-&gt;right)) + 1; r-&gt;height = Max(GetHeight(r-&gt;right),A-&gt;height) + 1; return r;&#125;//右左旋 AVLTree DoubleRightLeftRotation(AVLTree A)&#123; //将左子树右旋 A-&gt;right = SingleRightRotation(A-&gt;right); //再将当前节点左旋 return SingleLeftRotation(A);&#125; //左右旋 AVLTree DoubleLeftRightRotation(AVLTree A)&#123; //将右子树左旋 A-&gt;left = SingleLeftRotation(A-&gt;left); //再将当前节点右旋 return SingleRightRotation(A);&#125; AVLTree Insert(AVLTree T, int X)&#123; if(!T)&#123; T = new AVLNode(X); &#125;else if(X &lt; T-&gt;data)&#123; T-&gt;left = Insert(T-&gt;left,X); if(GetHeight(T-&gt;left)- GetHeight(T-&gt;right) == 2)&#123; if(X &lt; T-&gt;left-&gt;data)&#123; //右旋 T = SingleRightRotation(T); &#125;else&#123; //左右旋 T = DoubleLeftRightRotation(T); &#125; &#125; &#125;else if(X &gt; T-&gt;data)&#123; T-&gt;right = Insert(T-&gt;right,X); if(GetHeight(T-&gt;right)- GetHeight(T-&gt;left) == 2)&#123; if(X &gt; T-&gt;right-&gt;data)&#123; //左旋 T = SingleLeftRotation(T); &#125;else&#123; //右左旋 T = DoubleRightLeftRotation(T); &#125; &#125; &#125; //更新高度 T-&gt;height = Max(GetHeight(T-&gt;left),GetHeight(T-&gt;right))+1; return T;&#125;","categories":[],"tags":[]},{"title":"106-从中序与后序遍历序列构造二叉树","slug":"LeetCode-106-从中序与后序遍历序列构造二叉树","date":"2019-07-13T09:09:00.000Z","updated":"2020-08-27T15:06:24.617Z","comments":true,"path":"2019/07/13/LeetCode-106-从中序与后序遍历序列构造二叉树/","link":"","permalink":"https://yangzebin001.github.io/2019/07/13/LeetCode-106-从中序与后序遍历序列构造二叉树/","excerpt":"","text":"106. 从中序与后序遍历序列构造二叉树 根据一棵树的中序遍历与后序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 中序遍历 1inorder = [9,3,15,20,7] 后序遍历 1postorder = [9,15,7,20,3] 返回如下的二叉树： 12345 3 / \\9 20 / \\ 15 7 Solution123456789101112131415161718TreeNode* makeTree(vector&lt;int&gt;&amp; postorder, int&amp; postindex, vector&lt;int&gt;&amp; inorder,int left, int right)&#123; if(left &lt;= right)&#123; for(int i = 0; i &lt; inorder.size(); i++)&#123; if(postorder[postindex] == inorder[i])&#123; TreeNode* root = new TreeNode(postorder[postindex--]); root-&gt;right = makeTree(postorder,postindex,inorder,i+1,right); root-&gt;left = makeTree(postorder,postindex,inorder,left,i-1); return root; &#125; &#125; &#125; return NULL; &#125; TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; int postindex = postorder.size()-1; return makeTree(postorder,postindex,inorder,0,inorder.size()-1); &#125; 思路：根据后序遍历的特点，每棵子树的根节点总是最后遍历到。 所以用一个按引用传递的指针指向后序数组的末尾，用该值在中序数组中查找，并将该值当做当前树的根节点。 该值位置的左边为以该节点为根节点的左子树的范围，位置右边为右子树的范围，然后不断更新这个范围，递归下去即可，注意边界值。","categories":[],"tags":[]},{"title":"正则表达式全解——正则基础","slug":"正则表达式全解——正则基础","date":"2019-06-02T08:10:00.000Z","updated":"2020-08-27T15:06:24.614Z","comments":true,"path":"2019/06/02/正则表达式全解——正则基础/","link":"","permalink":"https://yangzebin001.github.io/2019/06/02/正则表达式全解——正则基础/","excerpt":"","text":"正则表达式正则基础^表示一行的开始 $表示一行的结束 […]表示其中的字符是选择性（逻辑或）的，要么是a,要么是b,要么是…。 c[a|b]t 可以匹配到cat、cbt[a-z]、[0-9]、[0-9A-Za-z]是支持的。[^$] 匹配空行像 . * + ? 这些词在[]中仅表示字面的意思，利用这一特性，如果想表示原本含义，例如要匹配 . ，可以写为[.] [^…]表示匹配不是其中的字符。为上一条的取反 -连字符，表示一个范围，见上一条。 如果要匹配 - ，请将 - 写在开始位置，如果[-a-z]，匹配-或者是小写字母。 . 表示任意字符（除了换行符）， |表示或者 (cat|dog) 表示要么cat,要么dog,注意：这和[…]不同的是，[…]匹配其中的单个字符，(..|…)可以匹配不同的字符组。 ?表示可选项，类似于单选框，匹配零个或一个。 +表示出现一次或多次。 *表示匹配零次或多次。 {min,max}表示匹配之前的子表达式重复min到max次。（闭区间） {count} 表示匹配count次。 括号与反向引用([0-9]){2,3}add\\1 \\1表示第一个括号中的内容再次使用。 转义字符像 . * + ? 这些词在正则中有特殊的含义，要想使用它原本的含义，使用\\来进行转义。 (…)括号的作用：1.限制多选结构，2.分组，3.捕获文本。 一些特殊的字符 \\t 制表符 \\n换行符 \\r 回车符 \\s 任何空白字符(例如空格符、制表符、换行符等) \\S 除\\s之外的任何字符(所以用(\\s|\\S) * )来表示任意字符。 \\w 相当于[a-zA-Z0-9] 所以经常用\\w+来表示一个单词 \\W \\w取反，也就是[^a-zA-Z0-9] \\d 相当于[0-9] 也就是数字 \\D \\d取反，也就是[^0-9]","categories":[],"tags":[]},{"title":"写在大一期末考试之际","slug":"写在大一期末考试之际","date":"2019-06-01T14:38:00.000Z","updated":"2020-08-27T15:06:24.612Z","comments":true,"path":"2019/06/01/写在大一期末考试之际/","link":"","permalink":"https://yangzebin001.github.io/2019/06/01/写在大一期末考试之际/","excerpt":"","text":"写在大一期末考试之际最近发生了很多各种各样的事，面对即将到来的期末考试，自己真的很没有底气，因为只有自己知道，对于大部分的课程，学的是如何糟糕。我不看重的课程不说，但数学学科的课程自己也没学到什么，一方面是老师的原因，但最多的是自己的问题，学习的重心绝对的向专业偏移，即使是专业，每天学的都是些业务类的技术，如果是这样，我觉得我可以立即辍学，这也不是我上大学的初衷，一定要向研究的方向转变，把数学基础提上来才是我大学应该做的事，大学时光1/4已经过去了，自己却没有调整到合适的状态，实属不应该。不过，也有些收获，算法竞赛这块是我没有预料到的，同时回想自己大一上学期学算法的时候是我最想要的状态，我不知道自己是不是喜欢，但无暇他顾地专心只搞一件事是我想要的，而通过学习它我可以进入这种状态，后来学长又找我说想打acm，我知道这个的难度，也知道意味着什么，但是我觉得人应该有些梦想，先让我做一年试试。 同时，我的学习方法也有很多的不足，很低效，我觉得得花些时间来调整下，通常都是学的快，忘的更快，再要用的时候，又要重新学（虽然会快很多），这也是我写博客项目的原因，一个是记录，一个是整理。记录是记录时光的流逝，整理是整理学习成果。要好好把博客写好了。慢就是快，就像姜文说的：步子迈大了，容易扯着蛋。我时刻提醒自己，一定不能浮起来，要沉下去。","categories":[],"tags":[]},{"title":"LeetCode-98-验证二叉搜索树","slug":"LeetCode-98-验证二叉搜索树","date":"2019-05-30T04:18:39.000Z","updated":"2020-08-27T15:06:24.606Z","comments":true,"path":"2019/05/30/LeetCode-98-验证二叉搜索树/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-98-验证二叉搜索树/","excerpt":"","text":"98. 验证二叉搜索树 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 Solution1：1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; vector&lt;TreeNode*&gt; v; inorder(root,v); for(int i = 1; i &lt; v.size(); i++)&#123; if(v[i-1]-&gt;val &gt;= v[i]-&gt;val)&#123; return false; &#125; &#125; return true; &#125; void inorder(TreeNode* node, vector&lt;TreeNode*&gt; &amp;v)&#123; if(!node) return; inorder(node-&gt;left,v); v.push_back(node); inorder(node-&gt;right,v); &#125;&#125;; 利用二叉搜索树的中序遍历是升序的特性。 将每个元素push进一个vector中，如果vector中元素不是按升序排列，这该树不是二叉搜索树。 Solution2：12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; return helper(root,NULL,NULL); &#125; //返回该结点是否在指定区间内。 bool helper(TreeNode *node, TreeNode *min, TreeNode *max)&#123; if(!node) return true; if((min &amp;&amp; node-&gt;val &lt;= min-&gt;val) || (max &amp;&amp; node-&gt;val &gt;= max-&gt;val)) return false; //左子节点的值不能比当前结点的值大，右节点的值不能不当前结点小。 return helper(node-&gt;left, min, node) &amp;&amp; helper(node-&gt;right, node, max); &#125;&#125;; 根据题目给的三条性质，所有结点及其下面的所有结点均可以构成二叉搜索树， 所以对于非叶子结点，可以以当前结点为根据，划分区间，区间内的点必须比左端点大，比右端点小。 用一个递归函数来不断更新该区间，判断该结点是否在区间内即可。","categories":[],"tags":[]},{"title":"LeetCode-922-按奇偶排序数-II","slug":"LeetCode-922-按奇偶排序数-II","date":"2019-05-30T04:18:38.000Z","updated":"2020-08-27T15:06:24.599Z","comments":true,"path":"2019/05/30/LeetCode-922-按奇偶排序数-II/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-922-按奇偶排序数-II/","excerpt":"","text":"922. 按奇偶排序数组 II 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 Solution:123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt;&amp; A) &#123; int i = 0; int len = A.size(); int j = 1; while(1)&#123; while(i &lt; len &amp;&amp; (A[i] &amp; 1) == 0) i+=2; while(j &lt; len &amp;&amp; (A[j] &amp; 1) != 0) j+=2; if(i &gt;= len || j &gt;= len) break; std::swap(A[i],A[j]); i+=2; j+=2; &#125; return A; &#125; &#125;; 思路：设置两个指针。一个指针只走奇数下标，一个指针只走偶数下标。当碰到不符合条件（奇数下标的值不是奇数，偶数下标的值不是偶数）就停下并交换两个值，之后接着走，直到指针越界为止。 看评论有人用栈或者另外准备两个数组的，速度比原地交换还快，不知道为什么。实现也比较简单，就不赘述了。","categories":[],"tags":[]},{"title":"LeetCode-78-子集","slug":"LeetCode-78-子集","date":"2019-05-30T04:18:37.000Z","updated":"2020-08-27T15:06:24.590Z","comments":true,"path":"2019/05/30/LeetCode-78-子集/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-78-子集/","excerpt":"","text":"78. 子集 Solution1：对于每一项相对每个子集来说，都有放与不放两种选择。 创建一个放元素的递归函数，该函数的作用为将一项放和不放两种选择进行描述。 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; result; vector&lt;int&gt; item; result.push_back(item); putitem(0, nums, item, result); return result; &#125; //把一项放进result中。 void putitem(int i, vector&lt;int&gt;&amp; nums,vector&lt;int&gt; item, vector&lt;vector&lt;int&gt; &gt; &amp;result)&#123; if(i == nums.size())&#123; return; &#125; //每个元素都有放和不放两种选择。 //放 item.push_back(nums[i]); result.push_back(item); putitem(i+1, nums, item, result); //不放 item.pop_back(); putitem(i+1, nums, item, result); &#125;&#125;; Solution2：遍历，遇到一个数就把所有子集加上该数组成新的子集，遍历完毕即是所有子集12345678910111213141516class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; result; vector&lt;int&gt; item; result.push_back(item); for(int i =0; i &lt; nums.size(); i++)&#123; int s = result.size(); for(int j = 0; j &lt; s;j++)&#123; result.push_back(result[j]); result[j].push_back(nums[i]); &#125; &#125; return result; &#125;&#125;; Solution3（位运算）：12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; result; //子集一共有2的n次方种，使用位运算来解。 //每一位代表一个元素。 //如，100 代表[3]、011代表[2,1]。 int all_set = 1 &lt;&lt; nums.size();//2的n次方种； for(int i = 0; i &lt; all_set; i++)&#123; vector&lt;int&gt; item; for(int j = 0; j &lt; nums.size(); j++)&#123; //如果i的第j位为1，说明，有这一位所代表的元素。 // （1 &lt;&lt; j）第j位为1，其他位为0。 // i &amp; (1 &lt;&lt; j)， i 这个数中，j这一位是不是为1。（i中是否包含这个元素） if(i &amp; (1 &lt;&lt; j))&#123; item.push_back(nums[j]); &#125; &#125; //将该子集放入集合中。 result.push_back(item); item.clear(); &#125; return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"LeetCode-88-合并两个有序数组","slug":"LeetCode-88-合并两个有序数组","date":"2019-05-30T04:18:37.000Z","updated":"2020-08-27T15:06:24.593Z","comments":true,"path":"2019/05/30/LeetCode-88-合并两个有序数组/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-88-合并两个有序数组/","excerpt":"","text":"88. 合并两个有序数组 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 Solution:1234567891011121314151617181920class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int tail = m + n -1; int nums1tail = m-1; int nums2tail = n-1; while(nums1tail &gt;= 0 &amp;&amp; nums2tail &gt;= 0)&#123; if(nums1[nums1tail] &gt;= nums2[nums2tail])&#123; nums1[tail] = nums1[nums1tail--]; &#125;else&#123; nums1[tail] = nums2[nums2tail--]; &#125; tail--; &#125; while(nums2tail &gt;= 0) nums1[tail--] = nums2[nums2tail--]; while(nums1tail &gt;= 0) nums1[tail--] = nums1[nums1tail--]; &#125;&#125;; 与归并排序的merge代码类似，不过是从数组的末尾往前比较。","categories":[],"tags":[]},{"title":"LeetCode-92-反转链-II","slug":"LeetCode-92-反转链-II","date":"2019-05-30T04:18:37.000Z","updated":"2020-08-27T15:06:24.597Z","comments":true,"path":"2019/05/30/LeetCode-92-反转链-II/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-92-反转链-II/","excerpt":"","text":"92. 反转链表 II 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 Solution：1234567891011121314151617181920212223242526272829struct ListNode* reverseBetween(struct ListNode* head, int m, int n) &#123; int chang_len = n-m+1;//逆置的结点个数。 struct ListNode* prevHead = NULL;//记录开始逆置结点的前驱。 struct ListNode* result = head;//用于最后返回。 while(head &amp;&amp; --m)&#123; //到达开始逆置的位置。 prevHead = head; head = head-&gt;next; &#125; struct ListNode * modify_list_tail = head;//将该结点之前当前开始逆置的结点。 struct ListNode * newHead = NULL;//用于逆置结点。 while(head &amp;&amp; chang_len)&#123; struct ListNode * next = head-&gt;next; head-&gt;next = newHead; newHead = head; head = next; chang_len--; &#125; //此时head就到了n处，modify_list_tail就到了逆置段的最后一个结点。 //将modify_list_tail 与 head连接。 modify_list_tail-&gt;next = head; if(prevHead)&#123; //如果prevHead不为空，说明不是从第一个几点开始逆置的。 m &gt; 1。 prevHead-&gt;next = newHead; &#125;else&#123; result = newHead; //如果prevHead为空， 则说明是从第一个就开始逆置，直接将逆置后的头结点赋值给res，m=1。 &#125; return result;&#125; 思路：解决这个问题主要是要找关键节点。 这个题的关键节点为： 要逆置的结点的前一个结点（prevHead）。 要逆置的第一个结点。（直接用head来探测）。 要逆置的最后一个结点。（此结点为逆置前的第一个结点，逆置后就变为了最后一个结点） 要逆置的最后一个结点的后一个结点。（在用head逆置后，head就到了逆置后的这个结点。） 找到前两个结点。 从m开始，到n，一共需要n-m+1个结点需要逆置。所以要逆置n-m+1次。 将逆置后的尾结点 与 逆置段后面一个结点相连。 如果结点是从开始逆置，将逆置后的头结点返回。否则，将前面的结点与逆置后的头结点链接返回。","categories":[],"tags":[]},{"title":"LeetCode-59-螺旋矩-II","slug":"LeetCode-59-螺旋矩-II","date":"2019-05-30T04:18:36.000Z","updated":"2020-08-27T15:06:24.579Z","comments":true,"path":"2019/05/30/LeetCode-59-螺旋矩-II/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-59-螺旋矩-II/","excerpt":"","text":"59. 螺旋矩阵 II 给定一个正整数 n，生成一个包含 1 到 n² 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 与54. 螺旋矩阵类似。 只需要依次给新数组中的相应元素赋值即可。 Solution：12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt; &gt; res(n, vector&lt;int&gt;(n));; if(n &lt;= 0) return res; int k = 1; int left = 0, right = n-1, up = 0, down = n-1; while(left &lt; right &amp;&amp; up &lt; down)&#123; int i = left, j = up; while(i &lt; right)&#123; res[j][i] = k++; i++; &#125; while(j &lt; down)&#123; res[j][i] = k++; j++; &#125; while(i &gt; left)&#123; res[j][i] = k++; i--; &#125; while(j &gt; up)&#123; res[j][i] = k++; j--; &#125; left++; right--; up++; down--; &#125; //形不成圈（单列或者单行） if(up == down)&#123; while(left &lt;= right)&#123; res[up][left++] = k++; &#125; &#125;else if(left == right)&#123; while(up &lt;= down)&#123; res[up++][left] = k++; &#125; &#125; return res; &#125;&#125;;","categories":[],"tags":[]},{"title":"LeetCode-693-交替位二进制数","slug":"LeetCode-693-交替位二进制数","date":"2019-05-30T04:18:36.000Z","updated":"2020-08-27T15:06:24.587Z","comments":true,"path":"2019/05/30/LeetCode-693-交替位二进制数/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-693-交替位二进制数/","excerpt":"","text":"693. 交替位二进制数 给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。 示例 1: 输入: 5 输出: True 解释:5的二进制数是: 101 Solution：123456789class Solution &#123;public: bool hasAlternatingBits(int n) &#123; //如果是奇偶交替，则n ^ (n &gt;&gt; 1) 会使有效位全为1， int temp = n ^ (n &gt;&gt; 1); //有效位全为1 再加1， 得到有效位前面为1，后面全为0，再与该数与，则全部清零。 return (temp &amp; (temp+1)) == 0; &#125;&#125;;","categories":[],"tags":[]},{"title":"LeetCode-476-数字的补数","slug":"LeetCode-476-数字的补数","date":"2019-05-30T04:18:34.000Z","updated":"2020-08-27T15:06:24.564Z","comments":true,"path":"2019/05/30/LeetCode-476-数字的补数/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-476-数字的补数/","excerpt":"","text":"476. 数字的补数 给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。 注意: 给定的整数保证在32位带符号整数的范围内。 你可以假定二进制数不包含前导零位。示例 1: 输入: 5 输出: 2 解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。 Solution：1234567891011121314class Solution &#123;public: int findComplement(int num) &#123; int cot = 0; int temp = num; while(1)&#123; if(num == 0) break; num = num &gt;&gt; 1; cot++; &#125; int mark = 0xffffffff; return ~temp ^ (mark &lt;&lt; cot); &#125;&#125;; 首先找到该数是从哪一位开始才算有效（即不包含前面零的位置。）再将该数所有位取反，然后用全位置的1左移cot次，与值异或即可。 异或：不同为一，相同为零，所以当前面的零取反后成为一后，相应位置与1异或，会恢复成为0，之后的有效位还保持不变。","categories":[],"tags":[]},{"title":"LeetCode-51-N皇后","slug":"LeetCode-51-N皇后","date":"2019-05-30T04:18:34.000Z","updated":"2020-08-27T15:06:24.570Z","comments":true,"path":"2019/05/30/LeetCode-51-N皇后/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-51-N皇后/","excerpt":"","text":"51. N皇后 该题为著名的n皇后问题。 Solution：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;string&gt; mark; vector&lt;string&gt; queenposition; vector&lt;vector&lt;string&gt; &gt; map; //初始化。 string a = &quot;&quot;; for(int i = 0; i &lt; n;i++)&#123; a = a + &quot;.&quot;; &#125; for(int i = 0; i &lt; n; i++)&#123; queenposition.push_back(a); mark.push_back(a); &#125; dfs(mark,queenposition,map,0,n); return map; &#125; void putOneQueen(vector&lt;string&gt; &amp;mark,int x,int y,int n)&#123; static const int dx[8] = &#123;-1,-1,-1,0,0,1,1,1&#125;; static const int dy[8] = &#123;-1,0,1,-1,1,-1,0,1&#125;; mark[x][y] = &apos;1&apos;; for(int i = 0; i &lt; 8; i++)&#123; int nx = x + dx[i],ny = y+dy[i]; while(0 &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; n)&#123; mark[nx][ny] = &apos;1&apos;; nx += dx[i]; ny += dy[i]; &#125; &#125; &#125; void dfs(vector&lt;string&gt; &amp;mark,vector&lt;string&gt; &amp;queenposition,vector&lt;vector&lt;string&gt; &gt; &amp;map,int col,int n)&#123; //出口 if(col == n)&#123; map.push_back(queenposition); return; &#125; for(int i = 0; i &lt; n;i++)&#123; if(mark[col][i] == &apos;.&apos;)&#123;//可以放皇后 vector&lt;string&gt; temp_mark = mark;//记录回溯前的镜像。 //放皇后。 queenposition[col][i] = &apos;Q&apos;; putOneQueen(mark,col,i,n); //递归调用。 dfs(mark,queenposition,map,col+1,n); //回溯 mark = temp_mark; queenposition[col][i] = &apos;.&apos;; &#125; &#125; &#125;&#125;; 该题考查对递归与回溯算法的掌握。 使用一个矩阵来存储是否可以放皇后的状态。每当一行放置了一个皇后后，更新其状态，并在下一行中挑选合适的位置来放置该行的皇后。 直到每一行都放置了皇后，保存状态，返回上一个递归过程。 回溯主要针对矩阵的状态和皇后放置的位置，以便利于递归返回过程中的再次使用。","categories":[],"tags":[]},{"title":"LeetCode-45-跳跃游-II","slug":"LeetCode-45-跳跃游-II","date":"2019-05-30T04:18:33.000Z","updated":"2020-08-27T15:06:24.553Z","comments":true,"path":"2019/05/30/LeetCode-45-跳跃游-II/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-45-跳跃游-II/","excerpt":"","text":"45. 跳跃游戏 II 此题55. 跳跃游戏的进阶版 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 按照前面题的思路，依然是从后往前搜索。每次搜索能跳到当前位置的最远位置。 123456789101112131415161718192021222324class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; // 选择当前能跳到当前点的最远的距离。 int max_index = nums.size()-1; int current_max_index = max_index; int step = 0; //当没有到达开头位置，进行循环。 while(max_index &gt; 0)&#123; //记录能跳到当前数组的最前面的点。 for(int i = max_index-1; i &gt;= 0; i--)&#123; if(i + nums[i] &gt;= max_index)&#123; current_max_index = i; &#125; &#125; //更新能跳的最远的点。 max_index = current_max_index; //步数更新 step++; &#125; return step; &#125; &#125;; 用了两层循环，发现能ac，但是又排在了末名。 看了大神的代码，写出了下面的代码： 123456789101112131415161718192021222324252627class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt; 2)&#123; return 0; &#125; //当前可到达的最远距离。 int current_max_index = nums[0]; //遍历各个位置中，可到达的最远距离。 int pre_max_max_index = nums[0]; int jump = 1; for(int i = 1; i &lt; nums.size(); i++)&#123; //更新当前可达到的最远距离。 if(i &gt; current_max_index)&#123; jump++; current_max_index = pre_max_max_index; &#125; if(pre_max_max_index &lt; nums[i] + i)&#123; //更新 pre_max_max_index = nums[i] + i; &#125; &#125; return jump; &#125; &#125;; 跳到当前所能跳到的最远的位置所在的位置中。 记录当前位置所能到达的最远的位置。 如果做到了该最远位置，更新一下。继续走。","categories":[],"tags":[]},{"title":"LeetCode-389-找不同","slug":"LeetCode-389-找不同","date":"2019-05-30T04:18:32.000Z","updated":"2020-08-27T15:06:24.547Z","comments":true,"path":"2019/05/30/LeetCode-389-找不同/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-389-找不同/","excerpt":"","text":"389. 找不同 给定两个字符串 s 和 t，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。 示例: 输入：s = “abcd”t = “abcde” 输出：e 解释：‘e’ 是那个被添加的字母。 Solution:123456789class Solution &#123;public: char findTheDifference(string s, string t) &#123; char e = 0; for(int i = 0; i &lt; s.size(); i++) e ^= s[i]; for(int i = 0; i &lt; t.size(); i++) e ^= t[i]; return e; &#125;&#125;; 与136. 只出现一次的数字一样的思路，考察异或的使用。","categories":[],"tags":[]},{"title":"LeetCode-40-组合总-II","slug":"LeetCode-40-组合总-II","date":"2019-05-30T04:18:32.000Z","updated":"2020-08-27T15:06:24.548Z","comments":true,"path":"2019/05/30/LeetCode-40-组合总-II/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-40-组合总-II/","excerpt":"","text":"40. 组合总和 II 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]] 该题为90. 子集 II的升级版 与上题相同的是，都要保证元素的非重复性，所以与上题使用set部分的代码是一致的。 区别在于在进行递归的过程中，需要随时对条件进行判断，只有满足等于target，才往result中添加。 并且在剪枝的时候，如果元素之和已经比target大，就没有必要进行下去了，直接退出即可。 Solution：123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt; &gt; result; vector&lt;int&gt; item; //去重所使用的集合 set&lt;vector&lt;int&gt;&gt; item_set; //对nums进行排序。 sort(candidates.begin(),candidates.end()); putitem(0, candidates, result, item, item_set,target, 0); return result; &#125; void putitem(int i, vector&lt;int&gt;&amp; nums,vector&lt;vector&lt;int&gt; &gt; &amp;result, vector&lt;int&gt; &amp;item, set&lt;vector&lt;int&gt;&gt; &amp;item_set,int target, int sum)&#123; if(i &gt;= nums.size() || sum &gt; target) return; sum += nums[i]; item.push_back(nums[i]); //如果没有重复，就加入到最终的集合里。 if(sum == target &amp;&amp; item_set.find(item) == item_set.end())&#123; result.push_back(item); //加入去重集合中。 item_set.insert(item); &#125; putitem(i+1, nums, result, item, item_set, target, sum); sum -= nums[i]; item.pop_back(); putitem(i+1, nums, result, item, item_set, target, sum); &#125; &#125;;","categories":[],"tags":[]},{"title":"LeetCode-240-搜索二维矩-II","slug":"LeetCode-240-搜索二维矩-II","date":"2019-05-30T04:18:31.000Z","updated":"2020-08-27T15:06:24.538Z","comments":true,"path":"2019/05/30/LeetCode-240-搜索二维矩-II/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-240-搜索二维矩-II/","excerpt":"","text":"240. 搜索二维矩阵 II 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 Solution：12345678910111213class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if(matrix.size() &lt;= 0) return false; int i = 0, j = matrix[0].size()-1; while(i &lt; matrix.size() &amp;&amp; j &gt;= 0)&#123; if(target == matrix[i][j]) return true; else if(target &gt; matrix[i][j]) i++; else if(target &lt; matrix[i][j]) j--; &#125; return false; &#125;&#125;; 思路： 从矩阵的左上角出发，如果比目标值大，向左移，如果比目标值小，向下移。出界或找到则结束。 对于一列，如果比当前值小，说明不在当前列中，列减一（缩小搜索范围）。 对于一行，如果比当前值小，则往前移动一个位置。 经过不断缩小范围（以经过的点划矩形），就可以得知目标值是否存在矩阵中。","categories":[],"tags":[]},{"title":"LeetCode-234.回文链表","slug":"LeetCode-234.回文链表","date":"2019-05-30T04:18:30.000Z","updated":"2020-08-27T15:06:24.526Z","comments":true,"path":"2019/05/30/LeetCode-234.回文链表/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-234.回文链表/","excerpt":"","text":"234.回文链表 请判断一个链表是否为回文链表。Solution1：1234567891011121314151617181920212223242526272829303132333435//获得链表长度int getListLength(ListNode* head)&#123; int len = 0; while(head)&#123; head = head-&gt;next; len++; &#125; return len;&#125;class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; ListNode* head1 = head; int listlen = getListLength(head1); if(listlen &lt;= 1) return true; int mid = listlen/2; std::stack&lt;int&gt; s; while(mid &amp;&amp; head)&#123; s.push(head-&gt;val); head = head-&gt;next; mid--; &#125; if(listlen%2 != 0)&#123; head = head-&gt;next; &#125; while(head)&#123; if(head-&gt;val != s.top())&#123; return false; &#125; s.pop(); head = head-&gt;next; &#125; return true; &#125;&#125;; 思路:借助stack。 将mid之前的元素值都push进stack中，然后到mid之后，将每个元素与栈顶值比较。不相等退出，相等继续下一轮。 Solution2：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//获得链表长度int getListLength(ListNode* head)&#123; int len = 0; while(head)&#123; head = head-&gt;next; len++; &#125; return len;&#125;//根据位置与所给链表，向后移动position步。ListNode* getNodeByPosition(ListNode* head,int position)&#123; while(position&gt;0)&#123; head = head-&gt;next; position--; &#125; return head;&#125;class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; //存储头结点。 ListNode* first = head; ListNode* head1 = head; int listlen = getListLength(head); int midposition = listlen/2; //如果链表长度&lt;=1，直接返回true; if(listlen &lt;= 1) return true; //到达需要翻转的长度，对于偶数，为（listlen/2）+1，对于奇数，为listlen/2; ListNode* mid = getNodeByPosition(head1,midposition); //翻转mid之后的指针。 ListNode * newHead = NULL; int position = listlen-midposition; while(mid &amp;&amp; position)&#123; ListNode* next = mid-&gt;next; mid-&gt;next = newHead; newHead = mid; mid = next; position--; &#125; //将翻转之后的链表与开头的链表的内容比较，向后比较listlen/2; //如果是偶数，则元素都会比较到，如果是奇数，最后一个元素不会比较到。他在原来的链表中就处于中心位置，不必比较。 while(first &amp;&amp; newHead &amp;&amp; midposition)&#123; //只要不相等，就为false; if(first-&gt;val != newHead-&gt;val) return false; first = first-&gt;next; newHead = newHead-&gt;next; midposition--; &#125; return true; &#125;&#125;; 思路：将链表的后半段翻转，从翻转位置开始与从头结点开始，依次比较（listlen/2次）。","categories":[],"tags":[]},{"title":"LeetCode-235-二叉搜索树的最近公共祖先","slug":"LeetCode-235-二叉搜索树的最近公共祖先","date":"2019-05-30T04:18:30.000Z","updated":"2020-08-27T15:06:24.527Z","comments":true,"path":"2019/05/30/LeetCode-235-二叉搜索树的最近公共祖先/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-235-二叉搜索树的最近公共祖先/","excerpt":"","text":"235. 二叉搜索树的最近公共祖先 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” Solution1（递归版）：1234567891011121314151617181920/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)&#123; return lowestCommonAncestor(root-&gt;right,p,q); &#125;else if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)&#123; return lowestCommonAncestor(root-&gt;left,p,q); &#125; return root; &#125;&#125;; ONELINE版：123456class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; return ((root-&gt;val - p-&gt;val) * (root-&gt;val - q-&gt;val) &lt; 1) ? root: lowestCommonAncestor(root-&gt;val &lt; p-&gt;val ? root-&gt;right : root-&gt;left, p, q ) ; &#125;&#125;; 1(root-&gt;val - p-&gt;val) * (root-&gt;val - q-&gt;val) &lt; 1 这段代码表示给定的两个结点是否在当前节点的两个不同的子树上，或者两个节点中有节点与当前所在节点相同。如果是，则该节点就是最近公共祖先。如果不是，说明在同一棵子树上，转移到该子树上继续递归调用。 Solution2（迭代版）：123456789class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; while((root-&gt;val - p-&gt;val) * (root-&gt;val - q-&gt;val) &gt; 0)&#123; root = root-&gt;val &gt; p-&gt;val ? root-&gt;left : root-&gt;right; &#125; return root; &#125;&#125;; 与上面思路类似。","categories":[],"tags":[]},{"title":"LeetCode-22-括号生成","slug":"LeetCode-22-括号生成","date":"2019-05-30T04:18:29.000Z","updated":"2020-08-27T15:06:24.502Z","comments":true,"path":"2019/05/30/LeetCode-22-括号生成/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-22-括号生成/","excerpt":"","text":"22. 括号生成 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。例如，给出 n = 3，生成结果为： [ “((()))”, “(()())”, “(())()”, “()(())”, “()()()”] Solution：12345678910111213141516171819202122class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; result; putone(&quot;&quot;,n,n,result); return result; &#125; void putone(string item, int left, int right, vector&lt;string&gt; &amp;result)&#123; if(left == 0 &amp;&amp; right == 0)&#123; result.push_back(item); return; &#125; //只要left还能放。 if(left &gt; 0)&#123; putone(item+ &quot;(&quot;,left-1,right,result); &#125; //left放的比right多， if(left &lt; right)&#123; putone(item+ &quot;)&quot;,left,right-1,result); &#125; &#125;&#125;; 使用递归+回溯来解决。 该题主要是要找放括号的时机。 首先要先放左括号。 第二，只要放左括号的个数比右括号多，就可以放右括号。","categories":[],"tags":[]},{"title":"LeetCode-167-两数之-I--输入有序数组","slug":"LeetCode-167-两数之-I--输入有序数组","date":"2019-05-30T04:18:28.000Z","updated":"2020-08-27T15:06:24.489Z","comments":true,"path":"2019/05/30/LeetCode-167-两数之-I--输入有序数组/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-167-两数之-I--输入有序数组/","excerpt":"","text":"167. 两数之和 II - 输入有序数组 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。示例: 输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 Solution：1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; vector&lt;int&gt; a; int lower = 0; int higher = numbers.size()-1; while(lower &lt; higher)&#123; if(numbers[lower] + numbers[higher] &lt; target)&#123; lower++; &#125;else if(numbers[lower] + numbers[higher] &gt; target)&#123; higher--; &#125;else&#123; a.push_back(lower+1); a.push_back(higher+1); break; &#125; &#125; return a; &#125;&#125;; 使用双指针技巧，一个从前扫描，一个从后扫描。符合条件退出。","categories":[],"tags":[]},{"title":"LeetCode-190-颠倒二进制位","slug":"LeetCode-190-颠倒二进制位","date":"2019-05-30T04:18:28.000Z","updated":"2020-08-27T15:06:24.493Z","comments":true,"path":"2019/05/30/LeetCode-190-颠倒二进制位/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-190-颠倒二进制位/","excerpt":"","text":"190. 颠倒二进制位 颠倒给定的 32 位无符号整数的二进制位。 示例 1： 输入: 00000010100101000001111010011100 输出: 00111001011110000010100101000000 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 Solution：1234567891011121314151617class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; uint32_t t = 0; int i = 32; while(i--)&#123; t &lt;&lt;= 1; //获得原数第一位的状态。 int a = n&amp;1; //将该状态赋给该数第一位。 t |= a; //原数右移。 n &gt;&gt;= 1; &#125; return t; &#125;&#125;; 思路： 初始化一个全位置为0的数，将原数的最后一位赋给该数的最后一位，原数右移，该数左移，如此32次。","categories":[],"tags":[]},{"title":"LeetCode-191-位1的个-&- 231-2的幂","slug":"LeetCode-191-位1的个-&- 231-2的幂","date":"2019-05-30T04:18:28.000Z","updated":"2020-08-27T15:06:24.495Z","comments":true,"path":"2019/05/30/LeetCode-191-位1的个-&- 231-2的幂/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-191-位1的个-&- 231-2的幂/","excerpt":"","text":"191. 位1的个数 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。Solution1：1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int cot = 0; while(n)&#123; cot += n&amp;1; n &gt;&gt;= 1; &#125; return cot; &#125;&#125;; 思路：将每一位移到最后一位检查是否为1，到0为止，最后返回个数。 由于是无符号整型，每次都会执行32次，所以时间复杂度是O(1)。 Solution2（优化）： 1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int cot = 0; while(n)&#123; n &amp;= (n-1); cot++; &#125; return cot; &#125;&#125;; 看了官方题解，这种方法是每一次将最后一个1给消除。这样顶多执行k次，k就为1的个数。这样就又优化了一点点计算。 eg： 11010 &amp; 11001 = 11000 11000 &amp; 10111 = 10000 10000 &amp; 01111 = 0 231. 2的幂给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 有了上面的思路： 这道题就可以写成这样： 123456class Solution &#123;public: bool isPowerOfTwo(int n) &#123; return n &gt; 0 &amp;&amp; !(n &amp; (n-1)); &#125;&#125;; 2的n次方在二进制中就是只有1个位置是1，其他全是0（对于正数）。","categories":[],"tags":[]},{"title":"LeetCode-142-环形链-II","slug":"LeetCode-142-环形链-II","date":"2019-05-30T04:18:27.000Z","updated":"2020-08-27T15:06:24.480Z","comments":true,"path":"2019/05/30/LeetCode-142-环形链-II/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-142-环形链-II/","excerpt":"","text":"142. 环形链表 II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。Solution1:123456789101112131415class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; std::set&lt;ListNode*&gt; node_set; while(head)&#123; if(node_set.find(head) == node_set.end())&#123; node_set.insert(head); &#125;else&#123; return head; &#125; head = head-&gt;next; &#125; return NULL; &#125;&#125;; 与141号问题的Solutions1一个思路，直接使用set。只不过返回的是结点不是boolean值罢了。 Solutions2:123456789101112131415161718192021222324252627282930313233class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; ListNode * head1 = head; ListNode * slow = head; ListNode * fast = head; //fast走一步，slow走两步 while(fast)&#123; slow = slow-&gt;next; fast = fast-&gt;next; if(fast)&#123; fast = fast-&gt;next; &#125;else&#123; //没有环退出 return NULL; &#125; //有环退出循环 if(fast == slow)&#123; break; &#125; &#125; //说明有环 while(head1 &amp;&amp; fast)&#123; if(head1 == fast)&#123; return fast; &#125; head1 = head1-&gt;next; fast = fast-&gt;next; &#125; //不会走到这步，只是为了保证函数正常运行 return NULL; &#125;&#125;; 思路：这种方法只会使用O(1)的空间。 该方法的思路需要一点数学基础： 在一个有环的链表中，slow指针与fast指针相遇，从该相遇的位置开始，与链表的头位置开始，两者走同样的步数，如果两者相交，就走到了环的开始位置。","categories":[],"tags":[]},{"title":"LeetCode-153-寻找旋转排序数组中的最小值","slug":"LeetCode-153-寻找旋转排序数组中的最小值","date":"2019-05-30T04:18:27.000Z","updated":"2020-08-27T15:06:24.484Z","comments":true,"path":"2019/05/30/LeetCode-153-寻找旋转排序数组中的最小值/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-153-寻找旋转排序数组中的最小值/","excerpt":"","text":"153. 寻找旋转排序数组中的最小值 假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。你可以假设数组中不存在重复元素。 示例 1: 12输入: [3,4,5,1,2]输出: 1 示例 2: 12输入: [4,5,6,7,0,1,2]输出: 0 Solution：12345678910111213141516171819202122class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int lo = 0; int hi = nums.size()-1; while(lo &lt; hi)&#123; int mid = (lo+hi)/2; //如果比右边大，说明在逆序数组中。 //从mid位置的下一个元素继续查找。 if(nums[mid] &gt; nums[hi])&#123; lo = mid+1; &#125; //如果不比右边的大，说明已在正序数组中。 // 缩小右边的范围。 else&#123; hi = mid; &#125; &#125; //hi == lo return nums[lo]; &#125;&#125;; 使用二分法。 当中间元素比右边界要大时，说明在逆序数组中，这时，令lo = mid + 1。 否则说明在顺序数组中，不断缩小范围直到 lo = hi 时，返回。","categories":[],"tags":[]},{"title":"LeetCode-136-只出现一次的数字","slug":"LeetCode-136-只出现一次的数字","date":"2019-05-30T04:18:26.000Z","updated":"2020-08-27T15:06:24.454Z","comments":true,"path":"2019/05/30/LeetCode-136-只出现一次的数字/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-136-只出现一次的数字/","excerpt":"","text":"136. 只出现一次的数字 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1]输出: 1 Solution：12345678910class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int a = 0; for(int i = 0; i &lt; nums.size(); i++)&#123; a = a ^ nums[i]; &#125; return a; &#125;&#125;; 使用异或来消除相同的元素。异或：两数相同，异或为0；两数不同，异或为1； a ^ a = 0; a ^ 0 = a;","categories":[],"tags":[]},{"title":"LeetCode-112-路径总和","slug":"LeetCode-112-路径总和","date":"2019-05-30T04:18:25.000Z","updated":"2020-08-27T15:06:24.445Z","comments":true,"path":"2019/05/30/LeetCode-112-路径总和/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-112-路径总和/","excerpt":"","text":"112. 路径总和 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 Solution1:123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(!root) return false; return dfs(root,0,sum); &#125; bool dfs(TreeNode* node,int currentsum, int sum)&#123; currentsum += node-&gt;val; if(node &amp;&amp; !node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; currentsum == sum) return true; bool a = false,b = false; if(node-&gt;left)&#123; a = dfs(node-&gt;left,currentsum,sum); &#125; if(node-&gt;right)&#123; b = dfs(node-&gt;right,currentsum,sum); &#125; return a || b; &#125;&#125;; 递归终止条件为叶子节点。","categories":[],"tags":[]},{"title":"LeetCode-113-路径总-II","slug":"LeetCode-113-路径总-II","date":"2019-05-30T04:18:25.000Z","updated":"2020-08-27T15:06:24.448Z","comments":true,"path":"2019/05/30/LeetCode-113-路径总-II/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-113-路径总-II/","excerpt":"","text":"113. 路径总和 II 该题为112. 路径总和的升级版 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 Solution1：12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt; &gt; result; if(root)&#123; dfs(root,0,sum,path,result); &#125; return result; &#125; void dfs(TreeNode* node,int currentsum, int sum,vector&lt;int&gt; &amp;path,vector&lt;vector&lt;int&gt; &gt; &amp;result)&#123; currentsum += node-&gt;val; path.push_back(node-&gt;val); //当到达叶子结点，并且路径之和与sum相同 if(node &amp;&amp; !node-&gt;left &amp;&amp; !node-&gt;right )&#123; if(currentsum == sum) result.push_back(path); return; &#125; if(node-&gt;left)&#123; dfs(node-&gt;left,currentsum,sum,path,result); //回溯，还原状态 path.pop_back(); &#125; if(node-&gt;right)&#123; dfs(node-&gt;right,currentsum,sum,path,result); //回溯，还原状态 path.pop_back(); &#125; &#125;&#125;; Solution2：12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt; &gt; result; preorder(root,0,sum,path,result); return result; &#125; void preorder(TreeNode* node, int currentsum, int sum, vector&lt;int&gt; &amp;path, vector&lt;vector&lt;int&gt; &gt; &amp;result)&#123; if(!node) return; currentsum += node-&gt;val; path.push_back(node-&gt;val); if(!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; currentsum == sum)&#123; result.push_back(path); &#125; preorder(node-&gt;left,currentsum,sum,path,result); preorder(node-&gt;right,currentsum,sum,path,result); //该步可有可无，因为只会递归到叶子节点才返回，又每次递归都在栈中保留了原来该值的副本。 // currentsum -= node-&gt;val; path.pop_back(); &#125;&#125;;","categories":[],"tags":[]},{"title":"LeetCode-107-二叉树的层次遍-II","slug":"LeetCode-107-二叉树的层次遍-II","date":"2019-05-30T04:18:24.000Z","updated":"2020-08-27T15:06:24.387Z","comments":true,"path":"2019/05/30/LeetCode-107-二叉树的层次遍-II/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-107-二叉树的层次遍-II/","excerpt":"","text":"107. 二叉树的层次遍历 II 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）该题为 102. 二叉树的层次遍历的进阶版。 有关102. 二叉树的层次遍历的题解，请参考429. N叉树的层序遍历，具体思路是一样的，不再赘述。 Solution1（迭代版）：1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt; &gt; res; if(!root) return res; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; int len = q.size(); vector&lt;int&gt; curLayerNodes; TreeNode* t; while(len--)&#123; t = q.front(); q.pop(); curLayerNodes.push_back(t-&gt;val); if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push(t-&gt;right); &#125; res.emplace(res.begin(),curLayerNodes); &#125; return res; &#125;&#125;; Solution2（递归版）：123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; preorder(root,1,res); return res; &#125; void preorder(TreeNode* node, int depth, vector&lt;vector&lt;int&gt;&gt; &amp;res)&#123; if(!node) return; if(res.size() &lt; depth)&#123; vector&lt;int&gt; t; t.push_back(node-&gt;val); res.emplace(res.begin(), t); &#125;else&#123; res[res.size()-depth].push_back(node-&gt;val); &#125; preorder(node-&gt;left, depth+1, res); preorder(node-&gt;right, depth+1, res); &#125;&#125;; 具体思路就是增加一层，就将该层放到头位置。 vector.emplace()配合vector.begin()实现插到头位置。","categories":[],"tags":[]},{"title":"LeetCode-101. 对称二叉树","slug":"LeetCode-101. 对称二叉树","date":"2019-05-30T04:18:00.000Z","updated":"2020-08-27T14:59:35.266Z","comments":true,"path":"2019/05/30/LeetCode-101. 对称二叉树/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/LeetCode-101. 对称二叉树/","excerpt":"","text":"101. 对称二叉树 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 Solution1（递归版）：123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; return isMirror(root, root); &#125; bool isMirror(TreeNode* t1, TreeNode* t2)&#123; //都为NULL if(!t1 &amp;&amp; !t2) return true; //有一个结点为NULL，另一个不为NULL if(!t1 || !t2) return false; return (t1-&gt;val == t2-&gt;val) &amp;&amp; isMirror(t1-&gt;left, t2-&gt;right) &amp;&amp; isMirror(t1-&gt;right, t2-&gt;left); &#125;&#125;; 看的官方题解。 把一棵对称树分成左子树和右子树。 如果左子树和右子树对称，则该数相同。 扩展到一般概念就是： 有两棵树。 两棵树的根节点相同。 每个树的右子树都与另一个树的左子树镜像对称。 翻译为递推公式就是： 1234TreeNode* t1,t2;t1-&gt;val == t2-&gt;val;t1-&gt;left == t2-&gt;right;t1-&gt;right = t2-&gt;left; 结束条件为两棵树为空。 整理可得上述代码。 Solution2（迭代版）：123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; q.push(root); q.push(root); while(!q.empty())&#123; TreeNode* t1 = q.front(); q.pop(); TreeNode* t2 = q.front(); q.pop(); if(!t1 &amp;&amp; !t2) continue; if(!t1 || !t2) return false; if(t1-&gt;val != t2-&gt;val) return false; q.push(t1-&gt;left); q.push(t2-&gt;right); q.push(t2-&gt;left); q.push(t1-&gt;right); &#125; return true; &#125;&#125;; 翻译为了迭代版，只不过根本的思想是一样的。都是将一棵树化为两棵树来进行判断的。 Solution3（中序迭代版）：123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; stack&lt;TreeNode*&gt; lefts,rights; TreeNode* l = root-&gt;left; TreeNode* r = root-&gt;right; while(l || r || lefts.size())&#123; while(l &amp;&amp; r)&#123; lefts.push(l),l = l-&gt;left; rights.push(r), r = r-&gt;right; &#125; if(l || r) return false; l = lefts.top();lefts.pop(); r = rights.top(); rights.pop(); if(l-&gt;val != r-&gt;val) return false; l = l-&gt;right,r = r-&gt;left; &#125; return true; &#125;&#125;;","categories":[],"tags":[]},{"title":"PAT《团体程序设计天梯赛-练习集》-L3-01-二叉搜索树的结-（3-分）","slug":"PAT《团体程序设计天梯赛-练习集》-L3-01-二叉搜索树的结-（3-分）","date":"2019-05-30T04:18:00.000Z","updated":"2020-08-27T15:06:24.610Z","comments":true,"path":"2019/05/30/PAT《团体程序设计天梯赛-练习集》-L3-01-二叉搜索树的结-（3-分）/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/PAT《团体程序设计天梯赛-练习集》-L3-01-二叉搜索树的结-（3-分）/","excerpt":"","text":"L3-016 二叉搜索树的结构 （30 分） 二叉搜索树或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。（摘自百度百科）给定一系列互不相等的整数，将它们顺次插入一棵初始为空的二叉搜索树，然后对结果树的结构进行描述。你需要能判断给定的描述是否正确。例如将{ 2 4 1 3 0 }插入后，得到一棵二叉搜索树，则陈述句如“2是树的根”、“1和4是兄弟结点”、“3和0在同一层上”（指自顶向下的深度相同）、“2是4的双亲结点”、“3是4的左孩子”都是正确的；而“4是2的左孩子”、“1和3是兄弟结点”都是不正确的。 输入格式：输入在第一行给出一个正整数N（≤100），随后一行给出N个互不相同的整数，数字间以空格分隔，要求将之顺次插入一棵初始为空的二叉搜索树。之后给出一个正整数M（≤100），随后M行，每行给出一句待判断的陈述句。陈述句有以下6种： A is the root，即”A是树的根”； A and B are siblings，即”A和B是兄弟结点”； A is the parent of B，即”A是B的双亲结点”； A is the left child of B，即”A是B的左孩子”； A is the right child of B，即”A是B的右孩子”； A and B are on the same level，即”A和B在同一层上”。题目保证所有给定的整数都在整型范围内。 输出格式：对每句陈述，如果正确则输出Yes，否则输出No，每句占一行。 Solution：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right; TreeNode(int x): val(x), left(NULL), right(NULL)&#123;&#125; &#125;;int rootval;void insertNode(TreeNode* root, int val)&#123; if(!root) return; if(root-&gt;val &gt; val)&#123; if(root-&gt;left)&#123; insertNode(root-&gt;left,val); &#125;else&#123; TreeNode* t = new TreeNode(val); root-&gt;left = t; &#125; &#125;else if(root-&gt;val &lt; val)&#123; if(root-&gt;right)&#123; insertNode(root-&gt;right,val); &#125;else&#123; TreeNode* t = new TreeNode(val); root-&gt;right = t; &#125; &#125;&#125;bool isContainNode(TreeNode* root, int val)&#123; if(!root) return false; if(root-&gt;val == val) return true; if(root-&gt;val &gt; val) return isContainNode(root-&gt;left,val); else return isContainNode(root-&gt;right,val);&#125;void printTree(TreeNode* root)&#123; if(!root) return; cout &lt;&lt; root-&gt;val &lt;&lt;\"\"; printTree(root-&gt;left); printTree(root-&gt;right);&#125;bool isRoot(int val)&#123; return val == rootval;&#125;TreeNode* parent(TreeNode *root, int child)&#123; if(!isContainNode(root,child) || root-&gt;val == child) return NULL; TreeNode* res = NULL; while(1)&#123; if(!root) return NULL; if((root-&gt;left &amp;&amp; root-&gt;left-&gt;val == child) || (root-&gt;right &amp;&amp; root-&gt;right-&gt;val == child))&#123; res = root; break; &#125;else if(root-&gt;val &gt; child)&#123; root = root-&gt;left; &#125;else if(root-&gt;val &lt; child)&#123; root = root-&gt;right; &#125; &#125; return res;&#125;bool isSibling(TreeNode* root, int valA, int valB)&#123; if(!root) return false; if(valA == root-&gt;val || valB == root-&gt;val) return false; //找到A的父亲 TreeNode* t = parent(root, valA); if(t)&#123; if(t-&gt;left &amp;&amp; t-&gt;left-&gt;val == valA )&#123; return t-&gt;right &amp;&amp; t-&gt;right-&gt;val == valB; &#125; else if(t-&gt;right &amp;&amp; t-&gt;right-&gt;val == valA )&#123; return t-&gt;left &amp;&amp; t-&gt;left-&gt;val == valB; &#125;else&#123; return false; &#125; &#125; return false;&#125;int getDepth(TreeNode* root, int val)&#123; if(root-&gt;val == val) return 0; if(root-&gt;val &gt; val) return 1 + getDepth(root-&gt;left,val); else return 1 + getDepth(root-&gt;right,val);&#125;bool isSameLevel(TreeNode* root, int A, int B)&#123;// A != B &amp;&amp; return isContainNode(root,A) &amp;&amp; isContainNode(root,B) &amp;&amp; getDepth(root, A) == getDepth(root, B);&#125;void pirntMassage(bool info)&#123; if(info)&#123; cout &lt;&lt; \"Yes\" &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; \"No\" &lt;&lt;endl; &#125;&#125;bool isParent(TreeNode* root, int parentVal, int childVal)&#123; if(parent(root, childVal) == NULL) return false; return parentVal == parent(root, childVal)-&gt;val;&#125;bool isLeftChild(TreeNode* root, int parentVal, int leftChildVal)&#123; if(parent(root, leftChildVal) == NULL) return false; TreeNode* p = parent(root, leftChildVal); return parentVal == p-&gt;val &amp;&amp; p-&gt;left-&gt;val == leftChildVal;&#125;bool isRightChild(TreeNode* root, int parentVal, int rightChildVal)&#123; if(parent(root, rightChildVal) == NULL) return false; TreeNode* p = parent(root, rightChildVal); return parentVal == p-&gt;val &amp;&amp; p-&gt;right-&gt;val == rightChildVal;&#125;int main()&#123; int c; cin &gt;&gt; c; if(c &lt;= 0) return 0; cin &gt;&gt; rootval; TreeNode* root = new TreeNode(rootval); for(int i = 1; i &lt; c; i++)&#123; int a; cin &gt;&gt; a; insertNode(root, a); &#125; cin &gt;&gt; c; getchar(); int rootV,siblingA,siblingB, parentv, childv,leftchildv,rightchildv,samelevelA,samelevelB; for(int i = 0 ; i &lt; c; i++)&#123; char state[100]; int q = 0; char ch; while((ch = getchar()) != '\\n') state[q++] = ch; state[q] = '\\0'; if(strstr(state,\"root\"))&#123; sscanf(state,\"%d is the root\",&amp;rootV); pirntMassage(isRoot(rootV)); &#125;else if(strstr(state,\"siblings\"))&#123; sscanf(state,\"%d and %d are siblings\",&amp;siblingA,&amp;siblingB); pirntMassage(isSibling(root,siblingA,siblingB)); &#125;else if(strstr(state,\"same\"))&#123; sscanf(state,\"%d and %d are on the same level\",&amp;samelevelA,&amp;samelevelB); pirntMassage(isSameLevel(root,samelevelA,samelevelB)); &#125;else if(strstr(state,\"parent\"))&#123; sscanf(state,\"%d is the parent of %d\",&amp;parentv,&amp;childv); pirntMassage(isParent(root,parentv,childv)); &#125;else if(strstr(state,\"left\"))&#123; sscanf(state,\"%d is the left child of %d\",&amp;leftchildv,&amp;parentv); pirntMassage(isLeftChild(root,parentv,leftchildv)); &#125;else if(strstr(state,\"right\"))&#123; sscanf(state,\"%d is the right child of %d\",&amp;rightchildv,&amp;parentv); pirntMassage(isRightChild(root,parentv,rightchildv)); &#125; &#125;// pirntMassage(isRoot(2));// pirntMassage(isSibling(root,1,1));// pirntMassage(isSameLevel(root, 0,3));// pirntMassage(isParent(root, 3,0));// pirntMassage(isLeftChild(root, 2,1));// pirntMassage(isRightChild(root, 2,4)); return 0;&#125; 第一次写这么多功能的代码，很考验耐力。没什么大的难点，注意考虑代码的重用性。 第一次用sscanf，还不太熟。 有一坑：它认为 3 and 3 are on the same level。我开始写的时候，直接把这种情况否定掉了。看来盲目做条件判断也不是好事。","categories":[],"tags":[]},{"title":"PAT《团体程序设计天梯赛-练习集》-L3-01-是否完全二叉搜索-（3-分）","slug":"PAT《团体程序设计天梯赛-练习集》-L3-01-是否完全二叉搜索-（3-分）","date":"2019-05-30T04:18:00.000Z","updated":"2020-08-27T15:06:24.608Z","comments":true,"path":"2019/05/30/PAT《团体程序设计天梯赛-练习集》-L3-01-是否完全二叉搜索-（3-分）/","link":"","permalink":"https://yangzebin001.github.io/2019/05/30/PAT《团体程序设计天梯赛-练习集》-L3-01-是否完全二叉搜索-（3-分）/","excerpt":"","text":"L3-010 是否完全二叉搜索树 （30 分） 将一系列给定数字顺序插入一个初始为空的二叉搜索树（定义为左子树键值大，右子树键值小），你需要判断最后的树是否一棵完全二叉树，并且给出其层序遍历的结果。 输入格式：输入第一行给出一个不超过20的正整数N；第二行给出N个互不相同的正整数，其间以空格分隔。 输出格式：将输入的N个正整数顺序插入一个初始为空的二叉搜索树。在第一行中输出结果树的层序遍历结果，数字间以1个空格分隔，行的首尾不得有多余空格。第二行输出YES，如果该树是完全二叉树；否则输出NO。 输入样例1：12938 45 42 24 58 30 67 12 51 输出样例1：1238 45 24 58 42 30 12 67 51YES 输入样例2：12838 24 12 45 58 67 42 51 输出样例2：1238 45 24 58 42 12 67 51NO 一道考察二叉树插入方法例程，层序遍历，判断是否为一棵完全二叉树的综合题。 Solution：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;struct TreeNode&#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;; void insertNode(TreeNode* root, int val)&#123; if(root == NULL)&#123; return; &#125; if(root-&gt;val &lt; val)&#123; if(root-&gt;left == NULL)&#123; TreeNode* now = new TreeNode(val); root-&gt;left = now; &#125;else&#123; insertNode(root-&gt;left, val); &#125; &#125;else if(root-&gt;val &gt; val)&#123; if(root-&gt;right == NULL)&#123; TreeNode* now = new TreeNode(val); root-&gt;right = now; &#125;else&#123; insertNode(root-&gt;right, val); &#125; &#125;&#125;void levelOrder(TreeNode* root)&#123; queue&lt;TreeNode*&gt; q; q.push(root); bool isfirst = true; while(!q.empty())&#123; TreeNode* node = q.front(); q.pop(); if(isfirst)&#123; cout &lt;&lt; node-&gt;val; isfirst = false; &#125;else&#123; cout &lt;&lt; &quot; &quot; &lt;&lt; node-&gt;val; &#125; if(node-&gt;left) &#123; q.push(node-&gt;left); &#125; if(node-&gt;right) &#123; q.push(node-&gt;right); &#125; &#125;&#125;bool isCST(TreeNode* root)&#123; bool leaf = false; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; TreeNode* node = q.front(); q.pop(); if(node-&gt;right &amp;&amp; !node-&gt;left) return false; if(leaf &amp;&amp; (node-&gt;left || node-&gt;right)) return false; if(!node-&gt;right &amp;&amp; !leaf)&#123; leaf = true; &#125; if(node-&gt;left) &#123; q.push(node-&gt;left); &#125; if(node-&gt;right) &#123; q.push(node-&gt;right); &#125; &#125; return true;&#125;void printTree(TreeNode* root)&#123; if(!root) return; printTree(root-&gt;left); cout &lt;&lt; &quot; &quot; &lt;&lt; root-&gt;val; printTree(root-&gt;right);&#125;int main()&#123; int c; cin &gt;&gt; c; int rootval; cin &gt;&gt; rootval; TreeNode* root = new TreeNode(rootval); for(int i = 1; i &lt; c; i++)&#123; int nodeval; cin &gt;&gt; nodeval; insertNode(root, nodeval); &#125; levelOrder(root); cout &lt;&lt; endl; if(isCST(root))&#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"LeetCode-5. 最长回文子串（待补充）","slug":"LeetCode-5-最长回文子串（待补充）","date":"2019-03-16T12:46:42.000Z","updated":"2019-03-16T12:49:16.804Z","comments":true,"path":"2019/03/16/LeetCode-5-最长回文子串（待补充）/","link":"","permalink":"https://yangzebin001.github.io/2019/03/16/LeetCode-5-最长回文子串（待补充）/","excerpt":"5. 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。示例 1： 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。","text":"5. 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。示例 1： 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2： 12输入: &quot;cbbd&quot;输出: &quot;bb&quot; Solution1：123456789101112131415161718192021222324252627class Solution &#123;public: int expandAroundCenter(string s, int left, int right)&#123; int L = left, R = right; while(L &gt;= 0 &amp;&amp; R &lt; s.size() &amp;&amp; s[L] == s[R])&#123; L--; R++; &#125; return R - L - 1; &#125; string longestPalindrome(string s) &#123; if( s.size() &lt; 1) return \"\"; int start = 0, end = 0; for(int i = 0; i &lt; s.size(); i++)&#123; //以i为中心点开始探测。 int len1 = expandAroundCenter(s,i,i); //以i与i+1位置的之间开始探测。 int len2 = expandAroundCenter(s,i,i+1); int len = max(len1,len2); if(len &gt; end-start)&#123; start = i - (len-1)/2; end = i + len/2; &#125; &#125; return s.substr(start,end-start+1); &#125;&#125;; 思路：只想到了O(n3)复杂度的暴力解法。看题解做的。 由于回文串的两侧互为镜像，所以可以从中心向两侧展开进行探测。一共会有2n-1个中心点（一个点为中心，两点之间也可以看作一个中点）。时间复杂度为O(n2);","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"字符串","slug":"字符串","permalink":"https://yangzebin001.github.io/tags/字符串/"}]},{"title":"LeetCode-105. 从前序与中序遍历序列构造二叉树（待补充）","slug":"LeetCode-105-从前序与中序遍历序列构造二叉树（待补充）","date":"2019-03-16T12:42:24.000Z","updated":"2019-03-16T12:49:34.384Z","comments":true,"path":"2019/03/16/LeetCode-105-从前序与中序遍历序列构造二叉树（待补充）/","link":"","permalink":"https://yangzebin001.github.io/2019/03/16/LeetCode-105-从前序与中序遍历序列构造二叉树（待补充）/","excerpt":"105. 从前序与中序遍历序列构造二叉树 根据一棵树的前序遍历与中序遍历构造二叉树。注意:你可以假设树中没有重复的元素。 例如，给出","text":"105. 从前序与中序遍历序列构造二叉树 根据一棵树的前序遍历与中序遍历构造二叉树。注意:你可以假设树中没有重复的元素。 例如，给出 1234前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 12345 3 / \\9 20 / \\ 15 7 Solution1（递归版）：1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; int s = 0; return buildNode(preorder, s, inorder, 0, inorder.size()-1); &#125; TreeNode* buildNode(vector&lt;int&gt;&amp; preorder, int &amp;preindex, vector&lt;int&gt;&amp; inorder, int start, int end)&#123; if(start &lt;= end)&#123; int inIndex = INT_MAX; for(int i = start; i &lt;= end; i++)&#123; if(inorder[i] == preorder[preindex]) &#123; inIndex = i; break; &#125; &#125; if(inIndex &lt; start || inIndex &gt; end) return NULL; TreeNode* node = new TreeNode(preorder[preindex++]); node-&gt;left = buildNode(preorder, preindex, inorder, start, inIndex-1); node-&gt;right = buildNode(preorder,preindex , inorder, inIndex+1, end); return node; &#125; return NULL; &#125;&#125;; 思路:在前序遍历中，根结点是第一个元素。在中序遍历中，根节点之前的元素都在根结点的左子树上。根节点之后的元素都在根节点的右子树上。对于其他的结点，与根节点构建的方式一样。所以可以使用递归。 所以重点就是找到根节点在中序遍历中的位置。 每次找到前序遍历中的一个结点，在中序遍历中找到该结点的位置，建立该结点。然后给该结点之下的结点（子树）划分区域。继续递归下去，直到区域缩小为0为止。 Solution2（迭代版）:","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://yangzebin001.github.io/tags/二叉树/"}]},{"title":"LeetCode-958. 二叉树的完全性检验（待补充）","slug":"LeetCode-958-二叉树的完全性检验（待补充）","date":"2019-03-16T12:41:05.000Z","updated":"2019-03-16T12:48:44.160Z","comments":true,"path":"2019/03/16/LeetCode-958-二叉树的完全性检验（待补充）/","link":"","permalink":"https://yangzebin001.github.io/2019/03/16/LeetCode-958-二叉树的完全性检验（待补充）/","excerpt":"958. 二叉树的完全性检验 给定一个二叉树，确定它是否是一个完全二叉树。若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）","text":"958. 二叉树的完全性检验 给定一个二叉树，确定它是否是一个完全二叉树。若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。） Solution1（迭代版）：1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isCompleteTree(TreeNode* root) &#123; bool havenullnode = false; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; TreeNode* node = q.front(); q.pop(); if(!node)&#123; havenullnode = true; &#125;else&#123; if(havenullnode) return false; q.push(node-&gt;left); q.push(node-&gt;right); &#125; &#125; return true; &#125;&#125;; 思路：使用层序遍历，完全二叉树的遍历结果为只要遇到了null结点，之后的结点也都为null结点，否则就不是完全二叉树。 Solution2（递归版）:","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://yangzebin001.github.io/tags/二叉树/"}]},{"title":"LeetCode-34. 在排序数组中查找元素的第一个和最后一个位置","slug":"LeetCode-34-在排序数组中查找元素的第一个和最后一个位置","date":"2019-03-02T11:11:33.000Z","updated":"2019-03-02T14:24:09.928Z","comments":true,"path":"2019/03/02/LeetCode-34-在排序数组中查找元素的第一个和最后一个位置/","link":"","permalink":"https://yangzebin001.github.io/2019/03/02/LeetCode-34-在排序数组中查找元素的第一个和最后一个位置/","excerpt":"34. 在排序数组中查找元素的第一个和最后一个位置 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。","text":"34. 在排序数组中查找元素的第一个和最后一个位置 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。示例 1: 12输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例 2: 12输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] Solution：1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res; res.push_back(left_bound(nums,target)); res.push_back(right_bound(nums,target)); return res; &#125; int left_bound(vector&lt;int&gt; &amp; nums, int target)&#123; int lo = 0; int hi = nums.size()-1; while(lo &lt;= hi)&#123; int mid = (lo + hi)/2; if(nums[mid] == target)&#123; if(mid == 0 || nums[mid-1] &lt; target) return mid; hi = mid-1; &#125;else if(nums[mid] &lt; target)&#123; lo = mid +1; &#125;else&#123; hi = mid -1; &#125; &#125; return -1; &#125; int right_bound(vector&lt;int&gt; &amp; nums, int target)&#123; int lo = 0; int hi = nums.size()-1; while(lo &lt;= hi)&#123; int mid = (lo + hi)/2; if(nums[mid] == target &amp;&amp; (mid == nums.size()-1 || nums[mid+1] &gt; target))&#123; return mid; &#125; else if(nums[mid] &lt;= target)&#123; lo = mid +1; &#125;else&#123; hi = mid -1; &#125; &#125; return -1; &#125;&#125;; 遍历两个函数，分别寻找左右界。 具体就是要找到最接近target值的位置。每次缩小范围。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二分查找","slug":"二分查找","permalink":"https://yangzebin001.github.io/tags/二分查找/"}]},{"title":"LeetCode-35. 搜索插入位置","slug":"LeetCode-35-搜索插入位置","date":"2019-03-02T11:10:13.000Z","updated":"2019-03-02T14:24:16.476Z","comments":true,"path":"2019/03/02/LeetCode-35-搜索插入位置/","link":"","permalink":"https://yangzebin001.github.io/2019/03/02/LeetCode-35-搜索插入位置/","excerpt":"35. 搜索插入位置 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。","text":"35. 搜索插入位置 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。示例 1: 12输入: [1,3,5,6], 5输出: 2 示例 2: 12输入: [1,3,5,6], 2输出: 1 示例 3: 12输入: [1,3,5,6], 7输出: 4 示例 4: 12输入: [1,3,5,6], 0输出: 0 Solution：12345678910111213141516class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int low = 0, high = nums.size()-1; while(low&lt;=high)&#123; int mid = (low+high)/2; if(nums[mid] == target) return mid; else if(nums[mid] &gt; target) high = mid-1; else low = mid+1; &#125; //当小于第一个元素时，low会停在0，hi会是-1； //当在数组区间时，low=hi在期望的位置。 //当大于最后一个元素是，low = nums.size(), hi = nums.size(); return low; &#125;&#125;; 二分的初步题。 要十分深刻的了解指针的运行状态才能写出简洁的代码。 比如自己写的最终版本： 1234567891011121314151617class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = 0; int hi = nums.size()-1; int mid; if(target &lt; nums[0]) return 0; while(lo &lt;= hi)&#123; mid = (lo + hi)/2; if(nums[mid] == target) return mid; else if(nums[mid] &lt; target) lo = mid+1; else if(nums[mid] &gt; target) hi = mid-1; &#125; return nums[hi] &gt; target ? hi : hi+1; &#125;&#125;; 没有上面的简洁。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二分查找","slug":"二分查找","permalink":"https://yangzebin001.github.io/tags/二分查找/"}]},{"title":"PAT《团体程序设计天梯赛-练习集》-L3-016 二叉搜索树的结构 （30 分）","slug":"PAT《团体程序设计天梯赛-练习集》-L3-016-二叉搜索树的结构-（30-分）","date":"2019-02-28T14:56:41.000Z","updated":"2019-02-28T14:57:44.146Z","comments":true,"path":"2019/02/28/PAT《团体程序设计天梯赛-练习集》-L3-016-二叉搜索树的结构-（30-分）/","link":"","permalink":"https://yangzebin001.github.io/2019/02/28/PAT《团体程序设计天梯赛-练习集》-L3-016-二叉搜索树的结构-（30-分）/","excerpt":"L3-016 二叉搜索树的结构 （30 分） 二叉搜索树或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。（摘自百度百科）","text":"L3-016 二叉搜索树的结构 （30 分） 二叉搜索树或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。（摘自百度百科） 给定一系列互不相等的整数，将它们顺次插入一棵初始为空的二叉搜索树，然后对结果树的结构进行描述。你需要能判断给定的描述是否正确。例如将{ 2 4 1 3 0 }插入后，得到一棵二叉搜索树，则陈述句如“2是树的根”、“1和4是兄弟结点”、“3和0在同一层上”（指自顶向下的深度相同）、“2是4的双亲结点”、“3是4的左孩子”都是正确的；而“4是2的左孩子”、“1和3是兄弟结点”都是不正确的。 输入格式：输入在第一行给出一个正整数N（≤100），随后一行给出N个互不相同的整数，数字间以空格分隔，要求将之顺次插入一棵初始为空的二叉搜索树。之后给出一个正整数M（≤100），随后M行，每行给出一句待判断的陈述句。陈述句有以下6种： A is the root，即”A是树的根”； A and B are siblings，即”A和B是兄弟结点”； A is the parent of B，即”A是B的双亲结点”； A is the left child of B，即”A是B的左孩子”； A is the right child of B，即”A是B的右孩子”； A and B are on the same level，即”A和B在同一层上”。题目保证所有给定的整数都在整型范围内。 输出格式：对每句陈述，如果正确则输出Yes，否则输出No，每句占一行。 Solution：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right; TreeNode(int x): val(x), left(NULL), right(NULL)&#123;&#125; &#125;;int rootval;void insertNode(TreeNode* root, int val)&#123; if(!root) return; if(root-&gt;val &gt; val)&#123; if(root-&gt;left)&#123; insertNode(root-&gt;left,val); &#125;else&#123; TreeNode* t = new TreeNode(val); root-&gt;left = t; &#125; &#125;else if(root-&gt;val &lt; val)&#123; if(root-&gt;right)&#123; insertNode(root-&gt;right,val); &#125;else&#123; TreeNode* t = new TreeNode(val); root-&gt;right = t; &#125; &#125;&#125;bool isContainNode(TreeNode* root, int val)&#123; if(!root) return false; if(root-&gt;val == val) return true; if(root-&gt;val &gt; val) return isContainNode(root-&gt;left,val); else return isContainNode(root-&gt;right,val);&#125;void printTree(TreeNode* root)&#123; if(!root) return; cout &lt;&lt; root-&gt;val &lt;&lt;\"\"; printTree(root-&gt;left); printTree(root-&gt;right);&#125;bool isRoot(int val)&#123; return val == rootval;&#125;TreeNode* parent(TreeNode *root, int child)&#123; if(!isContainNode(root,child) || root-&gt;val == child) return NULL; TreeNode* res = NULL; while(1)&#123; if(!root) return NULL; if((root-&gt;left &amp;&amp; root-&gt;left-&gt;val == child) || (root-&gt;right &amp;&amp; root-&gt;right-&gt;val == child))&#123; res = root; break; &#125;else if(root-&gt;val &gt; child)&#123; root = root-&gt;left; &#125;else if(root-&gt;val &lt; child)&#123; root = root-&gt;right; &#125; &#125; return res;&#125;bool isSibling(TreeNode* root, int valA, int valB)&#123; if(!root) return false; if(valA == root-&gt;val || valB == root-&gt;val) return false; //找到A的父亲 TreeNode* t = parent(root, valA); if(t)&#123; if(t-&gt;left &amp;&amp; t-&gt;left-&gt;val == valA )&#123; return t-&gt;right &amp;&amp; t-&gt;right-&gt;val == valB; &#125; else if(t-&gt;right &amp;&amp; t-&gt;right-&gt;val == valA )&#123; return t-&gt;left &amp;&amp; t-&gt;left-&gt;val == valB; &#125;else&#123; return false; &#125; &#125; return false;&#125;int getDepth(TreeNode* root, int val)&#123; if(root-&gt;val == val) return 0; if(root-&gt;val &gt; val) return 1 + getDepth(root-&gt;left,val); else return 1 + getDepth(root-&gt;right,val);&#125;bool isSameLevel(TreeNode* root, int A, int B)&#123;// A != B &amp;&amp; return isContainNode(root,A) &amp;&amp; isContainNode(root,B) &amp;&amp; getDepth(root, A) == getDepth(root, B);&#125;void pirntMassage(bool info)&#123; if(info)&#123; cout &lt;&lt; \"Yes\" &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; \"No\" &lt;&lt;endl; &#125;&#125;bool isParent(TreeNode* root, int parentVal, int childVal)&#123; if(parent(root, childVal) == NULL) return false; return parentVal == parent(root, childVal)-&gt;val;&#125;bool isLeftChild(TreeNode* root, int parentVal, int leftChildVal)&#123; if(parent(root, leftChildVal) == NULL) return false; TreeNode* p = parent(root, leftChildVal); return parentVal == p-&gt;val &amp;&amp; p-&gt;left-&gt;val == leftChildVal;&#125;bool isRightChild(TreeNode* root, int parentVal, int rightChildVal)&#123; if(parent(root, rightChildVal) == NULL) return false; TreeNode* p = parent(root, rightChildVal); return parentVal == p-&gt;val &amp;&amp; p-&gt;right-&gt;val == rightChildVal;&#125;int main()&#123; int c; cin &gt;&gt; c; if(c &lt;= 0) return 0; cin &gt;&gt; rootval; TreeNode* root = new TreeNode(rootval); for(int i = 1; i &lt; c; i++)&#123; int a; cin &gt;&gt; a; insertNode(root, a); &#125; cin &gt;&gt; c; getchar(); int rootV,siblingA,siblingB, parentv, childv,leftchildv,rightchildv,samelevelA,samelevelB; for(int i = 0 ; i &lt; c; i++)&#123; char state[100]; int q = 0; char ch; while((ch = getchar()) != '\\n') state[q++] = ch; state[q] = '\\0'; if(strstr(state,\"root\"))&#123; sscanf(state,\"%d is the root\",&amp;rootV); pirntMassage(isRoot(rootV)); &#125;else if(strstr(state,\"siblings\"))&#123; sscanf(state,\"%d and %d are siblings\",&amp;siblingA,&amp;siblingB); pirntMassage(isSibling(root,siblingA,siblingB)); &#125;else if(strstr(state,\"same\"))&#123; sscanf(state,\"%d and %d are on the same level\",&amp;samelevelA,&amp;samelevelB); pirntMassage(isSameLevel(root,samelevelA,samelevelB)); &#125;else if(strstr(state,\"parent\"))&#123; sscanf(state,\"%d is the parent of %d\",&amp;parentv,&amp;childv); pirntMassage(isParent(root,parentv,childv)); &#125;else if(strstr(state,\"left\"))&#123; sscanf(state,\"%d is the left child of %d\",&amp;leftchildv,&amp;parentv); pirntMassage(isLeftChild(root,parentv,leftchildv)); &#125;else if(strstr(state,\"right\"))&#123; sscanf(state,\"%d is the right child of %d\",&amp;rightchildv,&amp;parentv); pirntMassage(isRightChild(root,parentv,rightchildv)); &#125; &#125;// pirntMassage(isRoot(2));// pirntMassage(isSibling(root,1,1));// pirntMassage(isSameLevel(root, 0,3));// pirntMassage(isParent(root, 3,0));// pirntMassage(isLeftChild(root, 2,1));// pirntMassage(isRightChild(root, 2,4)); return 0;&#125; 第一次写这么多功能的代码，很考验耐力。没什么大的难点，注意考虑代码的重用性。 第一次用sscanf，还不太熟。 有一坑：它认为 3 and 3 are on the same level。我开始写的时候，直接把这种情况否定掉了。看来盲目做条件判断也不是好事。","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://yangzebin001.github.io/tags/二叉树/"},{"name":"PAT","slug":"PAT","permalink":"https://yangzebin001.github.io/tags/PAT/"}]},{"title":"PAT《团体程序设计天梯赛-练习集》-L3-010 是否完全二叉搜索树 （30 分）","slug":"PAT《团体程序设计天梯赛-练习集》-L3-010-是否完全二叉搜索树-（30-分）","date":"2019-02-27T09:57:50.000Z","updated":"2019-02-27T10:06:09.562Z","comments":true,"path":"2019/02/27/PAT《团体程序设计天梯赛-练习集》-L3-010-是否完全二叉搜索树-（30-分）/","link":"","permalink":"https://yangzebin001.github.io/2019/02/27/PAT《团体程序设计天梯赛-练习集》-L3-010-是否完全二叉搜索树-（30-分）/","excerpt":"L3-010 是否完全二叉搜索树 （30 分） 将一系列给定数字顺序插入一个初始为空的二叉搜索树（定义为左子树键值大，右子树键值小），你需要判断最后的树是否一棵完全二叉树，并且给出其层序遍历的结果。输入格式：输入第一行给出一个不超过20的正整数N；第二行给出N个互不相同的正整数，其间以空格分隔。 输出格式：将输入的N个正整数顺序插入一个初始为空的二叉搜索树。在第一行中输出结果树的层序遍历结果，数字间以1个空格分隔，行的首尾不得有多余空格。第二行输出YES，如果该树是完全二叉树；否则输出NO。 输入样例1：12938 45 42 24 58 30 67 12 51 输出样例1：1238 45 24 58 42 30 12 67 51YES","text":"L3-010 是否完全二叉搜索树 （30 分） 将一系列给定数字顺序插入一个初始为空的二叉搜索树（定义为左子树键值大，右子树键值小），你需要判断最后的树是否一棵完全二叉树，并且给出其层序遍历的结果。输入格式：输入第一行给出一个不超过20的正整数N；第二行给出N个互不相同的正整数，其间以空格分隔。 输出格式：将输入的N个正整数顺序插入一个初始为空的二叉搜索树。在第一行中输出结果树的层序遍历结果，数字间以1个空格分隔，行的首尾不得有多余空格。第二行输出YES，如果该树是完全二叉树；否则输出NO。 输入样例1：12938 45 42 24 58 30 67 12 51 输出样例1：1238 45 24 58 42 30 12 67 51YES 输入样例2：12838 24 12 45 58 67 42 51 输出样例2：1238 45 24 58 42 12 67 51NO 一道考察二叉树插入方法例程，层序遍历，判断是否为一棵完全二叉树的综合题。 Solution：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;struct TreeNode&#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;; void insertNode(TreeNode* root, int val)&#123; if(root == NULL)&#123; return; &#125; if(root-&gt;val &lt; val)&#123; if(root-&gt;left == NULL)&#123; TreeNode* now = new TreeNode(val); root-&gt;left = now; &#125;else&#123; insertNode(root-&gt;left, val); &#125; &#125;else if(root-&gt;val &gt; val)&#123; if(root-&gt;right == NULL)&#123; TreeNode* now = new TreeNode(val); root-&gt;right = now; &#125;else&#123; insertNode(root-&gt;right, val); &#125; &#125;&#125;void levelOrder(TreeNode* root)&#123; queue&lt;TreeNode*&gt; q; q.push(root); bool isfirst = true; while(!q.empty())&#123; TreeNode* node = q.front(); q.pop(); if(isfirst)&#123; cout &lt;&lt; node-&gt;val; isfirst = false; &#125;else&#123; cout &lt;&lt; \" \" &lt;&lt; node-&gt;val; &#125; if(node-&gt;left) &#123; q.push(node-&gt;left); &#125; if(node-&gt;right) &#123; q.push(node-&gt;right); &#125; &#125;&#125;bool isCST(TreeNode* root)&#123; bool leaf = false; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; TreeNode* node = q.front(); q.pop(); if(node-&gt;right &amp;&amp; !node-&gt;left) return false; if(leaf &amp;&amp; (node-&gt;left || node-&gt;right)) return false; if(!node-&gt;right &amp;&amp; !leaf)&#123; leaf = true; &#125; if(node-&gt;left) &#123; q.push(node-&gt;left); &#125; if(node-&gt;right) &#123; q.push(node-&gt;right); &#125; &#125; return true;&#125;void printTree(TreeNode* root)&#123; if(!root) return; printTree(root-&gt;left); cout &lt;&lt; \" \" &lt;&lt; root-&gt;val; printTree(root-&gt;right);&#125;int main()&#123; int c; cin &gt;&gt; c; int rootval; cin &gt;&gt; rootval; TreeNode* root = new TreeNode(rootval); for(int i = 1; i &lt; c; i++)&#123; int nodeval; cin &gt;&gt; nodeval; insertNode(root, nodeval); &#125; levelOrder(root); cout &lt;&lt; endl; if(isCST(root))&#123; cout &lt;&lt; \"YES\" &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; \"NO\" &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://yangzebin001.github.io/tags/二叉树/"},{"name":"PAT","slug":"PAT","permalink":"https://yangzebin001.github.io/tags/PAT/"}]},{"title":"LeetCode-240. 搜索二维矩阵 II","slug":"LeetCode-240-搜索二维矩阵-II","date":"2019-02-27T09:56:12.000Z","updated":"2019-02-27T09:57:30.476Z","comments":true,"path":"2019/02/27/LeetCode-240-搜索二维矩阵-II/","link":"","permalink":"https://yangzebin001.github.io/2019/02/27/LeetCode-240-搜索二维矩阵-II/","excerpt":"240. 搜索二维矩阵 II 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 Solution：","text":"240. 搜索二维矩阵 II 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 Solution： 12345678910111213class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if(matrix.size() &lt;= 0) return false; int i = 0, j = matrix[0].size()-1; while(i &lt; matrix.size() &amp;&amp; j &gt;= 0)&#123; if(target == matrix[i][j]) return true; else if(target &gt; matrix[i][j]) i++; else if(target &lt; matrix[i][j]) j--; &#125; return false; &#125;&#125;; 思路： 从矩阵的左上角出发，如果比目标值大，向左移，如果比目标值小，向下移。出界或找到则结束。 对于一列，如果比当前值小，说明不在当前列中，列减一（缩小搜索范围）。 对于一行，如果比当前值小，则往前移动一个位置。 经过不断缩小范围（以经过的点划矩形），就可以得知目标值是否存在矩阵中。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二维矩阵","slug":"二维矩阵","permalink":"https://yangzebin001.github.io/tags/二维矩阵/"}]},{"title":"LeetCode-46. 全排列","slug":"LeetCode-46-全排列","date":"2019-02-23T10:00:09.000Z","updated":"2019-02-27T10:07:03.888Z","comments":true,"path":"2019/02/23/LeetCode-46-全排列/","link":"","permalink":"https://yangzebin001.github.io/2019/02/23/LeetCode-46-全排列/","excerpt":"46. 全排列 给定一个没有重复数字的序列，返回其所有可能的全排列。示例: 输入: [1,2,3] 输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] Solution：","text":"46. 全排列 给定一个没有重复数字的序列，返回其所有可能的全排列。示例: 输入: [1,2,3] 输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] Solution： 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); vector&lt;bool&gt; isVisit(len,false); vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; temp; DFS(nums,isVisit,res,temp); return res; &#125; void DFS(vector&lt;int&gt; &amp; nums, vector&lt;bool&gt; &amp;isVisit, vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;temp)&#123; if(temp.size() == nums.size())&#123; res.push_back(temp); return; &#125; for(int i = 0; i &lt; nums.size(); i++)&#123; if(isVisit[i]) continue; temp.push_back(nums[i]); isVisit[i] = true; DFS(nums,isVisit,res,temp); temp.pop_back(); isVisit[i] = false; &#125; &#125;&#125;; 思路：对于每一个数在一个排列中出现且仅出现一次。所以需要定义一个记录该数是否访问过的与原数组相同长度的数组——isVisit。 首先限定递归层数，当temp数组的长度已经和原数组的长度相同，就将数组保存下来。 然后开始遍历数组中的每一个数，遇到一个数，就将该数标记为已访问，并且将该数添加到temp数组中。继续下一层递归。 回溯：当每一个数访问完后，将该数从temp中pop掉，然后接着探寻下一个数是不是符合条件。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"回溯","slug":"回溯","permalink":"https://yangzebin001.github.io/tags/回溯/"},{"name":"排列","slug":"排列","permalink":"https://yangzebin001.github.io/tags/排列/"}]},{"title":"LeetCode-107. 二叉树的层次遍历 II","slug":"LeetCode-107-二叉树的层次遍历-II","date":"2019-02-23T09:59:37.000Z","updated":"2019-02-27T10:07:17.511Z","comments":true,"path":"2019/02/23/LeetCode-107-二叉树的层次遍历-II/","link":"","permalink":"https://yangzebin001.github.io/2019/02/23/LeetCode-107-二叉树的层次遍历-II/","excerpt":"107. 二叉树的层次遍历 II 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）该题为 102. 二叉树的层次遍历的进阶版。 有关102. 二叉树的层次遍历的题解，请参考429. N叉树的层序遍历，具体思路是一样的，不再赘述。 Solution1（迭代版）：","text":"107. 二叉树的层次遍历 II 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）该题为 102. 二叉树的层次遍历的进阶版。 有关102. 二叉树的层次遍历的题解，请参考429. N叉树的层序遍历，具体思路是一样的，不再赘述。 Solution1（迭代版）： 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt; &gt; res; if(!root) return res; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; int len = q.size(); vector&lt;int&gt; curLayerNodes; TreeNode* t; while(len--)&#123; t = q.front(); q.pop(); curLayerNodes.push_back(t-&gt;val); if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push(t-&gt;right); &#125; res.emplace(res.begin(),curLayerNodes); &#125; return res; &#125;&#125;; Solution2（递归版）：123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; preorder(root,1,res); return res; &#125; void preorder(TreeNode* node, int depth, vector&lt;vector&lt;int&gt;&gt; &amp;res)&#123; if(!node) return; if(res.size() &lt; depth)&#123; vector&lt;int&gt; t; t.push_back(node-&gt;val); res.emplace(res.begin(), t); &#125;else&#123; res[res.size()-depth].push_back(node-&gt;val); &#125; preorder(node-&gt;left, depth+1, res); preorder(node-&gt;right, depth+1, res); &#125;&#125;; 具体思路就是增加一层，就将该层放到头位置。 vector.emplace()配合vector.begin()实现插到头位置。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://yangzebin001.github.io/tags/二叉树/"}]},{"title":"LeetCode-199. 二叉树的右视图","slug":"LeetCode-199-二叉树的右视图","date":"2019-02-23T09:55:09.000Z","updated":"2019-02-27T10:07:38.516Z","comments":true,"path":"2019/02/23/LeetCode-199-二叉树的右视图/","link":"","permalink":"https://yangzebin001.github.io/2019/02/23/LeetCode-199-二叉树的右视图/","excerpt":"199. 二叉树的右视图 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 Solution1（迭代版）：","text":"199. 二叉树的右视图 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 Solution1（迭代版）： 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; vector&lt;int&gt; res; if(!root) return res; q.push(root); TreeNode* t = NULL; while(!q.empty())&#123; int len = q.size(); while(len)&#123; t = q.front();q.pop(); if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push(t-&gt;right); len--; &#125; res.push_back(t-&gt;val); &#125; return res; &#125;&#125;; 第一种比较符合直觉的就是使用层序遍历，将每一层的最后一个留下。 Solution2（递归版）：12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; vector&lt;int&gt; res; preorder(root, 1, res); return res; &#125; void preorder(TreeNode* node, int depth, vector&lt;int&gt; &amp; res)&#123; if(!node) return; if(res.size() &lt; depth)&#123; res.push_back(node-&gt;val); &#125;else&#123; res[depth-1] = node-&gt;val; &#125; preorder(node-&gt;left,depth+1, res); preorder(node-&gt;right,depth+1, res); &#125;&#125;; 使用前序遍历，并且传入层级信息，每到一层，就将该层的信息更新。如果该层没有数据，则新增一层。遍历到最后就会更新为正确的数据。 优化：1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; vector&lt;int&gt; res; preorder(root, 0, res); return res; &#125; void preorder(TreeNode* node, int depth, vector&lt;int&gt; &amp; res)&#123; if(!node) return; if(res.size() == depth)&#123; res.push_back(node-&gt;val); &#125; preorder(node-&gt;right,depth+1, res); preorder(node-&gt;left,depth+1, res); &#125;&#125;; 思路：仔细观察发现，并没有必要先push进去左节点，碰到右节点再将左节点覆盖掉，而是一开始就直接push进右节点。到左节点的时候就什么事情也不需要做。 每到一个结点优先遍历右节点，res的size++。在遍历左节点的时候直接会跳过。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://yangzebin001.github.io/tags/二叉树/"}]},{"title":"LeetCode-191. 位1的个数 &&  231. 2的幂","slug":"LeetCode-191-位1的个数-231-2的幂","date":"2019-02-21T10:17:36.000Z","updated":"2019-02-27T10:12:48.262Z","comments":true,"path":"2019/02/21/LeetCode-191-位1的个数-231-2的幂/","link":"","permalink":"https://yangzebin001.github.io/2019/02/21/LeetCode-191-位1的个数-231-2的幂/","excerpt":"191. 位1的个数 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。Solution1：","text":"191. 位1的个数 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。Solution1： 1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int cot = 0; while(n)&#123; cot += n&amp;1; n &gt;&gt;= 1; &#125; return cot; &#125;&#125;; 思路：将每一位移到最后一位检查是否为1，到0为止，最后返回个数。 由于是无符号整型，每次都会执行32次，所以时间复杂度是O(1)。 Solution2（优化）：1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int cot = 0; while(n)&#123; n &amp;= (n-1); cot++; &#125; return cot; &#125;&#125;; 看了官方题解，这种方法是每一次将最后一个1给消除。这样顶多执行k次，k就为1的个数。这样就又优化了一点点计算。 eg： 11010 &amp; 11001 = 11000 11000 &amp; 10111 = 10000 10000 &amp; 01111 = 0 231. 2的幂给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 有了上面的思路： 这道题就可以写成这样： 123456class Solution &#123;public: bool isPowerOfTwo(int n) &#123; return n &gt; 0 &amp;&amp; !(n &amp; (n-1)); &#125;&#125;; 2的n次方在二进制中就是只有1个位置是1，其他全是0（对于正数）。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"位运算","slug":"位运算","permalink":"https://yangzebin001.github.io/tags/位运算/"}]},{"title":"LeetCode-129. 求根到叶子节点数字之和","slug":"LeetCode-129-求根到叶子节点数字之和","date":"2019-02-21T10:17:03.000Z","updated":"2019-02-23T09:58:41.801Z","comments":true,"path":"2019/02/21/LeetCode-129-求根到叶子节点数字之和/","link":"","permalink":"https://yangzebin001.github.io/2019/02/21/LeetCode-129-求根到叶子节点数字之和/","excerpt":"129. 求根到叶子节点数字之和 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。","text":"129. 求根到叶子节点数字之和 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。 Solution：1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int sumNumbers(TreeNode* root) &#123; int sum = 0; if(!root) return 0; sumVal(root,0,sum); return sum; &#125; void sumVal(TreeNode* root, int pathsum,int&amp;sum)&#123; if(!root-&gt;left &amp;&amp; !root-&gt;right)&#123; sum += pathsum*10 + root-&gt;val; return; &#125; if(root-&gt;left) sumVal(root-&gt;left, pathsum*10 + root-&gt;val, sum); if(root-&gt;right) sumVal(root-&gt;right, pathsum*10 + root-&gt;val, sum); &#125;&#125;; 这道题由于是到叶子节点的路径，并且要将其中走过的节点的值加起来，所以不能到空节点才停止（无法确定加值的时机），这里是到叶子节点就停止，并且把值加到sum中。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-114. 二叉树展开为链表","slug":"LeetCode-114-二叉树展开为链表","date":"2019-02-19T11:10:13.000Z","updated":"2019-02-27T10:15:03.072Z","comments":true,"path":"2019/02/19/LeetCode-114-二叉树展开为链表/","link":"","permalink":"https://yangzebin001.github.io/2019/02/19/LeetCode-114-二叉树展开为链表/","excerpt":"114. 二叉树展开为链表 给定一个二叉树，原地将它展开为链表。 Solution1：","text":"114. 二叉树展开为链表 给定一个二叉树，原地将它展开为链表。 Solution1： 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void flatten(TreeNode* root) &#123; if(!root) return; dfs(root); &#125; TreeNode* dfs(TreeNode* node)&#123; if(!node-&gt;left &amp;&amp; !node-&gt;right) return node; TreeNode* lastLeft = NULL; TreeNode* lastRight = NULL; if(node-&gt;left)&#123; lastLeft = dfs(node-&gt;left); &#125; if(node-&gt;right)&#123; lastRight = dfs(node-&gt;right); &#125; if(lastLeft)&#123; lastLeft-&gt;right = node-&gt;right; node-&gt;right = node-&gt;left; node-&gt;left = NULL; &#125; if(lastRight) return lastRight; else return lastLeft; &#125;&#125;; 思路：从叶子结点开始，向上展开。每到一层，分别获得左子树和右子树的最后节点，将左子树的最后节点与当前节点的右子树的开始节点连接，将当前节点的右节点指向左子树的开始节点，左子树置空。 接着返回当前子树的最后节点，作为上一层的相应结点做相应的处理。 优化：1234567891011121314151617181920class Solution &#123;public: void flatten(TreeNode* root) &#123; dfs(root); &#125; TreeNode* dfs(TreeNode* node)&#123; if(!node) return NULL; TreeNode* lastLeft; TreeNode* lastRight; lastLeft = dfs(node-&gt;left); lastRight = dfs(node-&gt;right); if(lastLeft)&#123; lastLeft-&gt;right = node-&gt;right; node-&gt;right = node-&gt;left; node-&gt;left = NULL; &#125; return lastRight ? lastRight : lastLeft ? lastLeft : node ; &#125;&#125;; 将空节点做一般化考虑，在返回的时候做相应的处理。 分几种情况： 有lastRight，优先返回lastRight， 没有lastRight，有lastLeft，此时由于之上的代码已经将子树展开为链表并转换到了右子树上面，这时返回lastLeft。 lastRight 和 lastLeft 都没有，这时为叶子节点，直接返回该节点即可。 Solution2（终极版）：123456789101112class Solution &#123;public: TreeNode* prev = NULL; void flatten(TreeNode* root) &#123; if(!root) return; flatten(root-&gt;right); flatten(root-&gt;left); root-&gt;right = prev; root-&gt;left = NULL; prev = root; &#125;&#125;; 看到评论区大神写的这段代码，我觉得我被虐的体无完肤。 首先，设置一个全局变量，该变量用来记录已经翻转过的开始结点。接着，递归是首先下到最右边，从最右边开始的，这就保证了只需要关心已经展开链表的头结点，尾结点没必要再关心了。每次到达一个子树，从最右的结点开始，每个节点接到全局变量上。全局变量刷新为新的展开链表的头。如此一直到达根节点。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"递归","slug":"递归","permalink":"https://yangzebin001.github.io/tags/递归/"}]},{"title":"LeetCode-110. 平衡二叉树","slug":"LeetCode-110-平衡二叉树","date":"2019-02-19T10:49:09.000Z","updated":"2019-02-19T10:56:41.935Z","comments":true,"path":"2019/02/19/LeetCode-110-平衡二叉树/","link":"","permalink":"https://yangzebin001.github.io/2019/02/19/LeetCode-110-平衡二叉树/","excerpt":"110. 平衡二叉树 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 Solution（递归版）：","text":"110. 平衡二叉树 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 Solution（递归版）： 12345678910111213141516class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; if(!root) return true; if(std::abs(depth(root-&gt;left)-depth(root-&gt;right)) &gt; 1 )&#123; return false; &#125;else&#123; return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125; &#125; int depth(TreeNode* root) &#123; if(!root) return 0; return 1 + std::max(depth(root-&gt;left),depth(root-&gt;right)); &#125;&#125;; 思路：依次向下判断每一个节点的下左右子树的高度差。如果大于1，返回false，否则继续向下判断。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-144. 二叉树的前序遍历","slug":"LeetCode-144-二叉树的前序遍历","date":"2019-02-18T04:19:45.000Z","updated":"2019-02-27T10:13:58.019Z","comments":true,"path":"2019/02/18/LeetCode-144-二叉树的前序遍历/","link":"","permalink":"https://yangzebin001.github.io/2019/02/18/LeetCode-144-二叉树的前序遍历/","excerpt":"144. 二叉树的前序遍历 给定一个二叉树，返回它的前序遍历。 Solution1（递归版）：","text":"144. 二叉树的前序遍历 给定一个二叉树，返回它的前序遍历。 Solution1（递归版）： 123456789101112131415class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; preorder(root,res); return res; &#125; void preorder(TreeNode* node, vector&lt;int&gt; &amp;res)&#123; if(!node) return; res.push_back(node-&gt;val); preorder(node-&gt;left, res); preorder(node-&gt;right, res); &#125; &#125;; Solution2（迭代版）：12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; s; TreeNode* cur = root; s.push(root); while(!s.empty())&#123; cur = s.top(); s.pop(); res.push_back(cur-&gt;val); if(cur-&gt;right) s.push(cur-&gt;right); if(cur-&gt;left) s.push(cur-&gt;left); &#125; return res; &#125;&#125;; 前序遍历的顺序为先处理当前节点，再处理左节点，最后处理右节点。 对于栈来说。首先处理当前节点。然后先把右节点压入栈中，转而处理左节点。 OR12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; toVisit; vector&lt;int&gt; result; if(root == NULL)&#123; return result; &#125; TreeNode* current = root; while(current || !toVisit.empty())&#123; if(current != NULL)&#123; result.push_back(current-&gt;val); toVisit.push(current-&gt;right); current = current-&gt;left; &#125; else &#123; current = toVisit.top(); toVisit.pop(); &#125; &#125; return result; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://yangzebin001.github.io/tags/二叉树/"}]},{"title":"LeetCode-94. 二叉树的中序遍历","slug":"LeetCode-94-二叉树的中序遍历","date":"2019-02-18T04:19:04.000Z","updated":"2019-02-27T10:15:44.253Z","comments":true,"path":"2019/02/18/LeetCode-94-二叉树的中序遍历/","link":"","permalink":"https://yangzebin001.github.io/2019/02/18/LeetCode-94-二叉树的中序遍历/","excerpt":"94. 二叉树的中序遍历 给定一个二叉树，返回它的中序遍历。 Solution1（递归版）：","text":"94. 二叉树的中序遍历 给定一个二叉树，返回它的中序遍历。 Solution1（递归版）： 123456789101112131415class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; inorder(root,res); return res; &#125; void inorder(TreeNode* node, vector&lt;int&gt; &amp;res)&#123; if(!node) return; inorder(node-&gt;left, res); res.push_back(node-&gt;val); inorder(node-&gt;right, res); &#125;&#125;; Solution2（迭代版）：1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; ss; TreeNode* cur = root; while(cur || !ss.empty())&#123; //优先把左节点push进栈。 if(cur)&#123; ss.push(cur); cur = cur-&gt;left; &#125; //该节点没有左节点，此时就该存储起来了。然后继续对右节点的操作。（自底向上的访问右节点） else&#123; cur = ss.top(); ss.pop(); res.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; &#125; return res; &#125;&#125;; 中序遍历的特点就是优先遍历左节点，之后是当前节点，最后是右节点。 所以遇到一个节点。先存储在栈内。考虑以下两点： 有左节点，继续加入栈。 没有左节点，处理该节点，并将该节点从栈中弹出，继续考虑该节点的右节点。 这里我在思考的时候，逻辑没有问题，在coding的时候，关注的是父节点与子节点的关系，这样写出来的代码很容易导致死循环（在左子节点判断玩后，无法弹出栈，下一层循环又继续进行左子节点的判断了）。看到评论是将每一个节点提出来作为观察对象。更加直接。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二叉树","slug":"二叉树","permalink":"https://yangzebin001.github.io/tags/二叉树/"}]},{"title":"LeetCode-111. 二叉树的最小深度","slug":"LeetCode-111-二叉树的最小深度","date":"2019-02-14T08:56:45.000Z","updated":"2019-02-14T09:01:00.176Z","comments":true,"path":"2019/02/14/LeetCode-111-二叉树的最小深度/","link":"","permalink":"https://yangzebin001.github.io/2019/02/14/LeetCode-111-二叉树的最小深度/","excerpt":"111. 二叉树的最小深度 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 Solution1（递归版）：","text":"111. 二叉树的最小深度 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 Solution1（递归版）： 1234567891011121314151617class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(!root) return 0; return depth(root); &#125; int depth(TreeNode* root)&#123; if(!root-&gt;left &amp;&amp; !root-&gt;right) return 1; int l = INT_MAX, r = INT_MAX; if(root-&gt;left)&#123; l = 1 + depth(root-&gt;left); &#125;if(root-&gt;right)&#123; r = 1 + depth(root-&gt;right); &#125; return min(l,r); &#125;&#125;; 递归到叶子节点就停止。 如果不是叶子结点。则向下递归，找到最小值即可。 Solution2（迭代版）：12345678910111213141516171819202122232425class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(!root) return 0; queue&lt;TreeNode*&gt; q; q.push(root); int depth = 0; while(!q.empty())&#123; int len = q.size(); depth++; while(len &gt; 0)&#123; TreeNode* t = q.front(); q.pop(); if(!t-&gt;left &amp;&amp; !t-&gt;right) &#123; return depth; &#125; if(t-&gt;left)q.push(t-&gt;left); if(t-&gt;right)q.push(t-&gt;right); len--; &#125; &#125; return depth; &#125; &#125;; 层次遍历二叉树，每次弹出一层，如果该层有叶子节点，直接返回当前记录的深度。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-74. 搜索二维矩阵","slug":"LeetCode-74-搜索二维矩阵","date":"2019-02-14T08:55:55.000Z","updated":"2019-02-27T10:16:49.354Z","comments":true,"path":"2019/02/14/LeetCode-74-搜索二维矩阵/","link":"","permalink":"https://yangzebin001.github.io/2019/02/14/LeetCode-74-搜索二维矩阵/","excerpt":"74. 搜索二维矩阵 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。","text":"74. 搜索二维矩阵 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 Solution1： 12345678910111213141516171819202122232425262728class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int j = matrix.size(); for(int i = 0; i &lt; j; i++)&#123; int k = matrix[i].size(); if(k == 0) continue; if(matrix[i][k-1] == target) return true; else if(matrix[i][k-1] &lt; target) continue; return hasNumInArray(matrix[i], target); &#125; return false; &#125; bool hasNumInArray(vector&lt;int&gt; &amp;a, int num)&#123; int i = 0, j = a.size(); while(i &lt; j)&#123; int mid = (i + j)/2; if(a[mid] == num) return true; else if(num &gt; a[mid])&#123; i = mid+1; &#125;else&#123; j = mid; &#125; &#125; return false; &#125;&#125;; 首先检查每一行的最后一个元素。如果等于直接返回，如果小于目标值，说明不在该行，继续进行下一行的检查。当上一行的最后一个元素比目标值大，当前行最后一个元素比目标值小时，就只在该行进行搜索（二分）。如果能够搜索到则返回true，找不到则说明整个矩阵内没有目标值。 待优化的点： 在进行对每一列的检查时，也可以使用二分来加速范围的选择。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二维矩阵","slug":"二维矩阵","permalink":"https://yangzebin001.github.io/tags/二维矩阵/"},{"name":"数组","slug":"数组","permalink":"https://yangzebin001.github.io/tags/数组/"}]},{"title":"LeetCode-59. 螺旋矩阵 II","slug":"LeetCode-59-螺旋矩阵-II","date":"2019-02-14T08:55:05.000Z","updated":"2019-02-27T10:17:21.081Z","comments":true,"path":"2019/02/14/LeetCode-59-螺旋矩阵-II/","link":"","permalink":"https://yangzebin001.github.io/2019/02/14/LeetCode-59-螺旋矩阵-II/","excerpt":"59. 螺旋矩阵 II 给定一个正整数 n，生成一个包含 1 到 n² 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 与54. 螺旋矩阵类似。 只需要依次给新数组中的相应元素赋值即可。 Solution：","text":"59. 螺旋矩阵 II 给定一个正整数 n，生成一个包含 1 到 n² 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 与54. 螺旋矩阵类似。 只需要依次给新数组中的相应元素赋值即可。 Solution： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt; &gt; res(n, vector&lt;int&gt;(n));; if(n &lt;= 0) return res; int k = 1; int left = 0, right = n-1, up = 0, down = n-1; while(left &lt; right &amp;&amp; up &lt; down)&#123; int i = left, j = up; while(i &lt; right)&#123; res[j][i] = k++; i++; &#125; while(j &lt; down)&#123; res[j][i] = k++; j++; &#125; while(i &gt; left)&#123; res[j][i] = k++; i--; &#125; while(j &gt; up)&#123; res[j][i] = k++; j--; &#125; left++; right--; up++; down--; &#125; //形不成圈（单列或者单行） if(up == down)&#123; while(left &lt;= right)&#123; res[up][left++] = k++; &#125; &#125;else if(left == right)&#123; while(up &lt;= down)&#123; res[up++][left] = k++; &#125; &#125; return res; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二维矩阵","slug":"二维矩阵","permalink":"https://yangzebin001.github.io/tags/二维矩阵/"},{"name":"数组","slug":"数组","permalink":"https://yangzebin001.github.io/tags/数组/"}]},{"title":"LeetCode-54. 螺旋矩阵","slug":"LeetCode-54-螺旋矩阵","date":"2019-02-14T08:54:22.000Z","updated":"2019-02-27T10:17:45.476Z","comments":true,"path":"2019/02/14/LeetCode-54-螺旋矩阵/","link":"","permalink":"https://yangzebin001.github.io/2019/02/14/LeetCode-54-螺旋矩阵/","excerpt":"54. 螺旋矩阵 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。","text":"54. 螺旋矩阵 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 Solution：12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; res; if(matrix.size() == 0) return res; int left = 0,up = 0, right = matrix[0].size()-1, down = matrix.size()-1; while(left &lt; right &amp;&amp; up &lt; down)&#123; int i = left, j = up; while(i &lt; right)&#123; res.push_back(matrix[j][i]); i++; &#125; while(j &lt; down)&#123; res.push_back(matrix[j][i]); j++; &#125; while(i &gt; left)&#123; res.push_back(matrix[j][i]); i--; &#125; while(j &gt; up)&#123; res.push_back(matrix[j][i]); j--; &#125; left++; right--; up++; down--; &#125; //形不成圈（单列或者单行） if(up == down)&#123; while(left &lt;= right)&#123; res.push_back(matrix[up][left++]); &#125; &#125;else if(left == right)&#123; while(up &lt;= down)&#123; res.push_back(matrix[up++][left]); &#125; &#125; return res; &#125;&#125;; 思路：每次将矩阵的外围当做一个圈来处理，然后缩小圈的范围。 直到形不成圈，此时要么是单行，要么是单列，要么是中心点（看做单行，单列都可行），然后单独处理即可。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"二维矩阵","slug":"二维矩阵","permalink":"https://yangzebin001.github.io/tags/二维矩阵/"},{"name":"数组","slug":"数组","permalink":"https://yangzebin001.github.io/tags/数组/"}]},{"title":"LeetCode-922. 按奇偶排序数组 II","slug":"LeetCode-922-按奇偶排序数组-II","date":"2019-02-14T08:52:27.000Z","updated":"2019-02-27T10:08:32.549Z","comments":true,"path":"2019/02/14/LeetCode-922-按奇偶排序数组-II/","link":"","permalink":"https://yangzebin001.github.io/2019/02/14/LeetCode-922-按奇偶排序数组-II/","excerpt":"922. 按奇偶排序数组 II 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 Solution:","text":"922. 按奇偶排序数组 II 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 Solution: 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt;&amp; A) &#123; int i = 0; int len = A.size(); int j = 1; while(1)&#123; while(i &lt; len &amp;&amp; (A[i] &amp; 1) == 0) i+=2; while(j &lt; len &amp;&amp; (A[j] &amp; 1) != 0) j+=2; if(i &gt;= len || j &gt;= len) break; std::swap(A[i],A[j]); i+=2; j+=2; &#125; return A; &#125; &#125;; 思路：设置两个指针。一个指针只走奇数下标，一个指针只走偶数下标。当碰到不符合条件（奇数下标的值不是奇数，偶数下标的值不是偶数）就停下并交换两个值，之后接着走，直到指针越界为止。 看评论有人用栈或者另外准备两个数组的，速度比原地交换还快，不知道为什么。实现也比较简单，就不赘述了。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"双指针","slug":"双指针","permalink":"https://yangzebin001.github.io/tags/双指针/"}]},{"title":"LeetCode-559. N叉树的最大深度","slug":"LeetCode-559-N叉树的最大深度","date":"2019-02-09T08:36:57.000Z","updated":"2019-02-09T08:45:59.240Z","comments":true,"path":"2019/02/09/LeetCode-559-N叉树的最大深度/","link":"","permalink":"https://yangzebin001.github.io/2019/02/09/LeetCode-559-N叉树的最大深度/","excerpt":"559. N叉树的最大深度 给定一个 N 叉树，找到其最大深度。 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。","text":"559. N叉树的最大深度 给定一个 N 叉树，找到其最大深度。 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。 Solution1（递归版）：123456789101112131415161718192021222324252627282930/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123;public: int maxDepth(Node* root) &#123; return dfs(root,1); &#125; int dfs(Node* node, int m)&#123; if(!node) return 0; int max = m; for(int i = 0; i &lt; node-&gt;children.size(); i++)&#123; max = std::max(dfs(node-&gt;children[i], m+1), max); &#125; return max; &#125;&#125;; 递归版本。 我的写法为： 定义空节点的深度为0，这样在做最大值比较的时候返回的是其父节点的深度。 这样做可以在root为空的时候不用做特殊处理。直接会返回0。 评论区有人是这样写的： 123456789public int maxDepth(Node root) &#123; //DFS递归写法 if(root == null) return 0; int depth = 0; for(int i = 0;i&lt;root.children.size();i++)&#123; depth = Math.max(depth,maxDepth(root.children.get(i))); &#125; return depth+1;&#125; 由下至上来确定最大深度，但是需要额外判断根节点为空的情况。 Solution2（迭代版）：12345678910111213141516171819202122232425262728293031323334353637383940/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123; public: int maxDepth(Node* root) &#123; if(!root) return 0; int maxDep = 0; queue&lt;Node*&gt; q; q.push(root); //队列中始终保持存储的节点都为同一层。 while(!q.empty())&#123; int n = q.size(); //当前层有结点。 maxDep++; //将当前层所有元素pop掉。 for(int i = 0; i &lt; n ;i++)&#123; Node* t = q.front(); q.pop(); //将子节点push进队列。 for(int j = 0; j &lt; t-&gt;children.size(); j++)&#123; q.push(t-&gt;children[j]); &#125; &#125; &#125; return maxDep; &#125;&#125;; 迭代版利用层次遍历。 每到一层，深度加1。然后将该层的所有结点pop掉。继续将下一层的结点push进来。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-101. 对称二叉树","slug":"LeetCode-101-对称二叉树","date":"2019-02-09T08:35:51.000Z","updated":"2019-02-09T08:39:49.522Z","comments":true,"path":"2019/02/09/LeetCode-101-对称二叉树/","link":"","permalink":"https://yangzebin001.github.io/2019/02/09/LeetCode-101-对称二叉树/","excerpt":"101. 对称二叉树 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 Solution1（递归版）：","text":"101. 对称二叉树 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 Solution1（递归版）： 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; return isMirror(root, root); &#125; bool isMirror(TreeNode* t1, TreeNode* t2)&#123; //都为NULL if(!t1 &amp;&amp; !t2) return true; //有一个结点为NULL，另一个不为NULL if(!t1 || !t2) return false; return (t1-&gt;val == t2-&gt;val) &amp;&amp; isMirror(t1-&gt;left, t2-&gt;right) &amp;&amp; isMirror(t1-&gt;right, t2-&gt;left); &#125;&#125;; 看的官方题解。 把一棵对称树分成左子树和右子树。 如果左子树和右子树对称，则该数相同。 扩展到一般概念就是： 有两棵树。 两棵树的根节点相同。 每个树的右子树都与另一个树的左子树镜像对称。 翻译为递推公式就是： 1234TreeNode* t1,t2;t1-&gt;val == t2-&gt;val;t1-&gt;left == t2-&gt;right;t1-&gt;right = t2-&gt;left; 结束条件为两棵树为空。 整理可得上述代码。 Solution2（迭代版）：123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; q.push(root); q.push(root); while(!q.empty())&#123; TreeNode* t1 = q.front(); q.pop(); TreeNode* t2 = q.front(); q.pop(); if(!t1 &amp;&amp; !t2) continue; if(!t1 || !t2) return false; if(t1-&gt;val != t2-&gt;val) return false; q.push(t1-&gt;left); q.push(t2-&gt;right); q.push(t2-&gt;left); q.push(t1-&gt;right); &#125; return true; &#125;&#125;; 翻译为了迭代版，只不过根本的思想是一样的。都是将一棵树化为两棵树来进行判断的。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-590. N叉树的后序遍历","slug":"LeetCode-590-N叉树的后序遍历","date":"2019-02-09T08:35:15.000Z","updated":"2019-02-09T08:39:38.854Z","comments":true,"path":"2019/02/09/LeetCode-590-N叉树的后序遍历/","link":"","permalink":"https://yangzebin001.github.io/2019/02/09/LeetCode-590-N叉树的后序遍历/","excerpt":"590. N叉树的后序遍历 给定一个 N 叉树，返回其节点值的后序遍历。 与589. N叉树的前序遍历相对应。 Solution：","text":"590. N叉树的后序遍历 给定一个 N 叉树，返回其节点值的后序遍历。 与589. N叉树的前序遍历相对应。 Solution： 12345678910111213141516171819202122232425262728293031/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt; postorder(Node* root) &#123; vector&lt;int&gt; data; lastord(root,data); return data; &#125; void lastord(Node* root, vector&lt;int&gt; &amp;data)&#123; if(!root) return; for(int i = 0; i &lt; root-&gt;children.size(); i++)&#123; lastord(root-&gt;children[i], data); &#125; data.push_back(root-&gt;val); &#125;&#125;; 基础题。 先访问子节点，等全部子节点访问完毕再将该节点的信息存储起来即可。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-589. N叉树的前序遍历","slug":"LeetCode-589-N叉树的前序遍历","date":"2019-02-09T08:34:30.000Z","updated":"2019-02-09T08:39:35.953Z","comments":true,"path":"2019/02/09/LeetCode-589-N叉树的前序遍历/","link":"","permalink":"https://yangzebin001.github.io/2019/02/09/LeetCode-589-N叉树的前序遍历/","excerpt":"589. N叉树的前序遍历 给定一个 N 叉树，返回其节点值的前序遍历。","text":"589. N叉树的前序遍历 给定一个 N 叉树，返回其节点值的前序遍历。 Solution：12345678910111213141516171819202122232425262728293031/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt; preorder(Node* root) &#123; vector&lt;int&gt; data; preord(root,data); return data; &#125; void preord(Node* root, vector&lt;int&gt; &amp;data)&#123; if(!root) return; data.push_back(root-&gt;val); for(int i = 0; i &lt; root-&gt;children.size(); i++)&#123; preord(root-&gt;children[i], data); &#125; &#125;&#125;; 基础题。 在访问子节点之前将该节点的信息存储起来即可。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-429. N叉树的层序遍历","slug":"LeetCode-429-N叉树的层序遍历","date":"2019-02-09T08:33:43.000Z","updated":"2019-02-09T08:39:43.345Z","comments":true,"path":"2019/02/09/LeetCode-429-N叉树的层序遍历/","link":"","permalink":"https://yangzebin001.github.io/2019/02/09/LeetCode-429-N叉树的层序遍历/","excerpt":"429. N叉树的层序遍历 给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。","text":"429. N叉树的层序遍历 给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。 Solution1：1234567891011121314151617181920212223242526272829303132333435363738394041424344/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123; vector&lt;vector&lt;int&gt; &gt; data; if(!root) return data; queue&lt;Node*&gt; q; // 从节点开始。 q.push(root); while(!q.empty())&#123; vector&lt;int&gt; t; int len = q.size(); //遍历目前队列中的节点，将他们逐一push进数组中。 for(int i = 0; i &lt; len; i++)&#123; Node* n = q.front(); //将当前元素从队列中移除。 q.pop(); //存储数据 t.push_back(n-&gt;val); // 将每个元素下面的子节点push进队列中。 for(int j = 0; j &lt; n-&gt;children.size(); j++)&#123; q.push(n-&gt;children[j]); &#125; &#125; data.push_back(t); &#125; return data; &#125;&#125;; 使用队列进行层序遍历。 每走到一层，记录该层有多少节点。对于该层的每一个节点都做 将该节点的数据存储起来。 将该节点从队列中移除。 将该节点下的所有子节点都push进入队列中。 当一层节点操作完毕后，队列中存储的就为下一层的全部节点。队列的个数就为当前所在层的节点的个数。 Solution2：123456789101112131415161718192021222324252627282930313233343536373839/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123; vector&lt;vector&lt;int&gt; &gt; data; dfs(root, data, 0); return data; &#125; void dfs(Node* node, vector&lt;vector&lt;int&gt; &gt; &amp;data, int level)&#123; if(!node) return; //如果当前层还没有初始化。 if(data.size()&lt;= level)&#123; vector&lt;int&gt; t; t.push_back(node-&gt;val); data.push_back(t); &#125;else&#123; data[level].push_back(node-&gt;val); &#125; for(int i = 0; i &lt; node-&gt;children.size(); i++)&#123; dfs(node-&gt;children[i], data, level+1); &#125; &#125;&#125;; 递归版本。 记录当前的层数。当前节点属于哪一层就往哪一层里push元素。 初始化小技巧： 当使用双层vector时，必须先初始化每一层vector。 可以利用size巧妙的进行初始化，每走到一层，将size与当前层作比较，size总是比当前层大1。 12345 if(data.size()&lt;= level)&#123; vector&lt;int&gt; t; t.push_back(node-&gt;val); data.push_back(t);&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-236. 二叉树的最近公共祖先","slug":"LeetCode-236-二叉树的最近公共祖先","date":"2019-02-02T08:00:23.000Z","updated":"2019-02-02T08:05:05.051Z","comments":true,"path":"2019/02/02/LeetCode-236-二叉树的最近公共祖先/","link":"","permalink":"https://yangzebin001.github.io/2019/02/02/LeetCode-236-二叉树的最近公共祖先/","excerpt":"236. 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”","text":"236. 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” Solution1：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */static int flag = 0;class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; // 1.找到从根节点到某一结点的路径。存储在栈内。 stack&lt;TreeNode*&gt; a; stack&lt;TreeNode*&gt; b; flag = 0; path(root,p,a); flag = 0; path(root,q,b); // 2.比较两个栈的栈顶，一样，返回，不一样，弹出较长的那个。如果长度一样，同时弹出。 TreeNode* t = NULL; while(1)&#123; if(a.top() == b.top())&#123; t = a.top(); break; &#125; if(a.size() &gt; b.size())&#123; a.pop(); &#125;else if(a.size() &lt; b.size())&#123; b.pop(); &#125;else&#123; a.pop(); b.pop(); &#125; &#125; return t; &#125; void path(TreeNode* root, TreeNode* p, stack&lt;TreeNode*&gt; &amp;a)&#123; if(!root || flag == 1) return; a.push(root); if(root == p)&#123; flag = 1; &#125; path(root-&gt;left,p,a); path(root-&gt;right,p,a); if(flag != 1)&#123; a.pop(); &#125; &#125;&#125;; 先寻找从根节点到给定结点的路径，并存储在栈中。再将两栈比较，找到第一个相同结点即为最近公共祖先。由于需要找最近相同的结点。所以在遍历二叉树时，要使用前序遍历，先将结点保存在栈中，再考虑其子节点。得到两个存储路径的栈（根节点在栈底）。 由于路径与层有关，路径越长的结点，所在的层也越低。所以寻找公共结点首先把较大的栈缩小到与较小的栈长度一致，然后比较栈顶，当遇到相同结点时，就为最近公共祖先。 Solution2：12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; // 找到最近符合条件的结点。 if(!root || root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left,p,q); TreeNode* right = lowestCommonAncestor(root-&gt;right,p,q); // 如果找到了两个结点，不在一个位置。返回该结点（该结点是两个结点的公共祖先）。 if(left &amp;&amp; right) return root; //如果在该结点的下面，只找到了一个，先将该结点返回，交给上一级处理。（为了递归） if(left) return left; else return right; &#125;&#125;; 递归版本。 看了评论区大神写的。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-226. 翻转二叉树","slug":"LeetCode-226-翻转二叉树","date":"2019-02-02T07:59:44.000Z","updated":"2019-02-02T08:05:11.341Z","comments":true,"path":"2019/02/02/LeetCode-226-翻转二叉树/","link":"","permalink":"https://yangzebin001.github.io/2019/02/02/LeetCode-226-翻转二叉树/","excerpt":"226. 翻转二叉树 翻转一棵二叉树。","text":"226. 翻转二叉树 翻转一棵二叉树。 Solution1（递归版）：12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root) return NULL; if(root-&gt;left) invertTree(root-&gt;left); if(root-&gt;right) invertTree(root-&gt;right); TreeNode* temp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = temp; return root; &#125;&#125;; 依次从叶子结点向上翻转。 Solution2（层次遍历版）：123456789101112131415161718class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root) return NULL; queue&lt;TreeNode*&gt; que; que.push(root); while(!que.empty())&#123; TreeNode* node = que.front(); que.pop(); TreeNode* nodeleft = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = nodeleft; if(node-&gt;left) que.push(node-&gt;left); if(node-&gt;right) que.push(node-&gt;right); &#125; return root; &#125;&#125;; 层次遍历，每到一个结点，就讲该结点下的子结点交换。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode-90. 子集 II","slug":"LeetCode-90-子集-II","date":"2019-01-24T08:39:22.000Z","updated":"2019-02-27T10:21:36.644Z","comments":true,"path":"2019/01/24/LeetCode-90-子集-II/","link":"","permalink":"https://yangzebin001.github.io/2019/01/24/LeetCode-90-子集-II/","excerpt":"90. 子集 II 该题为78. 子集的升级版 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。","text":"90. 子集 II 该题为78. 子集的升级版 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: [1,2,2]输出:[ [2], [1], [1,2,2], [2,2], [1,2], []] Solution1：123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; result; vector&lt;int&gt; item; result.push_back(item); //去重所使用的集合 set&lt;vector&lt;int&gt;&gt; item_set; //对nums进行排序。 sort(nums.begin(),nums.end()); putitem(0, nums, result, item, item_set); return result; &#125; void putitem(int i, vector&lt;int&gt;&amp; nums,vector&lt;vector&lt;int&gt; &gt; &amp;result, vector&lt;int&gt; &amp;item, set&lt;vector&lt;int&gt;&gt; &amp;item_set)&#123; if(i &gt;= nums.size()) return; item.push_back(nums[i]); //如果没有重复，就加入到最终的集合里。 if(item_set.find(item) == item_set.end())&#123; result.push_back(item); //加入去重集合中。 item_set.insert(item); &#125; putitem(i+1, nums, result, item, item_set); item.pop_back(); putitem(i+1, nums, result, item, item_set); &#125; &#125;; 使用一个set来先存储集合。每当在添加的时候，先检查set中是否已经包含，再决定放入。 由于该题中有重复元素，为了避免形如[2,3,3,2]与[3,2,2,3]，先进行排序插入","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"排列","slug":"排列","permalink":"https://yangzebin001.github.io/tags/排列/"}]},{"title":"LeetCode 452. 用最少数量的箭引爆气球","slug":"LeetCode-452-用最少数量的箭引爆气球","date":"2019-01-17T09:46:09.000Z","updated":"2019-02-27T10:08:02.700Z","comments":true,"path":"2019/01/17/LeetCode-452-用最少数量的箭引爆气球/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-452-用最少数量的箭引爆气球/","excerpt":"452. 用最少数量的箭引爆气球 维护一个射击区间。如果下一个区间的开始位置比当前区间的开始位置大，则需要更新。同理，结束位置也一样。 也是就是说，保持在这个射击区间内，每一个气球都能被射中（求射击区间内所有球的交集）。","text":"452. 用最少数量的箭引爆气球 维护一个射击区间。如果下一个区间的开始位置比当前区间的开始位置大，则需要更新。同理，结束位置也一样。 也是就是说，保持在这个射击区间内，每一个气球都能被射中（求射击区间内所有球的交集）。 如果气球不再能被这个射击区间所容纳，则在增加一个射击区间。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int findMinArrowShots(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) &#123; if(points.size() == 0)&#123; return 0; &#125; //对气球从左端点开始排序。 sort(points.begin(),points.end()); int arrow = 1; int startindex = points[0].first; int endindex = points[0].second; for(int i = 1; i &lt; points.size(); i++)&#123; //更新最小区间。 if(points[i].first &gt; startindex &amp;&amp; points[i].first &lt;= endindex)&#123; startindex = points[i].first; &#125; if(points[i].second &lt; endindex &amp;&amp; points[i].second &gt;= startindex)&#123; endindex = points[i].second; &#125; //继续下一轮。 else if(points[i].first &gt; startindex)&#123; startindex = points[i].first; endindex = points[i].second; arrow++; &#125; &#125; return arrow; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"贪心","slug":"贪心","permalink":"https://yangzebin001.github.io/tags/贪心/"}]},{"title":"LeetCode-45- 跳跃游戏 II","slug":"LeetCode-45-跳跃游戏-II","date":"2019-01-17T09:45:06.000Z","updated":"2019-02-27T10:17:58.904Z","comments":true,"path":"2019/01/17/LeetCode-45-跳跃游戏-II/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-45-跳跃游戏-II/","excerpt":"45. 跳跃游戏 II 此题55. 跳跃游戏的进阶版 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。","text":"45. 跳跃游戏 II 此题55. 跳跃游戏的进阶版 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 按照前面题的思路，依然是从后往前搜索。每次搜索能跳到当前位置的最远位置。 123456789101112131415161718192021222324class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; // 选择当前能跳到当前点的最远的距离。 int max_index = nums.size()-1; int current_max_index = max_index; int step = 0; //当没有到达开头位置，进行循环。 while(max_index &gt; 0)&#123; //记录能跳到当前数组的最前面的点。 for(int i = max_index-1; i &gt;= 0; i--)&#123; if(i + nums[i] &gt;= max_index)&#123; current_max_index = i; &#125; &#125; //更新能跳的最远的点。 max_index = current_max_index; //步数更新 step++; &#125; return step; &#125; &#125;; 用了两层循环，发现能ac，但是又排在了末名。 看了大神的代码，写出了下面的代码： 123456789101112131415161718192021222324252627class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt; 2)&#123; return 0; &#125; //当前可到达的最远距离。 int current_max_index = nums[0]; //遍历各个位置中，可到达的最远距离。 int pre_max_max_index = nums[0]; int jump = 1; for(int i = 1; i &lt; nums.size(); i++)&#123; //更新当前可达到的最远距离。 if(i &gt; current_max_index)&#123; jump++; current_max_index = pre_max_max_index; &#125; if(pre_max_max_index &lt; nums[i] + i)&#123; //更新 pre_max_max_index = nums[i] + i; &#125; &#125; return jump; &#125; &#125;; 跳到当前所能跳到的最远的位置所在的位置中。 记录当前位置所能到达的最远的位置。 如果做到了该最远位置，更新一下。继续走。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"贪心","slug":"贪心","permalink":"https://yangzebin001.github.io/tags/贪心/"}]},{"title":"LeetCode-402-移掉K位数字","slug":"LeetCode-402-移掉K位数字","date":"2019-01-17T09:44:04.000Z","updated":"2019-02-27T10:10:52.391Z","comments":true,"path":"2019/01/17/LeetCode-402-移掉K位数字/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-402-移掉K位数字/","excerpt":"402. 移掉K位数字 给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。在保持顺序的情况下，尽可能让较小的数充当较高位。 用一个栈来计较。如果要进的数字比栈顶要大，并且可以删。直接将该数字丢弃。","text":"402. 移掉K位数字 给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。在保持顺序的情况下，尽可能让较小的数充当较高位。 用一个栈来计较。如果要进的数字比栈顶要大，并且可以删。直接将该数字丢弃。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string removeKdigits(string num, int k) &#123; //在保持顺序的情况下，尽可能让较小的数充当较高位。 std::vector&lt;int&gt; S; std::string result = \"\"; for(int i = 0; i &lt; num.length(); i++)&#123; int number = num[i]-'0'; //比当前栈顶元素大，并且能删除（k&gt;0）,直接丢弃。 while(S.size() != 0 &amp;&amp; S[S.size()-1] &gt; number &amp;&amp; k &gt; 0)&#123; S.pop_back(); k--; &#125; //0 不能在第一个位置。即不允许“0132” if(number != 0 || S.size()!= 0)&#123; S.push_back(number); &#125; &#125; // 处理“123456789”的情况。 while(S.size() != 0 &amp;&amp; k &gt; 0)&#123; S.pop_back(); k--; &#125; for(int i = 0; i &lt; S.size(); i++)&#123; result.append(1,'0'+S[i]); &#125; if(result == \"\") return \"0\"; return result; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"贪心","slug":"贪心","permalink":"https://yangzebin001.github.io/tags/贪心/"}]},{"title":"LeeCode-455-分发饼干","slug":"LeetCode-455-分发饼干","date":"2019-01-17T09:42:46.000Z","updated":"2019-02-27T10:08:14.333Z","comments":true,"path":"2019/01/17/LeetCode-455-分发饼干/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-455-分发饼干/","excerpt":"455. 分发饼干","text":"455. 分发饼干 输入: [1,2,3], [1,1] 输出: 1 解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 尽量让胃口小的孩子分到尽量少的饼干。 先排序。在饼干的循环中，如果孩子的胃口大于等于饼干，孩子加一。 ###Solution:12345678910111213141516171819class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; //先将两组数据排序。 std::sort(g.begin(),g.end()); std::sort(s.begin(),s.end()); //记录被满足的孩子和饼干 int child = 0; int cookie = 0; while(cookie &lt; s.size() &amp;&amp; child &lt; g.size())&#123; //饼干可以满足该孩子。 if(g[child] &lt;= s[cookie])&#123; child++; &#125; cookie++; &#125; return child; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"贪心","slug":"贪心","permalink":"https://yangzebin001.github.io/tags/贪心/"}]},{"title":"LeetCode-295-数据流的中位数","slug":"LeetCode-295-数据流的中位数","date":"2019-01-17T09:41:23.000Z","updated":"2019-02-27T10:11:26.981Z","comments":true,"path":"2019/01/17/LeetCode-295-数据流的中位数/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-295-数据流的中位数/","excerpt":"295. 数据流的中位数 利用堆的堆顶可以随时保持最大（小）元素的特性。使用两个堆来存储数据。 由于需要取中位数。要保持两个堆堆顶为中间的元素。所以：","text":"295. 数据流的中位数 利用堆的堆顶可以随时保持最大（小）元素的特性。使用两个堆来存储数据。 由于需要取中位数。要保持两个堆堆顶为中间的元素。所以： 构建一个最小堆用来存放较大的数。 构建一个最大堆用来存放较小的数。 （比较绕，需要用心思考一下） 要随时保持两个堆的高度平衡。 这时，两堆堆顶就是数据中的中位数了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class MedianFinder &#123; public: /** initialize your data structure here. */ MedianFinder() &#123; &#125; void addNum(int num) &#123; if(smallNums.empty())&#123; //往存放小元素的最大堆添加数据。 smallNums.push(num); return; &#125; //如果两个堆的高度相同。优先push进当前堆顶元素更大的那一个。 if(largeNums.size() == smallNums.size())&#123; if(smallNums.top() &gt; num)&#123; smallNums.push(num); &#125;else&#123; largeNums.push(num); &#125; &#125; //为了保持两个堆的平衡 。如果两堆高度不一致，分两种情况讨论 //1.存放较大元素的最小堆的高度大于存放较小元素的最大堆的高度达。 else if(largeNums.size() &gt; smallNums.size())&#123; // 该数比存放较大元素的最小堆的堆顶要大。 // 首先将该堆堆顶元素push进存放较小元素的最大堆中。 // 再将该数push进存放较大元素的最小堆 if(num &gt; largeNums.top())&#123; smallNums.push(largeNums.top()); largeNums.pop(); largeNums.push(num); &#125; // 该数比存放较大元素的最小堆的堆顶要小。 // 直接push进存放较小元素的最大堆。 else&#123; smallNums.push(num); &#125; &#125; //2.存放较大元素的最小堆的高度小于存放较小元素的最大堆的高度达。 else if(largeNums.size() &lt; smallNums.size())&#123; // 该数比存放较小元素的最大堆的堆顶要小。（该数一定要进该堆） // 首先将该堆堆顶元素push进存放较大元素的最小堆中。 // 再将该数push进存放较小元素的最大堆中。 if(num &lt; smallNums.top())&#123; largeNums.push(smallNums.top()); smallNums.pop(); smallNums.push(num); &#125; // 该数比存放较小元素的最大堆的堆顶要大。 // 直接push进存放较大元素的最小堆。 else&#123; largeNums.push(num); &#125; &#125; &#125; double findMedian() &#123; // 两堆平衡，取中位数。 if(smallNums.size() == largeNums.size())&#123; return (((double)smallNums.top() + largeNums.top())/2 ); &#125; // 不平衡，谁高取谁的堆顶。 else if(smallNums.size() &gt; largeNums.size())&#123; return smallNums.top(); &#125; return largeNums.top(); &#125; private: // 存放较大元素的最小堆 std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; largeNums; // 存放较小元素的最大堆 std::priority_queue&lt;int&gt; smallNums;&#125;;/** * Your MedianFinder object will be instantiated and called as such: * MedianFinder obj = new MedianFinder(); * obj.addNum(num); * double param_2 = obj.findMedian(); */","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"堆","slug":"堆","permalink":"https://yangzebin001.github.io/tags/堆/"}]},{"title":"LeetCode-55- 跳跃游戏","slug":"LeetCode-55-跳跃游戏","date":"2019-01-17T09:40:08.000Z","updated":"2019-02-27T10:17:31.752Z","comments":true,"path":"2019/01/17/LeetCode-55-跳跃游戏/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-55-跳跃游戏/","excerpt":"55. 跳跃游戏 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。示例 1:","text":"55. 跳跃游戏 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。示例 1: 输入: [2,3,1,1,4]输出: true解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。 示例 2: 输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 首先想到的是将所有能达到的步数全部跑一遍，如果能到达返回true。结果TLE。 然后分析，在大部分情况下都做的是重复操作。需要剪枝。用了一个辅助表。用于记录该点能否到达的了最后一个位置。不能就标记一下，查找的时候先从表里查找。如果标记过，就不需要再进行遍历了。 代码如下 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: bool jump(vector&lt;int&gt;&amp; nums, int index,vector&lt;int&gt;&amp; q)&#123; //可以达到最后一个位置，返回true if (index &gt;= nums.size() - 1) &#123; return true; &#125; //在表中能查到，说明该点不能达到。 else if (q[index] == -1) &#123; return false; &#125; //从该点开始，到该点所能到达的最后一个元素，依次搜索。 for (int i = nums[index]; i &gt; 0; i--) &#123; if (jump(nums, index + i,q)) &#123; return true; &#125; //不能达到，在表中标记。 else if(index + i &lt; q.size())&#123; q[index + i] = -1; &#125; &#125; return false; &#125; bool canJump(vector&lt;int&gt;&amp; nums) &#123; //建一个辅助表 vector&lt;int &gt; q; for (int i = 0; i &lt; nums.size(); i++) &#123; q.push_back(0); &#125; return jump(nums,0,q); &#125; &#125;; 结果能通过。但是排在了最后。 然后看了小象学院的视频。思路是先记录下每一步能跳的最大距离， 遍历这个表。用一个变量记录步数，一个变量记录能走到的最大位置。当步数小于这个最大位置，并且该步数不是最后一个位置时，说明这个数组中不能到达最后一个位置。返回false。 如果步数能走到数组的末尾，说明能走到。返回true。 12345678910111213141516171819202122232425class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; //存储该位置能跳到哪个位置（下标）。 vector&lt;int&gt; index; for(int i = 0; i &lt; nums.size(); i++)&#123; index.push_back(i + nums[i]); &#125; //能够跳跃的位置。 int jump = 0; //当前最远的位置。 int max_index = index[0]; while(jump &lt; index.size() &amp;&amp; jump &lt;= max_index)&#123; //更新最远位置 if(max_index &lt; index[jump])&#123; max_index = index[jump]; &#125; //前进一步 jump++; &#125; //走到了数组末尾。 if(jump == index.size()) return true; return false; &#125;&#125;; 看了评论区大神的代码。发现是从后往前开始判断的，依次判断是否能到达最远的距离。如果能到达，把最远的距离更新为现在所在位置。于是写出了如下代码。 12345678910111213141516171819class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; //能到达最远位置坐标 int n = nums.size()-1; for(int i = nums.size()-2; i &gt;= 0; i--)&#123; //从该点可以达到终点坐标，则将最远位置的坐标更新为该点的坐标。 if(nums[i] + i &gt;= n)&#123; n = i; &#125; &#125; //能够到达头部。 if(n == 0)&#123; return true; &#125;else &#123; return false; &#125; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"贪心","slug":"贪心","permalink":"https://yangzebin001.github.io/tags/贪心/"}]},{"title":"LeetCode-215-数组中的第K个最大元素","slug":"LeetCode-215-数组中的第K个最大元素","date":"2019-01-17T09:38:26.000Z","updated":"2019-02-27T10:12:33.607Z","comments":true,"path":"2019/01/17/LeetCode-215-数组中的第K个最大元素/","link":"","permalink":"https://yangzebin001.github.io/2019/01/17/LeetCode-215-数组中的第K个最大元素/","excerpt":"215. 数组中的第K个最大元素 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。Solution1：","text":"215. 数组中的第K个最大元素 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。Solution1： 1234567class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; std::sort(nums.begin(),nums.end()); return nums[nums.size()-k]; &#125;&#125;; 思路：直接使用sort()函数。将倒数第K的元素直接返回。这样做的复杂度就为sort函数的复杂度。 Solution2：1234567891011121314151617#include &lt;vector&gt;#include &lt;queue&gt;class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; Q; for(int i = 0; i &lt; nums.size(); i++)&#123; if(Q.size() &lt; k)&#123; Q.push(nums[i]); &#125;else if(Q.top() &lt; nums[i])&#123; Q.pop(); Q.push(nums[i]); &#125; &#125; return Q.top(); &#125;&#125;; 思路：使用最小堆。 维护一个K大小的最小堆。最小堆的堆顶始终为最小元素。当有比堆顶更大的时候，让更大的元素进堆，堆顶的元素出堆。这样遍历一遍后。第K大的元素就到了堆顶。直接弹出即可。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"堆","slug":"堆","permalink":"https://yangzebin001.github.io/tags/堆/"}]},{"title":"LeetCode 224. 基本计算器","slug":"LeetCode-224-基本计算器","date":"2019-01-05T12:19:14.000Z","updated":"2019-02-27T10:12:08.959Z","comments":true,"path":"2019/01/05/LeetCode-224-基本计算器/","link":"","permalink":"https://yangzebin001.github.io/2019/01/05/LeetCode-224-基本计算器/","excerpt":"224. 基本计算器 实现一个基本的计算器来计算一个简单的字符串表达式的值。字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格。","text":"224. 基本计算器 实现一个基本的计算器来计算一个简单的字符串表达式的值。字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格。 Solution：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution &#123;public: void compute(std::stack&lt;int&gt; &amp;number_stack, std::stack&lt;char&gt; &amp;operation_stack)&#123; if(number_stack.size() &lt; 2)&#123; return; &#125; int num2 = number_stack.top(); number_stack.pop(); int num1 = number_stack.top(); number_stack.pop(); if(operation_stack.top() == '+')&#123; number_stack.push(num1 + num2); &#125;else if(operation_stack.top() == '-')&#123; number_stack.push(num1 - num2); &#125; operation_stack.pop(); &#125; int calculate(string s) &#123; static const int STATE_BEGIN = 0; static const int NUMBER_STATE = 1; static const int OPERATION_STATE = 2; std::stack&lt;int&gt; number_stack; std::stack&lt;char&gt; operation_stack; int number = 0; int STATE = STATE_BEGIN; int compuate_flag = 0; for(int i = 0; i &lt; s.length(); i++)&#123; if(s[i] == ' ')&#123; continue; &#125; switch(STATE)&#123; case STATE_BEGIN: if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9')&#123; STATE = NUMBER_STATE; &#125;else&#123; STATE = OPERATION_STATE; &#125; i--; break; case NUMBER_STATE: if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9')&#123; number = number * 10 + s[i] - '0'; &#125;else&#123; number_stack.push(number); if(compuate_flag == 1)&#123; compute(number_stack,operation_stack); &#125; number = 0; i--; STATE = OPERATION_STATE; &#125; break; case OPERATION_STATE: if(s[i] == '+' || s[i] == '-')&#123; operation_stack.push(s[i]); compuate_flag = 1; &#125;else if(s[i] == '(')&#123; STATE = NUMBER_STATE; compuate_flag = 0; &#125;else if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9')&#123; STATE = NUMBER_STATE; i--; &#125;else if(s[i] == ')')&#123; compute(number_stack,operation_stack); &#125; break; &#125; &#125; if(number != 0)&#123; number_stack.push(number); compute(number_stack,operation_stack); &#125; if(number == 0 &amp;&amp; number_stack.empty())&#123; return 0; &#125; return number_stack.top(); &#125;&#125;; 首先，数据用两个栈来存储。一个存数字，一个存操作符。 其次，建立一个状态机，来描述指针的走向状态。根据状态来做相应的操作。 刚开始有一个开始状态。检测下一个字符是数字还是字母。然后转换为相应的状态。 我们先讨论数字与操作符的存储时机： 当指针指向数字时，先将数字暂存起来，继续检查下一位置，还是数字，继续与暂存的数字融合。当指针指向的不是数字时，这时就需要把这个数字存起来。 字符的存储时机就为该位置为+、-时进行存储。 接下来讨论计算的时机。 首先是检测操作符，如果操作符后面是数字，则在该数字进行存储完成之后立马进行计算。 如果操作符之后是” ( “ 就要等下一个相应的” ) “出现。之后再进行计算。 所以设置一个计算标志。如果检测到操作符，把计算标志置为可计算，接着继续下一位的检测，如果是数字，就在存储后进行计算。如果是” ( “，就需要取消计算标志。 一定要注意退格操作！！！ 退格发生在下一位置不再是数字或者在操作符之后的检测是不是数字的时候。 最后就是将描述翻译成代码的工作了。 这里注意，在表达式的最后通常是数字，这时也需要将数字存储起来再进行一次运算。 如果表达式正确，存储数字的栈的长度一定是1，直接返回栈顶。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"状态机","slug":"状态机","permalink":"https://yangzebin001.github.io/tags/状态机/"}]},{"title":"LeetCode 232. 用栈实现队列","slug":"LeetCode-232-用栈实现队列","date":"2019-01-02T12:30:00.000Z","updated":"2019-01-31T10:12:30.984Z","comments":true,"path":"2019/01/02/LeetCode-232-用栈实现队列/","link":"","permalink":"https://yangzebin001.github.io/2019/01/02/LeetCode-232-用栈实现队列/","excerpt":"232. 用栈实现队列 使用栈实现队列的下列操作： push(x) – 将一个元素放入队列的尾部。 pop() – 从队列首部移除元素。 peek() – 返回队列首部的元素。 empty() – 返回队列是否为空。","text":"232. 用栈实现队列 使用栈实现队列的下列操作： push(x) – 将一个元素放入队列的尾部。 pop() – 从队列首部移除元素。 peek() – 返回队列首部的元素。 empty() – 返回队列是否为空。 Solution:1234567891011121314151617181920212223242526272829303132333435363738class MyQueue &#123;public: /** Initialize your data structure here. */ MyQueue() &#123; &#125; /** push all element of _s1 to _s2*/ void pushTos2()&#123; if(_s1.empty()) return; while(!_s1.empty())&#123; _s2.push(_s1.top()); _s1.pop(); &#125; &#125; /** Push element x to the back of queue. */ void push(int x) &#123; return _s1.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; if(_s2.empty()) pushTos2(); int a = _s2.top(); _s2.pop(); return a; &#125; /** Get the front element. */ int peek() &#123; if(_s2.empty()) pushTos2(); return _s2.top(); &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return _s1.empty() &amp;&amp; _s2.empty(); &#125; private: std::stack&lt;int&gt; _s1; std::stack&lt;int&gt; _s2;&#125;; 使用两个栈来实现堆。 在做push操作的时候，直接push进第一个栈。 当要pop时，先检查第二栈是否为空，如果为空，就把第一个栈的元素全push进第二个栈，这是原本在第一个栈栈底的元素，就到了第二个栈的栈顶（相当于翻了个个)。这时就可以pop出去了。 下面的函数实现的就是专门将第一个栈的元素全部push进第二栈的功能。12345678/** push all element of _s1 to _s2*/ void pushTos2()&#123; if(_s1.empty()) return; while(!_s1.empty())&#123; _s2.push(_s1.top()); _s1.pop(); &#125; &#125; 当peek时，如果第二个栈已经没有元素。 也需要把第一个栈的元素“倒”进来，再进行peek(); empty：当两个栈都没有元素才算空。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 225. 用队列实现栈","slug":"LeetCode-225-用队列实现栈","date":"2019-01-02T12:29:14.000Z","updated":"2019-01-31T10:12:21.866Z","comments":true,"path":"2019/01/02/LeetCode-225-用队列实现栈/","link":"","permalink":"https://yangzebin001.github.io/2019/01/02/LeetCode-225-用队列实现栈/","excerpt":"225. 用队列实现栈 使用队列实现栈的下列操作： push(x) – 元素 x 入栈 pop() – 移除栈顶元素 top() – 获取栈顶元素 empty() – 返回栈是否为空 Solution：","text":"225. 用队列实现栈 使用队列实现栈的下列操作： push(x) – 元素 x 入栈 pop() – 移除栈顶元素 top() – 获取栈顶元素 empty() – 返回栈是否为空 Solution： 1234567891011121314151617181920212223242526272829303132333435363738394041class MyStack &#123;public: /** Initialize your data structure here. */ MyStack() &#123; &#125; /** Push element x onto stack. */ void push(int x) &#123; std::queue&lt;int&gt; temp_queue; temp_queue.push(x); while(!data_queue.empty())&#123; temp_queue.push(data_queue.front()); data_queue.pop(); &#125; while(!temp_queue.empty())&#123; data_queue.push(temp_queue.front()); temp_queue.pop(); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int x = data_queue.front(); data_queue.pop(); return x; &#125; /** Get the top element. */ int top() &#123; return data_queue.front(); &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return data_queue.empty(); &#125; private: std::queue&lt;int&gt; data_queue;&#125;; 核心思想：让新进来的元素始终在队列的头位置。所以需要一个临时的队列。先让push进来的元素进去临时队列里。再让原来的队列的元素全进去临时队列，这样就保证了队列的头位置始终是新进来的元素。再将临时队列的所有元素push回原队列。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 61. 旋转链表","slug":"LeetCode-61-旋转链表","date":"2019-01-01T14:40:48.000Z","updated":"2019-02-27T10:17:12.203Z","comments":true,"path":"2019/01/01/LeetCode-61-旋转链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-61-旋转链表/","excerpt":"61. 旋转链表 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。Example: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL","text":"61. 旋转链表 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。Example: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 123456789101112131415161718192021222324252627282930int getListNodeLength(struct ListNode * head)&#123; struct ListNode * head1 = head; int len = 0; while(head1)&#123; len++; head1 = head1-&gt;next; &#125; return len;&#125;struct ListNode* getPosition(struct ListNode* head, int index)&#123; if(index &lt; 0) return NULL; struct ListNode * head1 = head; while(index)&#123; head1 = head1-&gt;next; index--; &#125; return head1;&#125;struct ListNode* rotateRight(struct ListNode* head, int k) &#123; int len = getListNodeLength(head); if(len &lt;=1 || (k %= len) &lt; 1) return head; int position = len-k-1; struct ListNode* oldlast = getPosition(head,len-1); struct ListNode* newhead = getPosition(head,position+1); struct ListNode* newlast = getPosition(head,position); oldlast-&gt;next = head; newlast-&gt;next = NULL; return newhead;&#125; 思路:该题看似是循环n次，实则将后K个元素移至头结点的位置。 直接找到最后一个元素，将它指向开始的位置。将倒数第k+1个元素指向NULL。 k可以大于链表的长度，所以要对链表长度取模。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"链表","slug":"链表","permalink":"https://yangzebin001.github.io/tags/链表/"}]},{"title":"LeetCode 24. 两两交换链表中的节点","slug":"LeetCode-24-两两交换链表中的节点","date":"2019-01-01T14:39:50.000Z","updated":"2019-02-27T10:18:38.313Z","comments":true,"path":"2019/01/01/LeetCode-24-两两交换链表中的节点/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-24-两两交换链表中的节点/","excerpt":"24. 两两交换链表中的节点 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。Example：给定 1-&gt;2-&gt;3-&gt;4，你应该返回 2-&gt;1-&gt;4-&gt;3。","text":"24. 两两交换链表中的节点 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。Example：给定 1-&gt;2-&gt;3-&gt;4，你应该返回 2-&gt;1-&gt;4-&gt;3。 1234567891011121314151617181920struct ListNode* swapPairs(struct ListNode* head) &#123; //设置头结点 struct ListNode* first = (struct ListNode*)malloc(sizeof(struct ListNode)); first-&gt;next = head; //备份 struct ListNode* first1 = first; // 如果头结点后有两个结点 while(first-&gt;next &amp;&amp; first-&gt;next-&gt;next)&#123; //两个结点 struct ListNode* one = first-&gt;next; struct ListNode* two = first-&gt;next-&gt;next; //交换两个结点。 one-&gt;next = two-&gt;next; first-&gt;next = two; two-&gt;next = one; first = one; &#125; //返回 return first1-&gt;next;&#125; 思路：用一个指针从开始读，如果可以读到该节点与下个节点，就将这两个结点交换位置，这时需要注意与前后的结点连接。 为了方便，用一个头结点来完成这个连接的工作。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"链表","slug":"链表","permalink":"https://yangzebin001.github.io/tags/链表/"}]},{"title":"LeetCode 86. 分隔链表","slug":"LeetCode-86-分隔链表","date":"2019-01-01T14:38:47.000Z","updated":"2019-01-31T10:11:39.065Z","comments":true,"path":"2019/01/01/LeetCode-86-分隔链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-86-分隔链表/","excerpt":"86. 分隔链表 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。你应当保留两个分区中每个节点的初始相对位置。Example：给定 head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2， x = 3。 你应该返回 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5。","text":"86. 分隔链表 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。你应当保留两个分区中每个节点的初始相对位置。Example：给定 head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2， x = 3。 你应该返回 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5。 Solution1：1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; //创建两个头结点 ListNode less_head(0); ListNode more_head(0); ListNode *less_ptr = &amp;less_head; ListNode *more_ptr = &amp;more_head; while(head)&#123; //将val小于x的分进less_ptr，大于等于的分进more_ptr; if(head-&gt;val &lt; x)&#123; less_ptr-&gt;next = head; less_ptr = less_ptr-&gt;next; &#125;else&#123; more_ptr-&gt;next = head; more_ptr = more_ptr-&gt;next; &#125; head = head-&gt;next; &#125; //连接两个指针。 less_ptr-&gt;next = more_head.next; more_ptr-&gt;next = NULL; return less_head.next; &#125;&#125;; 思路：用双指针。创建两个头结点。比x小的划到第一个里面，否则划到第二个里面，最后将两个链表链接返回。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 138. 复制带随机指针的链表","slug":"LeetCode-138-复制带随机指针的链表","date":"2019-01-01T14:36:49.000Z","updated":"2019-02-11T14:29:37.638Z","comments":true,"path":"2019/01/01/LeetCode-138-复制带随机指针的链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-138-复制带随机指针的链表/","excerpt":"138. 复制带随机指针的链表 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深度拷贝。","text":"138. 复制带随机指针的链表 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深度拷贝。 12345678/** * Definition for singly-linked list with a random pointer. * struct RandomListNode &#123; * int label; * RandomListNode *next, *random; * RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125; * &#125;; */ Solution: 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode *head) &#123; //建立结点与当前位置的映射 std::map&lt;RandomListNode *, int&gt; node_map; //存放copy了的所有结点。按位置。 std::vector&lt;RandomListNode *&gt; node_vec; RandomListNode *ptr = head; int i = 0; while(ptr)&#123; //创建与旧链表相等的结点。copy其中的值。 node_vec.push_back(new RandomListNode(ptr-&gt;label)); // 建立结点与当前位置的映射。 node_map[ptr] = i; ptr = ptr-&gt;next; i++; &#125; //push尾结点 node_vec.push_back(0); ptr = head; i = 0; while(ptr)&#123; //将依次排列的结点的next相连接。 node_vec[i]-&gt;next = node_vec[i+1]; if(ptr-&gt;random)&#123; //找到该结点对应所指向的random所映射的位置。然后赋给当前结点。 int id = node_map[ptr-&gt;random]; node_vec[i]-&gt;random = node_vec[id]; &#125; ptr = ptr-&gt;next; i++; &#125; //返回首结点 return node_vec[0]; &#125;&#125;; 思路:如果没有random域，copy链表只要依次创建结点，并将当前结点的next指向下一个结点就完成了。 有random域会比较麻烦一些。需要通过建立一张结点与其位置的表来完成。 当需要填充random指向时，通过原链表的random域在表中的位置来将vector中这一位置的结点地址赋给random域。 Solution2：1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode *head) &#123; //为每个节点添加一个副本，链接在当前节点之后。 RandomListNode* cur = head; while(cur)&#123; RandomListNode* next = cur-&gt;next; cur-&gt;next = new RandomListNode(cur-&gt;label); cur-&gt;next-&gt;next = next; cur = cur-&gt;next-&gt;next; &#125; //copy随机指针 cur = head; while(cur)&#123; RandomListNode* random = cur-&gt;random; //如果随机指针不为空 if(random) cur-&gt;next-&gt;random = random-&gt;next; cur = cur-&gt;next-&gt;next; &#125; cur = head; // 新链表的头节点 RandomListNode* copyhead = new RandomListNode(0); RandomListNode* copyhead1 = copyhead; //split为两个链表 while(cur)&#123; copyhead-&gt;next = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; copyhead = copyhead-&gt;next; cur = cur-&gt;next; &#125; copyhead-&gt;next = NULL; return copyhead1-&gt;next; &#125;&#125;; 思路： 第一遍遍历：将每个节点copy出来之后连接到该结点的后面。这样得到了两倍原本链表长度的链表。 第二遍遍历：将每个原节点的random域复制到它之后的copy节点。 第三遍遍历：将两个链表分离。原节点重新相链接，copy后的结点相链接。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"}]},{"title":"LeetCode 23. 合并K个排序链表","slug":"LeetCode-23-合并K个排序链表","date":"2019-01-01T14:35:08.000Z","updated":"2019-02-27T10:18:48.774Z","comments":true,"path":"2019/01/01/LeetCode-23-合并K个排序链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-23-合并K个排序链表/","excerpt":"23. 合并K个排序链表 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。Solution1：","text":"23. 合并K个排序链表 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。Solution1： 1234567891011121314151617181920212223242526272829bool cmp(const ListNode* a,const ListNode *b)&#123; return a-&gt;val &lt; b-&gt;val;&#125;class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; std::vector&lt;ListNode*&gt; node_vec; //将每个结点push到vec中。 for(int i = 0; i &lt; lists.size(); i++)&#123; ListNode* head = lists[i]; while(head)&#123; node_vec.push_back(head); head = head-&gt;next; &#125; &#125; if(node_vec.size() == 0)&#123; return NULL; &#125; //将vec中的元素按val域排序。 std::sort(node_vec.begin(),node_vec.end(),cmp); //链接各个结点。 for(int i = 1;i &lt; node_vec.size();i++)&#123; node_vec[i-1]-&gt;next = node_vec[i]; &#125; //最后一个结点指向NULL node_vec[node_vec.size()-1]-&gt;next = NULL; return node_vec[0]; &#125;&#125;; 该方法比较粗暴。将所有的结点存入一个vector中，按结点中的值排序，然后依次将每个结点链接，最后返回。 Solution2：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode p0 = ListNode(0); ListNode* p = &amp;p0; ListNode* p1 = p; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; p-&gt;next = new ListNode(l1-&gt;val); p = p-&gt;next; l1 = l1-&gt;next; &#125;else&#123; new ListNode(l2-&gt;val); p-&gt;next = new ListNode(l2-&gt;val); p = p-&gt;next; l2 = l2-&gt;next; &#125; &#125; p-&gt;next = (l1!=NULL) ? l1 :(l2!=NULL) ? l2 : NULL; return p1-&gt;next; &#125; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; //两个终止条件。 if(lists.size() == 0)&#123; return NULL; &#125; if(lists.size() == 1)&#123; return lists[0]; &#125; //将lists拆分成两个子lists; int mid = lists.size()/2; std::vector&lt;ListNode*&gt; sub1_lists; std::vector&lt;ListNode*&gt; sub2_lists; for(int i = 0; i &lt; mid; i++)&#123; sub1_lists.push_back(lists[i]); &#125; for(int i = mid; i &lt; lists.size(); i++)&#123; sub2_lists.push_back(lists[i]); &#125; //递归调用 ListNode *l1 = mergeKLists(sub1_lists); ListNode *l2 = mergeKLists(sub2_lists); //返回两个链表合并的结果。 return mergeTwoLists(l1,l2); &#125;&#125;; 思路:（归并思想）递归算法。将k个链表分割为独立的链表，再向上两两合并。 合并两个有序链表的子问题参照：21. 合并两个排序链表","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"归并","slug":"归并","permalink":"https://yangzebin001.github.io/tags/归并/"}]},{"title":"LeetCode 155. 最小栈","slug":"LeetCode-155-最小栈","date":"2019-01-01T14:33:56.000Z","updated":"2019-02-27T10:13:39.038Z","comments":true,"path":"2019/01/01/LeetCode-155-最小栈/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-155-最小栈/","excerpt":"155. 最小栈 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。 pop() – 删除栈顶的元素。 top() – 获取栈顶元素。 getMin() – 检索栈中的最小元素。 Solution：","text":"155. 最小栈 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。 pop() – 删除栈顶的元素。 top() – 获取栈顶元素。 getMin() – 检索栈中的最小元素。 Solution： 123456789101112131415161718192021222324252627282930class MinStack &#123; public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; _data.push(x); // 更新当前的最小值状态。 if(_min.empty() || _min.top() &gt;= x )&#123; _min.push(x); &#125; &#125; void pop() &#123; //如果是要弹出当前的最小值。将min中的值也一并弹出。 if(_data.top() == _min.top())&#123; _min.pop(); &#125; _data.pop(); &#125; int top() &#123; return _data.top(); &#125; int getMin() &#123; //返回最小栈的栈顶 return _min.top(); &#125; private: std::stack&lt;int&gt; _data; std::stack&lt;int&gt; _min;&#125;; 思路:原来想用一个变量来记录最小值，这在push的时候没什么问题，但是当执行pop操作的时候，就不知道怎么更新了。 所以需要将每次一更新最小值都记录下来。 使用另一个栈记录最小值的变更状态。 每插入一个值，与之比较最小栈的栈顶的元素，如果比栈顶的元素小，就更新其状态，如果与栈顶元素相等，也需要插入。 当出栈的时候，如果与最小栈栈顶元素相等，最小栈也出栈。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"设计，栈","slug":"设计，栈","permalink":"https://yangzebin001.github.io/tags/设计，栈/"}]},{"title":"LeetCode 92. 反转链表 II","slug":"LeetCode-92-反转链表-II","date":"2019-01-01T14:32:44.000Z","updated":"2019-02-27T10:16:23.057Z","comments":true,"path":"2019/01/01/LeetCode-92-反转链表-II/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-92-反转链表-II/","excerpt":"92. 反转链表 II 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 ###Solution：","text":"92. 反转链表 II 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 ###Solution： 1234567891011121314151617181920212223242526272829struct ListNode* reverseBetween(struct ListNode* head, int m, int n) &#123; int chang_len = n-m+1;//逆置的结点个数。 struct ListNode* prevHead = NULL;//记录开始逆置结点的前驱。 struct ListNode* result = head;//用于最后返回。 while(head &amp;&amp; --m)&#123; //到达开始逆置的位置。 prevHead = head; head = head-&gt;next; &#125; struct ListNode * modify_list_tail = head;//将该结点之前当前开始逆置的结点。 struct ListNode * newHead = NULL;//用于逆置结点。 while(head &amp;&amp; chang_len)&#123; struct ListNode * next = head-&gt;next; head-&gt;next = newHead; newHead = head; head = next; chang_len--; &#125; //此时head就到了n处，modify_list_tail就到了逆置段的最后一个结点。 //将modify_list_tail 与 head连接。 modify_list_tail-&gt;next = head; if(prevHead)&#123; //如果prevHead不为空，说明不是从第一个几点开始逆置的。 m &gt; 1。 prevHead-&gt;next = newHead; &#125;else&#123; result = newHead; //如果prevHead为空， 则说明是从第一个就开始逆置，直接将逆置后的头结点赋值给res，m=1。 &#125; return result;&#125; 思路：解决这个问题主要是要找关键节点。 这个题的关键节点为： 要逆置的结点的前一个结点（prevHead）。 要逆置的第一个结点。（直接用head来探测）。 要逆置的最后一个结点。（此结点为逆置前的第一个结点，逆置后就变为了最后一个结点） 要逆置的最后一个结点的后一个结点。（在用head逆置后，head就到了逆置后的这个结点。） 找到前两个结点。 从m开始，到n，一共需要n-m+1个结点需要逆置。所以要逆置n-m+1次。 将逆置后的尾结点 与 逆置段后面一个结点相连。 如果结点是从开始逆置，将逆置后的头结点返回。否则，将前面的结点与逆置后的头结点链接返回。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"链表","slug":"链表","permalink":"https://yangzebin001.github.io/tags/链表/"}]},{"title":"LeetCode 160. 相交链表","slug":"LeetCode-160-相交链表","date":"2019-01-01T14:26:20.000Z","updated":"2019-02-27T10:13:25.774Z","comments":true,"path":"2019/01/01/LeetCode-160-相交链表/","link":"","permalink":"https://yangzebin001.github.io/2019/01/01/LeetCode-160-相交链表/","excerpt":"160. 相交链表 Solution1：","text":"160. 相交链表 Solution1： 1234567891011121314151617class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; std::set&lt;ListNode*&gt; node_set; while(headA)&#123; node_set.insert(headA); headA = headA-&gt;next; &#125; while(headB)&#123; if(node_set.find(headB)!=node_set.end())&#123; return headB; &#125; headB = headB-&gt;next; &#125; return NULL; &#125;&#125;; 思路：这种思路很简单。就是先将链表A的每个元素存入set中，在链表B的元素逐个去set中查找。找到就返回。缺点：使用了O(n)的空间。 Solution2：1234567891011121314151617181920212223242526272829303132333435363738394041//获得链表的长度。int get_list_length(ListNode * head)&#123; int len = 0; while(head)&#123; head = head-&gt;next; len++; &#125; return len;&#125;//将长的链表移动多余的步数；以致两个链表到了相等的长度。ListNode* forward_long_list(int long_len, int short_len, ListNode* head)&#123; int step = long_len-short_len; while(head &amp;&amp; step)&#123; head = head-&gt;next; step--; &#125; return head;&#125;class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; int headA_len = get_list_length(headA); int headB_len = get_list_length(headB); //先移动较长的链表至两个链表的长度相等。 if(headA_len&gt;headB_len)&#123; headA = forward_long_list(headA_len,headB_len,headA); &#125;else&#123; headB = forward_long_list(headB_len,headA_len,headB); &#125; //再同时开始移动。如果这两个结点相等了，就找到了 while(headA &amp;&amp; headB)&#123; if(headA == headB)&#123; return headA; &#125; headA = headA-&gt;next; headB = headB-&gt;next; &#125; return NULL; &#125;&#125;; 思路：由于后面的结点是两个链表共享的，所以链表在相交结点之前有可能长度不相等。 我们先将长的链表移动到与短链表相同的长度，然后两个链表同时移动，当两个结点变得相同时，就得到了相同结点。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"双指针","slug":"双指针","permalink":"https://yangzebin001.github.io/tags/双指针/"}]},{"title":"LeetCode 141. 环形链表","slug":"LeetCode-141-环形链表","date":"2018-12-30T07:55:13.000Z","updated":"2019-02-27T10:14:29.891Z","comments":true,"path":"2018/12/30/LeetCode-141-环形链表/","link":"","permalink":"https://yangzebin001.github.io/2018/12/30/LeetCode-141-环形链表/","excerpt":"141. 环形链表 题目描述：给定一个链表，判断链表中是否有环。Solution1:","text":"141. 环形链表 题目描述：给定一个链表，判断链表中是否有环。Solution1: 123456789101112131415class Solution &#123;public: bool hasCycle(ListNode *head) &#123; std::set&lt;ListNode*&gt; node_set; while(head)&#123; if(node_set.find(head) == node_set.end())&#123; node_set.insert(head); &#125;else&#123; return true; &#125; head = head-&gt;next; &#125; return false; &#125;&#125;; 思路：使用set。将每一个结点在set中检查，如果没有，就插入该结点。如果找到了，就说明有环。如果到头了，说明没环，返回false； 该方法由于使用了set，所以空间复杂度为O(n); Solution2：1234567891011121314151617bool hasCycle(struct ListNode *head) &#123; struct ListNode *slow = head; struct ListNode *fast = head; while(fast)&#123; slow = slow-&gt;next; fast = fast-&gt;next; if(fast)&#123; fast = fast-&gt;next; &#125;else&#123; return false; &#125; if(slow == fast)&#123; return true; &#125; &#125; return false;&#125; 思路：使用双指针。用两个移动速度快慢不相同的指针来判断是否有环。如果有环，两个指针终会相遇，返回true。 由于快指针一定在慢指针的前面，所以在移动指针时，只要判断快指针是否为空，如果是，就说明没有环。返回false；","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"双指针","slug":"双指针","permalink":"https://yangzebin001.github.io/tags/双指针/"}]},{"title":"LeetCode 234.回文链表","slug":"leetcode-234-回文链表","date":"2018-12-30T07:44:12.000Z","updated":"2019-02-27T10:11:46.966Z","comments":true,"path":"2018/12/30/leetcode-234-回文链表/","link":"","permalink":"https://yangzebin001.github.io/2018/12/30/leetcode-234-回文链表/","excerpt":"234.回文链表 请判断一个链表是否为回文链表。Solution1：","text":"234.回文链表 请判断一个链表是否为回文链表。Solution1： 1234567891011121314151617181920212223242526272829303132333435//获得链表长度int getListLength(ListNode* head)&#123; int len = 0; while(head)&#123; head = head-&gt;next; len++; &#125; return len;&#125;class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; ListNode* head1 = head; int listlen = getListLength(head1); if(listlen &lt;= 1) return true; int mid = listlen/2; std::stack&lt;int&gt; s; while(mid &amp;&amp; head)&#123; s.push(head-&gt;val); head = head-&gt;next; mid--; &#125; if(listlen%2 != 0)&#123; head = head-&gt;next; &#125; while(head)&#123; if(head-&gt;val != s.top())&#123; return false; &#125; s.pop(); head = head-&gt;next; &#125; return true; &#125;&#125;; 思路:借助stack。 将mid之前的元素值都push进stack中，然后到mid之后，将每个元素与栈顶值比较。不相等退出，相等继续下一轮。 Solution2：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//获得链表长度int getListLength(ListNode* head)&#123; int len = 0; while(head)&#123; head = head-&gt;next; len++; &#125; return len;&#125;//根据位置与所给链表，向后移动position步。ListNode* getNodeByPosition(ListNode* head,int position)&#123; while(position&gt;0)&#123; head = head-&gt;next; position--; &#125; return head;&#125;class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; //存储头结点。 ListNode* first = head; ListNode* head1 = head; int listlen = getListLength(head); int midposition = listlen/2; //如果链表长度&lt;=1，直接返回true; if(listlen &lt;= 1) return true; //到达需要翻转的长度，对于偶数，为（listlen/2）+1，对于奇数，为listlen/2; ListNode* mid = getNodeByPosition(head1,midposition); //翻转mid之后的指针。 ListNode * newHead = NULL; int position = listlen-midposition; while(mid &amp;&amp; position)&#123; ListNode* next = mid-&gt;next; mid-&gt;next = newHead; newHead = mid; mid = next; position--; &#125; //将翻转之后的链表与开头的链表的内容比较，向后比较listlen/2; //如果是偶数，则元素都会比较到，如果是奇数，最后一个元素不会比较到。他在原来的链表中就处于中心位置，不必比较。 while(first &amp;&amp; newHead &amp;&amp; midposition)&#123; //只要不相等，就为false; if(first-&gt;val != newHead-&gt;val) return false; first = first-&gt;next; newHead = newHead-&gt;next; midposition--; &#125; return true; &#125;&#125;; 思路：将链表的后半段翻转，从翻转位置开始与从头结点开始，依次比较（listlen/2次）。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"双指针","slug":"双指针","permalink":"https://yangzebin001.github.io/tags/双指针/"}]},{"title":"LeetCode 142. 环形链表 II","slug":"leetcode-142-环形链表-II","date":"2018-12-30T07:27:57.000Z","updated":"2019-02-27T10:14:16.940Z","comments":true,"path":"2018/12/30/leetcode-142-环形链表-II/","link":"","permalink":"https://yangzebin001.github.io/2018/12/30/leetcode-142-环形链表-II/","excerpt":"142. 环形链表 II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。","text":"142. 环形链表 II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 Solution1:123456789101112131415class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; std::set&lt;ListNode*&gt; node_set; while(head)&#123; if(node_set.find(head) == node_set.end())&#123; node_set.insert(head); &#125;else&#123; return head; &#125; head = head-&gt;next; &#125; return NULL; &#125;&#125;; 与141号问题的Solutions1一个思路，直接使用set。只不过返回的是结点不是boolean值罢了。 Solutions2:123456789101112131415161718192021222324252627282930313233class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; ListNode * head1 = head; ListNode * slow = head; ListNode * fast = head; //fast走一步，slow走两步 while(fast)&#123; slow = slow-&gt;next; fast = fast-&gt;next; if(fast)&#123; fast = fast-&gt;next; &#125;else&#123; //没有环退出 return NULL; &#125; //有环退出循环 if(fast == slow)&#123; break; &#125; &#125; //说明有环 while(head1 &amp;&amp; fast)&#123; if(head1 == fast)&#123; return fast; &#125; head1 = head1-&gt;next; fast = fast-&gt;next; &#125; //不会走到这步，只是为了保证函数正常运行 return NULL; &#125;&#125;; 思路：这种方法只会使用O(1)的空间。 该方法的思路需要一点数学基础： 在一个有环的链表中，slow指针与fast指针相遇，从该相遇的位置开始，与链表的头位置开始，两者走同样的步数，如果两者相交，就走到了环的开始位置。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yangzebin001.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://yangzebin001.github.io/tags/algorithm/"},{"name":"双指针","slug":"双指针","permalink":"https://yangzebin001.github.io/tags/双指针/"}]},{"title":"一文学会Git","slug":"一文学会git","date":"2018-10-03T08:44:00.000Z","updated":"2018-10-05T14:10:57.810Z","comments":true,"path":"2018/10/03/一文学会git/","link":"","permalink":"https://yangzebin001.github.io/2018/10/03/一文学会git/","excerpt":"一、GIT下载、安装与配置1.下载与安装下载git只需要直接在官网下载就可以了，它会自动下载适合你电脑配置的版本。 官网 安装就一直下一步就可以了。","text":"一、GIT下载、安装与配置1.下载与安装下载git只需要直接在官网下载就可以了，它会自动下载适合你电脑配置的版本。 官网 安装就一直下一步就可以了。 2.配置安装完成之后右键菜单就会自动添加两个选项： Git GUI Git Bash 在任意目录下右键点击 Git Bash 打开Git 命令行，输入一下两条命令： 123git config --global user.name &quot;USERNAME&quot;git config --global user.email &quot;xxx@xx.com&quot; “USERNAME”填写你的用户名“xxx@xx.com”填写你的邮箱 这样配置完后你之后所创建的仓库都会默认创建在你的名下。 查看你的配置，输入下面的命令： 1git config --list 其中有两条条目为user.name和user.email即为你所配置的。 二、Git基本操作1、新建仓库进入一个你要进行Git的目录（通常是你的工程目录）然后在右键菜单中进入Git Bash，键入命令： 1git init 它会在当前目录下创建一个.git的隐藏文件夹用来保存与git操作有关的相关信息。 2、向仓库暂存区里添加文件1git add FILENAME 命令可以将文件添加到你所创建的仓库的暂存区中。 关于add命令有俩点需要注意： 1.add现在还没有真正添加到仓库中，而是作为预备项来决定是否最终添加到仓库中。 2.这里的添加文件并不是你所在仓库的文件有了这个文件就可以了。仓库创建好后并不等于你所在文件夹中的所有文件也同样包含于仓库中，你需要手动告诉Git你要添加当前目录下的哪些文件到它的仓库中。 你可以用以下命令来将所在文件夹下属的所有文件或者文件夹添加到暂存区中：123git add --all/-Aorgit add * 3、向仓库中提交文件我们已经把文件添加到了暂存区，那么怎样让文件真正进去仓库呢？用commit命令： 1git commit -m &quot;you need to record something&quot; 这个命令可以让你将暂存区中的文件添加到仓库中。 -m 选项是必选项，它需要你在提交时给他一下信息用于记录你的提交的原因。当然我们也提倡这样做。 4、一次性从工作区提交到仓库中有时候修改完文件要提交仓库中，要先添加到暂存区后再提交，很麻烦怎么办？给 git commit 加上 -a 选项： 1git commit -a -m &quot;say something&quot; 5、查看git状态不知道你的文件现在处于未跟踪状态还是处在暂存区，或者是一提交状态？用status命令： 1git status 它会告诉你当前文件夹中的文件的状态和分支情况。 6、从暂存区或仓库中移除文件如果你想删除一个文件，但是已经将它放入了暂存区中，如何去删除暂存区中的文件呢？先将本地文件删除，再使用下面的命令：1git rm FILENAME 就可以将暂存区中的文件移除了。当然，直接一同删除本地文件和暂存区文件也可以，添加 -f 选项。 那如果已经提交到仓库中了怎么办？从仓库中删除文件可以在上条命令的基础上添加–cached选项。 注意：如果之前你的本地目录中有该文件，从仓库中删除并不会把本地文件一并删除，所删除的文件在本地中会重新变为未跟踪状态。 那么我不想删除本地文件，又不想把它提交到仓库中，该怎么办呢？ 7、添加忽略列表可以在本地目录中添加一个名为 .gitignore 的文件，用来记录哪些文件需要被忽略。直接在.gitignore文件中添加你不想被跟踪的文件即可。 github上有一个项目列举了各种忽略列表：ignore 8、重命名文件你可以中暂存区和仓库中修改文件的名字。使用下面的命令： 1git mv FILE_FROM FILE_TO 实际上，git并不会直接将名字修改，mv命令相当于下面三条命令： 123mv README.md READMEgit rm README.mdgit add README 9、查看提交历史在提交了若干更新，又或者克隆了某个项目之后，如果查看提交历史呢？使用下面的命令：1git log 它会按照时间线（由近及远）列出你的提交历史，包括SHA-1 校验、日期、提交者以及提交说明。 log命令有很多选项，他可以满足你的各种查看需求： -p，用来显示每次提交的内容差异。 你也可以加上 -NUMBER 来仅显示最近两次提交：例如：1git log -p -2 来查看近俩次提交之间的差异。 –stat选项可以看到每次提交的简略的统计信息。 –pretty选项可以指定不同的显示格式。 其下有各种子选项：short、oneline、full、fuller、format等。 使用如下：1git log --pretty=oneline 会将每次提交在各自独自的一行中显示。 pretty选项中的format选项可以自定义选项格式：例如：1git log --pretty=format:&quot;%h - %an, %ar : %s&quot; 完成的选项如下图： 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 –date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者（committer）的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 –graph 显示 ASCII 图形表示的分支合并历史。 下面列举了一些常见的log下的选项： 选项 说明 -p 按补丁格式显示每个更新之间的差异。 –stat 显示每次更新的文件修改统计信息。 –shortstat 只显示 –stat 中最后的行数修改添加移除统计。 –name-only 仅在提交信息后显示已修改的文件清单。 –name-status 显示新增、修改、删除的文件清单。 –abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 –relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。 –graph 显示 ASCII 图形表示的分支合并历史。 –pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 你还可以限制输出的长度，包括按条目个数、时间和提交者等。这里就不一一列举了，需要的时候查一下即可。 10、回滚版本接下来我们学习git最核心的操作————回滚。我们学会了通过git log 来查看提交信息，会发现每次commit之后都有一串数字和字母的组合，而这串字符串是系统自动生成的唯一的代表了这次提交请求的一个ID，我们可以通过这串字符串来任意回滚到之前某一次提交上去。例如：1git checkout 9643a881f 将回退到这串字符串所代表的那次提交的状态上。 回滚的时候，并不需要将整个字符串都复制下来，从开头的一部分去截取也是可以的。 11、撤销操作（1）撤销提交后的操作当我们提交到了仓库文件以后，发现有一些文件漏添加了，或者提交信息写错了，这时就需要撤销操作。 先将你需要的文件添加到暂存区，然后使用下面的命令：1git commit --amend -m &quot;say something&quot; 来覆盖你之前的那次提交，之前的那次提交不会出现在你提交的历史中。也就是说最终你只用最后一次的提交结果。 （2）撤销暂存区中的操作如果不小心把不想放入暂存区的文件放入了暂存区，那么如何来撤销暂存区中的记录呢？使用下面的命令：1git reset HEAD FILENAME 执行之后你会发现原本在暂存区中的文件，已经变成 了未跟踪状态。 （3）撤销已修改文件的操作如果你修改了文件，却想撤回。此时文件并没有放入暂存区中，只是单纯的在工作环境中做了修改，那该怎么撤销呢？ 其实git status命令已经告诉你了： 123Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) 我们来使用下： 1git checkout --FIIENAME 这时你发现原本修改过的操作变成了之前未更改的状态。 12、给Git起别名如果不想使用Git本身的起名方式，那么可以通过起别名的方式来替换到Git默认的命令：1git config --global alias.ci commit 会将commit命令替换为ci，下次提交时，只要输入git ci就ok了。 当然，你也可以将常用的组合命令替换为一个命令：1git config --global alias.last &apos;log -1 HEAD&apos; 输入git last将会看到最后一次提交。 三、标签管理Git可以给历史中的某一次提交打上一个标签，用来标识这次提交，它相当于那次提交的引用，同样可以使用标签来回滚到所代表的提交。 1、创建标签如何在当前提交上打标签呢？使用下面的命令： 1git tag -a v1.9 -m &quot;some message&quot; -a选项表示创建一个新的标签。 -m和commit命令中的一样，为必填项，为标签添加一些注释。 还有一种轻量打标签的方式：1git tag v1.1.1 这种不需要选项而直接给当前的提交打上标签。 4、查看标签使用下面的命令来查看所有标签：1git tag 当然，在log命令中，你打的标签也会出现在提交的右边。 你也可以加-l 来进行特定的模式查找标签：1git tag -l v1.* 将列出tags中以v1.开头的标签。 你也可以查看某一标签所代表的提交，使用下面的命令： 1git show v1.1 将显示打标签者，标签信息，时间和哪一次提交。 5、给之前的提交打标签如何给之前的提交打标签呢？只要看一下那次提交的ID字符串就可以了：1git tag -a v1.2 9fceb02 将会给那次提交打上一个标签。 6、给远程仓库打标签由于默认情况下，git push命令不会将标签传输到远程仓库，你需要显示的将标签传送到远程仓库中：1git push origin TAGNAME 当然如果想传送的标签很多，可以使用带有–tags选项将所有标签全部传送到远程仓库中。 四、使用远程仓库我相信有相当大的一部分人，是想学习github的使用，之后才了解到了Git。这两者不是一种东西，git和github的关系，相当于球与球场的关系。git创建的是本地仓库，而github上存放了好多远程的仓库。这些仓库都是用户将自己的仓库上传到服务器上，让github来托管这些仓库。那么如何建立远程仓库以及让本地仓库与远程仓库关联起来呢？ 1、","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://yangzebin001.github.io/tags/Git/"}]}]}