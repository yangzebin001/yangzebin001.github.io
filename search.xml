<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>使用python实现一个ping小程序</title>
      <link href="/2020/12/22/%E4%BD%BF%E7%94%A8python%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAping%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <content type="html"><![CDATA[<p>在看《计算机网络：自顶向下方法》第四章的时候，有一个编程作业是用python编写一个ping小程序，我在实现的时候加深了一写对python的了解和对IP报文头部和ICMP报文头部信息有了一定理解，故记录一下。<br><a id="more"></a><br>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">ICMP_ECHO_REQUEST = <span class="number">8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checksum</span><span class="params">(strr)</span>:</span></span><br><span class="line">csum = <span class="number">0</span></span><br><span class="line">countTo = (len(strr) / <span class="number">2</span>) * <span class="number">2</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; countTo:</span><br><span class="line">thisVal = strr[count+<span class="number">1</span>] * <span class="number">256</span> + strr[count]</span><br><span class="line">csum = csum + thisVal</span><br><span class="line">csum = csum &amp; <span class="number">0xffffffff</span></span><br><span class="line">count = count + <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> countTo &lt; len(strr):</span><br><span class="line">csum = csum + str[len(strr) - <span class="number">1</span>]</span><br><span class="line">csum = csum &amp; <span class="number">0xffffffff</span></span><br><span class="line">csum = (csum &gt;&gt; <span class="number">16</span>) + (csum &amp; <span class="number">0xffff</span>)</span><br><span class="line">csum = csum + (csum &gt;&gt; <span class="number">16</span>)</span><br><span class="line">answer = ~csum</span><br><span class="line">answer = answer &amp; <span class="number">0xffff</span></span><br><span class="line">answer = answer &gt;&gt; <span class="number">8</span> | (answer &lt;&lt; <span class="number">8</span> &amp; <span class="number">0xff00</span>)</span><br><span class="line"><span class="keyword">return</span> answer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receiveOnePing</span><span class="params">(mySocket, ID, timeout, destAddr)</span>:</span></span><br><span class="line">timeLeft = timeout</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">startedSelect = time.time()</span><br><span class="line">whatReady = select.select([mySocket], [], [], timeLeft)</span><br><span class="line">howLongInSelect = (time.time() - startedSelect)</span><br><span class="line"><span class="keyword">if</span> whatReady[<span class="number">0</span>] == []: <span class="comment"># Timeout</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"请求超时。"</span></span><br><span class="line">timeReceived = time.time()</span><br><span class="line">recPacket, addr = mySocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line"><span class="comment">#Fill in start</span></span><br><span class="line"><span class="comment">#Fetch the ICMP header from the IP packet</span></span><br><span class="line">t, c, checksum, recID, seq = struct.unpack(<span class="string">"bbHHh"</span>, recPacket[<span class="number">20</span>:<span class="number">28</span>])</span><br><span class="line">ttl, = struct.unpack(<span class="string">"b"</span>, recPacket[<span class="number">8</span>:<span class="number">9</span>])</span><br><span class="line"><span class="keyword">if</span> t == <span class="number">3</span>:</span><br><span class="line"><span class="keyword">if</span> c == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Destination Network Unreachable."</span></span><br><span class="line"><span class="keyword">elif</span> c == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Destination Host Unreachable."</span></span><br><span class="line"><span class="keyword">if</span> t != <span class="number">0</span> <span class="keyword">or</span> c != <span class="number">0</span> <span class="keyword">or</span> recID != ID <span class="keyword">or</span> seq != <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Recieve error."</span></span><br><span class="line"><span class="comment">#Fill in end</span></span><br><span class="line">timeLeft = timeLeft - howLongInSelect</span><br><span class="line"><span class="keyword">if</span> timeLeft &lt;= <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"请求超时。"</span></span><br><span class="line"><span class="keyword">return</span> [<span class="number">1</span>-timeLeft, ttl, len(recPacket)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendOnePing</span><span class="params">(mySocket, destAddr, ID)</span>:</span></span><br><span class="line"><span class="comment"># Header is type (8), code (8), checksum (16), id (16), sequence (16)</span></span><br><span class="line">myChecksum = <span class="number">0</span></span><br><span class="line"><span class="comment"># Make a dummy header with a 0 checksum.</span></span><br><span class="line"><span class="comment"># struct -- Interpret strings as packed binary data</span></span><br><span class="line">header = struct.pack(<span class="string">"bbHHh"</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, <span class="number">1</span>)</span><br><span class="line">data = struct.pack(<span class="string">"d"</span>, time.time())</span><br><span class="line"><span class="comment"># Calculate the checksum on the data and the dummy header.</span></span><br><span class="line">myChecksum = checksum(header + data)</span><br><span class="line"><span class="comment"># Get the right checksum, and put in the header</span></span><br><span class="line"><span class="keyword">if</span> sys.platform == <span class="string">'darwin'</span>:</span><br><span class="line">myChecksum = htons(myChecksum) &amp; <span class="number">0xffff</span></span><br><span class="line"><span class="comment">#Convert 16-bit integers from host to network byte order.</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">myChecksum = htons(myChecksum)</span><br><span class="line">header = struct.pack(<span class="string">"bbHHh"</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, <span class="number">1</span>)</span><br><span class="line">packet = header + data</span><br><span class="line">mySocket.sendto(packet, (destAddr, <span class="number">1</span>)) <span class="comment"># AF_INET address must be tuple, not str</span></span><br><span class="line"><span class="comment">#Both LISTS and TUPLES consist of a number of objects</span></span><br><span class="line"><span class="comment">#which can be referenced by their position number within the object</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doOnePing</span><span class="params">(destAddr, timeout)</span>:</span></span><br><span class="line">icmp = getprotobyname(<span class="string">"icmp"</span>)</span><br><span class="line"><span class="comment">#SOCK_RAW is a powerful socket type. For more details see: http://sock-raw.org/papers/sock_raw</span></span><br><span class="line"><span class="comment">#Fill in start</span></span><br><span class="line">mySocket = socket(AF_INET, SOCK_RAW, icmp)</span><br><span class="line"><span class="comment">#Fill in end</span></span><br><span class="line">myID = os.getpid() &amp; <span class="number">0xFFFF</span> <span class="comment">#Return the current process i</span></span><br><span class="line">sendOnePing(mySocket, destAddr, myID)</span><br><span class="line">delay = receiveOnePing(mySocket, myID, timeout, destAddr)</span><br><span class="line">mySocket.close()</span><br><span class="line"><span class="keyword">return</span> delay</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(host, timeout=<span class="number">1</span>)</span>:</span></span><br><span class="line">dest = gethostbyname(host)</span><br><span class="line">print(<span class="string">"Pinging "</span> + dest + <span class="string">" using Python:"</span>)</span><br><span class="line">print()</span><br><span class="line">pingTimes = <span class="number">4</span></span><br><span class="line">lost = <span class="number">0</span></span><br><span class="line">delayList = []</span><br><span class="line"><span class="comment">#Send ping requests to a server separated by approximately one second</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(pingTimes):</span><br><span class="line">res = doOnePing(dest, timeout)</span><br><span class="line"><span class="keyword">if</span> type(res) == str:</span><br><span class="line">lost+=<span class="number">1</span>;</span><br><span class="line">print(res)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">delay, TTL, packetSize = res</span><br><span class="line">delay = int(delay * <span class="number">1000</span>)</span><br><span class="line">delayList.append(delay)</span><br><span class="line">print(<span class="string">"来自"</span>,dest,<span class="string">"的回复: 字节="</span>,packetSize,<span class="string">" 时间="</span>,delay,<span class="string">"ms TTL="</span>,TTL)</span><br><span class="line">time.sleep(<span class="number">1</span>)<span class="comment"># one second</span></span><br><span class="line"></span><br><span class="line">print(dest + <span class="string">" 的 Ping 统计信息:"</span>)</span><br><span class="line">print(<span class="string">"        数据包: 已发送 = "</span>,pingTimes,<span class="string">" ，已接收 = "</span>,pingTimes-lost,<span class="string">" ，丢失 = "</span>,lost, <span class="string">" ( "</span>,lost/pingTimes*<span class="number">100</span>,<span class="string">"% 丢失)"</span>)</span><br><span class="line"><span class="keyword">if</span> len(delayList) &gt; <span class="number">0</span>:</span><br><span class="line">print(<span class="string">"往返行程的估计时间(以毫秒为单位):"</span>)</span><br><span class="line">print(<span class="string">"最短 = "</span>,min(delayList),<span class="string">"ms，最长 = "</span>,max(delayList),<span class="string">"ms，平均 = "</span>,sum(delayList)/len(delayList),<span class="string">"ms"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &lt;= <span class="number">1</span>:</span><br><span class="line">print(<span class="string">"请输入要ping的主机地址!"</span>)</span><br><span class="line">exit()</span><br><span class="line">ping(sys.argv[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>作业中主要填写两个空，一个在doOnePing函数中，一个在receiveOnePing函数中。</p><p>首先看doOnePing函数，根据上下文可以猜测出这里需要定义一个socket变量，然后我们在第二章中做的实验知道，创建TCP类型的socket的语句是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket(AF_INET, SOCK_STREAM)</span><br></pre></td></tr></table></figure></p><p>创建UDP类型的socket的语句是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket(AF_INET, SOCK_DGRAM)</span><br></pre></td></tr></table></figure></p><p>而我们要发送的是ICMP报文，要知道ICMP工作在网络层，所以不能用传输层的协议来传输，进一步根据注释知道了使用SOCK_RAW来创建一个原始套接字，通过查API知道创建包含ICMP协议的原始套接字的语句是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">icmp = getprotobyname(&quot;icmp&quot;)</span><br><span class="line">mySocket = socket(AF_INET, SOCK_RAW, icmp)</span><br></pre></td></tr></table></figure></p><p>第一个空完成！</p><hr><p>接下来做receiveOnePing函数中的空。</p><p>这个函数要结合着sendOnePing函数看，因为一个是从当前主机往目标主机发数据，一个是从目标主机往当前主机接收数据，所以用什么方法打包数据，就要用同样的方法反向解包。</p><p>可以看到sendOnePing函数是通过struct.pack()来将header和data打包起来发送的，所以在receiveOnePing函数使用struct.unpack()来进行解包。注意这里recPacket是IP报文数据，又因为一般的IP首部占20个字节，所以从第20个字节开始才是ICMP报文。所以 recPacket[20:28] 就是ICMP的报文头，然后用struct.unpack()来把数据解包。注释中 Header is type (8), code (8), checksum (16), id (16), sequence (16) 可以帮助理解ICMP的报文头部信息。根据ICMP报文头部的信息确定ICMP的类型，我们需要的是TYPE为0，CODE为0，该报文类型为Echo Reply——回显应答（Ping应答），到这里我们解析ICMP报文的任务就完成了。</p><p>为了做的和windows中自带的ping看起来更像一些，我适当的做了一些修改。</p><p>比如字节数和TTL，由于TTL是在IP报文头部的第八个字节中存储的，所以也单独的提取出来。</p>]]></content>
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用信号量实现生产者消费者模型</title>
      <link href="/2020/09/04/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
      <content type="html"><![CDATA[<p>上一篇已经介绍过生产者消费者模型，这次使用信号量来解决该问题。</p><h4 id="使用信号量实现生产者消费者模型："><a href="#使用信号量实现生产者消费者模型：" class="headerlink" title="使用信号量实现生产者消费者模型："></a>使用信号量实现生产者消费者模型：</h4><p>我们用两个信号量empty和fill来分别表示缓冲区空或者填入数据项。</p><a id="more"></a><p>我们考虑信号量的初始值，因为buffer初始化为空，empty的初始值应该为buffer的容量，表示buffer中没有数据，也是就每一项都代表空，而fill则应该为空，这与消费者必须在生产者生产数据后才能进行相符合（如果消费者先执行，会因为fill信号量而阻塞）。</p><p>因为我们的缓冲区的容量超过1，如果两个生产者（pa和pb）同时put，pa线程在tail计数器更新到1之前被中断，pb开始执行，则会将老数据覆盖，所以在每次进行生产或者消费时都需要将临界区保护起来。</p><h5 id="使用一个二值信号量来充当互斥锁。将临界区保护起来。"><a href="#使用一个二值信号量来充当互斥锁。将临界区保护起来。" class="headerlink" title="使用一个二值信号量来充当互斥锁。将临界区保护起来。"></a>使用一个二值信号量来充当互斥锁。将临界区保护起来。</h5><h4 id="注意这里有一个死锁隐患。"><a href="#注意这里有一个死锁隐患。" class="headerlink" title="注意这里有一个死锁隐患。"></a>注意这里有一个死锁隐患。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">sem_wait(&amp;mutex); <span class="comment">//to avoid dead lock, mutex must be after fill.</span></span><br><span class="line">sem_wait(&amp;fill);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"get value is %d\n"</span>, get());</span><br><span class="line">sem_post(&amp;empty);</span><br><span class="line">sem_post(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">sem_wait(&amp;mutex);</span><br><span class="line">sem_wait(&amp;empty);</span><br><span class="line">put(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"put value is %d\n"</span>, i);</span><br><span class="line">sem_post(&amp;fill);</span><br><span class="line">sem_post(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，如果写成这个样子，有可能变为死锁。<br>死锁的状态是：消费者先运行，获得锁，然后对full信号量执行sem_wait()，并阻塞让出CPU（此时还持有mutex锁），然后生产者开始运行，但现在因为消费者持有mutex锁，所以也会阻塞并导致死锁。</p><p>所以要把获取和释放互斥量的操作调整为紧挨着临界区。把empty，fill的唤醒和等待操作调整到锁外。</p><h4 id="c版本代码："><a href="#c版本代码：" class="headerlink" title="c版本代码："></a>c版本代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buffer[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">sem_t</span> empty, fill, mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = buffer[head];</span><br><span class="line">head = (head + <span class="number">1</span>) % MAX;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">buffer[tail] = a;</span><br><span class="line">tail = (tail + <span class="number">1</span>) % MAX;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">sem_wait(&amp;fill);</span><br><span class="line">sem_wait(&amp;mutex); <span class="comment">//to avoid dead lock, mutex must be after fill.</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"get value is %d\n"</span>, get());</span><br><span class="line">sem_post(&amp;mutex);</span><br><span class="line">sem_post(&amp;empty);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">sem_wait(&amp;empty);</span><br><span class="line">sem_wait(&amp;mutex);</span><br><span class="line">put(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"put value is %d\n"</span>, i);</span><br><span class="line">sem_post(&amp;mutex);</span><br><span class="line">sem_post(&amp;fill);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">sem_init(&amp;empty, <span class="number">0</span> , MAX);</span><br><span class="line">sem_init(&amp;fill, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">pthread_t</span> t1,t2;</span><br><span class="line">pthread_create(&amp;t1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">pthread_create(&amp;t2, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"final size is %d\n"</span>, size);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yzb.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yzb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerProducerSem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CAPACITY = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Semaphore empty = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore fill = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] buffer = <span class="keyword">new</span> <span class="keyword">int</span>[CAPACITY];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = buffer[head];</span><br><span class="line">        head = (head+<span class="number">1</span>) % CAPACITY;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        buffer[tail] = data;</span><br><span class="line">        tail = (tail+<span class="number">1</span>) % CAPACITY;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        fill.acquire();</span><br><span class="line">        mutex.acquire();</span><br><span class="line"><span class="comment">//        System.out.println("get value is:" + get());</span></span><br><span class="line">        mutex.release();</span><br><span class="line">        empty.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">product</span><span class="params">(<span class="keyword">int</span> data)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        empty.acquire();</span><br><span class="line">        mutex.acquire();</span><br><span class="line">        put(data);</span><br><span class="line"><span class="comment">//        System.out.println("put value is:" + data);</span></span><br><span class="line">        mutex.release();</span><br><span class="line">        fill.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e4</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            ConsumerProducerSem cps = <span class="keyword">new</span> ConsumerProducerSem();</span><br><span class="line">            LocalConsumerThread c = cps.new LocalConsumerThread();</span><br><span class="line">            LocalProducerThread p = cps.new LocalProducerThread();</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(c);</span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(p);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join();</span><br><span class="line">                t2.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">assert</span> cps.count == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalConsumerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ConsumerProducerSem.CAPACITY; j++)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ConsumerProducerSem.<span class="keyword">this</span>.consume();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalProducerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ConsumerProducerSem.CAPACITY; j++)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ConsumerProducerSem.<span class="keyword">this</span>.product(j);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 锁 </tag>
            
            <tag> 信号量 </tag>
            
            <tag> 生产者消费者 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用锁+条件变量实现生产者消费者模型</title>
      <link href="/2020/09/02/%E4%BD%BF%E7%94%A8%E9%94%81+%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
      <content type="html"><![CDATA[<h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><p>假设有一个或多个生产者线程和一个或多个消费者线程。生产者把生成的数据项放入缓冲区，消费者从缓冲区取走数据项，以某种方式消费。</p><a id="more"></a><h4 id="使用锁-条件变量实现生产者消费者模型："><a href="#使用锁-条件变量实现生产者消费者模型：" class="headerlink" title="使用锁+条件变量实现生产者消费者模型："></a>使用锁+条件变量实现生产者消费者模型：</h4><p>一把锁控制整个模型的临界区，并使用两个条件变量分别控制生产和消费动作。<br>当消费时，如果已无数据项可供消费，就需要等待；而当生产时，如果缓冲区已满，则需要等待。<br>两个条件变量表明等待的时机：</p><ul><li>消费者在无数据项时无法继续消费，full条件需要等待，必须让出当前锁；消费完毕后说明有空间容纳新的数据项，empty去唤醒生产线程抢占锁。</li><li>生产者在缓冲区满时无法生产，empty条件等待，让出当前锁，而生产完毕一个数据项后，便可供消费，让full条件去通知消费线程进行消费。</li></ul><h4 id="C语言版"><a href="#C语言版" class="headerlink" title="C语言版"></a>C语言版</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAP 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_cond_t</span> fill, empty;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line"><span class="keyword">while</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">pthread_cond_wait(&amp;fill,&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line">count--;</span><br><span class="line">pthread_cond_signal(&amp;empty);</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line"><span class="keyword">while</span>(count == CAP) &#123;</span><br><span class="line">pthread_cond_wait(&amp;empty,&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line">count++;</span><br><span class="line">pthread_cond_signal(&amp;fill);</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">product</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s start\n"</span>, (<span class="keyword">char</span>*)arg);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CAP; i++) &#123;</span><br><span class="line">producer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s end\n"</span>, (<span class="keyword">char</span>*)arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consume</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s start\n"</span>, (<span class="keyword">char</span>*)arg);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CAP; i++) &#123;</span><br><span class="line">consumer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s end\n"</span>, (<span class="keyword">char</span>*)arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">pthread_cond_init(&amp;fill, <span class="literal">NULL</span>);</span><br><span class="line">pthread_cond_init(&amp;empty, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">pthread_t</span> t1,t2,t3;</span><br><span class="line">pthread_create(&amp;t1, <span class="literal">NULL</span>, product, <span class="string">"A"</span>);</span><br><span class="line">pthread_create(&amp;t2, <span class="literal">NULL</span>, product, <span class="string">"B"</span>);</span><br><span class="line">pthread_create(&amp;t3, <span class="literal">NULL</span>, consume, <span class="string">"C"</span>);</span><br><span class="line">pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(t3, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"end count is %d\n"</span>, count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="java版"><a href="#java版" class="headerlink" title="java版"></a>java版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yzb.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yzb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer_producter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CAPACITY = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fill = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> use = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition full = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition empty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] buffer = <span class="keyword">new</span> <span class="keyword">int</span>[CAPACITY];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = buffer[use];</span><br><span class="line">        use = (use+<span class="number">1</span>) % CAPACITY;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        buffer[fill] = data;</span><br><span class="line">        fill = (fill+<span class="number">1</span>) % CAPACITY;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                full.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> c = get();</span><br><span class="line"><span class="comment">//            System.out.println("消费了" + c);</span></span><br><span class="line">            empty.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == CAPACITY) &#123;</span><br><span class="line">                empty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            put(data);</span><br><span class="line"><span class="comment">//            System.out.println("生产了" + data);</span></span><br><span class="line">            full.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e3</span>; i++)&#123;</span><br><span class="line">            Consumer_producter consumerProducter = <span class="keyword">new</span> Consumer_producter();</span><br><span class="line">            Consumer_producter.LocalConsumerThread c1 = consumerProducter.new LocalConsumerThread();</span><br><span class="line">            Consumer_producter.LocalProducerThread c2 = consumerProducter.new LocalProducerThread();</span><br><span class="line">            Consumer_producter.LocalProducerThread p = consumerProducter.new LocalProducerThread();</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(c1);</span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(c2);</span><br><span class="line">            Thread t3 = <span class="keyword">new</span> Thread(p);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t3.start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                t1.join();</span><br><span class="line">                t2.join();</span><br><span class="line">                t3.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">assert</span>(consumerProducter.count == <span class="number">10</span>);</span><br><span class="line">            consumerProducter = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalConsumerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">                Consumer_producter.<span class="keyword">this</span>.consume();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalProducerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">                Consumer_producter.<span class="keyword">this</span>.producer(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 锁 </tag>
            
            <tag> 生产者消费者 </tag>
            
            <tag> 条件变量 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>并发数据结构——懒惰计数器</title>
      <link href="/2020/09/02/%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%87%92%E6%83%B0%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
      <content type="html"><![CDATA[<blockquote><p>懒惰计数器是并发数据结构，它是性能与准确度折中的结果。</p></blockquote><a id="more"></a><p>懒惰计数器通过多个局部计数器和一个全局计数器来实现一个逻辑计数器，其中每个CPU核心有一个局部计数器，另外有一个全局的计数器。</p><p>基本思想是如果一个核心上的线程想要增加计数器，那就增加它的局部计数器，访问这个局部计数器通过对应的局部锁同步。因为每个CPU有自己的局部计数器，所以不同CPU上的线程不会竞争，但是为了保持全局计数器更新，局部值会定期转移给全局计数器，方法是获取全局锁，让全局计数器加上局部计数器的值，然后局部计数器置零。</p><p>这里设定的一个阈值与扩展性成反比，阈值越小，扩展性越差，阈值越大，扩展性越高，相对应精度就越低。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMCPUS 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">counter_t</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> global; <span class="comment">//global count</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> glock;  <span class="comment">//global lock</span></span><br><span class="line"><span class="keyword">int</span> local[NUMCPUS];  <span class="comment">//local count (per cpu)</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> llock[NUMCPUS];  <span class="comment">// .. and locks</span></span><br><span class="line"><span class="keyword">int</span> threshold;       <span class="comment">// update frequency</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">counter_t</span> *c, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">c-&gt;threshold = threshold;</span><br><span class="line"></span><br><span class="line">c-&gt;global = <span class="number">0</span>;</span><br><span class="line">pthread_mutex_init(&amp;c-&gt;glock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NUMCPUS; i++) &#123;</span><br><span class="line">c-&gt;local[i] = <span class="number">0</span>;</span><br><span class="line">pthread_mutex_init(&amp;c-&gt;llock[i], <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">counter_t</span> *c, <span class="keyword">int</span> threadID, <span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line">pthread_mutex_lock(&amp;c-&gt;llock[threadID]);</span><br><span class="line">c-&gt;local[threadID] += amt;</span><br><span class="line"><span class="keyword">if</span>(c-&gt;local[threadID] &gt;= c-&gt;threshold) &#123;</span><br><span class="line">pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line">c-&gt;global += c-&gt;local[threadID];</span><br><span class="line">pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">c-&gt;local[threadID] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;c-&gt;llock[threadID]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">counter_t</span> *c)</span></span>&#123;</span><br><span class="line">pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line"><span class="keyword">int</span>  val = c-&gt;global;</span><br><span class="line">pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">force_update</span><span class="params">(<span class="keyword">counter_t</span> *c)</span></span>&#123;</span><br><span class="line">pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUMCPUS; i++) &#123;</span><br><span class="line">pthread_mutex_lock(&amp;c-&gt;llock[i]);</span><br><span class="line">c-&gt;global += c-&gt;local[i];</span><br><span class="line">c-&gt;local[i] = <span class="number">0</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;c-&gt;llock[i]);</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">counter_t</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">increment_counter</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s: start\n"</span>, (<span class="keyword">char</span>*) arg);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2e5</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; NUMCPUS; j++)&#123;</span><br><span class="line">update(&amp;c, j, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s: end, counter is %d\n"</span>, (<span class="keyword">char</span>*) arg, get(&amp;c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> p1,p2,p3,p4;</span><br><span class="line">init(&amp;c, <span class="number">1024</span>);</span><br><span class="line">pthread_create(&amp;p1, <span class="literal">NULL</span>, increment_counter, <span class="string">"A"</span>);</span><br><span class="line">pthread_create(&amp;p2, <span class="literal">NULL</span>, increment_counter, <span class="string">"B"</span>);</span><br><span class="line">pthread_create(&amp;p3, <span class="literal">NULL</span>, increment_counter, <span class="string">"C"</span>);</span><br><span class="line">pthread_create(&amp;p4, <span class="literal">NULL</span>, increment_counter, <span class="string">"D"</span>);</span><br><span class="line">pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(p3, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(p4, <span class="literal">NULL</span>);</span><br><span class="line">force_update(&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"finally counter is %d\n"</span>, get(&amp;c));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM OOM异常种类测试和解决方案总结</title>
      <link href="/2020/08/27/JVM%20OOM%E5%BC%82%E5%B8%B8%E7%A7%8D%E7%B1%BB%E6%B5%8B%E8%AF%95%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<blockquote><p>本文为学习《深入理解java虚拟机》书中2.4节实战部分的整理总结。</p></blockquote><p>jvm中能引起Out of memory Error 的运行时内存存储区域大致可以分为：</p><ul><li>java堆区溢出</li><li>java虚拟机栈和本地方法栈溢出</li><li>方法区和运行时常量池溢出</li><li>本机直接内存溢出</li></ul><a id="more"></a><p>下面通过示例代码来观察各个区域出错的状况。</p><h3 id="一、java堆区溢出"><a href="#一、java堆区溢出" class="headerlink" title="一、java堆区溢出"></a>一、java堆区溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yzb</span></span><br><span class="line"><span class="comment"> * VM args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        <span class="comment">// 不断向list中添加新创建的对象，对象实例会存储在堆中，所以会引起heap space OOM， 错误信息也能证明这一点。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="出错信息："><a href="#出错信息：" class="headerlink" title="出错信息："></a>出错信息：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: **Java heap space**</span><br><span class="line">Dumping heap to java_pid5472.hprof ...</span><br><span class="line">Heap dump file created [28155685 bytes in 0.209 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:3210)</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:3181)</span><br><span class="line">at java.util.ArrayList.grow(ArrayList.java:265)</span><br><span class="line">at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:239)</span><br><span class="line">at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:231)</span><br><span class="line">at java.util.ArrayList.add(ArrayList.java:462)</span><br><span class="line">at com.yzb.HeapTest.main(HeapTest.java:17)</span><br></pre></td></tr></table></figure><h4 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h4><p>java中的对象实例都是储存在堆区中，所以我们通过参数<code>-Xms20m -Xmx20m</code>固定好java堆的大小，并且保证有可达路径来避免GC回收对象，就可以很快将堆区占满，从而发生内存溢出异常，异常信息中的<br><code>Java heap space</code>也可以证明这一点。</p><p>另一个参数<code>-XX:+HeapDumpOnOutOfMemoryError</code>可以在堆溢出时dump出当前内存堆转储快照，我们用Jprofiler打开快照文件查看内存占用情况：</p><table><thead><tr><th>Name</th><th>Instance Count</th><th>Size</th></tr></thead><tbody><tr><td>com.yzb.HeapTest$OOMObject</td><td>810,326</td><td>12,965 kB</td></tr><tr><td>char[ ]</td><td>2,294</td><td>313 kB</td></tr><tr><td>java.lang.String</td><td>2,145</td><td>51,480 bytes</td></tr><tr><td>java.util.TreeMap$Entry</td><td>791</td><td>31,640 bytes</td></tr><tr><td>java.lang.Object[ ]</td><td>583</td><td>3,274 kB</td></tr><tr><td>java.lang.Class</td><td>546</td><td>174 kB</td></tr></tbody></table><p>可以看到 <code>com.yzb.HeapTest$OOMObject</code> 占用了绝大部分的内存，从而定位出是OOMObject对象实例过多的缘故。</p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>通过内存分析工具分析造成堆溢出的情况。如果是内存泄漏，找到泄漏对象的引用路径，定位对象创建和造成泄漏的位置。如果是内存溢出，检查虚拟机的堆参数<code>-Xmx -Xms</code> 是否还有上调的空间，再从代码上检查是否对象生命周期过长，设计不合理等情况，避免过多的内存消耗。</p><h3 id="二、java虚拟机栈和本地方法栈溢出"><a href="#二、java虚拟机栈和本地方法栈溢出" class="headerlink" title="二、java虚拟机栈和本地方法栈溢出"></a>二、java虚拟机栈和本地方法栈溢出</h3><p>关于栈溢出，我们可以有两种方法测试：</p><ul><li>缩小栈内存容量</li><li>增加栈帧长度</li></ul><p>我们先看第一种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yzb;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yzb</span></span><br><span class="line"><span class="comment"> * VM args： -Xss128k</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverFlowTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        StackOverFlowTest soft = <span class="keyword">new</span> StackOverFlowTest();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            soft.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length: "</span> + soft.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="错误信息："><a href="#错误信息：" class="headerlink" title="错误信息："></a>错误信息：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack length: 983</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">at com.yzb.StackOverFlowTest.stackLeak(StackOverFlowTest.java:8)</span><br><span class="line">at com.yzb.StackOverFlowTest.stackLeak(StackOverFlowTest.java:9)</span><br></pre></td></tr></table></figure><p>我们通过缩小栈容量，和无止境的递归调用来触发Stack Overflow异常。<br>这里可以看到，我们在128k的栈容量下，对于stackLeak方法，允许983次递归调用的深度。</p><p>再来试试第二种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yzb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverFlowTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> unused1, unused2, unused3, unused4, unused5,</span><br><span class="line">        unused6, unused7, unused8, unused9, unused10,</span><br><span class="line">        unused11, unused12, unused13, unused14, unused15,</span><br><span class="line">        unused16, unused17, unused18, unused19, unused20,</span><br><span class="line">        unused21, unused22, unused23, unused24, unused25,</span><br><span class="line">        unused26, unused27, unused28, unused29, unused30,</span><br><span class="line">        unused31, unused32, unused33, unused34, unused35,</span><br><span class="line">        unused36, unused37, unused38, unused39, unused40,</span><br><span class="line">        unused41, unused42, unused43, unused44, unused45,</span><br><span class="line">        unused46, unused47, unused48, unused49, unused50,</span><br><span class="line">        unused51, unused52, unused53, unused54, unused55,</span><br><span class="line">        unused56, unused57, unused58, unused59, unused60,</span><br><span class="line">        unused61, unused62, unused63, unused64, unused65,</span><br><span class="line">        unused66, unused67, unused68, unused69, unused70,</span><br><span class="line">        unused71, unused72, unused73, unused74, unused75,</span><br><span class="line">        unused76, unused77, unused78, unused79, unused80,</span><br><span class="line">        unused81, unused82, unused83, unused84, unused85,</span><br><span class="line">        unused86, unused87, unused88, unused89, unused90,</span><br><span class="line">        unused91, unused92, unused93, unused94, unused95,</span><br><span class="line">        unused96, unused97, unused98, unused99;</span><br><span class="line">        stackLength++;</span><br><span class="line">        test();</span><br><span class="line">        unused1 = unused2 = unused3 = unused4 = unused5 =</span><br><span class="line">        unused6 = unused7 = unused8 = unused9 = unused10 =</span><br><span class="line">        unused11 = unused12 = unused13 = unused14 = unused15 =</span><br><span class="line">        unused16 = unused17 = unused18 = unused19 = unused20 =</span><br><span class="line">        unused21 = unused22 = unused23 = unused24 = unused25 =</span><br><span class="line">        unused26 = unused27 = unused28 = unused29 = unused30 =</span><br><span class="line">        unused31 = unused32 = unused33 = unused34 = unused35 =</span><br><span class="line">        unused36 = unused37 = unused38 = unused39 = unused40 =</span><br><span class="line">        unused41 = unused42 = unused43 = unused44 = unused45 =</span><br><span class="line">        unused46 = unused47 = unused48 = unused49 = unused50 =</span><br><span class="line">        unused51 = unused52 = unused53 = unused54 = unused55 =</span><br><span class="line">        unused56 = unused57 = unused58 = unused59 = unused60 =</span><br><span class="line">        unused61 = unused62 = unused63 = unused64 = unused65 =</span><br><span class="line">        unused66 = unused67 = unused68 = unused69 = unused70 =</span><br><span class="line">        unused71 = unused72 = unused73 = unused74 = unused75 =</span><br><span class="line">        unused76 = unused77 = unused78 = unused79 = unused80 =</span><br><span class="line">        unused81 = unused82 = unused83 = unused84 = unused85 =</span><br><span class="line">        unused86 = unused87 = unused88 = unused89 = unused90 =</span><br><span class="line">        unused91 = unused92 = unused93 = unused94 = unused95 =</span><br><span class="line">        unused96 = unused97 = unused98 = unused99 = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StackOverFlowTest2 soft2 = <span class="keyword">new</span> StackOverFlowTest2();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            soft2.test();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length: "</span> + soft2.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="错误信息：-1"><a href="#错误信息：-1" class="headerlink" title="错误信息："></a>错误信息：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack length: 5209</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">at com.yzb.StackOverFlowTest2.test(StackOverFlowTest2.java:27)</span><br><span class="line">at com.yzb.StackOverFlowTest2.test(StackOverFlowTest2.java:27)</span><br></pre></td></tr></table></figure><p>现在使用jvm默认的栈大小，并且在方法内定义了100个本地变量来增加每个方法的调用栈帧。</p><p>我们看到该方法的调用深度为5209，并且报了StackOverflowError。</p><h4 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h4><p>对于StackOverflowError， 通常可以设置增加栈容量或者试着将其栈帧变大的方法内部进行削减本地变量，当然更多时候，栈溢出是递归过深造成的，试着减少递归深度或者改写成迭代形式。</p><h3 id="三、方法区和运行时常量池溢出"><a href="#三、方法区和运行时常量池溢出" class="headerlink" title="三、方法区和运行时常量池溢出"></a>三、方法区和运行时常量池溢出</h3><p>测试运行时常量池溢出，我们立马会想到String，但由于JDK7之后已经将字符串常量池移到了java堆区，所以只能通过限制堆区容量来观察错误信息，而JDK6之前可以通过限制永久代容量来看到错误情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yzb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yzb</span></span><br><span class="line"><span class="comment"> * VM args1: -XX:PermSize=6m -XX:MaxPermSize=6m  JDK 6 and before is work.</span></span><br><span class="line"><span class="comment"> * VM arg2: -Xms20m -Xmx20m  JDK 7 and after is work.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeContantPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; s = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            s.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JDK7-的报错信息："><a href="#JDK7-的报错信息：" class="headerlink" title="JDK7 的报错信息："></a>JDK7 的报错信息：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.HashMap.resize(HashMap.java:704)</span><br><span class="line">at java.util.HashMap.putVal(HashMap.java:663)</span><br><span class="line">at java.util.HashMap.put(HashMap.java:612)</span><br><span class="line">at java.util.HashSet.add(HashSet.java:220)</span><br><span class="line">at com.yzb.RuntimeContantPoolTest.main(RuntimeContantPoolTest.java:16)</span><br></pre></td></tr></table></figure><p>JDK8之后，元空间替代了永久代，如果到达了元空间初始空间大小，会触发垃圾收集进行类型卸载，并调整空间大小。</p><h3 id="四、本机直接内存溢出"><a href="#四、本机直接内存溢出" class="headerlink" title="四、本机直接内存溢出"></a>四、本机直接内存溢出</h3><p>通过反射获取Unsafe实例不断进行内存分配来导致本机直接的内存溢出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yzb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yzb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                unsafe.allocateMemory(_1MB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"allocated "</span> + cnt +<span class="string">"MB memory."</span>);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="报错信息："><a href="#报错信息：" class="headerlink" title="报错信息："></a>报错信息：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">allocated 13630MB memory.</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError</span><br><span class="line">at sun.misc.Unsafe.allocateMemory(Native Method)</span><br><span class="line">at com.yzb.DirectMemoryTest.main(DirectMemoryTest.java:22)</span><br></pre></td></tr></table></figure><p>可以看到在我的机器上申请了13GB的内存后出现了OutOfMemoryError。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Pinning a thread —— 如何让线程运行在特定的CPU上</title>
      <link href="/2020/08/24/Pinning%20a%20thread%20%E2%80%94%E2%80%94%20%E5%A6%82%E4%BD%95%E8%AE%A9%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%9C%A8%E7%89%B9%E5%AE%9A%E7%9A%84CPU%E4%B8%8A/"/>
      <content type="html"><![CDATA[<p>在看OSTEP的TLB部分时，作业中有一个问题是：<strong>如何让线程运行在特定的CPU上</strong>，觉得挺有趣的问题，随后通过STFW找到了答案。</p><p>主要用到两个 <code>pthread_setaffinity_np</code> 和 <code>pthread_getaffinity_np</code> api。</p><p>通过 RTFM<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man pthread_setaffinity_np</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>有一段示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> handle_error_en(en, msg) \</span></span><br><span class="line">       <span class="keyword">do</span> &#123; errno = en; perror(msg); <span class="built_in">exit</span>(EXIT_FAILURE); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> s, j;</span><br><span class="line">   <span class="keyword">cpu_set_t</span> cpuset;</span><br><span class="line">   <span class="keyword">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line">   thread = pthread_self();  <span class="comment">// 获取当前运行的线程数据结构</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Set affinity mask to include CPUs 0 to 7 */</span></span><br><span class="line">   CPU_ZERO(&amp;cpuset);   <span class="comment">// 将cpuset结构清零</span></span><br><span class="line">   <span class="comment">// 将0-7号CPU全部加入cpuset中（如果只想指定特定的cpu，运行循环中那一行即可）</span></span><br><span class="line">   <span class="comment">// 例如将线程运行在3号cpu上：CPU_SET(3, &amp;cpuset); </span></span><br><span class="line">   <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">       CPU_SET(j, &amp;cpuset);  <span class="comment">// 设置j号cpu到cpuset中。</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// set CPU affinity of a thread</span></span><br><span class="line">   s = pthread_setaffinity_np(thread, <span class="keyword">sizeof</span>(<span class="keyword">cpu_set_t</span>), &amp;cpuset);</span><br><span class="line">   <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">       handle_error_en(s, <span class="string">"pthread_setaffinity_np"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Check the actual affinity mask assigned to the thread */</span></span><br><span class="line">   s = pthread_getaffinity_np(thread, <span class="keyword">sizeof</span>(<span class="keyword">cpu_set_t</span>), &amp;cpuset);</span><br><span class="line">   <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">       handle_error_en(s, <span class="string">"pthread_getaffinity_np"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Set returned by pthread_getaffinity_np() contained:\n"</span>);</span><br><span class="line">   <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; CPU_SETSIZE; j++)</span><br><span class="line">       <span class="keyword">if</span> (CPU_ISSET(j, &amp;cpuset))</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"    CPU %d\n"</span>, j);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果gcc无法通过编译：undefined reference to pthread_setaffinity_np</p><p>在编译时加 <code>-lpthread</code> 参数即可。</p><blockquote><p>stackoverflow: <a href="https://stackoverflow.com/questions/32657609/pinning-a-thread-to-a-core-in-a-cpuset-through-c" target="_blank" rel="noopener">pinning-a-thread-to-a-core-in-a-cpuset-through-c</a></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 线程 </tag>
            
            <tag> cpu </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-10-正则表达式匹配</title>
      <link href="/2020/01/30/LeetCode-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. 正则表达式匹配</a></p><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;.&apos; 匹配任意单个字符</span><br><span class="line">&apos;*&apos; 匹配零个或多个前面的那一个元素</span><br></pre></td></tr></table></figure><p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><p>说明:</p><ul><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。</span><br></pre></td></tr></table></figure><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。</span><br></pre></td></tr></table></figure><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4:"></a>示例 4:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5:"></a>示例 5:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>可以使用动态规划来解此题。</p><p>首先定义状态，有过求LCS和LIC的经验，我们很轻易类似的写出该题的状态定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] 串S以i结尾，串P以j结尾是否能够匹配。</span><br></pre></td></tr></table></figure><p>我们考虑状态转移方程：<br>先分类考虑：</p><ul><li><p>s[i] != p[j] &amp;&amp; p[j] != ‘.’ &amp;&amp; p[j] != ‘*’</p></li><li><p>s[i] == p[j]</p></li></ul><ul><li>p[j] == ‘.’</li></ul><ul><li>p[j] == ‘*’</li></ul><p>第一种情况显然是false。</p><p>第二种情况是说明可以匹配，所以由S前i-1，P前j-1匹配的情况决定。</p><p>第三种情况把’.’看做s[i]可以和第二种情况合并</p><p>重点是第四种情况，p[j]为’*’ 的情况：</p><p>单独一个‘ <em> ’是不构成语义的，所以出现‘ </em> ’就要看前一个字符，而前面有可能出现的又有‘.’和字母两种情况。<br>前面说过了，我们遇见‘.’直接把他当作与s[i]相等的字符即可。不需要做特殊处理。</p><p>所以就只剩下了‘*’ 前面是字母的<br>而分成的两种情况：</p><ul><li>‘*’前面的字母和s[i-1]不匹配。</li></ul><ul><li>‘*’前面的字母和s[i-1]匹配。</li></ul><p>第一种情况由于’*’可以代表零个之前的字符。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aabc</span><br><span class="line">ad*abc</span><br></pre></td></tr></table></figure><p>是可以匹配的。<br>所以我们遇到’*’前面的字母和s[i-1]不匹配就可以跳过这两个字符。即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i][j-2]</span><br></pre></td></tr></table></figure><p>最后’*’前面的字母和s[i-1]匹配：</p><p>那么就有按照‘*’的语义，又需要划分三种情况：</p><ul><li>*加上前面的字符不与s[i-1]匹配。</li><li><em>加上前面的字符只与s[i-1]匹配 即 </em> 作废。</li><li>*加上前面的字符可以与多个s[i-1]匹配。</li></ul><p>前两种情况其实与我们之前分析的不加‘*’的情况基本一致。<br>那么与多个字符匹配怎么转移呢？</p><p>我们确定匹配多个字符可以一个一个来，只要dp[i-1][j]可以匹配。那么只要[j]是<em>，则dp[i][j]一定可以匹配上。（别忘了，我们的前提条件是 </em> 和之前的字母匹配）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###b</span><br><span class="line">###b* </span><br><span class="line">匹配。</span><br><span class="line"></span><br><span class="line">###bb</span><br><span class="line">###b*</span><br><span class="line">一定能匹配。</span><br></pre></td></tr></table></figure><p>至此我们就将所有情况分析完毕。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">        int n = s.size(), m = p.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(m+1));</span><br><span class="line">        dp[0][0] = 1;</span><br><span class="line">        //处理 aa 和c*c*c*aa 匹配的情况。前缀可以忽略。</span><br><span class="line">        for(int i = 1; i &lt;= m; i++)&#123;</span><br><span class="line">            if(i-2 &gt;= 0 &amp;&amp; dp[0][i-2] &amp;&amp; p[i-1] == &apos;*&apos;) dp[0][i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            for(int j = 1; j &lt;= m; j++)&#123;</span><br><span class="line">                //单个字符匹配。</span><br><span class="line">                if(s[i-1] == p[j-1] || (p[j-1] == &apos;.&apos;))&#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1];</span><br><span class="line">                //单个字符不匹配</span><br><span class="line">                &#125;else if(p[j-1] == &apos;*&apos;)&#123;</span><br><span class="line">                    // baa bc*aa 形式</span><br><span class="line">                    if(p[j-2] != s[i-1] &amp;&amp; p[j-2] != &apos;.&apos;)&#123;</span><br><span class="line">                        dp[i][j] = dp[i][j-2];</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                    // 否则是前一个字符可以匹配</span><br><span class="line">                    // 三种情况，</span><br><span class="line">                    // 忽略这个匹配的字符，dp[i][j] = dp[i][j-2];</span><br><span class="line">                    // 只匹配这个字符 dp[i][j] = dp[i][j-1];</span><br><span class="line">                    // 匹配多个字符，即看i之前的字符和当前能不能匹配上，dp[i][j] = dp[i-1][j];</span><br><span class="line">                    // ###b 和 ###b* 如果能匹配上， ###bb 和 ###b* 也能匹配上。</span><br><span class="line">                        dp[i][j] = (dp[i][j-2] || dp[i][j-1] || dp[i-1][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这里有一个点必须初始化，因为下标是从1开始的，无法访问到0，当遇到处理 aa 和c <em> c </em> c* aa 匹配的情况时，是需要访问到0的位置的，所以需要预处理。前缀可以为空的情况。</p></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>HDOJ102-Ma-Su-Plu-Plus</title>
      <link href="/2020/01/25/HDOJ102-Ma-Su-Plu-Plus/"/>
      <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1024" target="_blank" rel="noopener">Max Sum Plus Plus</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Now I think you have got an AC in Ignatius.L’s “Max Sum” problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem.</p><p>Given a consecutive number sequence S1, S2, S3, S4 … Sx, … Sn (1 ≤ x ≤ n ≤ 1,000,000, -32768 ≤ Sx ≤ 32767). We define a function sum(i, j) = Si + … + Sj (1 ≤ i ≤ j ≤ n).</p><p>Now given an integer m (m &gt; 0), your task is to find m pairs of i and j which make sum(i1, j1) + sum(i2, j2) + sum(i3, j3) + … + sum(im, jm) maximal (ix ≤ iy ≤ jx or ix ≤ jy ≤ jx is not allowed).</p><p>But I`m lazy, I don’t want to write a special-judge module, so you don’t have to output m pairs of i and j, just output the maximal summation of sum(ix, jx)(1 ≤ x ≤ m) instead. ^_^</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>Each test case will begin with two integers m and n, followed by n integers S1, S2, S3 … Sn.<br>Process to the end of file.</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>Output the maximal summation described above in one line.</p><h3 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h3><p>1 3 1 2 3<br>2 6 -1 4 -2 3 -2 3</p><h3 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h3><p>6<br>8</p><p>Hint</p><p>Huge input, scanf and dynamic programming is recommended.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定n个数，让其划分为k个不重叠的区间（不要求连续），求其中的最大值。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>因为给定一个区间，它的最大值是确定的，所以具有无后效性，所以我们考虑使用dp来解此题。</p><p>我们首先定义状态表示，很自然的想到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i][j] 表示将前i个数字分成j段的最大子段和。</span><br></pre></td></tr></table></figure><p>接下来考虑状态转移方程：</p><p>我们将状态转移分为：</p><ul><li>与前面划分的区间不合并，即自成一组。</li><li>与前面划分的区间合并为一组。</li></ul><p>第二种转移方程比较好考虑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + v[i];</span><br></pre></td></tr></table></figure><p>自成一组需要找上一组从哪里转移。由于不需要保证连续性，所以就需要从第一段一直到j-1段都要考虑到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max&#123;dp[k][j-1](1 &lt;= k &lt; i)&#125;</span><br></pre></td></tr></table></figure><p>由于只有k个长度的字符才能分成k段。所以这里取值范围应该改为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max&#123;dp[k][j-1](j-1 &lt;= k &lt; i)&#125; + v[i]</span><br></pre></td></tr></table></figure><p>综合一下就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] =max( dp[i-1][j], max&#123;dp[k][j-1](j-1 &lt;= k &lt; i)&#125; ) + v[i]</span><br></pre></td></tr></table></figure><p>分析工作准备完毕，我们准备写代码时发现，这个数组范围比较大，会O（n2）的算法会超时，所以要优化。</p><p>第二种转移方程没什么好优化的，我们转移到第一种上，它在转移上依赖了他之上的好多行的数组，列却只依赖一列。这里想象为二维数组，我们把行，列的含义互换，想象这个二维数组逆时针旋转了90度。<br>就得到了如下的转移方程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i][j] 表示将前j个数字分成i段的最大子段和。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] =max( dp[i][j-1], max&#123;dp[i-1][k](i-1 &lt;= k &lt; j)&#125; ) + v[j]</span><br></pre></td></tr></table></figure><p>我们可以将 max{dp[i-1]<a href="i-1 &lt;= k &lt; j">k</a>} 这个O(n)的时间，在上一层的d[i-1][j]计算结果时用一个变量来记录，使其优化为O(1)。</p><p>具体编程还是有些难度，需要好好思考。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Date: 2020-01-24 10:42:12</span><br><span class="line"> * @LastEditors  : BeckoninGshy</span><br><span class="line"> * @LastEditTime : 2020-01-25 11:37:00</span><br><span class="line"> */</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN =1e6+10;</span><br><span class="line">int dp[MAXN],v[MAXN],numax[MAXN]; //保存上一层dp的最大值。</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int k,n;</span><br><span class="line">    while(cin &gt;&gt; k &gt;&gt; n)&#123;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; v[i];</span><br><span class="line">            dp[i] = numax[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0] = numax[0] = 0;</span><br><span class="line">        int lastmax = INT_MIN;</span><br><span class="line">        for(int i = 1; i &lt;= k; i++)&#123;</span><br><span class="line">            lastmax = INT_MIN; //保存上一层dp的最大值</span><br><span class="line">            for(int j = i; j &lt;= n; j++)&#123;</span><br><span class="line">            //先利用之前的上一层最大值更新当前状态， </span><br><span class="line">                dp[j] = max(dp[j-1],numax[j-1]) + v[j];</span><br><span class="line">                //再将j-1的最大值更新到上一层的最大值数组中， 将在i+1层循环中使用，当前循环不使用</span><br><span class="line">                numax[j-1] = lastmax;</span><br><span class="line">                //存储当前层的最大值 </span><br><span class="line">                lastmax = max(lastmax,dp[j]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; lastmax &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-1320-二指输入的的最小距离</title>
      <link href="/2020/01/20/LeetCode-1320-%E4%BA%8C%E6%8C%87%E8%BE%93%E5%85%A5%E7%9A%84%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-distance-to-type-a-word-using-two-fingers/" target="_blank" rel="noopener">1320. 二指输入的的最小距离</a></p><p>二指输入法定制键盘在 XY 平面上的布局如上图所示，其中每个大写英文字母都位于某个坐标处，例如字母 A 位于坐标 (0,0)，字母 B 位于坐标 (0,1)，字母 P 位于坐标 (2,3) 且字母 Z 位于坐标 (4,1)。</p><p>给你一个待输入字符串 word，请你计算并返回在仅使用两根手指的情况下，键入该字符串需要的最小移动总距离。坐标 (x1,y1) 和 (x2,y2) 之间的距离是 |x1 - x2| + |y1 - y2|。 </p><p>注意，两根手指的起始位置是零代价的，不计入移动总距离。你的两根手指的起始位置也不必从首字母或者前两个字母开始。</p><h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：word = &quot;CAKE&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><blockquote><p>解释：<br>使用两根手指输入 “CAKE” 的最佳方案之一是：<br>手指 1 在字母 ‘C’ 上 -&gt; 移动距离 = 0<br>手指 1 在字母 ‘A’ 上 -&gt; 移动距离 = 从字母 ‘C’ 到字母 ‘A’ 的距离 = 2<br>手指 2 在字母 ‘K’ 上 -&gt; 移动距离 = 0<br>手指 2 在字母 ‘E’ 上 -&gt; 移动距离 = 从字母 ‘K’ 到字母 ‘E’ 的距离  = 1<br>总距离 = 3</p><h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：word = &quot;HAPPY&quot;</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><blockquote><p>解释：<br>使用两根手指输入 “HAPPY” 的最佳方案之一是：<br>手指 1 在字母 ‘H’ 上 -&gt; 移动距离 = 0<br>手指 1 在字母 ‘A’ 上 -&gt; 移动距离 = 从字母 ‘H’ 到字母 ‘A’ 的距离 = 2<br>手指 2 在字母 ‘P’ 上 -&gt; 移动距离 = 0<br>手指 2 在字母 ‘P’ 上 -&gt; 移动距离 = 从字母 ‘P’ 到字母 ‘P’ 的距离 = 0<br>手指 1 在字母 ‘Y’ 上 -&gt; 移动距离 = 从字母 ‘A’ 到字母 ‘Y’ 的距离 = 4<br>总距离 = 6</p><h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h4></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：word = &quot;NEW&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a>示例 4：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：word = &quot;YEAR&quot;</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure><blockquote><p>提示：<br>2 &lt;= word.length &lt;= 300<br>每个 word[i]。都是一个大写英文字母。</p></blockquote><h3 id="Solution1（记忆化）："><a href="#Solution1（记忆化）：" class="headerlink" title="Solution1（记忆化）："></a>Solution1（记忆化）：</h3><p>我们首先要定义一个递归方程，思考后发现有两类主要元素：第一类是要记录到哪个字符，第二类是两个手指当前的位置。</p><p>然后发现“记录到哪个字符”这个状态不太好与两个手指进行关联（只能和一个手指进行绑定），所以我们转化一下思路，将记录到哪个字符转变为从第i个字符起，到字符串的末尾这整个区间，然后记录两个手指的状态。这样就得到了如下的递归函数参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// i: [i:w.size()]区间内花费的最小距离，</span><br><span class="line">// l: 上一个第一个手指的位置。</span><br><span class="line">// r: 上一个第二个手指的位置</span><br><span class="line">dfs(int i, int l, int r)</span><br></pre></td></tr></table></figure><p>转移方程为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs(i,l,c) = min(dfs(i+1,l,c)+cost(r,c),dfs(i+1,c,r)+cost(l,c));</span><br></pre></td></tr></table></figure><p>然后添加记忆化数组，整理就得到了下面的解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    int mem[310][27][27];</span><br><span class="line">    int cost(int i, int j)&#123;</span><br><span class="line">        if(i == 26 || j == 26) return 0;</span><br><span class="line">        return abs(i/6-j/6)+abs(i%6-j%6);</span><br><span class="line">    &#125;</span><br><span class="line">    string w;</span><br><span class="line">    // i: [i:w.size()]区间内花费的最小距离，</span><br><span class="line">    // l: 上一个第一个手指的位置。</span><br><span class="line">    // r: 上一个第二个手指的位置。</span><br><span class="line">    int dfs(int i, int l, int r)&#123;</span><br><span class="line">        if(i == w.size()) return 0;</span><br><span class="line">        if(mem[i][l][r]) return mem[i][l][r];</span><br><span class="line">        int c = w[i]-&apos;A&apos;;</span><br><span class="line">        return mem[i][l][r] = min(dfs(i+1,l,c)+cost(r,c),dfs(i+1,c,r)+cost(l,c));</span><br><span class="line">    &#125;</span><br><span class="line">    int minimumDistance(string word) &#123;</span><br><span class="line">        w = word;</span><br><span class="line">        //计算整个字符串的区间，初始两指从悬空状态开始。</span><br><span class="line">        return dfs(0,26,26);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution2（DP）："><a href="#Solution2（DP）：" class="headerlink" title="Solution2（DP）："></a>Solution2（DP）：</h3><p>我们可以试着将记忆化搜索转化为dp求解，很明显，状态表示和递归函数的状态是一致的，都是三维表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int dp[i][j][k]; //第一个手指一动到i，第二个手指移动到j，已经移动了k个字符的最小代价。</span><br></pre></td></tr></table></figure><p>这里与记忆化搜索定义的字符区间范围正好相反，递归中用的是从i到n的区间，而这里由于天然的记忆化过程，可以直接表示从0到k。</p><p>接着写状态转移方程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//从上一个字符移动到当前字符使用第一个手指，计算的最小价值。</span><br><span class="line">dp[c][j][k] = min(dp[c][j][k],dp[i][j][k-1] + cost);</span><br><span class="line">//从上一个字符移动到当前字符使用第二个手指，计算的最小价值。</span><br><span class="line">dp[i][c][k] = min(dp[i][c][k],dp[i][j][k-1] + cost);</span><br></pre></td></tr></table></figure><p>最后我们查看手指停在任何字符上的代价取最小即为答案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Cost(int i, int j)&#123;</span><br><span class="line">        //悬空状态，代价为0</span><br><span class="line">        if(i == 26 || j == 26) return 0;</span><br><span class="line">        return abs(i/6-j/6)+abs(i%6-j%6);</span><br><span class="line">    &#125;</span><br><span class="line">    int dp[27][27][301]; //第一个手指一动到i，第二个手指移动到j，已经移动了k个字符的最小代价。</span><br><span class="line">    int minimumDistance(string word) &#123;</span><br><span class="line">        memset(dp,0x3f3f3f3f,sizeof(dp));</span><br><span class="line">        // 初始化悬空状态</span><br><span class="line">        dp[26][26][0] = 0;</span><br><span class="line">        int n = word.size();</span><br><span class="line">        for(int k = 1; k &lt;= n; k++)&#123;</span><br><span class="line">            int c = word[k-1]-&apos;A&apos;;</span><br><span class="line">            //a</span><br><span class="line">            int cost = 0;</span><br><span class="line">            for(int i = 0; i &lt;= 26; i++)&#123;</span><br><span class="line">                for(int j = 0; j &lt;= 26; j++)&#123;</span><br><span class="line">                    cost = Cost(i,c);</span><br><span class="line">                    //从上一个字符移动到当前字符使用第一个手指，计算的最小价值。</span><br><span class="line">                    dp[c][j][k] = min(dp[c][j][k],dp[i][j][k-1] + cost);</span><br><span class="line">                    cost = Cost(j,c);</span><br><span class="line">                    //从上一个字符移动到当前字符使用第二个手指，计算的最小价值。</span><br><span class="line">                    dp[i][c][k] = min(dp[i][c][k],dp[i][j][k-1] + cost);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 0x3f3f3f3f;</span><br><span class="line">        for(int i = 0; i &lt;= 26; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt;= 26; j++)&#123;</span><br><span class="line">                ans = min(ans,dp[i][j][n]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-89-格雷编码</title>
      <link href="/2020/01/14/LeetCode-89-%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/gray-code/" target="_blank" rel="noopener">89. 格雷编码</a></p><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p><p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0,1,3,2]</span><br><span class="line">解释:</span><br><span class="line">00 - 0</span><br><span class="line">01 - 1</span><br><span class="line">11 - 3</span><br><span class="line">10 - 2</span><br></pre></td></tr></table></figure><p>对于给定的 n，其格雷编码序列并不唯一。<br>例如，[0,2,3,1] 也是一个有效的格雷编码序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00 - 0</span><br><span class="line">10 - 2</span><br><span class="line">11 - 3</span><br><span class="line">01 - 1</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: 0</span><br><span class="line">输出: [0]</span><br><span class="line">解释: 我们定义格雷编码序列必须以 0 开头。</span><br><span class="line">     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。</span><br><span class="line">     因此，当 n = 0 时，其格雷编码序列为 [0]。</span><br></pre></td></tr></table></figure><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><p>动态规划法：</p><p>格雷码可以通过在当前的部分格雷码通过复制这一部分上下翻转次序后，使翻转后的部分通过新增加的最高位都转换为1来得到。</p><p>例如当前的部分序列为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00</span><br><span class="line">01</span><br></pre></td></tr></table></figure></p><p>翻转后为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">01</span><br><span class="line">00</span><br></pre></td></tr></table></figure></p><p>往每个数字前面增加一位前导零组合成新的部分格雷码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000</span><br><span class="line">001</span><br><span class="line">001</span><br><span class="line">000</span><br></pre></td></tr></table></figure></p><p>将翻转后的数字的前导零置为1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000</span><br><span class="line">001</span><br><span class="line">101</span><br><span class="line">100</span><br></pre></td></tr></table></figure></p><p>这一新的序列也是格雷码序列。</p><p>通过翻转n次，将得到长度为n全部的格雷码序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; grayCode(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        ans.push_back(0);</span><br><span class="line">        for(int k = 0; k &lt; n; k++)&#123;</span><br><span class="line">            int c = ans.size();</span><br><span class="line">            for(int j = c, i = 1; j &lt; 2*c; j++, i++)&#123;</span><br><span class="line">                ans.push_back(ans[c-i]|(1&lt;&lt;k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h3><p>直接构造法：</p><p>维基百科中生成格雷码的步骤为：</p><blockquote><p>以二进制为 0 值的格雷码为第零项，第一项改变最右边的位元，第二项改变右起第一个为1的位元的左边位元，第三、四项方法同第一、二项，如此反复，即可排列出n个位元的格雷码。</p></blockquote><p>以3为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">000 初始值</span><br><span class="line">001 改变右起第一项</span><br><span class="line">011 改变右起第一个为1的位元的左边位元</span><br><span class="line">010 改变右起第一项</span><br><span class="line">110 改变右起第一个为1的位元的左边位元</span><br><span class="line">111 改变右起第一项</span><br><span class="line">101 改变右起第一个为1的位元的左边位元</span><br><span class="line">100 改变右起第一项</span><br></pre></td></tr></table></figure><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; grayCode(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        ans.push_back(0);</span><br><span class="line">        for(int k = 1; k &lt; 1&lt;&lt;n; k++)&#123;</span><br><span class="line">            // 改变右起第一项。</span><br><span class="line">            if(k%2) ans.push_back(ans[k-1]^1);</span><br><span class="line">            // 改变右起第一个为1的位元的左边位元</span><br><span class="line">            else&#123;</span><br><span class="line">                int c = 0;</span><br><span class="line">                int pre = ans[k-1];</span><br><span class="line">                while(((pre&gt;&gt;c) &amp; 1) == 0) c++;</span><br><span class="line">                c++;</span><br><span class="line">                ans.push_back(pre^(1&lt;&lt;c));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="Solution3："><a href="#Solution3：" class="headerlink" title="Solution3："></a>Solution3：</h3><p>公式法：</p><p>当前第i项的二进制数的最高位保留，其它位是当前位和它的高一位进行异或操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; grayCode(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line"></span><br><span class="line">        for(int k = 0; k &lt; 1&lt;&lt;n; k++)&#123;</span><br><span class="line">            //每一项与当前数右移后异或得到。</span><br><span class="line">            ans.push_back(k^(k&gt;&gt;1));</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-394-字符串解码</title>
      <link href="/2019/12/26/LeetCode-394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394. 字符串解码</a></p><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.</span><br><span class="line">s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.</span><br><span class="line">s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;.</span><br></pre></td></tr></table></figure><h3 id="Solution1（递归法）："><a href="#Solution1（递归法）：" class="headerlink" title="Solution1（递归法）："></a>Solution1（递归法）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string decodeString(string s) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        string ans = &quot;&quot;;</span><br><span class="line">        while(i &lt; s.size())&#123;</span><br><span class="line">            ans += dfs(s,i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    string dfs(string s, int &amp;i)&#123;</span><br><span class="line">        int num = 0,flag = 0;</span><br><span class="line">        string t = &quot;&quot;, tt = &quot;&quot;;</span><br><span class="line">        while(i &lt; s.size() &amp;&amp; s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;)&#123;</span><br><span class="line">            num = num * 10 + (s[i]-&apos;0&apos;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &lt; s.size() &amp;&amp; s[i] == &apos;[&apos;) flag = 1, i++;</span><br><span class="line">        while(i &lt; s.size() &amp;&amp; s[i] != &apos;]&apos;)&#123;</span><br><span class="line">            if(s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                t += dfs(s,i);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            t += s[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(t.size() &gt; 0)&#123;</span><br><span class="line">            tt = t;</span><br><span class="line">            while(--num &gt; 0) tt += t;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &lt; s.size() &amp;&amp; s[i] == &apos;]&apos;) i++;</span><br><span class="line">        return tt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>很正常的思路就是递归，每遇到数字就递归到下一层，等下一层的结束后，返回到当前层接着处理，在遇到’]’或者走到最后时，结束这一层的处理。</p><h3 id="Solution2（栈）："><a href="#Solution2（栈）：" class="headerlink" title="Solution2（栈）："></a>Solution2（栈）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string decodeString(string s) &#123;</span><br><span class="line">        stack&lt;int&gt; numstk;</span><br><span class="line">        stack&lt;string&gt; strstk;</span><br><span class="line">        int num = 0;</span><br><span class="line">        string cur = &quot;&quot;; //当前层可以形成的串</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++)&#123;</span><br><span class="line">            if(s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                num = num * 10 + (s[i]-&apos;0&apos;);</span><br><span class="line">            &#125;else if(s[i] == &apos;[&apos;)&#123;</span><br><span class="line">                //模拟递归，该去下一层了。</span><br><span class="line">                numstk.push(num);</span><br><span class="line">                strstk.push(cur);</span><br><span class="line">                num = 0;</span><br><span class="line">                cur = &quot;&quot;;</span><br><span class="line">            &#125;else if(s[i] == &apos;]&apos;)&#123;</span><br><span class="line">                //这一层已经完成处理</span><br><span class="line">                for(int j = 0; j &lt; numstk.top(); j++)&#123;</span><br><span class="line">                    strstk.top() += cur;  </span><br><span class="line">                &#125;</span><br><span class="line">                //返回上一层</span><br><span class="line">                cur = strstk.top();</span><br><span class="line">                strstk.pop();</span><br><span class="line">                numstk.pop();</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                cur += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>使用栈就是为了能保留当前层的信息，这里的进入下一层的时机和递归版略有差别，在到达’[‘的时候才进入下一层，主要是为了确定num的值和保存之前正处理的串的信息，在’]’的时候要处理完当前层，并且返回上一层。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-117-填充每个节点的下一个右侧节点指-II</title>
      <link href="/2019/12/02/LeetCode-117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87-II/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117. 填充每个节点的下一个右侧节点指针 II</a></p><p>此题为<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. 填充每个节点的下一个右侧节点指针</a>的进阶版本。</p><p>给定一个二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>进阶：</p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,null,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,7,#]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>树中的节点数小于 6000</li><li>100 &lt;= node.val &lt;= 100</li></ul><h3 id="Solution1（迭代版）："><a href="#Solution1（迭代版）：" class="headerlink" title="Solution1（迭代版）："></a>Solution1（迭代版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        if(!root) return NULL;</span><br><span class="line">        Node* head = root;</span><br><span class="line">        Node* pre = NULL;</span><br><span class="line">        while(root)&#123;</span><br><span class="line">            Node* sub = NULL;</span><br><span class="line">            while(pre)&#123;</span><br><span class="line">                if(pre-&gt;left)&#123;</span><br><span class="line">                    if(sub) sub-&gt;next = pre-&gt;left;</span><br><span class="line">                    sub = pre-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                if(pre-&gt;right)&#123;</span><br><span class="line">                    if(sub) sub-&gt;next = pre-&gt;right;</span><br><span class="line">                    sub = pre-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = root;</span><br><span class="line">            while(root)&#123;</span><br><span class="line">                if(root-&gt;left)&#123;</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else if(root-&gt;right)&#123;</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    root = root-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>与上一题类似，先设置下父指针，找到父指针下所有存在的结点相连接，然后找到下一层的第一个结点，将其继续当做父节点。</p><h3 id="Solution2（递归版）："><a href="#Solution2（递归版）：" class="headerlink" title="Solution2（递归版）："></a>Solution2（递归版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        </span><br><span class="line">        if(!root || (!root-&gt;left &amp;&amp; !root-&gt;right)) return root;</span><br><span class="line">        //先把当前结点连接</span><br><span class="line">        if(root-&gt;left &amp;&amp; root-&gt;right) root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">        Node* sub = root-&gt;right ? root-&gt;right : root-&gt;left;</span><br><span class="line">        //跳过没有子节点的节点</span><br><span class="line">        Node* head = root-&gt;next;</span><br><span class="line">        while(head &amp;&amp; !head-&gt;left &amp;&amp; !head-&gt;right)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        sub-&gt;next = head ? (head-&gt;left ? head-&gt;left : head-&gt;right) : NULL;</span><br><span class="line">        connect(root-&gt;right);</span><br><span class="line">        connect(root-&gt;left);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>如果是叶子节点或空节点，则直接返回。<br>如果有两个子节点，先把两节点之间连接，把右节点当做下一层要操作的节点。<br>如果只有一个子节点，把该节点当做下一层要操作的节点。</p><p>将下一层的节点连接（寻找当前层的非叶子结点，将它的子节点与该结点的下一层节点连接）。</p><h5 id="这里注意一定要先构建右子树，再构建左子树，因为寻找父节点的兄弟节点是从左到右遍历的，如果右子树未构建好就遍历，则会出错。"><a href="#这里注意一定要先构建右子树，再构建左子树，因为寻找父节点的兄弟节点是从左到右遍历的，如果右子树未构建好就遍历，则会出错。" class="headerlink" title="这里注意一定要先构建右子树，再构建左子树，因为寻找父节点的兄弟节点是从左到右遍历的，如果右子树未构建好就遍历，则会出错。"></a>这里注意一定要先构建右子树，再构建左子树，因为寻找父节点的兄弟节点是从左到右遍历的，如果右子树未构建好就遍历，则会出错。</h5>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-116-填充每个节点的下一个右侧节点指针</title>
      <link href="/2019/11/25/LeetCode-116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/"/>
      <content type="html"><![CDATA[<p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><h3 id="Solution1（递归版）："><a href="#Solution1（递归版）：" class="headerlink" title="Solution1（递归版）："></a>Solution1（递归版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        if(!root) return NULL;</span><br><span class="line">        Node* l = root-&gt;left;</span><br><span class="line">        Node* r = root-&gt;right;</span><br><span class="line">        while(l)&#123;</span><br><span class="line">            l-&gt;next = r;</span><br><span class="line">            l = l-&gt;right;</span><br><span class="line">            r = r-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        connect(root-&gt;left);</span><br><span class="line">        connect(root-&gt;right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution2（迭代版）："><a href="#Solution2（迭代版）：" class="headerlink" title="Solution2（迭代版）："></a>Solution2（迭代版）：</h3><p>一层一层的考虑，由于每个结点往后连需要用到其父节点的信息，所以我们可以在下一层结点的next指针连接完毕后，在往下一层移动时，父结点就可以利用已经连接好的next指针进行平滑的向右移动了。这样直到最后一层结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        if(!root) return root;</span><br><span class="line">        Node* pre = NULL;</span><br><span class="line">        Node* cur = root;</span><br><span class="line">        while(cur)&#123;</span><br><span class="line">            while(pre)&#123;</span><br><span class="line">                pre-&gt;left-&gt;next = pre-&gt;right;</span><br><span class="line">                if(pre-&gt;next)&#123;</span><br><span class="line">                    pre-&gt;right-&gt;next = pre-&gt;next-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>01背包问题详解</title>
      <link href="/2019/11/25/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/"/>
      <content type="html"><![CDATA[<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>有 N 件物品和一个容量是 V的背包。每件物品只能使用一次。</p><p>第 i件物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积<strong>不超过</strong>背包容量，且<strong>总价值最大</strong>。<br>输出最大价值。</p><a id="more"></a><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>拿到这道题目，我们在不用动态规划的情况下，可以枚举这N件物品，每件物品都有选和不选两种情况，所以总的复杂度为O（2^n）。并且在计算过程中，我们发现有很多的重复计算。最直接优化的方法当然是记忆化，将搜到的状态保存下来，以便之后重复调用时直接取值，避免重复计算。</p><p>第二种优化方法就是动态规划了。我们对每一次的决策都保留最优解。最终得到问题的最优解。</p><p>构建动态规划的关键在于定义状态转移方程。<br>定义状态转移方程要符合两个条件：</p><ul><li>最优子结构</li><li>无后效性</li></ul><p>我们回到01背包问题具体来看：</p><p>由于只有当所有的背包全部考察完，我们才能得到最终的方案，并且对于每一层的背包我都可以选择拿或不拿，这一层的决策不会影响到之前已经得到的结论，所以很自然的要定义一个维度，用来指名当前要考察的背包。</p><p>又由于要限制条件为背包的容量，大于背包容量的我们自然永远都不会考虑，但是背包的容量会随着每个背包的选或不选能有变化，所以我们还需要一维信息，由来记录背包的容量变化。<br>所以我们得出来一个二维数组用来记录状态:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] //i是前i个背包，j是容量，dp[i][j]是当前前i个背包，容量是j时，可获得的最大价值。</span><br></pre></td></tr></table></figure><p>我们思考下转移方程：<br>在每个背包被考察时，我们先考虑不选当前背包，则方程为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j]</span><br></pre></td></tr></table></figure><p>然后考虑选择当前背包：</p><p>在选择了背包后容量肯定会变大，对照我们定义的状态，所以会有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i+1][j+w] = dp[i][j]+v; //这时w,v分别代表第i+1个背包的质量和价值。</span><br></pre></td></tr></table></figure><p>转换一下就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-wi]+vi;//这时w,v分别代表第i个背包的质量和价值。</span><br></pre></td></tr></table></figure><p>我们要保持当前状态为最大的价值。<br>所以综合起来，方程就变为了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i-1][j],dp[i-1][j-wi]+vi);</span><br></pre></td></tr></table></figure><p>整理成代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 1010;</span><br><span class="line">int n,m;</span><br><span class="line">//前i个物体，总体积是j 的最大总价值</span><br><span class="line">int f[MAXN][MAXN];</span><br><span class="line">int V[MAXN],W[MAXN];</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; V[i] &gt;&gt; W[i];</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt;= m; j++)&#123;</span><br><span class="line">            //要么不选</span><br><span class="line">            f[i][j] = f[i-1][j];</span><br><span class="line">            if(j &gt;= V[i])&#123;</span><br><span class="line">                //要么选择该背包，从f[i-1][j-v[i]]过来。</span><br><span class="line">                f[i][j] = max(f[i][j],f[i-1][j-V[i]]+W[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    //在前n个物体中，选价值最大的一个</span><br><span class="line">    for(int i = 0; i &lt;= m; i++)&#123;</span><br><span class="line">        ans = max(ans,f[n][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h4><p>我们再看一下转移方程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i-1][j],dp[i-1][j-wi]+vi);</span><br></pre></td></tr></table></figure><p>当前考察背包只会利用到上一个背包计算后的结果。所以我们考虑优化到一维，但是循环的顺序需要变一下，从后往前计算，只有这样我们不会改变了之前的值，而导致计算出错。</p><h4 id="一维数组优化"><a href="#一维数组优化" class="headerlink" title="一维数组优化"></a>一维数组优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 1010;</span><br><span class="line">int f[MAXN];</span><br><span class="line">int N,M;</span><br><span class="line">int V[MAXN],W[MAXN];</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;N,&amp;M);</span><br><span class="line">    for(int i = 1; i &lt;= N; i++) scanf(&quot;%d%d&quot;,&amp;V[i],&amp;W[i]);</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)</span><br><span class="line">        //从后往前推，保留i-1的状态</span><br><span class="line">        for(int j = M; j &gt;= V[i]; j--)&#123;</span><br><span class="line">            f[j] = max(f[j],f[j-V[i]]+W[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    printf(&quot;%d&quot;,f[M]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，01背包问题就完美的解决了。</p>]]></content>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>背包九讲</title>
      <link href="/2019/11/25/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/"/>
      <content type="html"><![CDATA[<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p>有 N 件物品和一个容量是 V的背包。每件物品只能使用一次。</p><p>第 i件物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积<strong>不超过</strong>背包容量，且<strong>总价值最大</strong>。<br>输出最大价值。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 1010;</span><br><span class="line">int n,m;</span><br><span class="line">//前i个物体，总体积是j 的最大总价值</span><br><span class="line">int f[MAXN][MAXN];</span><br><span class="line">int V[MAXN],W[MAXN];</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; V[i] &gt;&gt; W[i];</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt;= m; j++)&#123;</span><br><span class="line">            //要么不选</span><br><span class="line">            f[i][j] = f[i-1][j];</span><br><span class="line">            if(j &gt;= V[i])&#123;</span><br><span class="line">                //要么选择该背包，从f[i-1][j-v[i]]过来。</span><br><span class="line">                f[i][j] = max(f[i][j],f[i-1][j-V[i]]+W[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    //在前n个物体中，选价值最大的一个</span><br><span class="line">    for(int i = 0; i &lt;= m; i++)&#123;</span><br><span class="line">        ans = max(ans,f[n][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一维数组优化"><a href="#一维数组优化" class="headerlink" title="一维数组优化"></a>一维数组优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 1010;</span><br><span class="line">int f[MAXN];</span><br><span class="line">int N,M;</span><br><span class="line">int V[MAXN],W[MAXN];</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;N,&amp;M);</span><br><span class="line">    for(int i = 1; i &lt;= N; i++) scanf(&quot;%d%d&quot;,&amp;V[i],&amp;W[i]);</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)</span><br><span class="line">        //从后往前推，保留i-1的状态</span><br><span class="line">        for(int j = M; j &gt;= V[i]; j--)&#123;</span><br><span class="line">            f[j] = max(f[j],f[j-V[i]]+W[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    printf(&quot;%d&quot;,f[M]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。</p><p>第 i 种物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M;</span><br><span class="line">const int MAXN = 1010;</span><br><span class="line">int f[MAXN][MAXN],V[MAXN],W[MAXN];</span><br><span class="line">//转移方程，f[i][j] = max&#123;f[i-1][j-k*V[i]+k*W[i]&#125;</span><br><span class="line">//含义：可以在之前选完后，选择当前的[M/V[i]]个，取价值最大的那个。</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;N,&amp;M);</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;V[i],&amp;W[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        for(int j = 1; j &lt;= M; j++)&#123;</span><br><span class="line">            for(int k = 0; k * V[i] &lt;= j; k++)&#123;</span><br><span class="line">                f[i][j] = max(f[i][j],f[i-1][j-k*V[i]]+k*W[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= M; i++)&#123;</span><br><span class="line">        ans = max(ans,f[N][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一维数组优化："><a href="#一维数组优化：" class="headerlink" title="一维数组优化："></a>一维数组优化：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 1010;</span><br><span class="line">int f[MAXN];</span><br><span class="line">int N,M;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;N,&amp;M);</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        int v,w;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;v,&amp;w);</span><br><span class="line">        //每一层考虑--&gt;尽可能选取多的第i个背包后，最大的价值，所以直接从当前层的状态转移，表示选择0,1,...,k个的背包之后的价值。</span><br><span class="line">        for(int j = v; j &lt;= M; j++)&#123;</span><br><span class="line">            f[j] = max(f[j],f[j-v]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,f[M]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包："><a href="#多重背包：" class="headerlink" title="多重背包："></a>多重背包：</h3><p>有 N 种物品和一个容量是 V 的背包。</p><p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 110;</span><br><span class="line">int dp[MAXN],N,M;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;N,&amp;M);</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        int v,w,s;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;v,&amp;w,&amp;s);</span><br><span class="line">        for(int j = M; j &gt;= v; j--)&#123;</span><br><span class="line">            //从1到s个背包都试着选一下。</span><br><span class="line">            for(int k = 1; k &lt;= s &amp;&amp; k*v &lt;= j; k++)&#123;</span><br><span class="line">                dp[j] = max(dp[j],dp[j-k*v]+k*w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,dp[M]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二进制思想优化：</p><p>因为每个背包可选s个，我们试着将其转化为0/1背包问题，把每个背包划分0~s种，去做0/1背包，发现问题的复杂度没有变，我们考虑每个物品都有选和不选两种情况，我们知道每一个数都可以有相应的二进制对应位作为2的幂相乘得到，所以我们将s拆分成二进制数位相乘。这样每一层做0/1背包，之前的结果没有浪费掉，是可以接着相加，并且最后得到s个，做到了从O(n)到O(logn)的优化。</p><p>这里有一个问题就是在log(s)时，如果s不是二的整数次幂，会计算到大于s的第一个整数次幂，这样结果就不对了，成了计算到了大于s的第一个整数次幂个数量。我们<strong>必须要将加到的数最大只会到s</strong>，这里有一个做法：先加到小于s的最大的二的整数次幂x，然后加上 s-x 就可以表示为 0~s这么多种方案了。举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 = 0+ 1 + 2 + 4 + 3</span><br><span class="line">0 ~ 7 = (0,1,2,4)的任意组合</span><br><span class="line">8 = 5+3 //(0~7中的5)</span><br><span class="line">9 = 6+3 //(0~7中的6)</span><br><span class="line">10 = 7+3 //(0~7中的7)</span><br><span class="line">并且求和只能取到10</span><br></pre></td></tr></table></figure><p>所以该方法成立。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 2e6+10;</span><br><span class="line">int dp[2020],V[MAXN],W[MAXN];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t = 0;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        int v,w,s;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        for(int k = 1; k &lt;= s; k *= 2)&#123;</span><br><span class="line">            V[t] = v*k;</span><br><span class="line">            W[t++] = w*k;</span><br><span class="line">            s -= k;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s &gt; 0) &#123;</span><br><span class="line">            V[t] = v*s;</span><br><span class="line">            W[t++] = w*s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0; i &lt; t ; i++)&#123;</span><br><span class="line">        for(int j = m; j &gt;= V[i]; j--)&#123;</span><br><span class="line">            dp[j] = max(dp[j],dp[j-V[i]]+W[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[m];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h3><p>有 N 种物品和一个容量是 V 的背包。</p><p>物品一共有三类：</p><p>第一类物品只能用1次（01背包）；<br>第二类物品可以用无限次（完全背包）；<br>第三类物品最多只能用 si 次（多重背包）；<br>每种体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p><ul><li>si=−1 表示第 i 种物品只能用1次；</li><li>si=0 表示第 i 种物品可以用无限次；</li><li>si&gt;0 表示第 i 种物品可以使用 si 次；</li></ul><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>其实只是0-1背包（多重背包）和完全背包的组合版<br>每件物品该用完全背包解就用完全背包解，该用01背包解就用01背包解，当然多重背包可以用二进制优化分解成01背包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int dp[1010];</span><br><span class="line">struct thing&#123;</span><br><span class="line">    int kind,v,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;thing&gt; things;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i = 0;i &lt; n; i++)&#123;</span><br><span class="line">        int v, w, s;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        if(s == -1) things.push_back(&#123;-1,v,w&#125;);</span><br><span class="line">        else if(s == 0) things.push_back(&#123;0,v,w&#125;);</span><br><span class="line">        else&#123;</span><br><span class="line">            for(int k = 1; k &lt;= s; k*=2)&#123;</span><br><span class="line">                s -= k;</span><br><span class="line">                things.push_back(&#123;-1,v*k,w*k&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            if(s &gt; 0) things.push_back(&#123;-1,v*s,w*s&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(auto thing : things)&#123;</span><br><span class="line">        if(thing.kind == -1)&#123;</span><br><span class="line">            for(int j = m; j &gt;= thing.v; j--)&#123;</span><br><span class="line">                dp[j] = max(dp[j],dp[j-thing.v]+thing.w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for(int j = thing.v; j &lt;= m; j++)&#123;</span><br><span class="line">                dp[j] = max(dp[j],dp[j-thing.v]+thing.w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[m];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>POJ-3614-Sunscreen</title>
      <link href="/2019/10/26/POJ-3614-Sunscreen/"/>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=3614" target="_blank" rel="noopener">POJ-3614-Sunscreen</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>To avoid unsightly burns while tanning, each of the C (1 ≤ C ≤ 2500) cows must cover her hide with sunscreen when they’re at the beach. Cow i has a minimum and maximum SPF rating (1 ≤ minSPFi ≤ 1,000; minSPFi ≤ maxSPFi ≤ 1,000) that will work. If the SPF rating is too low, the cow suffers sunburn; if the SPF rating is too high, the cow doesn’t tan at all……..</p><p>The cows have a picnic basket with L (1 ≤ L ≤ 2500) bottles of sunscreen lotion, each bottle i with an SPF rating SPFi (1 ≤ SPFi ≤ 1,000). Lotion bottle i can cover coveri cows with lotion. A cow may lotion from only one bottle.</p><p>What is the maximum number of cows that can protect themselves while tanning given the available lotions?</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><ul><li><p>Line 1: Two space-separated integers: C and L</p></li><li><p>Lines 2..C+1: Line i describes cow i’s lotion requires with two integers: minSPFi and maxSPFi</p></li><li><p>Lines C+2..C+L+1: Line i+C+1 describes a sunscreen lotion bottle i with space-separated integers: SPFi and coveri</p></li></ul><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>A single line with an integer that is the maximum number of cows that can be protected while tanning</p><h3 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">3 10</span><br><span class="line">2 5</span><br><span class="line">1 5</span><br><span class="line">6 2</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure><h3 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>有C头牛，每个牛Ci在一个给定的区间上需要涂防晒霜，有L种防晒霜，给出每个防晒霜适合的数值SPF[i]和个数cover[i]，求能最多满足牛的个数。</p><h3 id="贪心策略："><a href="#贪心策略：" class="headerlink" title="贪心策略："></a>贪心策略：</h3><p>按区间的开始位置递减排序，依次考虑每头牛。<br>对于每头牛，选取满足在此区间内最大的防晒霜。</p><h3 id="Solution1（暴力版）："><a href="#Solution1（暴力版）：" class="headerlink" title="Solution1（暴力版）："></a>Solution1（暴力版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">const int MAXN = 5000+10;</span><br><span class="line">int C,L;</span><br><span class="line">PII p[MAXN];</span><br><span class="line">PII q[MAXN];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;C,&amp;L);</span><br><span class="line">    for(int i = 0; i &lt; C; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;p[i].first,&amp;p[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p,p+C);</span><br><span class="line">    for(int i = 0; i &lt; L; i++)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">        q[i].first = a;</span><br><span class="line">        q[i].second = b;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q,q+L);</span><br><span class="line">//从开始位置大到小考察每头牛。</span><br><span class="line">    for(int i = C-1; i &gt;= 0; i--)&#123;</span><br><span class="line">//同样，对于每头牛，考察在该牛区间内最右的防晒霜。</span><br><span class="line">        for(int j = L-1; j &gt;= 0; j--)&#123;</span><br><span class="line">            if(q[j].second &gt; 0 &amp;&amp; q[j].first &gt;= p[i].first &amp;&amp; q[j].first &lt;= p[i].second)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                q[j].second--;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Solution2（平衡树版）："><a href="#Solution2（平衡树版）：" class="headerlink" title="Solution2（平衡树版）："></a>Solution2（平衡树版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 2510;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">int N,M;</span><br><span class="line">PII cows[MAXN];</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt;M;</span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        cin &gt;&gt; cows[i].first &gt;&gt; cows[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(cows,cows+N);</span><br><span class="line">    map&lt;int,int&gt; spfa;</span><br><span class="line">    for(int i = 0; i &lt; M; i++)&#123;</span><br><span class="line">        int spa,cover;</span><br><span class="line">        cin &gt;&gt; spa &gt;&gt; cover;</span><br><span class="line">        spfa[spa] += cover;</span><br><span class="line">    &#125;</span><br><span class="line">    spfa[0] = spfa[1001] = N;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = N-1; i &gt;= 0; i--)&#123;</span><br><span class="line">        map&lt;int,int&gt;::iterator it = spfa.upper_bound(cows[i].second);</span><br><span class="line">        --it;</span><br><span class="line">        if(cows[i].first &lt;= it-&gt;first &amp;&amp; cows[i].second &gt;= it-&gt;first)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            if(-- it-&gt;second == 0) spfa.erase(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>AcWin-135-最大子序和</title>
      <link href="/2019/10/26/AcWin-135-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
      <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/description/137/" target="_blank" rel="noopener">AcWing 135. 最大子序和 </a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个长度为n的整数序列，从中找出一段长度不超过m的连续子序列，使得子序列中所有数的和最大。</p><p>输入格式<br>第一行输入两个整数n,m。</p><p>第二行输入n个数，代表长度为n的整数序列。</p><p>同一行数之间用空格隔开。</p><p>输出格式<br>输出一个整数，代表该序列的最大子序和。</p><p>数据范围<br>1≤n,m≤300000</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入样例：</span><br><span class="line">6 4</span><br><span class="line">1 -3 5 1 -2 3</span><br><span class="line">输出样例：</span><br><span class="line">7</span><br></pre></td></tr></table></figure><hr><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>求一个区间长度为M的序列和可以用前缀和相减的形式来得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k = sum[i]- sum[i-M]</span><br></pre></td></tr></table></figure><p>而要求当前区间P内的最大值，可以找到该区间（sum[i-1]–sum[i-m]）内的最小值，用sum[i]减去该值，得到以sum[i]为终点的区间的最大值，对于每个区间，都求得一个最大值，再到这些之内取最大即为答案。</p><p>所以现在的问题变为：给定一个区间，如何找出给区间内的最小值。</p><p>如果暴力求，会使总的复杂度为O(N2)，不符合要求。<br>再看一下要解决的问题，我们想到使用单调队列，可以在线求出一组序列的最值，所以我们使用一个大小为M的队列来维护最值。</p><p>这样总的复杂度就为线性的了。</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 1e6+10;</span><br><span class="line">long long a[MAXN],sum[MAXN],ans = -1e10;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    deque&lt;int&gt; q;</span><br><span class="line">    int N,M;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    for(int i = 0; i &lt; N; i++) cin &gt;&gt; a[i];</span><br><span class="line">    for(int i = 1; i &lt;= N; i++) sum[i] = sum[i-1] + a[i-1]; //前缀和</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        while(q.size() &amp;&amp; q.front() &lt; i - M) q.pop_front(); //超出窗口范围，清除</span><br><span class="line">        ans = max(ans, sum[i]-sum[q.front()]); //更新值</span><br><span class="line">        while(q.size() &amp;&amp; sum[q.back()] &gt; sum[i]) q.pop_back(); //维护单调性质</span><br><span class="line">        q.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>POJ-Telephon-Lines(二分+最短路)</title>
      <link href="/2019/10/09/POJ-Telephon-Lines(%E4%BA%8C%E5%88%86+%E6%9C%80%E7%9F%AD%E8%B7%AF)/"/>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=3662/" target="_blank" rel="noopener">POJ-Telephone Lines</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>Farmer John wants to set up a telephone line at his farm. Unfortunately, the phone company is uncooperative, so he needs to pay for some of the cables required to connect his farm to the phone system.</p><p>There are N (1 ≤ N ≤ 1,000) forlorn telephone poles conveniently numbered 1..N that are scattered around Farmer John’s property; no cables connect any them. A total of P (1 ≤ P ≤ 10,000) pairs of poles can be connected by a cable; the rest are too far apart.</p><p>The i-th cable can connect the two distinct poles Ai and Bi, with length Li (1 ≤ Li ≤ 1,000,000) units if used. The input data set never names any {Ai, Bi} pair more than once. Pole 1 is already connected to the phone system, and pole N is at the farm. Poles 1 and N need to be connected by a path of cables; the rest of the poles might be used or might not be used.</p><p>As it turns out, the phone company is willing to provide Farmer John with K (0 ≤ K &lt; N) lengths of cable for free. Beyond that he will have to pay a price equal to the length of the longest remaining cable he requires (each pair of poles is connected with a separate cable), or 0 if he does not need any additional cables.</p><p>Determine the minimum amount that Farmer John must pay.</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><ul><li>Line 1: Three space-separated integers: N, P, and K</li><li>Lines 2..P+1: Line i+1 contains the three space-separated integers: Ai, Bi, and Li</li></ul><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><ul><li>Line 1: A single integer, the minimum amount Farmer John can pay. If it is impossible to connect the farm to the phone company, print -1.</li></ul><h3 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">5 7 1</span><br><span class="line">1 2 5</span><br><span class="line">3 1 4</span><br><span class="line">2 4 8</span><br><span class="line">3 2 3</span><br><span class="line">5 2 9</span><br><span class="line">3 4 7</span><br><span class="line">4 5 6</span><br></pre></td></tr></table></figure><h3 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>一电话公司要链接编号1和N的电话，中间可能需要架设多条电话线，线缆厂商可以免费给电话公司铺设k条电缆，超过k条之后，要按其余的线缆中最长的进行相应收费费用与长度相同，求电话公司需要付的最小费用。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>其实就是求无向图中，从1到N中，使最多可以“宽恕”k条最长边之后最长的边的长度尽可能小的路径。</p><p>单独求这样一个问题好像很复杂，我们稍加分析发现，答案一定在给定的边长、零或者不存在这样的路径这三种情况中，我们先假定一个答案，用这个答案去试探从1-N的路径有没有符合条件的。</p><p>具体的判断就是求一条大于答案的边长数最小的一条路径。可以使用最短路来求，松弛条件根据到当前边的超过答案的数量中选择更小的一条边。我们最后判断到达N后其数量是否超过k，就能判断这是否是一条符合条件的边。</p><p>然后将存放所有可能是答案的数组排序后进行二分。</p><p>这里求“最短路”用了两个最短路模板：</p><h3 id="Solution1（Dijkstra）："><a href="#Solution1（Dijkstra）：" class="headerlink" title="Solution1（Dijkstra）："></a>Solution1（Dijkstra）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Date: 2019-10-07 18:55:30</span><br><span class="line"> * @LastEditors: BeckoninGshy</span><br><span class="line"> * @LastEditTime: 2019-10-08 22:59:49</span><br><span class="line"> */</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 10000+10;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">int n,p,k;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int b,ca;</span><br><span class="line">    node(int _b,int _ca):b(_b),ca(_ca)&#123;&#125;</span><br><span class="line">    node()&#123;&#125;</span><br><span class="line">    bool operator&lt;(const node &amp;q)const&#123;</span><br><span class="line">        return ca &gt; q.ca;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; V[MAXN];</span><br><span class="line">int dis[MAXN]; //dis存超过目标值x的电话线条数。</span><br><span class="line">int vis[MAXN];</span><br><span class="line">int cost[MAXN];</span><br><span class="line">int Dijkstra(int x)&#123;</span><br><span class="line">    memset(dis,INF,sizeof(dis));</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    dis[1] = 0;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    q.push(node(1,dis[1]));</span><br><span class="line">    node temp;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        temp = q.top(); q.pop();</span><br><span class="line">        int u = temp.b;</span><br><span class="line">        if(vis[u])continue;</span><br><span class="line">        vis[u] = 1;</span><br><span class="line">        for(int i = 0; i &lt; V[u].size(); i++)&#123;</span><br><span class="line">            int v = V[u][i].b;</span><br><span class="line">            int c = V[u][i].ca;</span><br><span class="line">            c = c &gt; x ? 1 : 0;</span><br><span class="line">            //更新到当前结点的超过x的条数</span><br><span class="line">            if(!vis[v] &amp;&amp; dis[v] &gt; dis[u] + c)&#123;</span><br><span class="line">                </span><br><span class="line">                dis[v] = dis[u] + c;</span><br><span class="line">                q.push(node(v,dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //是</span><br><span class="line">    return dis[n]&lt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;p,&amp;k);</span><br><span class="line">    for(int i = 0; i &lt; p; i++)&#123;</span><br><span class="line">        int a,b,c;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        V[a].push_back(node(b,c));</span><br><span class="line">        V[b].push_back(node(a,c));</span><br><span class="line">        cost[i+1] = c; </span><br><span class="line">    &#125;</span><br><span class="line">    //按长度进行二分，根据超过该长度的个数是否超过k来确定边界。</span><br><span class="line">    sort(cost+1,cost+1+p);</span><br><span class="line">    if(!Dijkstra(cost[p]))&#123;</span><br><span class="line">        printf(&quot;-1\\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //答案有可能是0，所以从0开始。</span><br><span class="line">    int l = 0, r = p-1;</span><br><span class="line">    while(l &lt; r)&#123;</span><br><span class="line">        int mid = l+r&gt;&gt;1;</span><br><span class="line">        if(Dijkstra(cost[mid])) r = mid;</span><br><span class="line">        else l = mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,cost[l]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Solution2（SPFA）："><a href="#Solution2（SPFA）：" class="headerlink" title="Solution2（SPFA）："></a>Solution2（SPFA）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Date: 2019-10-07 18:55:30</span><br><span class="line"> * @LastEditors: BeckoninGshy</span><br><span class="line"> * @LastEditTime: 2019-10-09 19:32:17</span><br><span class="line"> */</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 10000+10;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">int n,p,k;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int b,ca;</span><br><span class="line">    node(int _b,int _ca):b(_b),ca(_ca)&#123;&#125;</span><br><span class="line">    node()&#123;&#125;</span><br><span class="line">    bool operator&lt;(const node &amp;q)const&#123;</span><br><span class="line">        return ca &gt; q.ca;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; V[MAXN];</span><br><span class="line">int dis[MAXN]; //dis存超过目标值x的电话线条数。</span><br><span class="line">int vis[MAXN];</span><br><span class="line">int inq[MAXN];</span><br><span class="line">int cost[MAXN];</span><br><span class="line">int SPFA(int x)&#123;</span><br><span class="line">    memset(dis,INF,sizeof(dis));</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    memset(inq,0,sizeof(inq));</span><br><span class="line">    </span><br><span class="line">    dis[1] = 0;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    q.push(1);</span><br><span class="line">    node temp;</span><br><span class="line">    inq[1] = 1;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u = q.front(); q.pop();</span><br><span class="line">        inq[u] = false;</span><br><span class="line">        for(int i = 0; i &lt; V[u].size(); i++)&#123;</span><br><span class="line">            int v = V[u][i].b;</span><br><span class="line">            int c = V[u][i].ca;</span><br><span class="line">            c = c &gt; x ? 1 : 0;</span><br><span class="line">            //更新到当前结点的超过x的条数</span><br><span class="line">            if(dis[v] &gt; dis[u] + c)&#123;</span><br><span class="line">                </span><br><span class="line">                dis[v] = dis[u] + c;</span><br><span class="line">                if(!inq[v])&#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    inq[v] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //是</span><br><span class="line">    return dis[n]&lt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;p,&amp;k);</span><br><span class="line">    for(int i = 0; i &lt; p; i++)&#123;</span><br><span class="line">        int a,b,c;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        V[a].push_back(node(b,c));</span><br><span class="line">        V[b].push_back(node(a,c));</span><br><span class="line">        cost[i+1] = c; </span><br><span class="line">    &#125;</span><br><span class="line">    //按长度进行二分，根据超过该长度的个数是否超过k来确定边界。</span><br><span class="line">    sort(cost+1,cost+1+p);</span><br><span class="line">    if(!SPFA(cost[p]))&#123;</span><br><span class="line">        printf(&quot;-1\\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //答案有可能是0，所以从0开始。</span><br><span class="line">    int l = 0, r = p-1;</span><br><span class="line">    while(l &lt; r)&#123;</span><br><span class="line">        int mid = l+r&gt;&gt;1;</span><br><span class="line">        if(SPFA(cost[mid])) r = mid;</span><br><span class="line">        else l = mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,cost[l]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>POJ-2010-Mo-Universit--Financia-Aid（优先队列或二分）</title>
      <link href="/2019/10/07/POJ-2010-Mo-Universit--Financia-Aid%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E6%88%96%E4%BA%8C%E5%88%86%EF%BC%89/"/>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=2010" target="_blank" rel="noopener">POJ-2010-Moo University - Financial Aid</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>Bessie noted that although humans have many universities they can attend, cows have none. To remedy this problem, she and her fellow cows formed a new university called The University of Wisconsin-Farmside,”Moo U” for short.</p><p>Not wishing to admit dumber-than-average cows, the founders created an incredibly precise admission exam called the Cow Scholastic Aptitude Test (CSAT) that yields scores in the range 1..2,000,000,000.</p><p>Moo U is very expensive to attend; not all calves can afford it.In fact, most calves need some sort of financial aid (0 &lt;= aid &lt;=100,000). The government does not provide scholarships to calves,so all the money must come from the university’s limited fund (whose total money is F, 0 &lt;= F &lt;= 2,000,000,000).</p><p>Worse still, Moo U only has classrooms for an odd number N (1 &lt;= N &lt;= 19,999) of the C (N &lt;= C &lt;= 100,000) calves who have applied.Bessie wants to admit exactly N calves in order to maximize educational opportunity. She still wants the median CSAT score of the admitted calves to be as high as possible.</p><p>Recall that the median of a set of integers whose size is odd is the middle value when they are sorted. For example, the median of the set {3, 8, 9, 7, 5} is 7, as there are exactly two values above 7 and exactly two values below it.</p><p>Given the score and required financial aid for each calf that applies, the total number of calves to accept, and the total amount of money Bessie has for financial aid, determine the maximum median score Bessie can obtain by carefully admitting an optimal set of calves.</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><ul><li><p>Line 1: Three space-separated integers N, C, and F</p></li><li><p>Lines 2..C+1: Two space-separated integers per line. The first is the calf’s CSAT score; the second integer is the required amount of financial aid the calf needs</p></li></ul><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><ul><li>Line 1: A single integer, the maximum median score that Bessie can achieve. If there is insufficient money to admit N calves,output -1.</li></ul><h3 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 5 70</span><br><span class="line">30 25</span><br><span class="line">50 21</span><br><span class="line">20 20</span><br><span class="line">5 18</span><br><span class="line">35 30</span><br></pre></td></tr></table></figure><h3 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35</span><br></pre></td></tr></table></figure><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><p>Sample output:If Bessie accepts the calves with CSAT scores of 5, 35, and 50, the median is 35. The total financial aid required is 18 + 30 + 21 = 69 &lt;= 70. </p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>奶牛大学招收N名学生（奇数），有C名候选学生，该大学可以承受最多F的贷款，求能招收的学生中，中位数尽可能的大，如果没有满足条件的学生，输出-1。</p><h3 id="思路1（优先队列）："><a href="#思路1（优先队列）：" class="headerlink" title="思路1（优先队列）："></a>思路1（优先队列）：</h3><p>以学生成绩排序，然后以每个学生为中位数，寻找比他成绩低的学生中尽可能贷款少的N/2个学生，和比他成绩高的学生中尽可能贷款少的N/2个学生。结果就是满足:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aid：cur_i+lower_i+upper_i &lt;= F</span><br></pre></td></tr></table></figure><p>中最大的那个。</p><p>难度就是如何保持尽可能少的贷款。</p><p>这里选择维持一个长度始终为N/2长度的优先队列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Date: 2019-10-06 17:36:17</span><br><span class="line"> * @LastEditors: BeckoninGshy</span><br><span class="line"> * @LastEditTime: 2019-10-07 16:04:57</span><br><span class="line"> */</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 1e5+10;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line"></span><br><span class="line">PII arr[MAXN];</span><br><span class="line">int M,N,S;</span><br><span class="line">int lowa[MAXN],upa[MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;M,&amp;N,&amp;S);</span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;arr[i].first,&amp;arr[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    int half = M/2;</span><br><span class="line">    sort(arr,arr+N);</span><br><span class="line">    memset(lowa,INF,sizeof(lowa));</span><br><span class="line">    memset(upa,INF,sizeof(upa));</span><br><span class="line">    priority_queue&lt;int&gt; q;</span><br><span class="line">    //确定以每个人为中位数， 比自己分数低的人的最小aid总和</span><br><span class="line">    int total = 0;</span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        if(q.size() == half) lowa[i] = total;</span><br><span class="line">        total += arr[i].second;</span><br><span class="line">        q.push(arr[i].second);</span><br><span class="line">        if(q.size() &gt; half)&#123;</span><br><span class="line">            total -= q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(q.size()) q.pop();</span><br><span class="line">    total = 0;</span><br><span class="line">    //确定以每个人为中位数， 比自己分数高的人的最小aid总和</span><br><span class="line">    for(int i = N-1; i &gt;= 0; i--)&#123;</span><br><span class="line">        if(q.size() == half) upa[i] = total;</span><br><span class="line">        q.push(arr[i].second);</span><br><span class="line">        total += arr[i].second;</span><br><span class="line">        if(q.size() &gt; half)&#123;</span><br><span class="line">            total -= q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = -1;</span><br><span class="line">    //从后往前寻找第一个满足条件的</span><br><span class="line">    for(int i = N-1; i &gt;= 0; i--)&#123;</span><br><span class="line">        if(arr[i].second + lowa[i] + upa[i] &lt;= S) &#123;ans = arr[i].first;break;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2（二分）："><a href="#思路2（二分）：" class="headerlink" title="思路2（二分）："></a>思路2（二分）：</h3><p>先对成绩排序，按成绩进行二分，对是否满足是中位数和sum &lt;= F两个性质进行判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Date: 2019-10-06 17:36:17</span><br><span class="line"> * @LastEditors: BeckoninGshy</span><br><span class="line"> * @LastEditTime: 2019-10-07 17:18:16</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 1e5+10;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line"></span><br><span class="line">struct cow&#123;</span><br><span class="line">    int csat,aid;</span><br><span class="line">    bool operator &lt;(const cow &amp;q)const&#123;</span><br><span class="line">        if(csat == q.csat) return aid &lt; q.aid;</span><br><span class="line">        return csat &lt; q.csat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;cows[MAXN];</span><br><span class="line">struct n&#123;</span><br><span class="line">    int index,aid;</span><br><span class="line">    bool operator &lt;(const n &amp;q)const&#123;</span><br><span class="line">        return aid &lt; q.aid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[MAXN];</span><br><span class="line">int M,N,S,half,ans = -1;</span><br><span class="line">int aid[MAXN];</span><br><span class="line"></span><br><span class="line">int check(int x)&#123;</span><br><span class="line">    int l = 0, r = 0, sum = cows[x].aid;</span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        //在原位置的左边，且符合规定</span><br><span class="line">        if(l &lt; half &amp;&amp; node[i].index &lt; x &amp;&amp; sum + node[i].aid &lt;= S)&#123;</span><br><span class="line">            l++;</span><br><span class="line">            sum += node[i].aid;</span><br><span class="line">        //在原位置的右边，且符合规定</span><br><span class="line">        &#125;else if(r &lt; half &amp;&amp; node[i].index &gt; x &amp;&amp; sum + node[i].aid &lt;= S)&#123;</span><br><span class="line">            r++;</span><br><span class="line">            sum += node[i].aid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //都到不了half，说明无法满足小于等于S。</span><br><span class="line">    if(l &lt; half &amp;&amp; r &lt; half) return -1;</span><br><span class="line">    if(l &lt; half) return 1;</span><br><span class="line">    else if(r &lt; half) return 0;</span><br><span class="line">    //l = r = half 找到了一个符合条件的，更新答案，继续寻找后面。</span><br><span class="line">    ans = cows[x].csat;</span><br><span class="line">    return 1;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;M,&amp;N,&amp;S);</span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;cows[i].csat,&amp;cows[i].aid);</span><br><span class="line">    &#125;</span><br><span class="line">    half = M/2;</span><br><span class="line">    sort(cows,cows+N);//先按分数排序</span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        node[i].index = i; //记录位置关系</span><br><span class="line">        node[i].aid = cows[i].aid;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node,node+N); //排序是为了寻找尽可能小的aid</span><br><span class="line">    int l = 0, r = N-1;</span><br><span class="line">    while(l &lt; r)&#123;</span><br><span class="line">        int mid = l+r+1&gt;&gt;1;</span><br><span class="line">        //试探中位数。</span><br><span class="line">        int f = check(mid);</span><br><span class="line">        if(f == 1) l = mid;</span><br><span class="line">        else if(f == 0) r = mid-1;</span><br><span class="line">        else break;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>POJ-3579-Median(二分套二分)</title>
      <link href="/2019/10/05/POJ-3579-Median(%E4%BA%8C%E5%88%86%E5%A5%97%E4%BA%8C%E5%88%86)/"/>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=3579" target="_blank" rel="noopener">POJ-3579-Median</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>Given N numbers, X1, X2, … , XN, let us calculate the difference of every pair of numbers: ∣Xi - Xj∣ (1 ≤ i ＜ j ≤ N). We can get C(N,2) differences through this work, and now your task is to find the median of the differences as quickly as you can!</p><p>Note in this problem, the median is defined as the (m/2)-th  smallest number if m,the amount of the differences, is even. For example, you have to find the third smallest one in the case of m = 6.</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><p>The input consists of several test cases.<br>In each test case, N will be given in the first line. Then N numbers are given, representing X1, X2, … , XN, ( Xi ≤ 1,000,000,000  3 ≤ N ≤ 1,00,000 )</p><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>For each test case, output the median in a separate line.</p><h3 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 3 2 4</span><br><span class="line">3</span><br><span class="line">1 10 2</span><br></pre></td></tr></table></figure><h3 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定N个数，求每两个数的差的绝对值一共C(N,2)个，排序后的中位数。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>首先对于差的绝对值，我们只需要预先对数组进行排序，作后面对前面的差就不会出现负数。</p><p>我们考虑二分来解决该问题。答案是排序后的中位数，具有单调性，所以可以使用二分。我们先找到一个目标值，用这个目标值去判断是否为要求的中位数。</p><p>如何判断该数是否满足条件呢？<br>如果枚举全部这C(N,2)个数需要O(N2)的复杂度，超出了题目的要求，所以要寻找新的方案。我们已经将原数组排好序了，以每一项开始到数组最后，我们二分的寻找这里的所有的关系（i与i+1,i+2,…,N-1）中，满足：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[j] - arr[i] &lt;= x</span><br></pre></td></tr></table></figure><p>的一共有几项。</p><p>统计出项数与中位数作比较，就可以判断目标值是否满足条件。</p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Date: 2019-10-05 13:59:05</span><br><span class="line"> * @LastEditors: BeckoninGshy</span><br><span class="line"> * @LastEditTime: 2019-10-05 14:48:00</span><br><span class="line"> */</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN = 1e5+10;</span><br><span class="line"></span><br><span class="line">int N;</span><br><span class="line">int arr[MAXN];</span><br><span class="line"></span><br><span class="line">bool check(int x)&#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    int M = N*(N-1)/2;</span><br><span class="line">    M = (M+1)/2;</span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        int l = i, r = N-1;</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            int mid = l + r + 1 &gt;&gt; 1;</span><br><span class="line">            if(arr[mid] - arr[i] &lt;= x) l = mid;</span><br><span class="line">            else r = mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt += l-i;</span><br><span class="line">        // arr[mid] - arr[i] &lt;= x -----&gt; arr[mid] &lt;= arr[i]+x</span><br><span class="line">        // 所以找arr[i]+x 的 upper_bound。</span><br><span class="line">        // (upper_bound(arr,arr+N,arr[i]+x)-arr)-1 长度</span><br><span class="line">        // (upper_bound(arr,arr+N,arr[i]+x)-arr)-i-1 //减去偏移量</span><br><span class="line">        // cnt += (upper_bound(arr,arr+N,arr[i]+x)-arr)-i-1;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt &gt;= M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); </span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;N)!=EOF &amp;&amp; N)&#123;</span><br><span class="line">        for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr,arr+N);</span><br><span class="line">        int l = 0, r = arr[N-1];</span><br><span class="line">        //对结果进行二分</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            int mid = l+r&gt;&gt;1;</span><br><span class="line">            // 检查该结果是否大于等于总数的一半，</span><br><span class="line">            if(check(mid)) r = mid;</span><br><span class="line">            else l = mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\\n&quot;,l);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>POJ-2976-Droppin-tests</title>
      <link href="/2019/09/29/POJ-2976-Droppin-tests/"/>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=2976" target="_blank" rel="noopener">POJ-2976-Dropping tests</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>In a certain course, you take n tests. If you get ai out of bi questions correct on test i, your cumulative average is defined to be</p><p><img src="https://note.youdao.com/favicon.ico" alt="image"></p><p>Given your test scores and a positive integer k, determine how high you can make your cumulative average if you are allowed to drop any k of your test scores.</p><p>Suppose you take 3 tests with scores of 5/5, 0/1, and 2/6. Without dropping any tests, your cumulative average is</p><p><img src="https://note.youdao.com/favicon.ico" alt="image"></p><p>However, if you drop the third test, your cumulative average becomes</p><p><img src="https://note.youdao.com/favicon.ico" alt="image"></p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><p>The input test file will contain multiple test cases, each containing exactly three lines. The first line contains two integers, 1 ≤ n ≤ 1000 and 0 ≤ k &lt; n. The second line contains n integers indicating ai for all i. The third line contains n positive integers indicating bi for all i. It is guaranteed that 0 ≤ ai ≤ bi ≤ 1, 000, 000, 000. The end-of-file is marked by a test case with n = k = 0 and should not be processed.</p><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>For each test case, write a single line with the highest cumulative average possible after dropping k of the given test scores. The average should be rounded to the nearest integer.</p><h3 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 1</span><br><span class="line">5 0 2</span><br><span class="line">5 1 6</span><br><span class="line">4 2</span><br><span class="line">1 2 7 9</span><br><span class="line">5 6 7 9</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h3 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">83</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><p>To avoid ambiguities due to rounding errors, the judge tests have been constructed so that all answers are at least 0.001 away from a decision boundary (i.e., you can assume that the average is never 83.4997).</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>有N个考试，每个考试有ai和bi两个值，最后成绩由上面的公式求得。幸运的是，可以放弃K个科目，求最大化最后的成绩。(输出乘100后四舍五入的结果)</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>由题意可知当，当n-k个科目组成最优解时，再增加别的科目，解一定不如原来的解，放弃掉k个科目是最好的方案。</p><p>于是，题目就变成了最小化平均值的问题，另外在注意下取整时的四舍五入就好了。</p><h5 id="最小化平均值"><a href="#最小化平均值" class="headerlink" title="最小化平均值:"></a>最小化平均值:</h5><p>有n个物品的重量和价值分别为wi和vi，从中选择k个物品使得单位重量的价值最大。</p><p>对于这个问题，我们可以用二分搜索解决，先来看看判断条件：<br>设最大值为x，则需要满足 ∑vi / ∑wi &gt;=x，把不等式进行变形，就得到了 ∑ ( vi - x <em> wi )&gt;=0，于是判断就成了，对 vi-x</em>wi 的值进行排序之后贪心进行选择，判断前n-k个的和是否不小于0。判断的复杂度是O（nlogn）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Date: 2019-09-28 16:40:15</span><br><span class="line"> * @LastEditors: BeckoninGshy</span><br><span class="line"> * @LastEditTime: 2019-09-29 18:14:27</span><br><span class="line"> */</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 1000+10;</span><br><span class="line">int n,k;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">&#125;num[MAXN];</span><br><span class="line"></span><br><span class="line">double f[MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool check(double x)&#123;</span><br><span class="line">    for(int i = 0; i &lt; n; i++) f[i] = num[i].a - x*num[i].b;</span><br><span class="line">    sort(f,f+n);</span><br><span class="line">    double sum = 0;</span><br><span class="line">    for(int i = 0; i &lt;n-k; i++) sum += f[n-1-i];</span><br><span class="line">    return sum &gt;= 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;k)!= EOF &amp;&amp; n+k)&#123;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;num[i].a);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;num[i].b);</span><br><span class="line">        &#125;</span><br><span class="line">        double l = 0, r = 1e9;</span><br><span class="line">        for(int i = 0; i &lt; 100; i++)&#123;</span><br><span class="line">            double mid = (l+r)/2;</span><br><span class="line">            if(check(mid)) l = mid;</span><br><span class="line">            else r = mid;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">printf(&quot;%d\\n&quot;, int(l*100+0.5));</span><br><span class="line"></span><br><span class="line">        // int ans = 100 * (l+0.005);</span><br><span class="line">// printf(&quot;%d\\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>POJ-3045-Co-Acrobats</title>
      <link href="/2019/09/28/POJ-3045-Co-Acrobats/"/>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=3045" target="_blank" rel="noopener">Cow Acrobats</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>Farmer John’s N (1 &lt;= N &lt;= 50,000) cows (numbered 1..N) are planning to run away and join the circus. Their hoofed feet prevent them from tightrope walking and swinging from the trapeze (and their last attempt at firing a cow out of a cannon met with a dismal failure). Thus, they have decided to practice performing acrobatic stunts.</p><p>The cows aren’t terribly creative and have only come up with one acrobatic stunt: standing on top of each other to form a vertical stack of some height. The cows are trying to figure out the order in which they should arrange themselves ithin this stack.</p><p>Each of the N cows has an associated weight (1 &lt;= W_i &lt;= 10,000) and strength (1 &lt;= S_i &lt;= 1,000,000,000). The risk of a cow collapsing is equal to the combined weight of all cows on top of her (not including her own weight, of course) minus her strength (so that a stronger cow has a lower risk). Your task is to determine an ordering of the cows that minimizes the greatest risk of collapse for any of the cows.</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><ul><li><p>Line 1: A single line with the integer N.</p></li><li><p>Lines 2..N+1: Line i+1 describes cow i with two space-separated integers, W_i and S_i.</p></li></ul><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><ul><li>Line 1: A single integer, giving the largest risk of all the cows in any optimal ordering that minimizes the risk.</li></ul><h3 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">10 3</span><br><span class="line">2 5</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure><h3 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><p>OUTPUT DETAILS:</p><p>Put the cow with weight 10 on the bottom. She will carry the other two cows, so the risk of her collapsing is 2+3-3=2. The other cows have lower risk of collapsing.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>有N头牛，每个牛有一定的重量w和力量s，将这N头牛叠罗汉，每头牛有一个风险值，为它背上所有牛的重量减去他的力量。求最大风险值，并要求最大风险值尽可能小。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>该题就是要找到一个最优排列，让最大风险值尽可能小，显然的，重的牛应该尽可能的安排在下方，同样，力气大的牛也应该尽可能安排在下方。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论:"></a>结论:</h4><h5 id="将力量与重量之和从小到大排列。"><a href="#将力量与重量之和从小到大排列。" class="headerlink" title="将力量与重量之和从小到大排列。"></a>将力量与重量之和从小到大排列。</h5><h4 id="证明一："><a href="#证明一：" class="headerlink" title="证明一："></a>证明一：</h4><p>对于每头牛而言，将它与它上面的牛作为一个整体，总的重量为sum_w，则该牛的风险值为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(sum_w-w-s)=(sum_w-(w+s))</span><br></pre></td></tr></table></figure><p>我们要想取到最优解，就要sum_w-(w+s)的值最小，w+s就应该最大，所以w+s越大越应该在下面。</p><h4 id="证明二："><a href="#证明二：" class="headerlink" title="证明二："></a>证明二：</h4><p>假设当前的排列是最优的。任意位置上有第一头牛和第二头牛，第一头牛在第二头牛的上面，第一头牛上面的重量总和为sum，第一头牛和第二头牛的重量和力量分别为w1、s1、w2、s2，可以知道两头牛的危险值分别为 a = sum-s1, b = sum+w1-s2。<br>现在调换两头牛的位置，则a1 = sum+w1-s1, b1 = sum-s2。<br>因为之前是最优解，可得：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum+w2-s1 &gt;= sum+w1-s2</span><br><span class="line">w2-s1 &gt;= w1-s2</span><br></pre></td></tr></table></figure><p>移项可得：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w2+s2 &gt;= w1+s1</span><br></pre></td></tr></table></figure><p>所以重量与力量和越大越在下方。</p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Date: 2019-09-27 23:11:05</span><br><span class="line"> * @LastEditors: BeckoninGshy</span><br><span class="line"> * @LastEditTime: 2019-09-28 11:43:09</span><br><span class="line"> */</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN = 5e4+10;</span><br><span class="line">int N;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">    int w,s;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"></span><br><span class="line">bool cmp(node a, node b)&#123;</span><br><span class="line">    return a.s+a.w &gt; b.s+b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;N);</span><br><span class="line">    long long sum = 0;</span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;a[i].w,&amp;a[i].s);</span><br><span class="line">        sum += a[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,a+N,cmp);</span><br><span class="line">    long long ans = -0x3f3f3f;</span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        sum -= a[i].w;</span><br><span class="line">        ans = max(ans,sum-a[i].s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;%lld\\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>POJ-3276-Fac-Th-Righ-Way</title>
      <link href="/2019/09/17/POJ-3276-Fac-Th-Righ-Way/"/>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=3276" target="_blank" rel="noopener">POJ-3276-Face The Right Way</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>Farmer John has arranged his N (1 ≤ N ≤ 5,000) cows in a row and many of them are facing forward, like good cows. Some of them are facing backward, though, and he needs them all to face forward to make his life perfect.</p><p>Fortunately, FJ recently bought an automatic cow turning machine. Since he purchased the discount model, it must be irrevocably preset to turn K (1 ≤ K ≤ N) cows at once, and it can only turn cows that are all standing next to each other in line. Each time the machine is used, it reverses the facing direction of a contiguous group of K cows in the line (one cannot use it on fewer than K cows, e.g., at the either end of the line of cows). Each cow remains in the same <em>location</em> as before, but ends up facing the <em>opposite direction</em>. A cow that starts out facing forward will be turned backward by the machine and vice-versa.</p><p>Because FJ must pick a single, never-changing value of K, please help him determine the minimum value of K that minimizes the number of operations required by the machine to make all the cows face forward. Also determine M, the minimum number of machine operations required to get all the cows facing forward using that value of K.</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><p>Line 1: A single integer: N<br>Lines 2..N+1: Line i+1 contains a single character, F or B, indicating whether cow i is facing forward or backward.</p><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>Line 1: Two space-separated integers: K and M</p><h3 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">B</span><br><span class="line">B</span><br><span class="line">F</span><br><span class="line">B</span><br><span class="line">F</span><br><span class="line">B</span><br><span class="line">B</span><br></pre></td></tr></table></figure><h3 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br></pre></td></tr></table></figure><h3 id="暗示："><a href="#暗示：" class="headerlink" title="暗示："></a>暗示：</h3><p>For K = 3, the machine must be operated three times: turn cows (1,2,3), (3,4,5), and finally (5,6,7)</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>有N头牛，牛要么朝前要么朝后，一次操作只可以翻转区间内的所有牛，问最小的翻转次数和相应最小的翻转区间。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>首先，这是一个开关问题，一般性的开关问题具有两个性质：</p><ul><li><p>切换状态的顺序对结果不影响。</p></li><li><p>一个开关按偶数次等于不按。</p></li></ul><p>解决这个问题光有这两性质还不够，我们先求如果知道了区间长度K，如何求最小翻转次数M。</p><p>我们先选择考虑最左端的牛，如果该牛朝向前，则不需要翻转，所以范围可以缩减1，如果该牛朝向后，则必须翻转该区间了。我们贪心的翻转遇到的第一个朝向后的牛，就可以求出来最少的翻转次数了。</p><p>这样我们枚举K,并且每个K都需要检查N-K+1个区间，每个区间的检查又需要O(N)的时间，所以总的时间为O(N^3)。达不到题目要求的时限。</p><h3 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h3><p>我们的目标是将所有的朝向后面的牛翻转，所以牛朝向决定了该区间是否发生翻转。我们将关注点移动到每个具体的牛与之前已经翻转的次数的关系上。</p><p>对于每个牛，与所在区间的已翻转次数有下列四种情况：</p><ul><li><p>当前牛朝向前，已经翻转了偶数次。</p></li><li><p>当前牛朝向后，已经翻转了奇数次。</p></li><li><p>当前牛朝向前，已经翻转了奇数次。</p></li><li><p>房钱牛朝向后，已经翻转了偶数次。</p></li></ul><p>我们结合前面开关问题的第二条性质发现：前两种情况不需要进行任何操作。后两种情况则需要进行一次翻转。所以结论就是：</p><p>如果朝向前为0，朝向后为1，则</p><h5 id="当前牛的朝向-之前已经翻转的次数-奇数"><a href="#当前牛的朝向-之前已经翻转的次数-奇数" class="headerlink" title="当前牛的朝向 + 之前已经翻转的次数 = 奇数"></a>当前牛的朝向 + 之前已经翻转的次数 = 奇数</h5><p>的时候则说明该翻转了。</p><p>这样，可以在常数时间内知道每个区间的翻转次数。优化到了O(N^2)，能在时限内解决了。</p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Date: 2019-09-17 17:05:23</span></span><br><span class="line"><span class="comment"> * @LastEditors: BeckoninGshy</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2019-09-17 18:13:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N,K,M;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> dir[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 表示区间[i, i+k-1] 是否翻转</span></span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//区间内翻转的次数</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + k<span class="number">-1</span> &lt; N; i++)&#123;</span><br><span class="line">        <span class="comment">//当牛的朝向与之前已翻转的次数。</span></span><br><span class="line">        <span class="keyword">if</span>((dir[i] + sum) % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            f[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新翻转次数</span></span><br><span class="line">        sum += f[i];</span><br><span class="line">        <span class="comment">//固定区间</span></span><br><span class="line">        <span class="keyword">if</span>(i - k + <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            sum -= f[i-k+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由于前n-k+1个 已经翻转到正面了，只有当后面的牛都不用翻转才合法。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N-k+<span class="number">1</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((dir[i] + sum) % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//固定区间</span></span><br><span class="line">        <span class="keyword">if</span>(i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) sum -= f[i-k+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"in.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">    K = <span class="number">1</span>, M = N;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,c);</span><br><span class="line">        <span class="keyword">if</span>(c[<span class="number">0</span>] == <span class="string">'B'</span>) dir[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//枚举K</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k++)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = cal(k);</span><br><span class="line">        <span class="keyword">if</span>(m &gt;= <span class="number">0</span> &amp;&amp; m &lt; M)&#123;</span><br><span class="line">            M = m;</span><br><span class="line">            K = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,K,M);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-42-接雨水</title>
      <link href="/2019/09/07/LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></p><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="https://note.youdao.com/favicon.ico" alt="接雨水"></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line"></span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><h3 id="Solution1（直观解法）"><a href="#Solution1（直观解法）" class="headerlink" title="Solution1（直观解法）:"></a>Solution1（直观解法）:</h3><p>我们可以稍稍使用减法，接水的区域正好是最好的柱子乘以整个宽度，再减去从左到制高点和从右到制高点每个单调上升的柱子到两边的距离乘以前柱子的高度差。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int n = height.size();</span><br><span class="line">        //小于等于两个是蓄不住水的。</span><br><span class="line">        if(n &lt;= 2) return 0;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int Max = -1;</span><br><span class="line">        int k = -1;</span><br><span class="line">        //找到至高点。</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            //先减去柱子本身高度</span><br><span class="line">            ans -= height[i];</span><br><span class="line">            if(Max &lt; height[i]) Max = height[i], k = i;</span><br><span class="line">        &#125;</span><br><span class="line">        //加上整个图的面积</span><br><span class="line">        ans += n*Max;</span><br><span class="line">        </span><br><span class="line">        //从前到最高点，每次减去从开始到每个更高柱子高度的面积。</span><br><span class="line">        int cur = height[0];</span><br><span class="line">        int i = 1;</span><br><span class="line">        while(i &lt;= k)&#123;</span><br><span class="line">            //i为从开始到当前柱子距离。height[i]-cur为高度差。</span><br><span class="line">            if(height[i] &gt; cur) ans -= i * (height[i]-cur),cur = height[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = height[n-1];</span><br><span class="line">        i = height.size()-2;</span><br><span class="line">        while(i&gt;=k)&#123;</span><br><span class="line">            //i最后到当前柱子的距离。height[i]-cur为高度差。</span><br><span class="line">            if(height[i] &gt; cur) ans -= (n-i-1) * (height[i]-cur),cur = height[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution2（单调栈）："><a href="#Solution2（单调栈）：" class="headerlink" title="Solution2（单调栈）："></a>Solution2（单调栈）：</h3><p>使用单调栈的原因是我们发现如果把每个柱子当作最低点，则接雨水的区域是左右第一个比当前柱子高的柱子所形成的区域乘以两者之间较小的柱子与当前柱子的高度差。所以我们进行单调栈寻找左右最近的比当前元素高的位置，来计算结果。</p><p>从直观来看，这样很像一层层的往里接水。（当然计算的时候不一定只是一层）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int n = height.size();</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            //找每个元素右边最近的大于他的值。//单调递减栈</span><br><span class="line">            while(s.size() &amp;&amp; height[i] &gt; height[s.top()])&#123;</span><br><span class="line">                int top = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                if(s.empty())break;</span><br><span class="line">                //由于维持的是单调递减栈，所以当前栈顶是目前已知的最小一个元素，将栈顶取出，而新的栈顶元素与新发现的比它大的元素，一定能就组成边界，使得以目前最小元素为底，至左右边界中小的那一个，可以接到雨水。形象点就是一层一层的接。</span><br><span class="line">                int dis = i-s.top()-1;</span><br><span class="line">                ans += dis * (min(height[i],height[s.top()])-height[top]);</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution3（双指针）："><a href="#Solution3（双指针）：" class="headerlink" title="Solution3（双指针）："></a>Solution3（双指针）：</h3><p>我们写第一种解法时发现，并没有必要去进行那么多减法，每次直接观察当前柱子高度与之前记录的最高柱子的高度关系，如果没有之前最高柱子高就说明可以接住雨水（因为我们每次寻找的是更高的柱子，直到全图最高柱子出现为止），这样可以直接计算该柱子之上可以接住的雨水。由于左右都是到了最高柱子就会停止，所以使用双指针来优化，每次选较小的柱子来计算，直到制高点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int n = height.size();</span><br><span class="line">        int l = 0, r = n-1;</span><br><span class="line">        int lm = -1,rm = -1;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            //从小的一方开始</span><br><span class="line">            if(height[l] &lt; height[r])&#123;</span><br><span class="line">                if(height[l] &gt; lm)&#123;</span><br><span class="line">                    lm = height[l];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    ans += lm-height[l];</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(height[r] &gt; rm)&#123;</span><br><span class="line">                    rm = height[r];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    ans += rm-height[r];</span><br><span class="line">                &#125;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>单调栈详解</title>
      <link href="/2019/09/06/%E5%8D%95%E8%B0%83%E6%A0%88%E8%AF%A6%E8%A7%A3/"/>
      <content type="html"><![CDATA[<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="一、概述："><a href="#一、概述：" class="headerlink" title="一、概述："></a>一、概述：</h3><p>单调栈是一种特殊的栈结构，他要维持栈内元素保持一种单调性，从而能很快速的在线判断当前元素与后进来的元素大小关系。</p><h3 id="二、单调性质"><a href="#二、单调性质" class="headerlink" title="二、单调性质"></a>二、单调性质</h3><p>为了维持单调性，在进栈时需要做元素的检查工作。以单调递增栈来说，如果发现要进栈的元素比目前栈顶元素小，如果此时将该元素进栈，必然会破坏单调性，所以需要对栈内元素进行调整工作：即如果该元素比栈顶元素小，则一定要将栈顶元素弹出，直到该元素不再比栈顶元素大或者栈为空时，可将该元素进栈。</p><h3 id="三、功能用途"><a href="#三、功能用途" class="headerlink" title="三、功能用途"></a>三、功能用途</h3><p>在进行调整工作时，由于栈内元素时刻保持单调性，所以在遇见要进栈的元素比栈顶元素小时，对于当前栈顶元素，这个要进栈的元素是它第一次见到的比它小的元素。利用这一性质，我们就发现了单调栈的一个主要用途：求一个元素左/右边第一个比它大/小的元素。</p><h4 id="四、具体做法"><a href="#四、具体做法" class="headerlink" title="四、具体做法"></a>四、具体做法</h4><p>对于具体怎么求比它大的元素还是比它小的元素，可以通过分析发现，求值的时机是在要进栈的元素破坏了当前栈所保持的单调性，即与当前栈保持的单调性相反。所以我们可以说：</p><ul><li><p>如果求比当前元素大的元素的位置，可以建立单调递减栈。</p></li><li><p>如果求比当前元素小的元素的位置，可以建立单调递增栈。</p></li></ul><h5 id="那如何求左边的或者右边的目标元素位置呢？"><a href="#那如何求左边的或者右边的目标元素位置呢？" class="headerlink" title="那如何求左边的或者右边的目标元素位置呢？"></a>那如何求左边的或者右边的目标元素位置呢？</h5><p>我们稍加分析就会知道：无论求哪个方向的元素，目标元素都一定要在当前元素之后进栈。所以可以得到：</p><ul><li><p>求当前元素左边的比该元素大/小的元素，要从右向左依次添加。</p></li><li><p>求当前元素右边的比该元素大/小的元素，要从左向右依次添加。</p></li></ul><p>由于我们需要求得每个元素的目标元素位置，但在一轮循环完毕后，栈中还存在符合单调性但没出栈的元素。也就是说当前栈内的每个元素都是没有与之相匹配的目标元素位置的。这时就要根据情况单独进行处理。</p><p>通常的处理方式是在循环操作结束时，再往栈内添加一个违反单调性的并且比所有的元素都要大的最值，迫使栈中的所有元素弹出。</p><h3 id="核心代码："><a href="#核心代码：" class="headerlink" title="核心代码："></a>核心代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//例：单调递减栈。 找当前数的左边的第一个比当前数大的值的位置。</span><br><span class="line">arr[0] = 2000000100;//最后位置添加一个最值。</span><br><span class="line">for(int i = N; i &gt;= 0; i--)&#123;</span><br><span class="line">    //找到了比当前栈顶大的数，更新值</span><br><span class="line">    while(stk.size() &amp;&amp; arr[i] &gt; arr[stk.top()])&#123;</span><br><span class="line">        对该stk.top()进行需求操作。</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    stk.push(i);</span><br><span class="line">&#125;</span><br><span class="line">//将最后一个元素弹出。</span><br><span class="line">stk.pop();</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>POJ-2796-FeelGood</title>
      <link href="/2019/09/06/POJ-2796-FeelGood/"/>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=2796" target="_blank" rel="noopener">POJ-2796-FeelGood</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>Bill is developing a new mathematical theory for human emotions. His recent investigations are dedicated to studying how good or bad days influent people’s memories about some period of life.</p><p>A new idea Bill has recently developed assigns a non-negative integer value to each day of human life.</p><p>Bill calls this value the emotional value of the day. The greater the emotional value is, the better the daywas. Bill suggests that the value of some period of human life is proportional to the sum of the emotional values of the days in the given period, multiplied by the smallest emotional value of the day in it. This schema reflects that good on average period can be greatly spoiled by one very bad day.</p><p>Now Bill is planning to investigate his own life and find the period of his life that had the greatest value. Help him to do so.</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><p>The first line of the input contains n - the number of days of Bill’s life he is planning to investigate(1 &lt;= n &lt;= 100 000). The rest of the file contains n integer numbers a1, a2, … an ranging from 0 to 106 - the emotional values of the days. Numbers are separated by spaces and/or line breaks.</p><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>Print the greatest value of some period of Bill’s life in the first line. And on the second line print two numbers l and r such that the period from l-th to r-th day of Bill’s life(inclusive) has the greatest possible value. If there are multiple periods with the greatest possible value,then print any one of them.</p><h3 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">3 1 6 4 5 2</span><br></pre></td></tr></table></figure><h3 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">60</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定一串数字，求一区间，使得区间内的每个数之和乘以区间内最小值最大，并求出区间范围。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>初次看，只能暴力枚举每一个区间，复杂度为O(n2)。</p><p>然后我们思考对于每个数，如果把它当做最小数，我们看他能向左右延伸到的最长区间范围，然后在这些区间内选一个符合条件最大的即可。</p><p>这就将问题转化为求每一个数左/右边尽可能远的大于等于该数的数的位置，进一步转化为求每个数的左右边遇到的第一个小于该数的位置，再往延伸的反方向退一格。这明显是单调栈问题。所以可以将复杂度降到O(n)。</p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Date: 2019-09-04 17:29:23</span><br><span class="line"> * @LastEditors: BeckoninGshy</span><br><span class="line"> * @LastEditTime: 2019-09-06 22:01:01</span><br><span class="line"> */</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 100010;</span><br><span class="line">int a[MAXN],R[MAXN],L[MAXN],ll,rr;</span><br><span class="line">long long sum[MAXN],ans = -1;</span><br><span class="line">int N;</span><br><span class="line">stack&lt;int&gt; s;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    //思路：将枚举区间转化为以每个点为最低点，求向左和向右最多可以延长的长度。再转化一下就是求每个数左边或者右边第一个比它小的元素后 再往回退一格（L+1,R-1)。然后求区间内的最大值。</span><br><span class="line">    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;N);</span><br><span class="line">    a[0] = -1;</span><br><span class="line">    a[N+1] = -1;</span><br><span class="line">    for(int i = 1; i &lt;= N; i++) scanf(&quot;%d&quot;,&amp;a[i]),sum[i] = sum[i-1] + a[i];</span><br><span class="line">    //求每个元素的左边第一个比它小的元素，加一 ----&gt; 找大于等于该数的最前一个数的位置。</span><br><span class="line"></span><br><span class="line">    //从右到左  单调递增栈</span><br><span class="line">    for(int i = N; i &gt;= 0; i--)&#123;</span><br><span class="line">        while(s.size() &amp;&amp; a[i] &lt; a[s.top()]) &#123;</span><br><span class="line">            L[s.top()] = i+1;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    s.pop();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    //求每个元素的右边第一个比它小的元素 减一 ----&gt; 大于等于该数的最后一个数的位置</span><br><span class="line">    //从左到右，单调递增栈</span><br><span class="line">    for(int i = 1; i &lt;= N+1; i++)&#123;</span><br><span class="line">        while(s.size() &amp;&amp; a[i] &lt; a[s.top()])&#123;</span><br><span class="line">            R[s.top()] = i-1;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        if((sum[R[i]] - sum[L[i]-1])*a[i] &gt; ans)&#123;</span><br><span class="line">            ans = (sum[R[i]] - sum[L[i]-1])*a[i];</span><br><span class="line">            ll = L[i];</span><br><span class="line">            rr = R[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\\n%d %d\\n&quot;,ans,ll,rr);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里由于是单调递增栈，所以在循环最后给他压进一个最小值，让栈内元素都弹出，做到代码简化。</p></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>POJ-3250-Ba-Hai-Day（单调栈入门）</title>
      <link href="/2019/09/06/POJ-3250-Ba-Hai-Day%EF%BC%88%E5%8D%95%E8%B0%83%E6%A0%88%E5%85%A5%E9%97%A8%EF%BC%89/"/>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=3250" target="_blank" rel="noopener">POJ-3250-Bad Hair Day</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>Some of Farmer John’s N cows (1 ≤ N ≤ 80,000) are having a bad hair day! Since each cow is self-conscious about her messy hairstyle, FJ wants to count the number of other cows that can see the top of other cows’ heads.</p><p>Each cow i has a specified height hi (1 ≤ hi ≤ 1,000,000,000) and is standing in a line of cows all facing east (to the right in our diagrams). Therefore, cow i can see the tops of the heads of cows in front of her (namely cows i+1, i+2, and so on), for as long as these cows are strictly shorter than cow i.</p><p>Consider this example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=</span><br><span class="line">=       =</span><br><span class="line">=   -   =         Cows facing right --&gt;</span><br><span class="line">=   =   =</span><br><span class="line">= - = = =</span><br><span class="line">= = = = = =</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure><ul><li>Cow#1 can see the hairstyle of cows #2, 3, 4</li><li>Cow#2 can see no cow’s hairstyle</li><li>Cow#3 can see the hairstyle of cow #4</li><li>Cow#4 can see no cow’s hairstyle</li><li>Cow#5 can see the hairstyle of cow 6</li><li>Cow#6 can see no cows at all!</li></ul><p>Let ci denote the number of cows whose hairstyle is visible from cow i; please compute the sum of c1 through cN.For this example, the desired is answer 3 + 0 + 1 + 0 + 1 + 0 = 5.</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><p>Line 1: The number of cows, N.<br>Lines 2..N+1: Line i+1 contains a single integer that is the height of cow i.</p><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>Line 1: A single integer that is the sum of c1 through cN.</p><h3 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">10</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">4</span><br><span class="line">12</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>有一排奶牛，每个奶牛可以看到它右边身高严格比它小的奶牛发型，问这一排奶牛可以看到的奶牛发型总数。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>这道题是单调栈模板题。</p><p>具体做法就是在当前奶牛的右边找一个大于等于（原题说要严格小于，所以等于也算边界）它身高的奶牛的位置（由于求大于等于，所以维持一个单调递减栈），然后两者位置之差再减一就是中间的奶牛数量，每一个奶牛都做此操作即可求得结果。当然有一种情况是它找不到右边身高大于等于它的奶牛。这时可以把最后一个奶牛有一个无限高的奶牛，然后用该位置去减栈中每个奶牛的位置（n+1-x-1 = n-x）。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Date: 2019-09-04 16:39:06</span><br><span class="line"> * @LastEditors: BeckoninGshy</span><br><span class="line"> * @LastEditTime: 2019-09-06 21:41:17</span><br><span class="line"> */</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int a,x;</span><br><span class="line">    node()&#123;&#125;</span><br><span class="line">    node(int _a, int _x):x(_x),a(_a)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">stack&lt;node&gt; s;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    int n;</span><br><span class="line">    long long ans = 0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    node temp;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;temp.a);</span><br><span class="line">        temp.x = i;</span><br><span class="line">        //单调递减栈</span><br><span class="line">        //找到了第一个比当前栈顶大的值（刚读入的值）。</span><br><span class="line">        while(s.size() &amp;&amp; s.top().a &lt;= temp.a)&#123;</span><br><span class="line">            //计算坐标差</span><br><span class="line">            ans += i-s.top().x-1;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    //当前栈顶元素的右边没有比他更高的元素了，用最右边的无限高减去该元素位置。</span><br><span class="line">    while(s.size())&#123;</span><br><span class="line">        ans += n-s.top().x;</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>洛谷-P1901-发射站</title>
      <link href="/2019/09/05/%E6%B4%9B%E8%B0%B7-P1901-%E5%8F%91%E5%B0%84%E7%AB%99/"/>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P1901" target="_blank" rel="noopener">P1901 发射站</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>某地有 N 个能量发射站排成一行，每个发射站 i 都有不相同的高度 Hi，并能向两边（当 然两端的只能向一边）同时发射能量值为 Vi 的能量，并且发出的能量只被两边最近的且比 它高的发射站接收。</p><p>显然，每个发射站发来的能量有可能被 0 或 1 或 2 个其他发射站所接受，特别是为了安 全，每个发射站接收到的能量总和是我们很关心的问题。由于数据很多，现只需要你帮忙计 算出接收最多能量的发射站接收的能量是多少。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第 1 行：一个整数 N;</p><p>第 2 到 N+1 行：第 i+1 行有两个整数 Hi 和 Vi，表示第 i 个人发射站的高度和发射的能量值。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出仅一行，表示接收最多能量的发射站接收到的能量值，答案不超过 longint。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4 2 </span><br><span class="line">3 5 </span><br><span class="line">6 10</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="说明-提示："><a href="#说明-提示：" class="headerlink" title="说明/提示："></a>说明/提示：</h3><p>对于 40%的数据，1&lt;=N&lt;=5000；1&lt;=Hi&lt;=100000；1&lt;=Vi&lt;=10000;</p><p>对于 70%的数据，1&lt;=N&lt;=100000；1&lt;=Hi&lt;=2,000,000,000；1&lt;=Vi&lt;=10000;</p><p>对于 100%的数据，1&lt;=N&lt;=1000000;1&lt;=Hi&lt;=2,000,000,000；1&lt;=Vi&lt;=10000。</p><h3 id="题目解析："><a href="#题目解析：" class="headerlink" title="题目解析："></a>题目解析：</h3><p>题目中有一句至关重要的话：发出的能量只被两边最近的且比 它高的发射站接收。</p><p>这句话揭露了解法：使用单调栈。</p><p>将题目精简下，留其核心就是要分别求每个数左边和右边碰到的第一个比它大的数的位置。</p><p>这是经典的单调栈可以解决的问题，所以直接写两个单调栈：一个求左边的位置，一个求右边的位置，找到位置后将其能量值存起来，在其中找一个最大值即可。</p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Date: 2019-09-05 21:32:02</span><br><span class="line"> * @LastEditors: BeckoninGshy</span><br><span class="line"> * @LastEditTime: 2019-09-05 23:10:34</span><br><span class="line"> */</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line">const int MAXN = 1000010;</span><br><span class="line"></span><br><span class="line">LL arr[MAXN],s[MAXN],sum[MAXN],N,ans = -1;</span><br><span class="line">stack&lt;LL&gt; stk;</span><br><span class="line">int main()&#123;</span><br><span class="line">    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;N);</span><br><span class="line">    arr[0] = 2000000100;</span><br><span class="line">    arr[N+1] = 2000000100;</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;arr[i],&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    //找一个数左右两边离该数最近的并且比该数大的数的位置</span><br><span class="line">    </span><br><span class="line">    //单调递减栈。 找当前数的右边目标数</span><br><span class="line">    for(int i = 1; i &lt;= N+1; i++)&#123;</span><br><span class="line">        //找到了比当前栈顶大的数，更新值</span><br><span class="line">        while(stk.size() &amp;&amp; arr[i] &gt; arr[stk.top()])&#123;</span><br><span class="line">            sum[i] += s[stk.top()];</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    stk.pop();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //单调递减栈。 找当前数的左边目标数</span><br><span class="line">    for(int i = N; i &gt;= 0; i--)&#123;</span><br><span class="line">        //找到了比当前栈顶大的数，更新值</span><br><span class="line">        while(stk.size() &amp;&amp; arr[i] &gt; arr[stk.top()])&#123;</span><br><span class="line">            sum[i] += s[stk.top()];</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    stk.pop();</span><br><span class="line">    for(int i = 1; i &lt;= N; i++) ans = max(ans,sum[i]);</span><br><span class="line">    printf(&quot;%lld&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>最小生成树相关算法学习总结</title>
      <link href="/2019/08/30/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>最小生成树是一副连通加权无向图中一棵权值最小的生成树。</p><p>在现实生活中，经常要求在类似网络的复杂关系中，既要面面俱到（任意两个结点之间都可以访问到），又要使所用成本尽可能的小。最小生成树就是解决相关问题的。</p><p>一个连通图可能有多个不同的最小生成树，但是其权值之和一定相等。一棵最小生成树一定有N个顶点，N-1条边。通过对生成树关注的角度不同，有相应两种不同但同样常用的算法。</p><h2 id="一、Prim算法："><a href="#一、Prim算法：" class="headerlink" title="一、Prim算法："></a>一、Prim算法：</h2><p>prim算法是按每一步为一棵生长中的树添加一条边，该数最开始只有一个顶点，然后会添加v-1条边。</p><p>每次总是选择一条与生长中的树和图中与该树相连的部分所形成的具有最小权值的横切边添加到该生成树中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int G[MAXN][MAXN];//权值矩阵</span><br><span class="line">int vis[MAXN];//记录访问</span><br><span class="line">int lowc[MAXN];//记录与树连接的边的权重</span><br><span class="line">memset(G,INF,sizeof(G));</span><br><span class="line">memset(vis,false,sizeof(vis));</span><br><span class="line">memset(lowc,INF,sizeof(lowc));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//标号0-n-1，返回最小生成树的权值，返回-1表示不连通</span><br><span class="line">int Prim(int n)&#123;</span><br><span class="line">int ans = 0;</span><br><span class="line"></span><br><span class="line">//从0节点开始</span><br><span class="line">vis[0] = true;</span><br><span class="line">//首先更新与0结点直接相连的边的权值。</span><br><span class="line">for(int i = 1; i &lt; n; i++) lowc[i] = G[0][i];</span><br><span class="line">    //循环n-1次</span><br><span class="line">for(int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">int minc = INF;</span><br><span class="line">int p = -1;</span><br><span class="line">//找到与当前树相连并且权值最小的边。</span><br><span class="line">for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">if(!vis[j]&amp;&amp;minc &gt; lowc[j])&#123;</span><br><span class="line">minc = lowc[j];</span><br><span class="line">p = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//不连通</span><br><span class="line">if(minc == INF) return -1;</span><br><span class="line">//更新树的权值</span><br><span class="line">ans += minc;</span><br><span class="line">vis[p] = true;</span><br><span class="line">//继续更新新树的最小权值数组。</span><br><span class="line">for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">if(!vis[j]&amp;&amp;lowc[j] &gt; G[p][j])</span><br><span class="line">lowc[j] = G[p][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、-Kruskal算法"><a href="#二、-Kruskal算法" class="headerlink" title="二、 Kruskal算法"></a>二、 Kruskal算法</h2><h4 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h4><ul><li>新建图G，G中拥有原图中相同的节点，但没有边。</li></ul><ul><li>将原图中所有的边按权值从小到大排序</li></ul><ul><li>从权值最小的边开始，如果这条边连接的两个结点与图G中不在同一个连通分量重，则添加这条边到图G中。</li></ul><ul><li>重复3，直至图G中所有的结点都在同一个连通分量中。一共需要合并n-1次。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">const int MAXN = 1010;//最大点数 </span><br><span class="line">const int MAXM = 10000;//最大边数</span><br><span class="line"> </span><br><span class="line">int F[MAXN]; //并查集使用</span><br><span class="line"></span><br><span class="line">//存储边的信息，起点，终点，权值</span><br><span class="line">struct Edge&#123;</span><br><span class="line">int u,v,w;</span><br><span class="line">&#125;edge[MAXM]; </span><br><span class="line">int tol = 0;//边数，加边前赋值为0</span><br><span class="line"></span><br><span class="line">//加边函数</span><br><span class="line">void addedge(int u,int v,int w)&#123;</span><br><span class="line">edge[tol].u = u;</span><br><span class="line">edge[tol].v = v;</span><br><span class="line">edge[tol++].w = w;</span><br><span class="line">&#125; </span><br><span class="line">//比较函数，排序用</span><br><span class="line">bool cmp(Edge a,Edge b)&#123;</span><br><span class="line">return a.w &lt; b.w;</span><br><span class="line">&#125; </span><br><span class="line">//查找元素所属集合。路径压缩版</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">return F[x] == -1 ? x : F[x] = find(F[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//传入点数，返回最小生成树的权值，如果不连通返回-1</span><br><span class="line">int Kruskal(int n)&#123;</span><br><span class="line">memset(F,-1,sizeof(F));</span><br><span class="line">//先对边排序</span><br><span class="line">sort(edge,edge+tol,cmp);</span><br><span class="line">int cnt = 0; //计算加入的边数。</span><br><span class="line">int ans = 0;</span><br><span class="line">//最多循环tol次</span><br><span class="line">for(int i = 0; i &lt; tol; i++)&#123;</span><br><span class="line">int u = edge[i].u;</span><br><span class="line">int v = edge[i].v;</span><br><span class="line">int w = edge[i].w;</span><br><span class="line">int t1 = find(u);</span><br><span class="line">int t2 = find(v);</span><br><span class="line">//如果属于不同集合，合并</span><br><span class="line">if(t1 != t2)&#123;</span><br><span class="line">ans+= w;</span><br><span class="line">F[t1] = t2;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">//共需合并n-1次，已经完成，可提前结束</span><br><span class="line">if(cnt == n-1) break;</span><br><span class="line">&#125; </span><br><span class="line">if(cnt &lt; n-1) return -1;//不连通</span><br><span class="line">return ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于稀疏图，选择Kruskal算法较优，而对于稠密图，Prim算法会更高效。</p></blockquote><p>此外还有最大生成树，其实只要将图中的权值取反一下，就可以求得最大生成树，或者在kruskal算法，按从大到小排序之后再合并，得出来的也是最大生成树。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>POJ-3660-Co-Contest</title>
      <link href="/2019/08/30/POJ-3660-Co-Contest/"/>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=3660" target="_blank" rel="noopener">POJ-3660-Cow Contest</a></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>N (1 ≤ N ≤ 100) cows, conveniently numbered 1..N, are participating in a programming contest. As we all know, some cows code better than others. Each cow has a certain constant skill rating that is unique among the competitors.</p><p>The contest is conducted in several head-to-head rounds, each between two cows. If cow A has a greater skill level than cow B (1 ≤ A ≤ N; 1 ≤ B ≤ N; A ≠ B), then cow A will always beat cow B.</p><p>Farmer John is trying to rank the cows by skill level. Given a list the results of M (1 ≤ M ≤ 4,500) two-cow rounds, determine the number of cows whose ranks can be precisely determined from the results. It is guaranteed that the results of the rounds will not be contradictory.</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><ul><li>Line 1: Two space-separated integers: N and M</li></ul><ul><li>Lines 2..M+1: Each line contains two space-separated integers that describe the competitors and results (the first integer, A, is the winner) of a single round of competition: A and B</li></ul><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>Line 1: A single integer representing the number of cows whose ranks can be determined　</p><h4 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">4 3</span><br><span class="line">4 2</span><br><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure><h4 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>有N头牛，现在给出M个输赢列表（第一代表赢，第二代表输），并且实力是绝对的（这句话很重要）。要求你确定谁的排名是确定的，输出确定的个数。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>使用传递闭包来确定赢的关系，并通过判断其中一头牛与其他牛是否都有联系（赢了别的牛，或输给了别的牛）。如果与其余N-1条牛都有联系，说明该牛的排名是确定的。</p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 200;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line"></span><br><span class="line">int G[MAXN][MAXN];</span><br><span class="line">int N,M;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    memset(G,0,sizeof(G));</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;N,&amp;M);</span><br><span class="line">    for(int i = 0; i &lt; M; i++)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">        //生成a赢b的关系图</span><br><span class="line">        G[a][b] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int k = 1; k &lt;= N; k++)</span><br><span class="line">        for(int i = 1; i &lt;= N; i++)</span><br><span class="line">            for(int j = 1; j &lt;= N; j++)</span><br><span class="line">                //B&gt;C，A&gt;B，说明A&gt;C</span><br><span class="line">                if(G[i][k] &amp;&amp; G[k][j]) G[i][j] = 1;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    只有当一个点与其他个点都有联系（或赢或输）,才可以确定该点</span><br><span class="line">    */</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int j = 1; j &lt;= N; j++)&#123;</span><br><span class="line">        // 又因为该题有唯一的赢输判定，所以与其他各点都有联系可以直接表示为加的和为N-1</span><br><span class="line">        // 否则只能一一判定当前点与其他个点的关系。</span><br><span class="line">            sum = sum + G[i][j] + G[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum == N-1) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\\n&quot;,ans);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>POJ-1416-Shreddin-Company</title>
      <link href="/2019/08/25/POJ-1416-Shreddin-Company/"/>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=1416" target="_blank" rel="noopener">POJ-1416</a></p><h3 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h3><p>You have just been put in charge of developing a new shredder for the Shredding Company Although a “normal” shredder would just shred sheets of paper into little pieces so that the contents would become unreadable, this new shredder needs to have the following unusual basic characteristics.</p><ul><li><p>1.The shredder takes as input a target number and a sheet of paper with a number written on it.</p></li><li><p>2.It shreds (or cuts) the sheet into pieces each of which has one or more digits on it.</p></li><li><p>3.The sum of the numbers written on each piece is the closest possible number to the target number, without going over it.</p></li></ul><p>For example, suppose that the target number is 50, and the sheet of paper has the number 12346. The shredder would cut the sheet into four pieces, where one piece has 1, another has 2, the third has 34, and the fourth has 6. This is because their sum 43 (= 1 + 2 + 34 + 6) is closest to the target number 50 of all possible combinations without going over 50. For example, a combination where the pieces are 1, 23, 4, and 6 is not valid, because the sum of this combination 34 (= 1 + 23 + 4 + 6) is less than the above combination’s 43. The combination of 12, 34, and 6 is not valid either, because the sum 52 (= 12 + 34 + 6) is greater than the target number of 50.</p><p>Figure 1. Shredding a sheet of paper having the number 12346 when the target number is 50</p><p>There are also three special rules :</p><ul><li>1.If the target number is the same as the number on the sheet of paper, then the paper is not cut.</li></ul><p>For example, if the target number is 100 and the number on the sheet of paper is also 100, then the paper is not cut.</p><ul><li><p>2.If it is not possible to make any combination whose sum is less than or equal to the target number, then error is printed on a display. For example, if the target number is 1 and the number on the sheet of paper is 123, it is not possible to make any valid combination, as the combination with the smallest possible sum is 1, 2, 3. The sum for this combination is 6, which is greater than the target number, and thus error is printed.</p></li><li><p>3.If there is more than one possible combination where the sum is closest to the target number without going over it, then rejected is printed on a display. For example, if the target number is 15, and the number on the sheet of paper is 111, then there are two possible combinations with the highest possible sum of 12: (a) 1 and 11 and (b) 11 and 1; thus rejected is printed. In order to develop such a shredder, you have decided to first make a simple program that would simulate the above characteristics and rules. Given two numbers, where the first is the target number and the second is the number on the sheet of paper to be shredded, you need to figure out how the shredder should “cut up” the second number.</p></li></ul><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><p>The input consists of several test cases, each on one line, as follows :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tl num1</span><br><span class="line">t2 num2</span><br><span class="line">...</span><br><span class="line">tn numn</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p>Each test case consists of the following two positive integers, which are separated by one space : (1) the first integer (ti above) is the target number, (2) the second integer (numi above) is the number that is on the paper to be shredded.</p><p>Neither integers may have a 0 as the first digit, e.g., 123 is allowed but 0123 is not. You may assume that both integers are at most 6 digits in length. A line consisting of two zeros signals the end of the input.</p><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>For each test case in the input, the corresponding output takes one of the following three types :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum part1 part2 ...</span><br><span class="line">rejected</span><br><span class="line">error</span><br></pre></td></tr></table></figure><p>In the first type, partj and sum have the following meaning :</p><p>1.Each partj is a number on one piece of shredded paper. The order of partj corresponds to the order of the original digits on the sheet of paper.</p><p>2.sum is the sum of the numbers after being shredded, i.e., sum = part1 + part2 +…</p><p>Each number should be separated by one space.<br>The message error is printed if it is not possible to make any combination, and rejected if there is<br>more than one possible combination.<br>No extra characters including spaces are allowed at the beginning of each line, nor at the end of each line.</p><h3 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">50 12346</span><br><span class="line">376 144139</span><br><span class="line">927438 927438</span><br><span class="line">18 3312</span><br><span class="line">9 3142</span><br><span class="line">25 1299</span><br><span class="line">111 33333</span><br><span class="line">103 862150</span><br><span class="line">6 1104</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h3 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">43 1 2 34 6</span><br><span class="line">283 144 139</span><br><span class="line">927438 927438</span><br><span class="line">18 3 3 12</span><br><span class="line">error</span><br><span class="line">21 1 2 9 9</span><br><span class="line">rejected</span><br><span class="line">103 86 2 15 0</span><br><span class="line">rejected</span><br></pre></td></tr></table></figure><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你一个有n个数的纸条，一个目标值，你可以任意剪纸条，要找出剪出的数的和最接近并且小于目标数的分解方式。</p><p>如果该数可以由多个分解方式组成，则输出error；如果无论如何分解都比目标值大，则输出rejected。如果分解值和目标数相同，则直接输出。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>首先对于剪纸条，无论如何剪，相邻数的位置关系并不会发生变化，只是选择元素的个数会发生变化，则可以dfs枚举所有的可能————对于某一过程，可以选择从该数开始到纸条结尾，每次都选择增加一个数，然后进行下一层的dfs，即可取得所有的分解组合。</p><p>接下来要保留选择数的路径，我们使用一个数的每一位来记录当前选择了几个数（N最大为6位，所以一位足够表示）。</p><p>然后，对于大于目标数的情况，只有当最小分解方式（每一位都被分解）之和都比目标值大，则可以直接输出rejected。该步可在dfs之前判断。</p><p>对于error的情况，只要在每次更新当前值的时候，也更新其相同的次数，如果大于1，则符合该情况。</p><p>可以小小的剪枝下：当过程中的取值比目标值大的话，就可以直接剪掉。</p><p>最后就是编码的时刻了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; ans;</span><br><span class="line">int num; //目标数</span><br><span class="line">int npath; //最优路径</span><br><span class="line">int curNum; //当前数，dfs中间值</span><br><span class="line">int cntNum; //当前数的出现次数。</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">将结果数组中的各值相加</span><br><span class="line">*/</span><br><span class="line">int getNum(vector&lt;vector&lt;int&gt; &gt; t, int n)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    int cont = 0;</span><br><span class="line">    for(int j = 0; j &lt; t.size(); j++)&#123;</span><br><span class="line">        int c = 0;</span><br><span class="line">        cont += t[j].size();</span><br><span class="line">        for(int k = 0; k &lt; t[j].size(); k++)&#123;</span><br><span class="line">            c = c*10 + t[j][k];</span><br><span class="line">        &#125;    </span><br><span class="line">        ans +=c;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">i:当前位置</span><br><span class="line">n：总长度</span><br><span class="line">path：记录每次分割长度</span><br><span class="line">s：总数据</span><br><span class="line">t：结果数组。</span><br><span class="line">*/</span><br><span class="line">void dfs(int i,int n,int path,char s[],vector&lt;vector&lt;int&gt; &gt; t)&#123;</span><br><span class="line">    int tt = getNum(t,n);</span><br><span class="line">    //如果过程中已经比当前数大了，直接剪掉</span><br><span class="line">    if(tt &gt; num) return;</span><br><span class="line">    </span><br><span class="line">    if(i == n)&#123;</span><br><span class="line">        //在当前一轮结束时更新离目标数最近并小于目标数的值、次数与路径。</span><br><span class="line">        if(curNum &lt; tt)&#123;</span><br><span class="line">            cntNum = 1;</span><br><span class="line">            curNum = tt;</span><br><span class="line">            npath = path;</span><br><span class="line">        &#125;else if(curNum == tt)&#123;</span><br><span class="line">            cntNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    dfs核心：</span><br><span class="line">    输入：1234</span><br><span class="line">    生成下列排列</span><br><span class="line">    1 2 3 4 </span><br><span class="line">    1 2 34 </span><br><span class="line">    1 23 4 </span><br><span class="line">    1 234 </span><br><span class="line">    12 3 4 </span><br><span class="line">    12 34 </span><br><span class="line">    123 4 </span><br><span class="line">    1234</span><br><span class="line">    */</span><br><span class="line">    vector&lt;int&gt; a;</span><br><span class="line">    for(int j = i; j &lt; n; j++)&#123;</span><br><span class="line">        a.push_back(s[j]-&apos;0&apos;);</span><br><span class="line">        t.push_back(a);</span><br><span class="line">        dfs(j+1,n,path*10+j-i+1,s,t);</span><br><span class="line">        t.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据path输出各个数。</span><br><span class="line">void show(char s[],int path)&#123;</span><br><span class="line">    vector&lt;int&gt; a;</span><br><span class="line">    while(path)&#123;</span><br><span class="line">        a.push_back(path%10);</span><br><span class="line">        path/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(a.begin(),a.end());</span><br><span class="line">    int j = 0;</span><br><span class="line">    for(int i = 0; i &lt; a.size(); i++)&#123;</span><br><span class="line">        printf(&quot; &quot;);</span><br><span class="line">        for(int k = 0; k &lt; a[i]; k++)&#123;</span><br><span class="line">            printf(&quot;%c&quot;,s[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    int a;</span><br><span class="line">    char s[1000];</span><br><span class="line">    while(scanf(&quot;%d%s&quot;,&amp;a,s) &amp;&amp; a)&#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; t;</span><br><span class="line">        num = a;</span><br><span class="line">        curNum = 0;</span><br><span class="line">        cntNum = 0;</span><br><span class="line"></span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0; i &lt; strlen(s); i++)&#123;</span><br><span class="line">            sum += s[i]-&apos;0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        //给定数的每一位相加都比目标数大</span><br><span class="line">        if(sum &gt; a)&#123;</span><br><span class="line">            printf(&quot;error\\n&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            dfs(0,strlen(s),0,s,t);</span><br><span class="line">            if(cntNum &gt; 1)&#123;</span><br><span class="line">                printf(&quot;rejected\\n&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                printf(&quot;%d&quot;,curNum);</span><br><span class="line">                show(s,npath);</span><br><span class="line">                printf(&quot;\\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>POJ-3083-Childre-o-th-Cand-Corn</title>
      <link href="/2019/08/23/POJ-3083-Childre-o-th-Cand-Corn/"/>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=3083" target="_blank" rel="noopener">POJ-3083</a></p><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><p>The cornfield maze is a popular Halloween treat. Visitors are shown the entrance and must wander through the maze facing zombies, chainsaw-wielding psychopaths, hippies, and other terrors on their quest to find the exit.</p><p>One popular maze-walking strategy guarantees that the visitor will eventually find the exit. Simply choose either the right or left wall, and follow it. Of course, there’s no guarantee which strategy (left or right) will be better, and the path taken is seldom the most efficient. (It also doesn’t work on mazes with exits that are not on the edge; those types of mazes are not represented in this problem.)</p><p>As the proprieter of a cornfield that is about to be converted into a maze, you’d like to have a computer program that can determine the left and right-hand paths along with the shortest path so that you can figure out which layout has the best chance of confounding visitors.</p><h4 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h4><p>Input to this problem will begin with a line containing a single integer n indicating the number of mazes. Each maze will consist of one line with a width, w, and height, h (3 &lt;= w, h &lt;= 40), followed by h lines of w characters each that represent the maze layout. Walls are represented by hash marks (‘#’), empty space by periods (‘.’), the start by an ‘S’ and the exit by an ‘E’.</p><p>Exactly one ‘S’ and one ‘E’ will be present in the maze, and they will always be located along one of the maze edges and never in a corner. The maze will be fully enclosed by walls (‘#’), with the only openings being the ‘S’ and ‘E’. The ‘S’ and ‘E’ will also be separated by at least one wall (‘#’).</p><p>You may assume that the maze exit is always reachable from the start point.</p><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><p>For each maze in the input, output on a single line the number of (not necessarily unique) squares that a person would visit (including the ‘S’ and ‘E’) for (in order) the left, right, and shortest paths, separated by a single space each. Movement from one square to another is only allowed in the horizontal or vertical direction; movement along the diagonals is not allowed.</p><h4 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">8 8</span><br><span class="line">########</span><br><span class="line">#......#</span><br><span class="line">#.####.#</span><br><span class="line">#.####.#</span><br><span class="line">#.####.#</span><br><span class="line">#.####.#</span><br><span class="line">#...#..#</span><br><span class="line">#S#E####</span><br><span class="line">9 5</span><br><span class="line">#########</span><br><span class="line">#.#.#.#.#</span><br><span class="line">S.......E</span><br><span class="line">#.#.#.#.#</span><br><span class="line">#########</span><br></pre></td></tr></table></figure><h4 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">37 5 5</span><br><span class="line">17 17 9</span><br></pre></td></tr></table></figure><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有一张地图，# 是墙壁，. 是路，S是点，E是终点。（S和E在地图边缘且不在四个对角）</p><p>问：优先选择左边到达终点的路径长度（目前朝向的左边为优先选边，顺时针），优先选择右边到达终点的路径长度（目前朝向的右边为优先选边，逆时针），和最短的路径长度。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>该题使用dfs（前两问）加bfs（后一问）来解答，由于有一个优先选择当前方向的左边或者右边位置，所以需要处理一个当前的朝向问题。比普通的dfs要复杂一点。但是根据定义的方向数组，只要知道了向左转就是当前的朝向减一个单位，右转为当前的朝向加一个单位，以此为起始探测方向，并且处理好顺逆时针关系就可以化解该题。</p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN = 50;</span><br><span class="line">char m[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">int N,M;</span><br><span class="line">int sx,sy,ex,ey;</span><br><span class="line">int ans;</span><br><span class="line">int flag;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y,d;</span><br><span class="line">    node()&#123;&#125;</span><br><span class="line">    node(int _x,int _y, int _d):x(_x),y(_y),d(_d)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//从左顺时针</span><br><span class="line">int dx[] = &#123;0,-1,0,1&#125;;</span><br><span class="line">int dy[] = &#123;-1,0,1,0&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void dfs(int x, int y, int pos,int t,int s)&#123;</span><br><span class="line">    // printf(&quot;%d %d %d\\n&quot;,x,y,d);</span><br><span class="line">    if(flag) return;</span><br><span class="line">    if(x == ex &amp;&amp; y == ey)&#123;</span><br><span class="line">        flag = 1;</span><br><span class="line">        ans = max(ans,s);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //t = -1 表示顺时针，t = 1 表示逆时针</span><br><span class="line">    //pp : 当前的方向</span><br><span class="line">    //如果是左优先，就将当前方向-1开始顺时针，</span><br><span class="line">    //如果是右优先，就将当前方向+1开始逆时针。</span><br><span class="line">    for(int i = 1,pp = (pos+t+4)%4; i &lt;= 4; i++,pp = (pp-t+4)%4)&#123;</span><br><span class="line">        int nx = dx[pp] + x;</span><br><span class="line">        int ny = dy[pp] + y;</span><br><span class="line">        if(nx &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; M &amp;&amp; m[nx][ny] == &apos;.&apos;)&#123;</span><br><span class="line">            dfs(nx,ny,pp,t,s+1);</span><br><span class="line">            if(flag) return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void bfs(int x,int y)&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.push(node(x,y,1));</span><br><span class="line">    m[x][y] = &apos;#&apos;;</span><br><span class="line">    node temp;</span><br><span class="line">    while(q.size())&#123;</span><br><span class="line">        temp = q.front();q.pop();</span><br><span class="line">        if(temp.x == ex &amp;&amp; temp.y == ey)&#123;</span><br><span class="line">            ans = temp.d;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">            int nx = dx[i] + temp.x;</span><br><span class="line">            int ny = dy[i] + temp.y;</span><br><span class="line">            if(nx &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; M &amp;&amp; m[nx][ny] == &apos;.&apos;)&#123;</span><br><span class="line">                m[nx][ny] = &apos;#&apos;;</span><br><span class="line">                q.push(node(nx,ny,temp.d+1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        int pos = 0;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;M,&amp;N);</span><br><span class="line">        // memset(m,0,sizeof(m));</span><br><span class="line">        for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,m[i]);</span><br><span class="line">            for(int j = 0; j &lt; M; j++)&#123;</span><br><span class="line">                if(m[i][j] == &apos;S&apos;)&#123;</span><br><span class="line">                    sx = i,sy = j; m[i][j] = &apos;.&apos;;</span><br><span class="line">                &#125;else if(m[i][j] == &apos;E&apos;)&#123;</span><br><span class="line">                    ex = i,ey = j; m[i][j] = &apos;.&apos;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        //     for(int j = 0; j &lt; M; j++)&#123;</span><br><span class="line">        //         printf(&quot;%c&quot;,m[i][j]);</span><br><span class="line">        //     &#125;</span><br><span class="line">        //     printf(&quot;\\n&quot;);</span><br><span class="line">        // &#125;</span><br><span class="line">        /*</span><br><span class="line">        pos = 0 表示向上为初始方向</span><br><span class="line">        pos = 1 表示向右为初始方向</span><br><span class="line">        pos = 2 表示向下为初始方向</span><br><span class="line">        pos = 3 表示向左为初始方向</span><br><span class="line">        */</span><br><span class="line">        if(sx == 0) pos = 2;</span><br><span class="line">        if(sx == N-1) pos = 0;</span><br><span class="line">        if(sy == 0) pos = 1;</span><br><span class="line">        if(sy == M-1) pos = 3;</span><br><span class="line">        ans = 0;</span><br><span class="line">        flag = 0;</span><br><span class="line">        dfs(sx,sy,pos,-1,1);</span><br><span class="line">        printf(&quot;%d&quot;,ans);</span><br><span class="line">        ans = 0;</span><br><span class="line">        flag = 0;</span><br><span class="line">        dfs(sx,sy,pos,1,1);</span><br><span class="line">        printf(&quot; %d&quot;,ans);</span><br><span class="line">        ans = 0;</span><br><span class="line">        bfs(sx,sy);</span><br><span class="line">        printf(&quot; %d\\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-473-火柴拼正方形</title>
      <link href="/2019/08/16/LeetCode-473-%E7%81%AB%E6%9F%B4%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/matchsticks-to-square/" target="_blank" rel="noopener">473. 火柴拼正方形</a></p><p>还记得童话《卖火柴的小女孩》吗？现在，你知道小女孩有多少根火柴，请找出一种能使用所有火柴拼成一个正方形的方法。不能折断火柴，可以把火柴连接起来，并且每根火柴都要用到。</p><p>输入为小女孩拥有火柴的数目，每根火柴用其长度表示。输出即为是否能用所有的火柴拼成正方形。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,2,2,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><blockquote><p>解释: 能拼成一个边长为2的正方形，每边两根火柴。</p></blockquote><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,3,3,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><blockquote><p>解释: 不能用所有火柴拼成一个正方形。</p></blockquote><h5 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h5><p>给定的火柴长度和在 0 到 10^9之间。火柴数组的长度不超过15。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int part;</span><br><span class="line">    vector&lt;bool&gt; vis;</span><br><span class="line">    bool f = true;</span><br><span class="line">    bool makesquare(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++) sum += nums[i];</span><br><span class="line">        if(!sum || sum%4) return false;</span><br><span class="line">        part = sum / 4;</span><br><span class="line">        vis = vector&lt;bool&gt;(nums.size());</span><br><span class="line">        //从大到小枚举所有边</span><br><span class="line">        sort(nums.begin(),nums.end(),greater&lt;int&gt;());</span><br><span class="line">        return dfs(nums,0,0,part);</span><br><span class="line">    &#125;</span><br><span class="line">    //u:当前选了几个数，sum：当前的和，k:选到了第几层</span><br><span class="line">    bool dfs(vector&lt;int&gt; &amp;nums,int u,int cur,int length)&#123;</span><br><span class="line">        if(cur == length) u+=1,cur=0;</span><br><span class="line">        if(u == 4) return true;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            //</span><br><span class="line">            if(!vis[i] &amp;&amp; cur+nums[i] &lt;= length)&#123;</span><br><span class="line">                vis[i] = true;</span><br><span class="line">                if(dfs(nums,u,cur+nums[i],length)) return true;</span><br><span class="line">                vis[i] = false;</span><br><span class="line">                //如果当前木棒拼接失败，并且是第一个，则剪掉。</span><br><span class="line">                if(cur == 0) return false;</span><br><span class="line">                //如果当前木棒拼接失败，并且是最后一个，则剪掉。</span><br><span class="line">                if(cur + nums[i] == length) return false;</span><br><span class="line">                //如果当前木棒拼接失败，跳过所有相同长度的木棒。</span><br><span class="line">                while(i+1 &lt; nums.size() &amp;&amp; nums[i] == nums[i+1]) i++;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>剪枝策略：</p><ul><li>从小到大枚举所有边</li><li>每条边内部的木棒长度规定为从大到小</li><li>如果当前木棒拼接失败，则跳过接下来所有长度相同的木棒。</li><li>如果当前木棒拼接失败，且是当前边的第一个，则直接剪掉当前分支。</li><li>如果当前木棒拼接失败，且是当前边的最后一个，则直接剪掉当前分支。</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-216-组合总-III</title>
      <link href="/2019/08/16/LeetCode-216-%E7%BB%84%E5%90%88%E6%80%BB-III/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/combination-sum-iii/" target="_blank" rel="noopener">216. 组合总和 III</a></p><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><ul><li><p>所有数字都是正整数。</p></li><li><p>解集不能包含重复的组合。 </p></li></ul><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br></pre></td></tr></table></figure><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        dfs(0,1,0,k,n);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    //u:当前选择数的个数，a：当前可以枚举的位置，sum:当前组合数的和。</span><br><span class="line">    void dfs(int u,int a,int sum,int k,int n)&#123;</span><br><span class="line">        if(u == k &amp;&amp; sum == n)&#123;</span><br><span class="line">            ans.push_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(a == 10)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum &gt; n) return;</span><br><span class="line">        for(int i = a; i &lt; 10; i++)&#123;</span><br><span class="line">            tmp.push_back(i);</span><br><span class="line">            dfs(u+1,i+1,sum+i,k,n);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-47-全排-II</title>
      <link href="/2019/08/16/LeetCode-47-%E5%85%A8%E6%8E%92-II/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></p><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><p>输入: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,1,2]</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="Solution1-set去重-："><a href="#Solution1-set去重-：" class="headerlink" title="Solution1(set去重)："></a>Solution1(set去重)：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">    vector&lt;bool&gt; bt;</span><br><span class="line">    int n;</span><br><span class="line">    set&lt;vector&lt;int&gt;&gt; s;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        bt = vector&lt;bool&gt;(n);</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        dfs(0,0,nums);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(int u,int start,vector&lt;int&gt; &amp;nums)&#123;</span><br><span class="line">        if(u == n)&#123;</span><br><span class="line">            if(!s.count(tmp))&#123;</span><br><span class="line">            ans.push_back(tmp);</span><br><span class="line">                s.insert(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            if(!bt[i])&#123;</span><br><span class="line">                bt[i] = true;</span><br><span class="line">                tmp.push_back(nums[i]);</span><br><span class="line">                dfs(u+1,start,nums);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">                bt[i] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>去重问题，首先想到set，比较简单粗暴的都放到set容器里，有重复就不往答案里面去。</p><h3 id="Solution2（排序去重）："><a href="#Solution2（排序去重）：" class="headerlink" title="Solution2（排序去重）："></a>Solution2（排序去重）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">    vector&lt;bool&gt; bt;</span><br><span class="line">    int n;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        bt = vector&lt;bool&gt;(n);</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        dfs(0,0,nums);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    bool judge(int i,vector&lt;int&gt; nums)&#123;</span><br><span class="line">        for(int j = 0; j &lt; i; j++)&#123;</span><br><span class="line">            if(nums[i] == nums[j])&#123;</span><br><span class="line">                if(!bt[j]) return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void dfs(int u,int start,vector&lt;int&gt; &amp;nums)&#123;</span><br><span class="line">        if(u == n)&#123;</span><br><span class="line">            ans.push_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            //如果所选是重复数，并且前面都选过了，才能选择当前的。</span><br><span class="line">            if(!bt[i] &amp;&amp; (i == 0 ? 1 : nums[i-1] == nums[i] ? bt[i-1] : 1))&#123;</span><br><span class="line">                bt[i] = true;</span><br><span class="line">                tmp.push_back(nums[i]);</span><br><span class="line">                dfs(u+1,start,nums);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">                bt[i] = false;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>选择不重复元素的全排列我们已经解决过了，现在我们研究如何去重的问题。</p><p>首先我们发现去重的原因是两个位置不同的相同的数在交换之后，整体排列不变，这样就会产生重复，为了达到去重的目的，我们人为规定，当前元素必须在所有在它之前的元素都已经被选了以后，它才能选。这样，相同元素的相对位置就固定下来，不会发生交换重复问题。所以为了方便，我们把相同的元素排在一起，这时需要先排序。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>费解的开关</title>
      <link href="/2019/08/13/%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/"/>
      <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/97/" target="_blank" rel="noopener">费解的开关</a></p><p>你玩过“拉灯”游戏吗？25盏灯排成一个5x5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。</p><p>我们用数字“1”表示一盏开着的灯，用数字“0”表示关着的灯。下面这种状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10111</span><br><span class="line">01101</span><br><span class="line">10111</span><br><span class="line">10000</span><br><span class="line">11011</span><br></pre></td></tr></table></figure><p>在改变了最左上角的灯的状态后将变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01111</span><br><span class="line">11101</span><br><span class="line">10111</span><br><span class="line">10000</span><br><span class="line">11011</span><br></pre></td></tr></table></figure><p>再改变它正中间的灯后状态将变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01111</span><br><span class="line">11001</span><br><span class="line">11001</span><br><span class="line">10100</span><br><span class="line">11011</span><br></pre></td></tr></table></figure><p>给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。<br>输入格式</p><p>第一行输入正整数n，代表数据中共有n个待解决的游戏初始状态。</p><p>以下若干行数据分为n组，每组数据有5行，每行5个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。<br>输出格式</p><p>一共输出n行数据，每行有一个小于等于6的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。</p><p>对于某一个游戏初始状态，若6步以内无法使所有灯变亮，则输出“-1”。</p><h4 id="数据范围：0-lt-n≤500"><a href="#数据范围：0-lt-n≤500" class="headerlink" title="数据范围：0&lt;n≤500"></a>数据范围：0&lt;n≤500</h4><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">00111</span><br><span class="line">01011</span><br><span class="line">10001</span><br><span class="line">11010</span><br><span class="line">11100</span><br><span class="line"></span><br><span class="line">11101</span><br><span class="line">11101</span><br><span class="line">11110</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line"></span><br><span class="line">01111</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11111</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><h3 id="Solution1（TLE）："><a href="#Solution1（TLE）：" class="headerlink" title="Solution1（TLE）："></a>Solution1（TLE）：</h3><p>我们可以枚举每个开关的状态，然后查看是否全亮，每个开关两个状态（开和关），一共有25个开关，所以复杂度为O(2^25) = 33554432次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int m;</span><br><span class="line">int ans = 26;</span><br><span class="line">void flip(int k)&#123;</span><br><span class="line">    int i = k / 5,j = k % 5;</span><br><span class="line">    m ^= 1 &lt;&lt; k;</span><br><span class="line">    if(j-1 &gt;= 0) m ^= (1 &lt;&lt; (i * 5 + (j-1)));</span><br><span class="line">    if(j+1 &lt; 5) m ^= (1 &lt;&lt; (i *5 + (j+1)));</span><br><span class="line">    if(i-1 &gt;= 0) m ^= (1 &lt;&lt; ((i-1) *5 + j));</span><br><span class="line">    if(i+1 &lt; 5) m ^= (1 &lt;&lt; ((i+1) *5 + j));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int k,int d)&#123;</span><br><span class="line">    if(m == (1&lt;&lt;25)-1)&#123;</span><br><span class="line">        ans = min(ans,d);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(k &gt;= 26) return;</span><br><span class="line">    dfs(k+1,d);</span><br><span class="line">    flip(k);</span><br><span class="line">    dfs(k+1,d+1);</span><br><span class="line">    flip(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    getchar();</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        char c[10];</span><br><span class="line">        m = 0;</span><br><span class="line">        ans = 26;</span><br><span class="line">        for(int i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,c);</span><br><span class="line">            for(int j = 0; j &lt; 5; j++)&#123;</span><br><span class="line">                if(c[j] == &apos;1&apos;) m |= (1 &lt;&lt; (i*5+j));</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%s\\n&quot;,c);</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%#x\\n&quot;,m);</span><br><span class="line">        dfs(0,0);</span><br><span class="line">        if(ans &gt; 6) ans = -1;</span><br><span class="line">        printf(&quot;%d\\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h3><p>我们可以从行的角度来看：<br>如果当前行确定了，我们要让所有的开关打开，就要选把当前行中关闭的灯的下面位置的切换状态。<br>归纳到一般情况，当第一行的状态确定了，我们为了使所有的开关打开，去下一行改变状态，使得当前行的所有灯打开。如此4次后，由于到达了最后一行，这时，我们检查最后一行的灯是否全部亮，（前面4行已经全部亮了）。如果全亮，则当前的选择为一个可选方案，这时更新翻转的次数。</p><p>复杂度为O(n * 2^5)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line"></span><br><span class="line">char m[10][10];</span><br><span class="line">int ans = INF;</span><br><span class="line">int dx[5] = &#123;0,-1,0,1,0&#125;;</span><br><span class="line">int dy[5] = &#123;0,0,1,0,-1&#125;;</span><br><span class="line">void flip(int x,int y)&#123;</span><br><span class="line">    for(int i = 0; i &lt;5; i++)&#123;</span><br><span class="line">        int xi = x + dx[i];</span><br><span class="line">        int yi = y + dy[i];</span><br><span class="line">        if(xi &gt;= 0 &amp;&amp; xi &lt; 5 &amp;&amp; yi &gt;= 0 &amp;&amp; yi &lt; 5)&#123;</span><br><span class="line">            m[xi][yi] ^= 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    char backup[10][10];</span><br><span class="line">    int res = 0;</span><br><span class="line">    memcpy(backup,m,sizeof(m));</span><br><span class="line">    for(int i = 0; i &lt; 1 &lt;&lt; 5; i++)&#123;</span><br><span class="line">        res = 0;</span><br><span class="line">        for(int j = 0; j &lt; 5; j++)&#123;</span><br><span class="line">            if(i &gt;&gt; j &amp; 1)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                flip(0,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 0; j &lt; 4; j++)&#123;</span><br><span class="line">            for(int k = 0; k &lt; 5; k++)&#123;</span><br><span class="line">                if(m[j][k] == &apos;0&apos;)&#123;</span><br><span class="line">                    flip(j+1,k);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bool flag = true;</span><br><span class="line">        for(int j = 0; j &lt; 5; j++)&#123;</span><br><span class="line">            if(m[4][j] == &apos;0&apos;)&#123;</span><br><span class="line">                flag = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag) ans = min(ans,res);</span><br><span class="line">        memcpy(m,backup,sizeof(backup));    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    // freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    getchar();</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        ans = INF;</span><br><span class="line">        for(int i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,m[i]);</span><br><span class="line">            // printf(&quot;%s\\n&quot;,m[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">        if(ans &gt; 6) ans = -1;</span><br><span class="line">        printf(&quot;%d\\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>POJ-1062-昂贵的聘礼</title>
      <link href="/2019/08/13/POJ-1062-%E6%98%82%E8%B4%B5%E7%9A%84%E8%81%98%E7%A4%BC/"/>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=1062" target="_blank" rel="noopener">POJ-1062</a></p><p>年轻的探险家来到了一个印第安部落里。在那里他和酋长的女儿相爱了，于是便向酋长去求亲。酋长要他用10000个金币作为聘礼才答应把女儿嫁给他。探险家拿不出这么多金币，便请求酋长降低要求。酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要8000金币。如果你能够弄来他的水晶球，那么只要5000金币就行了。”探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。另外他要告诉你的是，在这个部落里，等级观念十分森严。地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。他是一个外来人，所以可以不受这些限制。但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。因此你需要在考虑所有的情况以后给他提供一个最好的方案。</p><p>为了方便起见，我们把所有的物品从1开始进行编号，酋长的允诺也看作一个物品，并且编号总是1。每个物品都有对应的价格P，主人的地位等级L，以及一系列的替代品Ti和该替代品所对应的”优惠”Vi。如果两人地位等级差距超过了M，就不能”间接交易”。你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。</p><p>输入第一行是两个整数M，N（1 &lt;= N &lt;= 100），依次表示地位等级差距限制和物品的总数。接下来按照编号从小到大依次给出了N个物品的描述。每个物品的描述开头是三个非负整数P、L、X（X &lt; N），依次表示该物品的价格、主人的地位等级和替代品总数。接下来X行每行包括两个整数T和V，分别表示替代品的编号和”优惠价格”。</p><p>输出最少需要的金币数。</p><h4 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 4</span><br><span class="line">10000 3 2</span><br><span class="line">2 8000</span><br><span class="line">3 5000</span><br><span class="line">1000 2 1</span><br><span class="line">4 200</span><br><span class="line">3000 2 1</span><br><span class="line">4 200</span><br><span class="line">50 2 0</span><br></pre></td></tr></table></figure><h4 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5250</span><br></pre></td></tr></table></figure><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>一开始需要n金币，每个物品都有自己的价值，你可以用其他物品来抵消一部分金币（优惠价格），而用来抵消的物品也可以由其他物品来抵消该物品的一部分，如此往复。并且主人是分等级的，要确保交换物品过程中任何两个人的等级差距都不能超过M。<br>问最少需要的金币数量。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>把每个物品看成结点，B物品可以抵消A物品的一部分,表示A有一条边指向B,边权是替代品的优惠价格，点权为该物品的价值。</p><p>可以求第一个物品到其他物品的最短路，松弛操作为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dis[v] &gt; dis[u] + u到v的边权</span><br></pre></td></tr></table></figure><p>这样求得的dis为每个顶点到起点的优惠价格，而到当前点的总花费为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dis[i] + coin[i] //优惠价格+当前物品的价格</span><br></pre></td></tr></table></figure><p>而题目还有一层约束条件为物品交换不能超过等级差距。<br>我们就需要检查每个点到起点的等级差了。<br>例如起点的等级为5，等级差距为3，则要枚举的区间为 3 ~ 5、4 ~ 6、5 ~ 7 ，在每个区间中，求符合等级差距的点，并求起点到该点的最短路（这里比较绕，建议多思考下）。最后答案取一个最小值即可。</p><h4 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 110;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">    int to,cost;</span><br><span class="line">    Edge()&#123;&#125;;</span><br><span class="line">    Edge(int _to,int _cost)&#123;</span><br><span class="line">        to = _to;</span><br><span class="line">        cost = _cost;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct qnode&#123;</span><br><span class="line">    int v,cost;</span><br><span class="line">    qnode(int _v, int _cost)&#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        cost = _cost;</span><br><span class="line">    &#125;</span><br><span class="line">    qnode()&#123;&#125;</span><br><span class="line">    bool operator &lt;(const qnode &amp;b)const&#123;</span><br><span class="line">        return cost &gt; b.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line">int coin[MAXN]; //价值多少金币 </span><br><span class="line">int dis[MAXN];//最少优惠 </span><br><span class="line">int vis[MAXN];</span><br><span class="line">int pos[MAXN];  //等级 </span><br><span class="line">int M,N;</span><br><span class="line">int ans;</span><br><span class="line"> void Dijkstra(int S,int N)&#123;</span><br><span class="line"> for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line"> dis[i] = S== i ? 0 : INF;</span><br><span class="line"> &#125;</span><br><span class="line">     priority_queue&lt;qnode&gt; pq;</span><br><span class="line">     pq.push(qnode(S,dis[S]));</span><br><span class="line">     qnode temp;</span><br><span class="line">     while(pq.size())&#123;</span><br><span class="line">         temp = pq.top();pq.pop();</span><br><span class="line">         int u = temp.v;</span><br><span class="line">         if(vis[u])continue;</span><br><span class="line">         vis[u] = 1;</span><br><span class="line">         for(int i = 0; i &lt; G[u].size(); i++)&#123;</span><br><span class="line">             int v = G[u][i].to;</span><br><span class="line">             int vc = G[u][i].cost;</span><br><span class="line">             if(!vis[v] &amp;&amp; dis[v] &gt; dis[u] + vc)&#123;</span><br><span class="line">                dis[v] = dis[u] + vc;</span><br><span class="line">                //更新答案 </span><br><span class="line">                ans = min(ans,dis[v] + coin[v]);</span><br><span class="line">                pq.push(qnode(v,dis[v]));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">//     for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">//     ans = min(ans,dis[i] + coin[i]);</span><br><span class="line">// &#125; </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">void init(int N)&#123;</span><br><span class="line">for(int i = 0; i &lt;= N; i++)&#123;</span><br><span class="line">G[i].clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;M,&amp;N);</span><br><span class="line">    init(N);</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        int c,r,n;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;c,&amp;r,&amp;n);</span><br><span class="line">        coin[i] = c;</span><br><span class="line">        pos[i] = r;</span><br><span class="line"></span><br><span class="line">        for(int j = 1; j &lt;= n; j++)&#123;</span><br><span class="line">            int t,cost;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;t,&amp;cost);</span><br><span class="line">            G[i].push_back(Edge(t,cost));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //设最大值为起始值 </span><br><span class="line">    ans = coin[1];</span><br><span class="line">    for(int i = 0; i &lt;= M; i++)&#123;</span><br><span class="line">    //更新每个点是否在当前区间内 </span><br><span class="line">    for(int j = 1; j &lt;= N; j++)&#123;</span><br><span class="line">    if(pos[j] &gt;= pos[1]-M+i &amp;&amp; pos[j] &lt;= pos[1]+i) vis[j] = 0;</span><br><span class="line">    else vis[j] = 1;</span><br><span class="line">&#125;</span><br><span class="line">//求一下当前区间的最短路。 </span><br><span class="line">Dijkstra(1,N);</span><br><span class="line">&#125;</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>POJ-2965-Th-Pilot-Brothers-refrigerator</title>
      <link href="/2019/08/09/POJ-2965-Th-Pilot-Brothers-refrigerator/"/>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=2965" target="_blank" rel="noopener">POJ-2965</a></p><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有一个4X4的冰箱阵列，当你改变一个冰箱门的状态（开或关），同行同列的冰箱门也会发生改变，给定一个序列，问从全部的冰箱门打开（“-”为开、“+”为关）到给定序列需要几步，以及具体的打开方式。</p><h5 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-+--</span><br><span class="line">----</span><br><span class="line">----</span><br><span class="line">-+--</span><br></pre></td></tr></table></figure><h5 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">1 1</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">4 1</span><br><span class="line">4 3</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure><h3 id="Solution1（枚举）"><a href="#Solution1（枚举）" class="headerlink" title="Solution1（枚举）:"></a>Solution1（枚举）:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int m[4][4];</span><br><span class="line">int dx[16],dy[16],ans[16][2];</span><br><span class="line">int ansn = 40;</span><br><span class="line">bool isComplete()&#123;</span><br><span class="line">    for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; 4; j++)&#123;</span><br><span class="line">            if(m[i][j] == 1) return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void flip(int i, int j)&#123;</span><br><span class="line">    for(int k = 0; k &lt; 4; k++)&#123;</span><br><span class="line">        m[k][j] = !m[k][j];</span><br><span class="line">        m[i][k] = !m[i][k];</span><br><span class="line">    &#125;</span><br><span class="line">    //m[i][j]被翻转了两次，再翻转抵消一次。</span><br><span class="line">    m[i][j] = !m[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//d:翻转的次数，s:要翻转的序号</span><br><span class="line">void dfs(int d, int s)&#123;</span><br><span class="line">    if(isComplete())&#123;</span><br><span class="line">        ansn = min(ansn,d);</span><br><span class="line">        for(int i = 0; i &lt; ansn; i++)&#123;</span><br><span class="line">            ans[i][0] = dx[i];</span><br><span class="line">            ans[i][1] = dy[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(s &gt;= 16) return;</span><br><span class="line">    dfs(d,s+1);</span><br><span class="line">    flip(s/4,s%4);</span><br><span class="line">    dx[d] = s/4;</span><br><span class="line">    dy[d] = s%4;</span><br><span class="line">    dfs(d+1,s+1);</span><br><span class="line">    flip(s/4,s%4);</span><br><span class="line">    dx[d] = 0;</span><br><span class="line">    dy[d] = 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; 4; j++)&#123;</span><br><span class="line">            char c;</span><br><span class="line">            scanf(&quot;%c&quot;,&amp;c);</span><br><span class="line">            m[i][j] = c == &apos;+&apos; ? 1 : 0;</span><br><span class="line">        &#125;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(0,0);</span><br><span class="line">    printf(&quot;%d\\n&quot;,ansn);</span><br><span class="line">    for(int i = 0; i &lt; ansn; i++)&#123;</span><br><span class="line">        printf(&quot;%d %d\\n&quot;,ans[i][0]+1,ans[i][1]+1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>直接枚举所有的状态，每个冰箱门都有转换和不转换两种状态，一共有16个冰箱门，所以有2的16次方种状态。<br>在所有的序列中取一个步数最小的即可。</p><h3 id="Solution2（位运算压缩）："><a href="#Solution2（位运算压缩）：" class="headerlink" title="Solution2（位运算压缩）："></a>Solution2（位运算压缩）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dx[16],ans[16];</span><br><span class="line">int ansn = 40;</span><br><span class="line">int state;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void flip(int i, int j)&#123;</span><br><span class="line">    for(int k = 0; k &lt; 4; k++)&#123;</span><br><span class="line">        state = state ^ (1&lt;&lt; (i*4+k));</span><br><span class="line">        state = state ^ (1 &lt;&lt; (k*4+j));</span><br><span class="line">    &#125;</span><br><span class="line">    state = state ^ (1 &lt;&lt; (i*4+j));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//d:翻转的次数，s:要翻转的序号</span><br><span class="line">void dfs(int d, int s)&#123;</span><br><span class="line">    if(!state)&#123;</span><br><span class="line">        //更新结果</span><br><span class="line">        ansn = min(ansn,d);</span><br><span class="line">        for(int i = 0; i &lt; ansn; i++)&#123;</span><br><span class="line">            ans[i] = dx[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(s &gt;= 16) return;</span><br><span class="line">    dfs(d,s+1);</span><br><span class="line">    //翻转</span><br><span class="line">    flip(s/4,s%4);</span><br><span class="line">    //保留翻转的位置</span><br><span class="line">    dx[d] = 1 &lt;&lt; s;</span><br><span class="line">    dfs(d+1,s+1);</span><br><span class="line">    //回溯</span><br><span class="line">    flip(s/4,s%4);</span><br><span class="line">    dx[d] = 0;</span><br><span class="line">&#125;</span><br><span class="line">int Pos(int a)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    while(a)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        a &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; 4; j++)&#123;</span><br><span class="line">            char c;</span><br><span class="line">            scanf(&quot;%c&quot;,&amp;c);</span><br><span class="line">            // m[i][j] = c == &apos;+&apos; ? 1 : 0;</span><br><span class="line">            if(c == &apos;+&apos;)</span><br><span class="line">                state = state | (1 &lt;&lt; (i*4+j));</span><br><span class="line">        &#125;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(0,0);</span><br><span class="line">    printf(&quot;%d\\n&quot;,ansn);</span><br><span class="line">    for(int i = 0; i &lt; ansn; i++)&#123;</span><br><span class="line">        int a  = Pos(ans[i])-1;</span><br><span class="line">        printf(&quot;%d %d\\n&quot;,a/4+1,a%4+1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>在上一题解的基础上，我们发现没有必要用二维数组来存储状态，可以使用一个16位的整数来存储，第几位二进制位表示第几个冰箱的状态。</p><p>记录改变冰箱的位置也同样可以使用一个16位的整数来存储。1表示该冰箱门改变了状态，所有的改变不会超过16个，使用16个整数就可以表示全部的移动的过程。</p><p>然后更新结果，并提取出来每一位即可。</p><h3 id="Solution3（找规律）："><a href="#Solution3（找规律）：" class="headerlink" title="Solution3（找规律）："></a>Solution3（找规律）：</h3><p>通过找规律我们发现：</p><ul><li><p>一个冰箱门状态改变两次等于不变。</p></li><li><p>在上一条的基础上，如果以某一冰箱门为基准，将该冰箱门所在的行列上所有的冰箱门都翻转一次，该冰箱门改变，其他冰箱门都不变。</p></li></ul><p>所以我们只要从结果反向推，将每个关闭的冰箱门所在的行列的冰箱门都翻转，更新每个冰箱门的改变的次数，结果状态就为当所有的关闭的冰箱门都被打开后的状态。当次数为奇数说明我们需要改变，偶数则忽略。最后遍历一遍结果数组，取出次数为奇数的冰箱门的坐标即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int record[16][16];</span><br><span class="line"></span><br><span class="line">void flip(int i, int j)&#123;</span><br><span class="line">    for(int k = 0; k &lt; 4; k++)&#123;</span><br><span class="line">        record[i][k]++;</span><br><span class="line">        record[k][j]++;</span><br><span class="line">    &#125;</span><br><span class="line">    record[i][j]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; 4; j++)&#123;</span><br><span class="line">            char c;</span><br><span class="line">            scanf(&quot;%c&quot;,&amp;c);</span><br><span class="line">            if(c == &apos;+&apos;) flip(i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for(int i = 0; i &lt;4; i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; 4; j++)&#123;</span><br><span class="line">            if(record[i][j]&amp;1) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\\n&quot;,cnt);</span><br><span class="line">    for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; 4; j++)&#123;</span><br><span class="line">            if(record[i][j]&amp;1)&#123;</span><br><span class="line">                printf(&quot;%d %d\\n&quot;,i+1,j+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-785-判断二分图</title>
      <link href="/2019/08/06/LeetCode-785-%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/is-graph-bipartite/" target="_blank" rel="noopener">785. 判断二分图</a></p><p>给定一个无向图graph，当这个图为二分图时返回true。</p><p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p><p>graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">输出: true</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;。</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">输出: false</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br></pre></td></tr></table></figure><p>我们不能将节点分割成两个独立的子集。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><ul><li><p>graph 的长度范围为 [1, 100]。</p></li><li><p>graph[i] 中的元素的范围为 [0, graph.length - 1]。</p></li><li><p>graph[i] 不会包含 i 或者有重复的值。</p></li><li><p>图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。</p></li></ul><h5 id="一个裸二分图染色题。"><a href="#一个裸二分图染色题。" class="headerlink" title="一个裸二分图染色题。"></a>一个裸二分图染色题。</h5><h3 id="Solution1（DFS）："><a href="#Solution1（DFS）：" class="headerlink" title="Solution1（DFS）："></a>Solution1（DFS）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;</span><br><span class="line">        int vis[graph.size()] = &#123;false&#125;;</span><br><span class="line">        for(int i = 0; i &lt; graph.size(); i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; graph[i].size(); j++)&#123;</span><br><span class="line">                if(vis[graph[i][j]] == 0 &amp;&amp; !dfs(graph,vis,graph[i][j],1)) return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool dfs(vector&lt;vector&lt;int&gt;&gt;&amp; G,int vis[],int j, int c)&#123;</span><br><span class="line">        vis[j] = c;</span><br><span class="line">        for(int i = 0; i &lt; G[j].size(); i++)&#123;</span><br><span class="line">            if(vis[G[j][i]] == c) return false;</span><br><span class="line">            if(vis[G[j][i]] == 0 &amp;&amp; !dfs(G,vis,G[j][i],-c)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>二分染色题。<br>重点在dfs函数的编写，到达当前结点，先染色，再判断与之相连的结点的颜色是否被染过，如果没有染过，则染与当前结点不同的颜色，如果染过色且与当前结点颜色相同则表示不符合要求，颜色不同则可以直接忽略。</p><h3 id="Solution2（BFS）"><a href="#Solution2（BFS）" class="headerlink" title="Solution2（BFS）:"></a>Solution2（BFS）:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;</span><br><span class="line">        int vis[graph.size()] = &#123;0&#125;;</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        int curr = -1;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            if(q.size() == 0)&#123;</span><br><span class="line">                int k;</span><br><span class="line">                for(k = 0; k &lt; graph.size(); k++)&#123;</span><br><span class="line">                    if(vis[k] == 0)&#123;</span><br><span class="line">                        q.push(k);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(k == graph.size()) break;</span><br><span class="line">            &#125;</span><br><span class="line">            curr *= -1;</span><br><span class="line">            int len = q.size();</span><br><span class="line">            for(int j = 0; j &lt; len; j++)&#123;</span><br><span class="line">                int f = q.front(); q.pop();</span><br><span class="line">                vis[f] = curr;</span><br><span class="line">                for(int i = 0; i &lt; graph[f].size(); i++)&#123;</span><br><span class="line">                    if(vis[graph[f][i]] == curr) return false;</span><br><span class="line">                    if(vis[graph[f][i]] == 0)&#123;</span><br><span class="line">                        q.push(graph[f][i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>与DFS思路相同，只不过改写为BFS版。</p><blockquote><p>注意：给定的图有可能为多棵树组成的森林。所以每个树都要考虑到。</p></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-207-课程表</title>
      <link href="/2019/08/06/LeetCode-207-%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">207. 课程表</a></p><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p><p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h5><blockquote><p>输入: 2, [[1,0]] </p><p>输出: true</p><p>解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</p></blockquote><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h5><blockquote><p>输入: 2, [[1,0],[0,1]]</p><p>输出: false</p><p>解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</p></blockquote><h3 id="Solution1（DFS）"><a href="#Solution1（DFS）" class="headerlink" title="Solution1（DFS）:"></a>Solution1（DFS）:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        if(numCourses &lt;= 0) return true;</span><br><span class="line">        vector&lt;int&gt; G[numCourses];</span><br><span class="line">        int vis[numCourses] = &#123;0&#125;;</span><br><span class="line">        for(int i = 0; i &lt; numCourses; i++) G[i].clear();</span><br><span class="line">        for(int i = 0; i &lt; prerequisites.size(); i++)&#123;</span><br><span class="line">            G[prerequisites[i][1]].push_back(prerequisites[i][0]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; numCourses; i++)&#123;</span><br><span class="line">            if(!vis[i])&#123;</span><br><span class="line">                if(!dfs(G,vis,i)) return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool dfs(vector&lt;int&gt; G[], int vis[],int j)&#123;</span><br><span class="line">        vis[j] = 2;</span><br><span class="line">        for(int i = 0; i &lt; G[j].size(); i++)&#123;</span><br><span class="line">            if(vis[G[j][i]] == 2) return false;</span><br><span class="line">            if(!vis[G[j][i]])&#123;</span><br><span class="line">                if(!dfs(G,vis,G[j][i])) return false;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        vis[j] = 1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h5><p>把该题看做判断一个有向图是否有环的问题。<br>进而可以看做一个染色问题：</p><ul><li><p>如果该节点没有被访问过，则是白色（用0表示）。</p></li><li><p>如果该节点正在访问，但是没有访问结束，则是灰色（用2表示）。</p></li><li><p>如果该节点已经访问，则是黑色（用1表示）。</p></li></ul><p>只有在DFS中维护颜色数组（我这里为vis数组）即可。</p><h3 id="Solution2（拓扑排序）："><a href="#Solution2（拓扑排序）：" class="headerlink" title="Solution2（拓扑排序）："></a>Solution2（拓扑排序）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        int inDegree[numCourses] = &#123;0&#125;;</span><br><span class="line">        vector&lt;int&gt; G[numCourses];</span><br><span class="line">        for(int i = 0; i &lt; prerequisites.size(); i++)&#123;</span><br><span class="line">            G[prerequisites[i][1]].push_back(prerequisites[i][0]);</span><br><span class="line">            inDegree[prerequisites[i][0]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        int inqnum = 0;</span><br><span class="line">        for(int i = 0; i &lt; numCourses; i++)&#123;</span><br><span class="line">            if(inDegree[i] == 0)&#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(q.size())&#123;</span><br><span class="line">            inqnum++;</span><br><span class="line">            int f = q.front();q.pop();</span><br><span class="line">            for(int i = 0; i &lt; G[f].size(); i++)&#123;</span><br><span class="line">                inDegree[G[f][i]]--;</span><br><span class="line">                if(inDegree[G[f][i]] == 0)&#123;</span><br><span class="line">                    q.push(G[f][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return inqnum == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>利用拓扑排序，每次将节点入度为零所在的边删去并更新边的另一端节点的入度信息，如果在多轮“删边”之后还有结点，说明有环。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Dijkstra算法学习总结</title>
      <link href="/2019/07/31/Dijkstra%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<p>单源最短路径算法</p><h2 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h2><p>对于图G（V，E）维护一个集合S,存放已经被访问过的顶点（准备期间只有源点s），每次从集合V-S中选择与起点s的距离最小的一个顶点（记为u），访问u并加入集合S，并令u为中介点，更新起点s与所有从u能达到的顶点v之间的最短距离。这样执行n次（n为顶点个数），直到集合S包含所有顶点。</p><p><img src="https://note.youdao.com/favicon.ico" alt="算法书上的图"></p><h4 id="适用范围：有向无负权图"><a href="#适用范围：有向无负权图" class="headerlink" title="适用范围：有向无负权图"></a>适用范围：有向无负权图</h4><h3 id="1-优先队列版-复杂度O-ElogE"><a href="#1-优先队列版-复杂度O-ElogE" class="headerlink" title="1.优先队列版 复杂度O(ElogE)"></a>1.优先队列版 复杂度O(ElogE)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line"></span><br><span class="line">struct qnode&#123;</span><br><span class="line">    int v,d;</span><br><span class="line">    qnode(int _v=0,int _d=0):v(_v),d(_d)&#123;&#125;</span><br><span class="line">    friend bool operator &lt;(const qnode &amp;r)const&#123;</span><br><span class="line">        return d&gt;r.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Edge&#123;</span><br><span class="line">    int v,cost;</span><br><span class="line">    Edge(int _v=0,int _cost=0):v(_v),cost(_cost)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">const int MAXN = 100010;</span><br><span class="line">vector&lt;Edge&gt; E[MAXN];</span><br><span class="line">//是否访问标志</span><br><span class="line">int vis[MAXN];</span><br><span class="line">//到源点的最短距离，准备期间设置为无穷大，表示不可及。</span><br><span class="line">int dis[MAXN]; </span><br><span class="line">//加边</span><br><span class="line">void add_edge(int u,int v,int w)&#123;</span><br><span class="line">    E[u].push_back(Edge(v,w));</span><br><span class="line">&#125;</span><br><span class="line">//初始化(从0开始编号)</span><br><span class="line">void init(int n)&#123;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        E[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Dijkstra(int s,int n)&#123;</span><br><span class="line">    for(int i=0;i&lt;n;i++)vis[i] = 0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)dis[i] = (i == s ? 0 : INF);</span><br><span class="line">    priority_queue&lt;qnode&gt; q;//声明优先队列：每次从队列中取出的是具有最高优先权的元素。</span><br><span class="line">    //优先队列第一个参数为比较类型，第二个为容器类型，第三个为比较函数。</span><br><span class="line">//greater实现小顶堆//less 实现大顶堆（默认为大顶堆）</span><br><span class="line">q.push(qnode(s,dis[s]));//先将源点推进优先队列</span><br><span class="line">qnode temp;</span><br><span class="line">    while(!q.empty())&#123;//当队列空时所有边已被访问</span><br><span class="line">        temp = q.top();q.pop();</span><br><span class="line">        //当前顶点</span><br><span class="line">        int u = temp.v;</span><br><span class="line">        if(vis[u])continue;</span><br><span class="line">        vis[u] = true;</span><br><span class="line">        //每一条与u相邻的边都要更新</span><br><span class="line">        for(int i=0;i&lt;E[u].size();i++)&#123;</span><br><span class="line">            //邻点</span><br><span class="line">            int v = E[u][i].v;</span><br><span class="line">            //权重</span><br><span class="line">            int cost = E[u][i].cost;</span><br><span class="line">            //松弛操作，更新权重时机</span><br><span class="line">            if(!vis[v] &amp;&amp; dis[u] + cost &lt; dis[v])&#123;</span><br><span class="line">                dis[v] = dis[u] + cost;</span><br><span class="line">                //把每一个更新的长度加进队列</span><br><span class="line">                q.push(qnode(v,dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-邻接矩阵版-复杂度O-N-2-记录路径版"><a href="#2-邻接矩阵版-复杂度O-N-2-记录路径版" class="headerlink" title="2.邻接矩阵版 复杂度O(N^2) 记录路径版"></a>2.邻接矩阵版 复杂度O(N^2) 记录路径版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">const int MAXN = 10000;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">bool vis[MAXN];//访问记录</span><br><span class="line">int pre[MAXN];//父节点</span><br><span class="line">int cost[MAXN][MAXN];//权重矩阵</span><br><span class="line">int lowcost[MAXN];//记录最短路径</span><br><span class="line"></span><br><span class="line">//初始化矩阵为无穷。</span><br><span class="line">void Init(int N)&#123;</span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">for(int j = 0; j &lt; N; j++)&#123;</span><br><span class="line">cost[i][j] = INF;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//如果INF是满十六进制表示。如：const int INF = 0x3f3f3f3f;</span><br><span class="line">//则可以使用memset(cost,INF,sizeof(cost));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//cost:权重矩阵,lowcost:最短路径，n:数据范围,beg:源点</span><br><span class="line">void Dijkstra(int cost[][MAXN],int lowcost[],int n,int beg)&#123;</span><br><span class="line">//初始化各值</span><br><span class="line">for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">lowcost[i] = INF;</span><br><span class="line">vis[i] = false;</span><br><span class="line">pre[i] = -1;</span><br><span class="line">&#125;</span><br><span class="line">//设置源点</span><br><span class="line">lowcost[beg] = 0;</span><br><span class="line">for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">int k = -1;</span><br><span class="line">int Min = INF;</span><br><span class="line">//找到目前最短路径数组中到源点最短的节点。</span><br><span class="line">for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">if(!vis[i] &amp;&amp; lowcost[i] &lt; Min)&#123;</span><br><span class="line">Min = lowcost[i];</span><br><span class="line">k = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//找不到，说明节点都已经全部访问。</span><br><span class="line">if(k == -1)break;</span><br><span class="line">//记录该节点。</span><br><span class="line">vis[k] = true;</span><br><span class="line">//松弛操作。更新每条与该节点相连并且还未访问到的节点的路径。</span><br><span class="line">for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">if(!vis[i] &amp;&amp; lowcost[k] + cost[k][i] &lt; lowcost[i])&#123;</span><br><span class="line">    //发现一条更短的路径，更新。</span><br><span class="line">lowcost[i] = lowcost[k] + cost[k][i];</span><br><span class="line">//更新父节点。</span><br><span class="line">pre[i] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解题通用思路"><a href="#解题通用思路" class="headerlink" title="解题通用思路"></a>解题通用思路</h3><p>做关于Dijkstra算法的题，通常不会只出一个裸的寻找最短路径，而是会给出一个或多个次级标尺。通常不会超出三个维度：</p><ul><li>边权</li><li>点权</li><li>多少条最短路径，或该路径的长度。</li></ul><p>通常是多个维度组合起来寻找最优解。</p><p>遇到这类问题，可通过将每条最短路径都保存下来，依次进行处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; paths[MAXN];</span><br><span class="line">//在其松弛操作中，将路径保存</span><br><span class="line">for(int j = 0; j &lt; N; j++)&#123;</span><br><span class="line">if(!vis[j] &amp;&amp; G[k][j] != INF)&#123;</span><br><span class="line">if(dis[j] &gt; dis[k] + G[k][j])&#123;</span><br><span class="line">dis[j] = dis[k] + G[k][j];</span><br><span class="line">paths[j].clear();</span><br><span class="line">paths[j].push_back(k);</span><br><span class="line">&#125;else if(dis[j] == dis[k] + G[k][j])&#123;</span><br><span class="line">paths[j].push_back(k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; ans;//用于存放每一个最短路径</span><br><span class="line">vector&lt;int&gt; p;</span><br><span class="line">//计算每条路径，注意，这样的路径是反序并且不包含源点的，如需要，则单独计算。</span><br><span class="line">void makeMinPath(vector&lt;vector&lt;int&gt; &gt; &amp;ans,vector&lt;int&gt; p,int j)&#123;</span><br><span class="line">if(j == 0)&#123;</span><br><span class="line">ans.push_back(p);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; paths[j].size(); i++)&#123;</span><br><span class="line">p.push_back(paths[j][i]);</span><br><span class="line">makeMinPath(ans,p,paths[j][i]);</span><br><span class="line">p.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就可以根据要求计算每一条路径，并挑出符合问题的解了。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>AVL树详解</title>
      <link href="/2019/07/19/AVL%E6%A0%91%E8%AF%A6%E8%A7%A3/"/>
      <content type="html"><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>我们在学习二叉搜索树的时候，发现无论是查找还是插入元素在理想情况下都可以达到O(logN)级别，但是由于插入的顺序，数的结构也会不同，这种理想情况很难保持甚至最坏的情况会退化成链表。导致性能下降。这时就需要一个能实现高度自动平衡的树结构。就出现了平衡树，<br>今天讲的是平衡树的一种：AVL树。</p><h3 id="初识AVL树"><a href="#初识AVL树" class="headerlink" title="初识AVL树"></a>初识AVL树</h3><p>AVL树得名与 Adelson-Velsky和 Landis两位发明者的首字母，它是自平衡的二叉搜索树，具有二叉树搜索树的性质（左子树的结点都比当前结点小，右子树都比当前结点大），同时它又是平衡二叉树，能够自适应高度。在AVL树中，<strong>任意节点的两个子树的高度差不超过1</strong>，这也是将不平衡的子树调整为平衡子树的重要指标。</p><h3 id="AVL树的调整策略"><a href="#AVL树的调整策略" class="headerlink" title="AVL树的调整策略"></a>AVL树的调整策略</h3><p>AVL是在进行插入节点时，通过检测是否破坏了平衡条件，进而通过进行一定程度的节点旋转来达到整棵树的平衡。</p><h3 id="简单情形"><a href="#简单情形" class="headerlink" title="简单情形"></a>简单情形</h3><p>我们知道一个树如果只有一个或两个时，树是平衡的。所以问题会出现在第三个节点插入的位置，如果是下图：</p><p><img src="https://note.youdao.com/favicon.ico" alt="单左旋后"></p><p>则是平衡的。</p><p>先来看最简单的不平衡情况：</p><p><img src="https://note.youdao.com/favicon.ico" alt="单左旋前"></p><p>当把根节点的右节点“提”到根节点的位置，将旧根节点当新的根节点的左子节点。就可达到平衡状态。</p><p><img src="https://note.youdao.com/favicon.ico" alt="单左旋后"></p><p>具体到树中，可以归结为以下四种情况：</p><h4 id="1-左旋"><a href="#1-左旋" class="headerlink" title="1.左旋"></a>1.左旋</h4><p>上述是最特殊的只有三个节点的情况，下面我们将它代入一般的二叉树来研究：</p><p>对于一个节点，当右子树的高度比左子树高一个高度的时候，此时新进来的节点也需要插入右子树。当然，如果新插入节点以后，右子树还维持原来的高度，那么这颗树就还是平衡的。问题出在当新插入节点后，右子树的高度增加了，这时破坏了平衡树两个子树的高度差不超过一的性质，就需要调整使其达到平衡状态。这时，我们首先考虑比较好处理的情况，也就是插在右子树的右边的情况。</p><p><img src="https://note.youdao.com/favicon.ico" alt="左旋前"></p><p>调整的策略：</p><p>此时我们需要将当前节点的右子树“提”到当前节点的位置，当前节点“下降”为其右子树的左子树，具体操作过程如图：</p><p><img src="https://note.youdao.com/favicon.ico" alt="左旋中1"></p><p><img src="/images/placeholder.png" alt="左旋中2" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p><p>调整之后变为：</p><p><img src="/images/placeholder.png" alt="左旋后" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p><p>到此，树变成了平衡的，由于整棵树要往左边旋转，所以左旋的操作就右子树的地位上移，根节点的地位下降。</p><h3 id="2-右旋"><a href="#2-右旋" class="headerlink" title="2.右旋"></a>2.右旋</h3><p>现在我们有了左旋的经验，很容易推出需要进行右旋操作的时机：</p><p>对于一个节点，当左子树的高度原先就比右子树的高度多一时，插入节点又使左子树的高度增加，并且插在了左子树的左边的时候，就需要调整了：</p><p><img src="/images/placeholder.png" alt="右旋前" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p><p><img src="/images/placeholder.png" alt="右旋中1" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p><p><img src="/images/placeholder.png" alt="右旋中2" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p><p><img src="/images/placeholder.png" alt="右旋后" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p><p>树变为平衡的。</p><p>至此，单旋转就学习完毕，下面学习双旋转。</p><h3 id="3-右左旋"><a href="#3-右左旋" class="headerlink" title="3.右左旋"></a>3.右左旋</h3><p>前面我们学习单旋转时，插入节点都是与其子树同向的位置，这种情况由于倾斜的状况比较明显，所以只要找到中间的位置，将其“提”到“根节点”的位置，就可以达到平衡。而当其中子树失去平衡是由于所处子树往相反的方向插入，导致倾斜的状况不容易看出，所以需要经过两次旋转来达到平衡状态。<br>如下图：</p><p><img src="/images/placeholder.png" alt="右左旋前" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p><p>我们可以观察到，在当前的结点的右子树的倾斜情况与我们刚才介绍到的右旋的情况很相似：</p><p><img src="/images/placeholder.png" alt="右左旋前1" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p><p>所以将右子树按右旋处理，处理之后变为：</p><p><img src="/images/placeholder.png" alt="左旋前" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p><p>这时我们惊奇的发现它变成了我们前面介绍的左旋前时的情形。这种情况我们已经会处理了：将右子节点“提”上来，把当前“根”节点变为右子节点的左子树，最后就调整到平衡状态了。</p><p><img src="/images/placeholder.png" alt="左旋后" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p><h3 id="4-左右旋"><a href="#4-左右旋" class="headerlink" title="4.左右旋"></a>4.左右旋</h3><p>同样地，左右旋也可通过先将左子树左旋，再将当前根节点右旋的调整来达到平衡状态。</p><p><img src="/images/placeholder.png" alt="左右旋前" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p><p>先将左子树左旋：</p><p><img src="/images/placeholder.png" alt="左右旋前1" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p><p><img src="/images/placeholder.png" alt="右旋前" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p><p>再进行右旋：</p><p><img src="/images/placeholder.png" alt="右旋后" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p><p>达到平衡状态。</p><hr><p>到此，二叉树的调整策略就介绍完了，下面上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">typedef struct AVLNode* AVLTree;</span><br><span class="line">struct AVLNode&#123;</span><br><span class="line">int data;</span><br><span class="line">AVLTree left;</span><br><span class="line">AVLTree right;</span><br><span class="line">int height;</span><br><span class="line">AVLNode(int data):data(data)&#123;</span><br><span class="line">left = NULL;</span><br><span class="line">right = NULL;</span><br><span class="line">height = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Max(int a, int b)&#123;</span><br><span class="line">return a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetHeight(AVLTree t)&#123;</span><br><span class="line">if(!t) return 0;</span><br><span class="line">return t-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//右旋 </span><br><span class="line">AVLTree SingleRightRotation(AVLTree A)&#123;</span><br><span class="line">//先记录左子树,将左节点的右子树变为根节点的左子树，再将根节点作为左节点的右子树。 </span><br><span class="line">AVLTree l = A-&gt;left;</span><br><span class="line">A-&gt;left = l-&gt;right;</span><br><span class="line">l-&gt;right = A;</span><br><span class="line">//更新两节点的高度。 </span><br><span class="line">A-&gt;height = Max(GetHeight(A-&gt;left),GetHeight(A-&gt;right))+1;</span><br><span class="line">l-&gt;height = Max(GetHeight(l-&gt;left),A-&gt;height) + 1;</span><br><span class="line">return l; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//左旋 </span><br><span class="line">AVLTree SingleLeftRotation(AVLTree A)&#123;</span><br><span class="line">//先记录右子树,将右节点的左子树变为根节点的右子树，再将根节点作为右节点的左子树。 </span><br><span class="line">AVLTree r = A-&gt;right;</span><br><span class="line">A-&gt;right = r-&gt;left;</span><br><span class="line">r-&gt;left = A;</span><br><span class="line">//更新两节点的高度。 </span><br><span class="line">A-&gt;height = Max(GetHeight(A-&gt;left),GetHeight(A-&gt;right)) + 1;</span><br><span class="line">r-&gt;height = Max(GetHeight(r-&gt;right),A-&gt;height) + 1;</span><br><span class="line">return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//右左旋 </span><br><span class="line">AVLTree DoubleRightLeftRotation(AVLTree A)&#123;</span><br><span class="line">//将左子树右旋 </span><br><span class="line">A-&gt;right = SingleRightRotation(A-&gt;right);</span><br><span class="line">//再将当前节点左旋 </span><br><span class="line">return SingleLeftRotation(A);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//左右旋 </span><br><span class="line">AVLTree DoubleLeftRightRotation(AVLTree A)&#123;</span><br><span class="line">//将右子树左旋 </span><br><span class="line">A-&gt;left = SingleLeftRotation(A-&gt;left);</span><br><span class="line">//再将当前节点右旋 </span><br><span class="line">return SingleRightRotation(A);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">AVLTree Insert(AVLTree T, int X)&#123;</span><br><span class="line">if(!T)&#123;</span><br><span class="line">T = new AVLNode(X);</span><br><span class="line">&#125;else if(X &lt; T-&gt;data)&#123;</span><br><span class="line">T-&gt;left = Insert(T-&gt;left,X);</span><br><span class="line">if(GetHeight(T-&gt;left)- GetHeight(T-&gt;right) == 2)&#123;</span><br><span class="line">if(X &lt; T-&gt;left-&gt;data)&#123; //右旋 </span><br><span class="line">T = SingleRightRotation(T);</span><br><span class="line">&#125;else&#123; //左右旋 </span><br><span class="line">T = DoubleLeftRightRotation(T);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else if(X &gt; T-&gt;data)&#123;</span><br><span class="line">T-&gt;right = Insert(T-&gt;right,X);</span><br><span class="line">if(GetHeight(T-&gt;right)- GetHeight(T-&gt;left) == 2)&#123;</span><br><span class="line">if(X &gt; T-&gt;right-&gt;data)&#123; //左旋 </span><br><span class="line">T = SingleLeftRotation(T);</span><br><span class="line">&#125;else&#123; //右左旋 </span><br><span class="line">T = DoubleRightLeftRotation(T);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//更新高度 </span><br><span class="line">T-&gt;height = Max(GetHeight(T-&gt;left),GetHeight(T-&gt;right))+1;</span><br><span class="line">return T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>106-从中序与后序遍历序列构造二叉树</title>
      <link href="/2019/07/13/LeetCode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. 从中序与后序遍历序列构造二叉树</a></p><h3 id="根据一棵树的中序遍历与后序遍历构造二叉树。"><a href="#根据一棵树的中序遍历与后序遍历构造二叉树。" class="headerlink" title="根据一棵树的中序遍历与后序遍历构造二叉树。"></a>根据一棵树的中序遍历与后序遍历构造二叉树。</h3><blockquote><p>注意:<br>你可以假设树中没有重复的元素。</p></blockquote><p>例如，给出</p><p>中序遍历 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure><p>后序遍历 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postorder = [9,15,7,20,3]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* makeTree(vector&lt;int&gt;&amp; postorder, int&amp; postindex, vector&lt;int&gt;&amp; inorder,int left, int right)&#123;</span><br><span class="line">        if(left &lt;= right)&#123;</span><br><span class="line">            for(int i = 0; i &lt; inorder.size(); i++)&#123;</span><br><span class="line">                if(postorder[postindex] == inorder[i])&#123;</span><br><span class="line"></span><br><span class="line">                    TreeNode* root = new TreeNode(postorder[postindex--]);</span><br><span class="line">                    root-&gt;right = makeTree(postorder,postindex,inorder,i+1,right);</span><br><span class="line">                    root-&gt;left = makeTree(postorder,postindex,inorder,left,i-1);  </span><br><span class="line">                    return root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        int postindex = postorder.size()-1;</span><br><span class="line">        return makeTree(postorder,postindex,inorder,0,inorder.size()-1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>根据后序遍历的特点，每棵子树的根节点总是最后遍历到。</p><p>所以用一个按引用传递的指针指向后序数组的末尾，用该值在中序数组中查找，并将该值当做当前树的根节点。</p><p>该值位置的左边为以该节点为根节点的左子树的范围，位置右边为右子树的范围，然后不断更新这个范围，递归下去即可，注意边界值。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>正则表达式全解——正则基础</title>
      <link href="/2019/06/02/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E5%9F%BA%E7%A1%80/"/>
      <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h3 id="正则基础"><a href="#正则基础" class="headerlink" title="正则基础"></a>正则基础</h3><h5 id=""><a href="#" class="headerlink" title="^"></a>^</h5><p>表示一行的开始</p><h5 id="-1"><a href="#-1" class="headerlink" title="$"></a>$</h5><p>表示一行的结束</p><h5 id="…"><a href="#…" class="headerlink" title="[…]"></a>[…]</h5><p>表示其中的字符是选择性（逻辑或）的，要么是a,要么是b,要么是…。</p><blockquote><p>c[a|b]t 可以匹配到cat、cbt<br>[a-z]、[0-9]、[0-9A-Za-z]是支持的。<br>[^$] 匹配空行<br>像 . * + ?  这些词在[]中仅表示字面的意思，利用这一特性，如果想表示原本含义，例如要匹配 . ，可以写为[.]</p></blockquote><h5 id="…-1"><a href="#…-1" class="headerlink" title="[^…]"></a>[^…]</h5><p>表示匹配不是其中的字符。为上一条的取反</p><h5 id="-2"><a href="#-2" class="headerlink" title="-"></a>-</h5><p>连字符，表示一个范围，见上一条。</p><blockquote><p>如果要匹配  - ，请将 - 写在开始位置，如果[-a-z]，匹配-或者是小写字母。</p></blockquote><h5 id="-3"><a href="#-3" class="headerlink" title="."></a>.</h5><p>   表示任意字符（除了换行符），</p><h5 id="-4"><a href="#-4" class="headerlink" title="|"></a>|</h5><p>表示或者</p><blockquote><p>(cat|dog) 表示要么cat,要么dog,<br>注意：这和[…]不同的是，[…]匹配其中的单个字符，(..|…)可以匹配不同的字符组。</p></blockquote><h5 id="-5"><a href="#-5" class="headerlink" title="?"></a>?</h5><p>表示可选项，类似于单选框，匹配零个或一个。</p><h5 id="-6"><a href="#-6" class="headerlink" title="+"></a>+</h5><p>表示出现一次或多次。</p><h5 id="-7"><a href="#-7" class="headerlink" title="*"></a>*</h5><p>表示匹配零次或多次。</p><h5 id="min-max"><a href="#min-max" class="headerlink" title="{min,max}"></a>{min,max}</h5><p>表示匹配之前的子表达式重复min到max次。（闭区间）</p><blockquote><p>{count} 表示匹配count次。</p></blockquote><h5 id="括号与反向引用"><a href="#括号与反向引用" class="headerlink" title="括号与反向引用"></a>括号与反向引用</h5><p>([0-9]){2,3}add\1    \1表示第一个括号中的内容再次使用。</p><h5 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h5><p>像 . * + ?  这些词在正则中有特殊的含义，要想使用它原本的含义，使用\来进行转义。</p><h5 id="…-2"><a href="#…-2" class="headerlink" title="(…)"></a>(…)</h5><p>括号的作用：1.限制多选结构，2.分组，3.捕获文本。</p><h5 id="一些特殊的字符"><a href="#一些特殊的字符" class="headerlink" title="一些特殊的字符"></a>一些特殊的字符</h5><ul><li>\t 制表符</li><li>\n换行符</li><li>\r 回车符</li><li>\s 任何空白字符(例如空格符、制表符、换行符等)</li><li>\S 除\s之外的任何字符(所以用(\s|\S) * )来表示任意字符。</li><li>\w 相当于[a-zA-Z0-9] 所以经常用\w+来表示一个单词 </li><li>\W \w取反，也就是[^a-zA-Z0-9] </li><li>\d  相当于[0-9] 也就是数字</li><li>\D \d取反，也就是[^0-9]</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>写在大一期末考试之际</title>
      <link href="/2019/06/01/%E5%86%99%E5%9C%A8%E5%A4%A7%E4%B8%80%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E4%B9%8B%E9%99%85/"/>
      <content type="html"><![CDATA[<h3 id="写在大一期末考试之际"><a href="#写在大一期末考试之际" class="headerlink" title="写在大一期末考试之际"></a>写在大一期末考试之际</h3><p>最近发生了很多各种各样的事，面对即将到来的期末考试，自己真的很没有底气，因为只有自己知道，对于大部分的课程，学的是如何糟糕。我不看重的课程不说，但数学学科的课程自己也没学到什么，一方面是老师的原因，但最多的是自己的问题，学习的重心绝对的向专业偏移，即使是专业，每天学的都是些业务类的技术，如果是这样，我觉得我可以立即辍学，这也不是我上大学的初衷，一定要向研究的方向转变，把数学基础提上来才是我大学应该做的事，大学时光1/4已经过去了，自己却没有调整到合适的状态，实属不应该。不过，也有些收获，算法竞赛这块是我没有预料到的，同时回想自己大一上学期学算法的时候是我最想要的状态，我不知道自己是不是喜欢，但无暇他顾地专心只搞一件事是我想要的，而通过学习它我可以进入这种状态，后来学长又找我说想打acm，我知道这个的难度，也知道意味着什么，但是我觉得人应该有些梦想，先让我做一年试试。</p><p>同时，我的学习方法也有很多的不足，很低效，我觉得得花些时间来调整下，通常都是学的快，忘的更快，再要用的时候，又要重新学（虽然会快很多），这也是我写博客项目的原因，一个是记录，一个是整理。记录是记录时光的流逝，整理是整理学习成果。要好好把博客写好了。慢就是快，就像姜文说的：步子迈大了，容易扯着蛋。我时刻提醒自己，一定不能浮起来，要沉下去。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-98-验证二叉搜索树</title>
      <link href="/2019/05/30/LeetCode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/comments/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></p><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; v;</span><br><span class="line">        inorder(root,v);</span><br><span class="line">        for(int i = 1; i &lt; v.size(); i++)&#123;</span><br><span class="line">            if(v[i-1]-&gt;val &gt;= v[i]-&gt;val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void inorder(TreeNode* node, vector&lt;TreeNode*&gt; &amp;v)&#123;</span><br><span class="line">        if(!node) return;</span><br><span class="line">        inorder(node-&gt;left,v);</span><br><span class="line">        v.push_back(node);</span><br><span class="line">        inorder(node-&gt;right,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用二叉搜索树的中序遍历是升序的特性。</p><p>将每个元素push进一个vector中，如果vector中元素不是按升序排列，这该树不是二叉搜索树。</p><h3 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        return helper(root,NULL,NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    //返回该结点是否在指定区间内。</span><br><span class="line">    bool helper(TreeNode *node, TreeNode *min, TreeNode *max)&#123;</span><br><span class="line">        if(!node) return true;</span><br><span class="line">        if((min &amp;&amp; node-&gt;val &lt;= min-&gt;val) || (max &amp;&amp; node-&gt;val &gt;= max-&gt;val)) return false;</span><br><span class="line">        //左子节点的值不能比当前结点的值大，右节点的值不能不当前结点小。</span><br><span class="line">        return helper(node-&gt;left, min, node) &amp;&amp; helper(node-&gt;right, node, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据题目给的三条性质，所有结点及其下面的所有结点均可以构成二叉搜索树，</p><p>所以对于非叶子结点，可以以当前结点为根据，划分区间，区间内的点必须比左端点大，比右端点小。</p><p>用一个递归函数来不断更新该区间，判断该结点是否在区间内即可。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-922-按奇偶排序数-II</title>
      <link href="/2019/05/30/LeetCode-922-%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0-II/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/submissions/" target="_blank" rel="noopener">922. 按奇偶排序数组 II</a></p><p>给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。</p><p>对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int len = A.size();</span><br><span class="line">        int j = 1;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            while(i &lt; len &amp;&amp; (A[i] &amp; 1) == 0) i+=2;</span><br><span class="line">            while(j &lt; len &amp;&amp; (A[j] &amp; 1) != 0) j+=2;</span><br><span class="line">            if(i &gt;= len || j &gt;= len) break;</span><br><span class="line">            std::swap(A[i],A[j]);</span><br><span class="line">            i+=2;</span><br><span class="line">            j+=2;</span><br><span class="line">        &#125;</span><br><span class="line">        return A;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>设置两个指针。<br>一个指针只走奇数下标，一个指针只走偶数下标。<br>当碰到不符合条件（奇数下标的值不是奇数，偶数下标的值不是偶数）就停下并交换两个值，之后接着走，直到指针越界为止。</p><blockquote><p>看评论有人用栈或者另外准备两个数组的，速度比原地交换还快，不知道为什么。实现也比较简单，就不赘述了。</p></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-78-子集</title>
      <link href="/2019/05/30/LeetCode-78-%E5%AD%90%E9%9B%86/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/subsets/comments/" target="_blank" rel="noopener">78. 子集</a></p><h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><p>对于每一项相对每个子集来说，都有放与不放两种选择。</p><p>创建一个放元素的递归函数，该函数的作用为将一项<strong>放</strong>和<strong>不放</strong>两种选择进行描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">        vector&lt;int&gt; item;</span><br><span class="line">        result.push_back(item);</span><br><span class="line">        </span><br><span class="line">        putitem(0, nums, item, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    //把一项放进result中。</span><br><span class="line">    void putitem(int i, vector&lt;int&gt;&amp; nums,vector&lt;int&gt; item, vector&lt;vector&lt;int&gt; &gt; &amp;result)&#123;</span><br><span class="line">        if(i == nums.size())&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //每个元素都有放和不放两种选择。</span><br><span class="line">        //放</span><br><span class="line">        item.push_back(nums[i]);</span><br><span class="line">        result.push_back(item);</span><br><span class="line">        putitem(i+1, nums, item, result);</span><br><span class="line">        //不放</span><br><span class="line">        item.pop_back();</span><br><span class="line">        putitem(i+1, nums, item, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h3><h5 id="遍历，遇到一个数就把所有子集加上该数组成新的子集，遍历完毕即是所有子集"><a href="#遍历，遇到一个数就把所有子集加上该数组成新的子集，遍历完毕即是所有子集" class="headerlink" title="遍历，遇到一个数就把所有子集加上该数组成新的子集，遍历完毕即是所有子集"></a>遍历，遇到一个数就把所有子集加上该数组成新的子集，遍历完毕即是所有子集</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">        vector&lt;int&gt; item;</span><br><span class="line">        result.push_back(item);</span><br><span class="line">        for(int i =0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            int s = result.size();</span><br><span class="line">            for(int j = 0; j &lt; s;j++)&#123;</span><br><span class="line">                result.push_back(result[j]);</span><br><span class="line">                result[j].push_back(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution3（位运算）："><a href="#Solution3（位运算）：" class="headerlink" title="Solution3（位运算）："></a>Solution3（位运算）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">        //子集一共有2的n次方种，使用位运算来解。</span><br><span class="line">        //每一位代表一个元素。</span><br><span class="line">        //如，100 代表[3]、011代表[2,1]。</span><br><span class="line">        int all_set = 1 &lt;&lt; nums.size();//2的n次方种；</span><br><span class="line">        for(int i = 0; i &lt; all_set; i++)&#123;</span><br><span class="line">            vector&lt;int&gt; item;</span><br><span class="line">            for(int j = 0; j &lt; nums.size(); j++)&#123;</span><br><span class="line">                //如果i的第j位为1，说明，有这一位所代表的元素。</span><br><span class="line">                // （1 &lt;&lt; j）第j位为1，其他位为0。</span><br><span class="line">                // i &amp; (1 &lt;&lt; j)， i 这个数中，j这一位是不是为1。（i中是否包含这个元素）</span><br><span class="line">                if(i &amp; (1 &lt;&lt; j))&#123;</span><br><span class="line">                    item.push_back(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //将该子集放入集合中。</span><br><span class="line">            result.push_back(item);</span><br><span class="line">            item.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-88-合并两个有序数组</title>
      <link href="/2019/05/30/LeetCode-88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-sorted-array/submissions/" target="_blank" rel="noopener">88. 合并两个有序数组</a></p><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><blockquote><p>说明:</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p></blockquote><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int tail = m + n -1;</span><br><span class="line">        int nums1tail = m-1;</span><br><span class="line">        int nums2tail = n-1;</span><br><span class="line">        while(nums1tail &gt;= 0 &amp;&amp; nums2tail &gt;= 0)&#123;</span><br><span class="line">            if(nums1[nums1tail] &gt;= nums2[nums2tail])&#123;</span><br><span class="line">                nums1[tail] = nums1[nums1tail--];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                nums1[tail] = nums2[nums2tail--];</span><br><span class="line">            &#125;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        while(nums2tail &gt;= 0)</span><br><span class="line">            nums1[tail--] = nums2[nums2tail--];</span><br><span class="line">        while(nums1tail &gt;= 0)</span><br><span class="line">            nums1[tail--] = nums1[nums1tail--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与归并排序的merge代码类似，不过是从数组的末尾往前比较。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-92-反转链-II</title>
      <link href="/2019/05/30/LeetCode-92-%E5%8F%8D%E8%BD%AC%E9%93%BE-II/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a></p><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* reverseBetween(struct ListNode* head, int m, int n) &#123;</span><br><span class="line">    int chang_len = n-m+1;//逆置的结点个数。</span><br><span class="line">    struct ListNode* prevHead = NULL;//记录开始逆置结点的前驱。</span><br><span class="line">    struct ListNode* result = head;//用于最后返回。</span><br><span class="line">    while(head &amp;&amp; --m)&#123; //到达开始逆置的位置。</span><br><span class="line">        prevHead = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    struct ListNode * modify_list_tail = head;//将该结点之前当前开始逆置的结点。</span><br><span class="line">    struct ListNode * newHead = NULL;//用于逆置结点。</span><br><span class="line">    while(head &amp;&amp; chang_len)&#123;</span><br><span class="line">        struct ListNode * next = head-&gt;next;</span><br><span class="line">        head-&gt;next = newHead;</span><br><span class="line">        newHead = head;</span><br><span class="line">        head = next;</span><br><span class="line">        chang_len--;</span><br><span class="line">    &#125;</span><br><span class="line">    //此时head就到了n处，modify_list_tail就到了逆置段的最后一个结点。</span><br><span class="line">    //将modify_list_tail 与 head连接。</span><br><span class="line">    modify_list_tail-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">    if(prevHead)&#123; //如果prevHead不为空，说明不是从第一个几点开始逆置的。 m &gt; 1。</span><br><span class="line">        prevHead-&gt;next = newHead;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        result = newHead; //如果prevHead为空， 则说明是从第一个就开始逆置，直接将逆置后的头结点赋值给res，m=1。</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>解决这个问题主要是要找关键节点。</p><p>这个题的关键节点为：</p><ul><li>要逆置的结点的前一个结点（prevHead）。</li><li>要逆置的第一个结点。（直接用head来探测）。</li><li>要逆置的最后一个结点。（此结点为逆置前的第一个结点，逆置后就变为了最后一个结点）</li><li>要逆置的最后一个结点的后一个结点。（在用head逆置后，head就到了逆置后的这个结点。）</li></ul><ol><li>找到前两个结点。</li><li>从m开始，到n，一共需要n-m+1个结点需要逆置。所以要逆置n-m+1次。</li><li>将逆置后的尾结点 与 逆置段后面一个结点相连。</li><li>如果结点是从开始逆置，将逆置后的头结点返回。否则，将前面的结点与逆置后的头结点链接返回。</li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-59-螺旋矩-II</title>
      <link href="/2019/05/30/LeetCode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9-II/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">59. 螺旋矩阵 II</a></p><p>给定一个正整数 n，生成一个包含 1 到 n² 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>与<a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. 螺旋矩阵</a>类似。</p><p>只需要依次给新数组中的相应元素赋值即可。</p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n<span class="number">-1</span>, up = <span class="number">0</span>, down = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; up &lt; down)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i = left, j = up;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; right)&#123;</span><br><span class="line">                res[j][i] = k++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">while</span>(j &lt; down)&#123;</span><br><span class="line">                res[j][i] = k++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &gt; left)&#123;</span><br><span class="line">                res[j][i] = k++;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; up)&#123;</span><br><span class="line">                res[j][i] = k++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            up++;</span><br><span class="line">            down--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//形不成圈（单列或者单行）</span></span><br><span class="line">        <span class="keyword">if</span>(up == down)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">                res[up][left++] = k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(up &lt;= down)&#123;</span><br><span class="line">                res[up++][left] = k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-693-交替位二进制数</title>
      <link href="/2019/05/30/LeetCode-693-%E4%BA%A4%E6%9B%BF%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/" target="_blank" rel="noopener">693. 交替位二进制数</a></p><p>给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。</p><blockquote><p>示例 1:</p><p>输入: 5</p><p>输出: True</p><p>解释:<br>5的二进制数是: 101</p></blockquote><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasAlternatingBits(int n) &#123;</span><br><span class="line">        //如果是奇偶交替，则n ^ (n &gt;&gt; 1) 会使有效位全为1，</span><br><span class="line">        int temp = n ^ (n &gt;&gt; 1);</span><br><span class="line">        //有效位全为1 再加1， 得到有效位前面为1，后面全为0，再与该数与，则全部清零。</span><br><span class="line">        return (temp &amp; (temp+1)) == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-476-数字的补数</title>
      <link href="/2019/05/30/LeetCode-476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-complement/" target="_blank" rel="noopener">476. 数字的补数</a></p><p>给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。</p><p>注意:</p><ul><li>给定的整数保证在32位带符号整数的范围内。</li><li>你可以假定二进制数不包含前导零位。<br>示例 1:</li></ul><blockquote><p>输入: 5</p><p>输出: 2</p><p>解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。</p></blockquote><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findComplement(int num) &#123;</span><br><span class="line">        int cot = 0;</span><br><span class="line">        int temp = num;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            if(num == 0) break;</span><br><span class="line">            num = num &gt;&gt; 1;</span><br><span class="line">            cot++;</span><br><span class="line">        &#125; </span><br><span class="line">        int mark = 0xffffffff;</span><br><span class="line">        return ~temp ^ (mark &lt;&lt; cot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先找到该数是从哪一位开始才算有效（即不包含前面零的位置。）<br>再将该数所有位取反，<br>然后用全位置的1左移cot次，与值异或即可。</p><blockquote><p>异或：不同为一，相同为零，所以当前面的零取反后成为一后，相应位置与1异或，会恢复成为0，之后的有效位还保持不变。</p></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-51-N皇后</title>
      <link href="/2019/05/30/LeetCode-51-N%E7%9A%87%E5%90%8E/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></p><p>该题为著名的n皇后问题。</p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        vector&lt;string&gt; mark;</span><br><span class="line">        vector&lt;string&gt; queenposition;</span><br><span class="line">        vector&lt;vector&lt;string&gt; &gt; map;</span><br><span class="line">        //初始化。</span><br><span class="line">        string a = &quot;&quot;;</span><br><span class="line">        for(int i = 0; i &lt; n;i++)&#123;</span><br><span class="line">            a = a + &quot;.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            queenposition.push_back(a);</span><br><span class="line">            mark.push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dfs(mark,queenposition,map,0,n);</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">    void putOneQueen(vector&lt;string&gt; &amp;mark,int x,int y,int n)&#123;</span><br><span class="line">        static const int dx[8] = &#123;-1,-1,-1,0,0,1,1,1&#125;;</span><br><span class="line">        static const int dy[8] = &#123;-1,0,1,-1,1,-1,0,1&#125;;</span><br><span class="line">        </span><br><span class="line">        mark[x][y] = &apos;1&apos;;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; 8; i++)&#123;</span><br><span class="line">            int nx = x + dx[i],ny = y+dy[i]; </span><br><span class="line">            while(0 &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; n)&#123;</span><br><span class="line">                mark[nx][ny] = &apos;1&apos;;</span><br><span class="line">                nx += dx[i];</span><br><span class="line">                ny += dy[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    void dfs(vector&lt;string&gt; &amp;mark,vector&lt;string&gt; &amp;queenposition,vector&lt;vector&lt;string&gt; &gt; &amp;map,int col,int n)&#123;</span><br><span class="line">        //出口</span><br><span class="line">        if(col == n)&#123;</span><br><span class="line">            map.push_back(queenposition);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; n;i++)&#123;</span><br><span class="line">            if(mark[col][i] == &apos;.&apos;)&#123;//可以放皇后 </span><br><span class="line">                vector&lt;string&gt; temp_mark = mark;//记录回溯前的镜像。</span><br><span class="line">                //放皇后。 </span><br><span class="line">                queenposition[col][i] = &apos;Q&apos;;</span><br><span class="line">                putOneQueen(mark,col,i,n);</span><br><span class="line">                //递归调用。 </span><br><span class="line">                dfs(mark,queenposition,map,col+1,n);</span><br><span class="line">                //回溯 </span><br><span class="line">                mark = temp_mark;</span><br><span class="line">                queenposition[col][i] = &apos;.&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该题考查对递归与回溯算法的掌握。</p><p>使用一个矩阵来存储是否可以放皇后的状态。<br>每当一行放置了一个皇后后，更新其状态，并在下一行中挑选合适的位置来放置该行的皇后。</p><p>直到每一行都放置了皇后，保存状态，返回上一个递归过程。</p><p>回溯主要针对矩阵的状态和皇后放置的位置，以便利于递归返回过程中的再次使用。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-45-跳跃游-II</title>
      <link href="/2019/05/30/LeetCode-45-%E8%B7%B3%E8%B7%83%E6%B8%B8-II/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></p><p>此题<a href="https://leetcode-cn.com/problems/jump-game/comments/" target="_blank" rel="noopener">55. 跳跃游戏</a>的进阶版</p><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>按照前面题的思路，依然是从后往前搜索。<strong>每次搜索能跳到当前位置的最远位置。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 选择当前能跳到当前点的最远的距离。</span><br><span class="line">        int max_index = nums.size()-1;</span><br><span class="line">        int current_max_index = max_index;</span><br><span class="line">        int step = 0;</span><br><span class="line">        //当没有到达开头位置，进行循环。</span><br><span class="line">        while(max_index &gt; 0)&#123;</span><br><span class="line">            //记录能跳到当前数组的最前面的点。</span><br><span class="line">            for(int i = max_index-1; i &gt;= 0; i--)&#123;</span><br><span class="line">                if(i + nums[i] &gt;= max_index)&#123;</span><br><span class="line">                    current_max_index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             //更新能跳的最远的点。</span><br><span class="line">            max_index = current_max_index;</span><br><span class="line">            //步数更新</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        return step;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用了两层循环，发现能ac，但是又排在了末名。</p><p>看了大神的代码，写出了下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size() &lt; 2)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //当前可到达的最远距离。</span><br><span class="line">        int current_max_index = nums[0];</span><br><span class="line">        //遍历各个位置中，可到达的最远距离。</span><br><span class="line">        int pre_max_max_index = nums[0];</span><br><span class="line">        int jump = 1;</span><br><span class="line">        </span><br><span class="line">        for(int i = 1; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            //更新当前可达到的最远距离。</span><br><span class="line">            if(i &gt; current_max_index)&#123;</span><br><span class="line">                jump++;</span><br><span class="line">                current_max_index = pre_max_max_index;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pre_max_max_index &lt; nums[i] + i)&#123;</span><br><span class="line">                //更新</span><br><span class="line">                pre_max_max_index = nums[i] + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return jump;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>跳到当前所能跳到的最远的位置所在的位置中</strong>。</p><p>记录当前位置所能到达的最远的位置。</p><p>如果做到了该最远位置，更新一下。继续走。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-389-找不同</title>
      <link href="/2019/05/30/LeetCode-389-%E6%89%BE%E4%B8%8D%E5%90%8C/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-the-difference/submissions/" target="_blank" rel="noopener">389. 找不同</a></p><p>给定两个字符串 s 和 t，它们只包含小写字母。</p><p>字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 t 中被添加的字母。</p><blockquote><p>示例:</p><p>输入：<br>s = “abcd”<br>t = “abcde”</p><p>输出：<br>e</p><p>解释：<br>‘e’ 是那个被添加的字母。</p></blockquote><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    char findTheDifference(string s, string t) &#123;</span><br><span class="line">        char e = 0;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++) e ^= s[i];</span><br><span class="line">        for(int i = 0; i &lt; t.size(); i++) e ^= t[i];</span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与<a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a>一样的思路，考察异或的使用。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-40-组合总-II</title>
      <link href="/2019/05/30/LeetCode-40-%E7%BB%84%E5%90%88%E6%80%BB-II/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></p><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><blockquote><p>示例 1: </p><p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]</p><p>示例 2:</p><p>输入: candidates = [2,5,2,1,2], target = 5,<br>所求解集为:<br>[<br>  [1,2,2],<br>  [5]<br>]</p></blockquote><p>该题为<a href="https://leetcode-cn.com/problems/subsets-ii/submissions/" target="_blank" rel="noopener">90. 子集 II</a>的升级版</p><p>与上题相同的是，都要保证元素的非重复性，所以与上题使用set部分的代码是一致的。</p><p>区别在于在进行递归的过程中，需要随时对条件进行判断，只有满足等于target，才往result中添加。</p><p>并且在剪枝的时候，如果元素之和已经比target大，就没有必要进行下去了，直接退出即可。</p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">        vector&lt;int&gt; item;</span><br><span class="line">        //去重所使用的集合</span><br><span class="line">        set&lt;vector&lt;int&gt;&gt; item_set;</span><br><span class="line">        //对nums进行排序。</span><br><span class="line">        sort(candidates.begin(),candidates.end());</span><br><span class="line">        putitem(0, candidates, result, item, item_set,target, 0);</span><br><span class="line">        return result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    void putitem(int i, vector&lt;int&gt;&amp; nums,vector&lt;vector&lt;int&gt; &gt; &amp;result, vector&lt;int&gt; &amp;item, set&lt;vector&lt;int&gt;&gt; &amp;item_set,int target, int sum)&#123;</span><br><span class="line">        if(i &gt;= nums.size() || sum &gt; target) return;</span><br><span class="line">        </span><br><span class="line">        sum += nums[i];</span><br><span class="line">        item.push_back(nums[i]);</span><br><span class="line">        //如果没有重复，就加入到最终的集合里。</span><br><span class="line">        if(sum == target &amp;&amp; item_set.find(item) == item_set.end())&#123;</span><br><span class="line">            result.push_back(item);</span><br><span class="line">            //加入去重集合中。</span><br><span class="line">            item_set.insert(item);</span><br><span class="line">        &#125;</span><br><span class="line">        putitem(i+1, nums, result, item, item_set, target, sum);</span><br><span class="line">        sum -= nums[i];</span><br><span class="line">        item.pop_back();</span><br><span class="line">        putitem(i+1, nums, result, item, item_set, target, sum);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-240-搜索二维矩-II</title>
      <link href="/2019/05/30/LeetCode-240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9-II/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii" target="_blank" rel="noopener">240. 搜索二维矩阵 II</a></p><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。</li></ul><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = matrix[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; matrix.size() &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == matrix[i][j]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[i][j]) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; matrix[i][j]) j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p> 从矩阵的左上角出发，如果比目标值大，向左移，如果比目标值小，向下移。出界或找到则结束。</p><p> 对于一列，如果比当前值小，说明不在当前列中，列减一（缩小搜索范围）。<br> 对于一行，如果比当前值小，则往前移动一个位置。</p><p> 经过不断缩小范围（以经过的点划矩形），就可以得知目标值是否存在矩阵中。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-234.回文链表</title>
      <link href="/2019/05/30/LeetCode-234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/submissions/" target="_blank" rel="noopener">234.回文链表</a></p><h3 id="请判断一个链表是否为回文链表。"><a href="#请判断一个链表是否为回文链表。" class="headerlink" title="请判断一个链表是否为回文链表。"></a>请判断一个链表是否为回文链表。</h3><h5 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//获得链表长度</span><br><span class="line">int getListLength(ListNode* head)&#123;</span><br><span class="line">    int len = 0;</span><br><span class="line">    while(head)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        ListNode* head1 = head;</span><br><span class="line">        int listlen = getListLength(head1);</span><br><span class="line">        if(listlen &lt;= 1) return true;</span><br><span class="line">        int mid = listlen/2;</span><br><span class="line">        std::stack&lt;int&gt; s;</span><br><span class="line">        while(mid &amp;&amp; head)&#123;</span><br><span class="line">            s.push(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            mid--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(listlen%2 != 0)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(head)&#123;</span><br><span class="line">            if(head-&gt;val != s.top())&#123;</span><br><span class="line">               return false; </span><br><span class="line">            &#125;</span><br><span class="line">            s.pop();</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h5><p>借助stack。</p><p>将mid之前的元素值都push进stack中，然后到mid之后，将每个元素与栈顶值比较。不相等退出，相等继续下一轮。</p><hr><h5 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//获得链表长度</span><br><span class="line">int getListLength(ListNode* head)&#123;</span><br><span class="line">    int len = 0;</span><br><span class="line">    while(head)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据位置与所给链表，向后移动position步。</span><br><span class="line">ListNode* getNodeByPosition(ListNode* head,int position)&#123;</span><br><span class="line">    while(position&gt;0)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        position--;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        //存储头结点。</span><br><span class="line">        ListNode* first = head;</span><br><span class="line">        ListNode* head1 = head;</span><br><span class="line">        int listlen = getListLength(head);</span><br><span class="line">        int midposition = listlen/2;</span><br><span class="line">        //如果链表长度&lt;=1，直接返回true;</span><br><span class="line">        if(listlen &lt;= 1) return true;</span><br><span class="line">        //到达需要翻转的长度，对于偶数，为（listlen/2）+1，对于奇数，为listlen/2;</span><br><span class="line">        ListNode* mid = getNodeByPosition(head1,midposition);</span><br><span class="line">        //翻转mid之后的指针。</span><br><span class="line">        ListNode * newHead = NULL;</span><br><span class="line">        int position = listlen-midposition;</span><br><span class="line">        while(mid &amp;&amp; position)&#123;</span><br><span class="line">            ListNode* next = mid-&gt;next;</span><br><span class="line">            mid-&gt;next = newHead;</span><br><span class="line">            newHead = mid;</span><br><span class="line">            mid = next;</span><br><span class="line">            position--;</span><br><span class="line">        &#125;</span><br><span class="line">        //将翻转之后的链表与开头的链表的内容比较，向后比较listlen/2;</span><br><span class="line">        //如果是偶数，则元素都会比较到，如果是奇数，最后一个元素不会比较到。他在原来的链表中就处于中心位置，不必比较。</span><br><span class="line">        while(first &amp;&amp; newHead &amp;&amp; midposition)&#123;</span><br><span class="line">            //只要不相等，就为false;</span><br><span class="line">            if(first-&gt;val != newHead-&gt;val) return false;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            newHead = newHead-&gt;next;</span><br><span class="line">            midposition--;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>将链表的后半段翻转，从翻转位置开始与从头结点开始，依次比较（listlen/2次）。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-235-二叉搜索树的最近公共祖先</title>
      <link href="/2019/05/30/LeetCode-235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">235. 二叉搜索树的最近公共祖先</a></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><h3 id="Solution1（递归版）："><a href="#Solution1（递归版）：" class="headerlink" title="Solution1（递归版）："></a>Solution1（递归版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)&#123;</span><br><span class="line">            return lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">        &#125;else if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)&#123;</span><br><span class="line">            return lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ONELINE版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        return ((root-&gt;val - p-&gt;val) * (root-&gt;val - q-&gt;val) &lt; 1) ? root: lowestCommonAncestor(root-&gt;val &lt; p-&gt;val ? root-&gt;right : root-&gt;left, p, q ) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(root-&gt;val - p-&gt;val) * (root-&gt;val - q-&gt;val) &lt; 1</span><br></pre></td></tr></table></figure><p>这段代码表示给定的两个结点是否在当前节点的两个不同的子树上，或者两个节点中有节点与当前所在节点相同。如果是，则该节点就是最近公共祖先。如果不是，说明在同一棵子树上，转移到该子树上继续递归调用。</p><h3 id="Solution2（迭代版）："><a href="#Solution2（迭代版）：" class="headerlink" title="Solution2（迭代版）："></a>Solution2（迭代版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        while((root-&gt;val - p-&gt;val) * (root-&gt;val - q-&gt;val) &gt; 0)&#123;</span><br><span class="line">            root = root-&gt;val &gt; p-&gt;val ? root-&gt;left : root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与上面思路类似。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-22-括号生成</title>
      <link href="/2019/05/30/LeetCode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></p><h3 id="给出-n-代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。"><a href="#给出-n-代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。" class="headerlink" title="给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。"></a>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</h3><p>例如，给出 n = 3，生成结果为：</p><blockquote><p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p></blockquote><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        putone(&quot;&quot;,n,n,result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    void putone(string item, int left, int right, vector&lt;string&gt; &amp;result)&#123;</span><br><span class="line">       if(left == 0 &amp;&amp; right == 0)&#123;</span><br><span class="line">           result.push_back(item);</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">        //只要left还能放。</span><br><span class="line">        if(left &gt; 0)&#123;</span><br><span class="line">            putone(item+ &quot;(&quot;,left-1,right,result);</span><br><span class="line">        &#125;</span><br><span class="line">        //left放的比right多，</span><br><span class="line">        if(left &lt; right)&#123;</span><br><span class="line">            putone(item+ &quot;)&quot;,left,right-1,result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用递归+回溯来解决。</p><p>该题主要是要找放括号的时机。</p><p>首先要先放左括号。</p><p>第二，只要放左括号的个数比右括号多，就可以放右括号。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-167-两数之-I--输入有序数组</title>
      <link href="/2019/05/30/LeetCode-167-%E4%B8%A4%E6%95%B0%E4%B9%8B-I--%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></p><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><blockquote><p>说明:</p><p>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br>示例:</p><p>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p></blockquote><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</span><br><span class="line">        vector&lt;int&gt; a;</span><br><span class="line">        int lower = 0;</span><br><span class="line">        int higher = numbers.size()-1;</span><br><span class="line">        while(lower &lt; higher)&#123;</span><br><span class="line">            if(numbers[lower] + numbers[higher] &lt; target)&#123;</span><br><span class="line">                lower++;</span><br><span class="line">            &#125;else if(numbers[lower] + numbers[higher] &gt; target)&#123;</span><br><span class="line">                higher--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                a.push_back(lower+1);</span><br><span class="line">                a.push_back(higher+1);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用双指针技巧，一个从前扫描，一个从后扫描。符合条件退出。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-190-颠倒二进制位</title>
      <link href="/2019/05/30/LeetCode-190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">190. 颠倒二进制位</a></p><p>颠倒给定的 32 位无符号整数的二进制位。</p><blockquote><p>示例 1：</p><p>输入: 00000010100101000001111010011100</p><p>输出: 00111001011110000010100101000000</p><p>解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，<br>      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</p></blockquote><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    uint32_t reverseBits(uint32_t n) &#123;</span><br><span class="line">        uint32_t t = 0;</span><br><span class="line">        int i = 32;</span><br><span class="line">        while(i--)&#123;</span><br><span class="line">            t &lt;&lt;= 1;</span><br><span class="line">            //获得原数第一位的状态。</span><br><span class="line">            int a = n&amp;1;</span><br><span class="line">            //将该状态赋给该数第一位。</span><br><span class="line">            t |= a;</span><br><span class="line">            //原数右移。</span><br><span class="line">            n &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路：</p><p>初始化一个全位置为0的数，将原数的最后一位赋给该数的最后一位，原数右移，该数左移，如此32次。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-191-位1的个-&amp;- 231-2的幂</title>
      <link href="/2019/05/30/LeetCode-191-%E4%BD%8D1%E7%9A%84%E4%B8%AA-&amp;-%20231-2%E7%9A%84%E5%B9%82/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">191. 位1的个数</a></p><h3 id="编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为-‘1’-的个数（也被称为汉明重量）。"><a href="#编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为-‘1’-的个数（也被称为汉明重量）。" class="headerlink" title="编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。"></a>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</h3><h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingWeight(uint32_t n) &#123;</span><br><span class="line">        int cot = 0;</span><br><span class="line">        while(n)&#123;</span><br><span class="line">            cot += n&amp;1;</span><br><span class="line">            n &gt;&gt;= 1; </span><br><span class="line">        &#125;</span><br><span class="line">        return cot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>将每一位移到最后一位检查是否为1，到0为止，最后返回个数。</p><p>由于是无符号整型，每次都会执行32次，所以时间复杂度是O(1)。</p><p>Solution2（优化）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingWeight(uint32_t n) &#123;</span><br><span class="line">        int cot = 0;</span><br><span class="line">        while(n)&#123;</span><br><span class="line">            n &amp;= (n-1);</span><br><span class="line">            cot++;</span><br><span class="line">        &#125;</span><br><span class="line">        return cot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看了官方题解，这种方法是每一次将最后一个1给消除。这样顶多执行k次，k就为1的个数。这样就又优化了一点点计算。</p><blockquote><p>eg：</p><p>11010 &amp; 11001 = 11000</p><p>11000 &amp; 10111 = 10000</p><p>10000 &amp; 01111 = 0</p></blockquote><h3 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231. 2的幂"></a>231. 2的幂</h3><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p><p>有了上面的思路：</p><p>这道题就可以写成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPowerOfTwo(int n) &#123;</span><br><span class="line">        return n &gt; 0 &amp;&amp; !(n &amp; (n-1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2的n次方在二进制中就是只有1个位置是1，其他全是0（对于正数）。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-142-环形链-II</title>
      <link href="/2019/05/30/LeetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE-II/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></p><h3 id="给定一个链表，返回链表开始入环的第一个节点。-如果链表无环，则返回-null。"><a href="#给定一个链表，返回链表开始入环的第一个节点。-如果链表无环，则返回-null。" class="headerlink" title="给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。"></a>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</h3><h5 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        std::set&lt;ListNode*&gt; node_set;</span><br><span class="line">        while(head)&#123;</span><br><span class="line">            if(node_set.find(head) == node_set.end())&#123;</span><br><span class="line">                node_set.insert(head);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与141号问题的Solutions1一个思路，直接使用set。只不过返回的是结点不是boolean值罢了。</p><hr><h5 id="Solutions2"><a href="#Solutions2" class="headerlink" title="Solutions2:"></a>Solutions2:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode * head1 = head;</span><br><span class="line">        ListNode * slow = head;</span><br><span class="line">        ListNode * fast = head;</span><br><span class="line">        //fast走一步，slow走两步</span><br><span class="line">        while(fast)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            if(fast)&#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;else&#123; //没有环退出</span><br><span class="line">                return NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            //有环退出循环</span><br><span class="line">            if(fast == slow)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //说明有环</span><br><span class="line">        while(head1 &amp;&amp; fast)&#123;</span><br><span class="line">            if(head1 == fast)&#123;</span><br><span class="line">                return fast;</span><br><span class="line">            &#125;</span><br><span class="line">            head1 = head1-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        //不会走到这步，只是为了保证函数正常运行</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>这种方法只会使用O(1)的空间。</p><p>该方法的思路需要一点数学基础：</p><p>在一个有环的链表中，slow指针与fast指针相遇，从该相遇的位置开始，与链表的头位置开始，两者走同样的步数，如果两者相交，就走到了环的开始位置。</p><p><img src="http://pkjge38r4.bkt.clouddn.com/18-12-30/36603912.jpg" alt="image"></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-153-寻找旋转排序数组中的最小值</title>
      <link href="/2019/05/30/LeetCode-153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></p><h5 id="假设按照升序排序的数组在预先未知的某个点上进行了旋转。"><a href="#假设按照升序排序的数组在预先未知的某个点上进行了旋转。" class="headerlink" title="假设按照升序排序的数组在预先未知的某个点上进行了旋转。"></a>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</h5><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><h5 id="请找出其中最小的元素。"><a href="#请找出其中最小的元素。" class="headerlink" title="请找出其中最小的元素。"></a>请找出其中最小的元素。</h5><p>你可以假设数组中不存在重复元素。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int lo = 0;</span><br><span class="line">        int hi = nums.size()-1;</span><br><span class="line">        while(lo &lt; hi)&#123;</span><br><span class="line">            int mid = (lo+hi)/2;</span><br><span class="line">            //如果比右边大，说明在逆序数组中。</span><br><span class="line">            //从mid位置的下一个元素继续查找。</span><br><span class="line">            if(nums[mid] &gt; nums[hi])&#123;</span><br><span class="line">                lo = mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果不比右边的大，说明已在正序数组中。</span><br><span class="line">            // 缩小右边的范围。</span><br><span class="line">            else&#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //hi == lo</span><br><span class="line">        return nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<strong>二分法</strong>。</p><p>当中间元素比右边界要大时，说明在逆序数组中，这时，令lo = mid + 1。</p><p>否则说明在顺序数组中，不断缩小范围直到 lo = hi 时，返回。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-136-只出现一次的数字</title>
      <link href="/2019/05/30/LeetCode-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></p><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><blockquote><p>示例 1:</p><p>输入: [2,2,1]<br>输出: 1</p></blockquote><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int a = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            a = a ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用异或来消除相同的元素。<br>异或：<br>两数相同，异或为0；<br>两数不同，异或为1；</p><ul><li>a ^ a = 0;</li><li>a ^ 0 = a;</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-113-路径总-II</title>
      <link href="/2019/05/30/LeetCode-113-%E8%B7%AF%E5%BE%84%E6%80%BB-II/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/path-sum-ii/submissions/" target="_blank" rel="noopener">113. 路径总和 II</a></p><p>该题为<a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">112. 路径总和</a>的升级版</p><blockquote><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p></blockquote><h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">        vector&lt;int&gt; path;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">        if(root)&#123;</span><br><span class="line">            dfs(root,0,sum,path,result);</span><br><span class="line">        &#125; </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void dfs(TreeNode* node,int currentsum, int sum,vector&lt;int&gt; &amp;path,vector&lt;vector&lt;int&gt; &gt; &amp;result)&#123;</span><br><span class="line">        currentsum += node-&gt;val;</span><br><span class="line"></span><br><span class="line">        path.push_back(node-&gt;val);</span><br><span class="line">        //当到达叶子结点，并且路径之和与sum相同</span><br><span class="line">        if(node &amp;&amp; !node-&gt;left &amp;&amp; !node-&gt;right )&#123;</span><br><span class="line">            if(currentsum == sum)</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(node-&gt;left)&#123;</span><br><span class="line">            dfs(node-&gt;left,currentsum,sum,path,result);</span><br><span class="line">            //回溯，还原状态</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        if(node-&gt;right)&#123;</span><br><span class="line">            dfs(node-&gt;right,currentsum,sum,path,result);</span><br><span class="line">            //回溯，还原状态</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">        vector&lt;int&gt; path;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">        preorder(root,0,sum,path,result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    void preorder(TreeNode* node, int currentsum, int sum, vector&lt;int&gt; &amp;path, vector&lt;vector&lt;int&gt; &gt; &amp;result)&#123;</span><br><span class="line">        if(!node) return;</span><br><span class="line">        currentsum += node-&gt;val;</span><br><span class="line">        path.push_back(node-&gt;val);</span><br><span class="line">        if(!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; currentsum == sum)&#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        preorder(node-&gt;left,currentsum,sum,path,result);</span><br><span class="line">        preorder(node-&gt;right,currentsum,sum,path,result);</span><br><span class="line">        //该步可有可无，因为只会递归到叶子节点才返回，又每次递归都在栈中保留了原来该值的副本。</span><br><span class="line">        // currentsum -= node-&gt;val;</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-112-路径总和</title>
      <link href="/2019/05/30/LeetCode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">112. 路径总和</a></p><blockquote><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>说明: 叶子节点是指没有子节点的节点。</p></blockquote><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">        if(!root) return false;</span><br><span class="line">        return dfs(root,0,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool dfs(TreeNode* node,int currentsum, int sum)&#123;</span><br><span class="line">        currentsum += node-&gt;val;</span><br><span class="line">        if(node &amp;&amp; !node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; currentsum == sum)</span><br><span class="line">            return true;</span><br><span class="line">        bool a = false,b = false;</span><br><span class="line">        if(node-&gt;left)&#123;</span><br><span class="line">            a = dfs(node-&gt;left,currentsum,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        if(node-&gt;right)&#123;</span><br><span class="line">            b = dfs(node-&gt;right,currentsum,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        return a || b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归终止条件为叶子节点。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-107-二叉树的层次遍-II</title>
      <link href="/2019/05/30/LeetCode-107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D-II/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">107. 二叉树的层次遍历 II</a></p><h5 id="给定一个二叉树，返回其节点值自底向上的层次遍历。-（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）"><a href="#给定一个二叉树，返回其节点值自底向上的层次遍历。-（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）" class="headerlink" title="给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）"></a>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</h5><p>该题为 <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal" target="_blank" rel="noopener">102. 二叉树的层次遍历</a>的进阶版。</p><p>有关<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal" target="_blank" rel="noopener">102. 二叉树的层次遍历</a>的题解，请参考<a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/submissions/" target="_blank" rel="noopener">429. N叉树的层序遍历</a>，具体思路是一样的，不再赘述。</p><h3 id="Solution1（迭代版）："><a href="#Solution1（迭代版）：" class="headerlink" title="Solution1（迭代版）："></a>Solution1（迭代版）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curLayerNodes;</span><br><span class="line">            TreeNode* t;</span><br><span class="line">            <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">                t = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                curLayerNodes.push_back(t-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.emplace(res.begin(),curLayerNodes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution2（递归版）："><a href="#Solution2（递归版）：" class="headerlink" title="Solution2（递归版）："></a>Solution2（递归版）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        preorder(root,<span class="number">1</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* node, <span class="keyword">int</span> depth, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.size() &lt; depth)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">            t.push_back(node-&gt;val);</span><br><span class="line">            res.emplace(res.begin(), t);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[res.size()-depth].push_back(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        preorder(node-&gt;left, depth+<span class="number">1</span>, res);</span><br><span class="line">        preorder(node-&gt;right, depth+<span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具体思路就是增加一层，就将该层放到头位置。</p><blockquote><p>vector.emplace()配合vector.begin()实现插到头位置。</p></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-101. 对称二叉树</title>
      <link href="/2019/05/30/LeetCode-101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></p><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><h3 id="Solution1（递归版）："><a href="#Solution1（递归版）：" class="headerlink" title="Solution1（递归版）："></a>Solution1（递归版）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode* t1, TreeNode* t2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//都为NULL</span></span><br><span class="line">        <span class="keyword">if</span>(!t1 &amp;&amp; !t2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//有一个结点为NULL，另一个不为NULL</span></span><br><span class="line">        <span class="keyword">if</span>(!t1 || !t2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (t1-&gt;val == t2-&gt;val) &amp;&amp; isMirror(t1-&gt;left, t2-&gt;right)</span><br><span class="line">            &amp;&amp; isMirror(t1-&gt;right, t2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看的官方题解。</p><p>把一棵对称树分成左子树和右子树。</p><p>如果左子树和右子树对称，则该数相同。</p><p>扩展到一般概念就是：</p><ul><li>有两棵树。</li><li>两棵树的根节点相同。</li><li>每个树的右子树都与另一个树的左子树镜像对称。</li></ul><p>翻译为递推公式就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* t1,t2;</span><br><span class="line">t1-&gt;val == t2-&gt;val;</span><br><span class="line">t1-&gt;left == t2-&gt;right;</span><br><span class="line">t1-&gt;right = t2-&gt;left;</span><br></pre></td></tr></table></figure><p>结束条件为两棵树为空。</p><p>整理可得上述代码。</p><h3 id="Solution2（迭代版）："><a href="#Solution2（迭代版）：" class="headerlink" title="Solution2（迭代版）："></a>Solution2（迭代版）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode* t1 = q.front(); q.pop();</span><br><span class="line">            TreeNode* t2 = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!t1 &amp;&amp; !t2) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!t1 || !t2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(t1-&gt;val != t2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            q.push(t1-&gt;left);</span><br><span class="line">            q.push(t2-&gt;right);</span><br><span class="line">            q.push(t2-&gt;left);</span><br><span class="line">            q.push(t1-&gt;right);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>翻译为了迭代版，只不过根本的思想是一样的。都是将一棵树化为两棵树来进行判断的。</p><h3 id="Solution3（中序迭代版）："><a href="#Solution3（中序迭代版）：" class="headerlink" title="Solution3（中序迭代版）："></a>Solution3（中序迭代版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        stack&lt;TreeNode*&gt; lefts,rights;</span><br><span class="line">        TreeNode* l = root-&gt;left;</span><br><span class="line">        TreeNode* r = root-&gt;right;</span><br><span class="line">        while(l || r || lefts.size())&#123;</span><br><span class="line">            while(l &amp;&amp; r)&#123;</span><br><span class="line">                lefts.push(l),l = l-&gt;left;</span><br><span class="line">                rights.push(r), r = r-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l || r) return false;</span><br><span class="line">            l = lefts.top();lefts.pop();</span><br><span class="line">            r = rights.top(); rights.pop();</span><br><span class="line">            if(l-&gt;val != r-&gt;val) return false;</span><br><span class="line">            l = l-&gt;right,r = r-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>PAT《团体程序设计天梯赛-练习集》-L3-01-二叉搜索树的结-（3-分）</title>
      <link href="/2019/05/30/PAT%E3%80%8A%E5%9B%A2%E4%BD%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E7%BB%83%E4%B9%A0%E9%9B%86%E3%80%8B-L3-01-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%BB%93-%EF%BC%883-%E5%88%86%EF%BC%89/"/>
      <content type="html"><![CDATA[<p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805047903240192" target="_blank" rel="noopener">L3-016 二叉搜索树的结构 （30 分）</a></p><h4 id="二叉搜索树或者是一棵空树，或者是具有下列性质的二叉树：-若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。（摘自百度百科）"><a href="#二叉搜索树或者是一棵空树，或者是具有下列性质的二叉树：-若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。（摘自百度百科）" class="headerlink" title="二叉搜索树或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。（摘自百度百科）"></a>二叉搜索树或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。（摘自百度百科）</h4><p>给定一系列互不相等的整数，将它们顺次插入一棵初始为空的二叉搜索树，然后对结果树的结构进行描述。你需要能判断给定的描述是否正确。例如将{ 2 4 1 3 0 }插入后，得到一棵二叉搜索树，则陈述句如“2是树的根”、“1和4是兄弟结点”、“3和0在同一层上”（指自顶向下的深度相同）、“2是4的双亲结点”、“3是4的左孩子”都是正确的；而“4是2的左孩子”、“1和3是兄弟结点”都是不正确的。</p><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>输入在第一行给出一个正整数N（≤100），随后一行给出N个互不相同的整数，数字间以空格分隔，要求将之顺次插入一棵初始为空的二叉搜索树。之后给出一个正整数M（≤100），随后M行，每行给出一句待判断的陈述句。陈述句有以下6种：</p><ul><li>A is the root，即”A是树的根”；</li><li>A and B are siblings，即”A和B是兄弟结点”；</li><li>A is the parent of B，即”A是B的双亲结点”；</li><li>A is the left child of B，即”A是B的左孩子”；</li><li>A is the right child of B，即”A是B的右孩子”；</li><li>A and B are on the same level，即”A和B在同一层上”。<br>题目保证所有给定的整数都在整型范围内。</li></ul><h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>对每句陈述，如果正确则输出Yes，否则输出No，每句占一行。</p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode* left;</span><br><span class="line">TreeNode* right;</span><br><span class="line">TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>)&#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rootval;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;val &gt; val)&#123;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">insertNode(root-&gt;left,val);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">TreeNode* t = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">root-&gt;left = t; </span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; val)&#123;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">insertNode(root-&gt;right,val);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">TreeNode* t = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">root-&gt;right = t; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isContainNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;val == val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;val &gt; val) <span class="keyword">return</span> isContainNode(root-&gt;left,val);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> isContainNode(root-&gt;right,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt;<span class="string">""</span>;</span><br><span class="line">printTree(root-&gt;left);</span><br><span class="line">printTree(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRoot</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val == rootval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">parent</span><span class="params">(TreeNode *root, <span class="keyword">int</span> child)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!isContainNode(root,child) || root-&gt;val == child) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">TreeNode* res = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>((root-&gt;left &amp;&amp; root-&gt;left-&gt;val == child) || (root-&gt;right &amp;&amp; root-&gt;right-&gt;val == child))&#123;</span><br><span class="line">res = root;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &gt; child)&#123;</span><br><span class="line">root = root-&gt;left;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; child)&#123;</span><br><span class="line">root = root-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSibling</span><span class="params">(TreeNode* root, <span class="keyword">int</span> valA, <span class="keyword">int</span> valB)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(valA == root-&gt;val || valB == root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//找到A的父亲</span></span><br><span class="line">TreeNode* t = parent(root, valA); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(t)&#123;</span><br><span class="line"><span class="keyword">if</span>(t-&gt;left &amp;&amp; t-&gt;left-&gt;val == valA )&#123;</span><br><span class="line"><span class="keyword">return</span> t-&gt;right &amp;&amp; t-&gt;right-&gt;val == valB;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;right &amp;&amp; t-&gt;right-&gt;val == valA )&#123;</span><br><span class="line"><span class="keyword">return</span> t-&gt;left &amp;&amp; t-&gt;left-&gt;val == valB;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(root-&gt;val == val) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;val &gt; val) <span class="keyword">return</span> <span class="number">1</span> + getDepth(root-&gt;left,val);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span> + getDepth(root-&gt;right,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameLevel</span><span class="params">(TreeNode* root, <span class="keyword">int</span> A, <span class="keyword">int</span> B)</span></span>&#123;</span><br><span class="line"><span class="comment">//A != B &amp;&amp; </span></span><br><span class="line"><span class="keyword">return</span> isContainNode(root,A) &amp;&amp; isContainNode(root,B) &amp;&amp; getDepth(root, A) == getDepth(root, B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pirntMassage</span><span class="params">(<span class="keyword">bool</span> info)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(info)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isParent</span><span class="params">(TreeNode* root, <span class="keyword">int</span> parentVal, <span class="keyword">int</span> childVal)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(parent(root, childVal) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> parentVal == parent(root, childVal)-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeftChild</span><span class="params">(TreeNode* root, <span class="keyword">int</span> parentVal, <span class="keyword">int</span> leftChildVal)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(parent(root, leftChildVal) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">TreeNode* p = parent(root, leftChildVal);</span><br><span class="line"><span class="keyword">return</span> parentVal == p-&gt;val &amp;&amp; p-&gt;left-&gt;val == leftChildVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRightChild</span><span class="params">(TreeNode* root, <span class="keyword">int</span> parentVal, <span class="keyword">int</span> rightChildVal)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(parent(root, rightChildVal) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">TreeNode* p = parent(root, rightChildVal);</span><br><span class="line"><span class="keyword">return</span> parentVal == p-&gt;val &amp;&amp; p-&gt;right-&gt;val == rightChildVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span>(c &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; rootval;</span><br><span class="line">TreeNode* root = <span class="keyword">new</span> TreeNode(rootval);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; c; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">insertNode(root, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">int</span> rootV,siblingA,siblingB, parentv, childv,leftchildv,rightchildv,samelevelA,samelevelB;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; c; i++)&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> state[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>((ch = getchar()) != <span class="string">'\n'</span>) state[q++] = ch;</span><br><span class="line">state[q] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strstr</span>(state,<span class="string">"root"</span>))&#123;</span><br><span class="line"><span class="built_in">sscanf</span>(state,<span class="string">"%d is the root"</span>,&amp;rootV);</span><br><span class="line">pirntMassage(isRoot(rootV));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(state,<span class="string">"siblings"</span>))&#123;</span><br><span class="line"><span class="built_in">sscanf</span>(state,<span class="string">"%d and %d are siblings"</span>,&amp;siblingA,&amp;siblingB);</span><br><span class="line">pirntMassage(isSibling(root,siblingA,siblingB));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(state,<span class="string">"same"</span>))&#123;</span><br><span class="line"><span class="built_in">sscanf</span>(state,<span class="string">"%d and %d are on the same level"</span>,&amp;samelevelA,&amp;samelevelB);</span><br><span class="line">pirntMassage(isSameLevel(root,samelevelA,samelevelB));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(state,<span class="string">"parent"</span>))&#123;</span><br><span class="line"><span class="built_in">sscanf</span>(state,<span class="string">"%d is the parent of %d"</span>,&amp;parentv,&amp;childv);</span><br><span class="line">pirntMassage(isParent(root,parentv,childv));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(state,<span class="string">"left"</span>))&#123;</span><br><span class="line"><span class="built_in">sscanf</span>(state,<span class="string">"%d is the left child of %d"</span>,&amp;leftchildv,&amp;parentv);</span><br><span class="line">pirntMassage(isLeftChild(root,parentv,leftchildv));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(state,<span class="string">"right"</span>))&#123;</span><br><span class="line"><span class="built_in">sscanf</span>(state,<span class="string">"%d is the right child of %d"</span>,&amp;rightchildv,&amp;parentv);</span><br><span class="line">pirntMassage(isRightChild(root,parentv,rightchildv));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pirntMassage(isRoot(2));</span></span><br><span class="line"><span class="comment">//pirntMassage(isSibling(root,1,1));</span></span><br><span class="line"><span class="comment">//pirntMassage(isSameLevel(root, 0,3));</span></span><br><span class="line"><span class="comment">//pirntMassage(isParent(root, 3,0));</span></span><br><span class="line"><span class="comment">//pirntMassage(isLeftChild(root, 2,1));</span></span><br><span class="line"><span class="comment">//pirntMassage(isRightChild(root, 2,4));</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次写这么多功能的代码，很考验耐力。<br>没什么大的难点，注意考虑代码的重用性。</p><p>第一次用sscanf，还不太熟。</p><blockquote><p>有一坑：它认为 3 and 3 are on the same level。我开始写的时候，直接把这种情况否定掉了。看来盲目做条件判断也不是好事。</p></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>PAT《团体程序设计天梯赛-练习集》-L3-01-是否完全二叉搜索-（3-分）</title>
      <link href="/2019/05/30/PAT%E3%80%8A%E5%9B%A2%E4%BD%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E7%BB%83%E4%B9%A0%E9%9B%86%E3%80%8B-L3-01-%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2-%EF%BC%883-%E5%88%86%EF%BC%89/"/>
      <content type="html"><![CDATA[<p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805049870368768" target="_blank" rel="noopener">L3-010 是否完全二叉搜索树 </a>（30 分）</p><p>将一系列给定数字顺序插入一个初始为空的二叉搜索树（定义为左子树键值大，右子树键值小），你需要判断最后的树是否一棵完全二叉树，并且给出其层序遍历的结果。</p><h5 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h5><p>输入第一行给出一个不超过20的正整数N；第二行给出N个互不相同的正整数，其间以空格分隔。</p><h5 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h5><p>将输入的N个正整数顺序插入一个初始为空的二叉搜索树。在第一行中输出结果树的层序遍历结果，数字间以1个空格分隔，行的首尾不得有多余空格。第二行输出YES，如果该树是完全二叉树；否则输出NO。</p><h5 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">38 45 42 24 58 30 67 12 51</span><br></pre></td></tr></table></figure><h5 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">38 45 24 58 42 30 12 67 51</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><h5 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">38 24 12 45 58 67 42 51</span><br></pre></td></tr></table></figure><h5 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">38 45 24 58 42 12 67 51</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><p>一道考察二叉树插入方法例程，层序遍历，判断是否为一棵完全二叉树的综合题。</p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">int val;</span><br><span class="line">TreeNode *left;</span><br><span class="line">TreeNode *right;</span><br><span class="line">TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">void insertNode(TreeNode* root, int val)&#123;</span><br><span class="line">if(root == NULL)&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(root-&gt;val &lt; val)&#123;</span><br><span class="line">if(root-&gt;left == NULL)&#123;</span><br><span class="line">TreeNode* now = new TreeNode(val);</span><br><span class="line">root-&gt;left = now;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">insertNode(root-&gt;left, val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else if(root-&gt;val &gt; val)&#123;</span><br><span class="line">if(root-&gt;right == NULL)&#123;</span><br><span class="line">TreeNode* now = new TreeNode(val);</span><br><span class="line">root-&gt;right = now;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">insertNode(root-&gt;right, val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void levelOrder(TreeNode* root)&#123;</span><br><span class="line">queue&lt;TreeNode*&gt; q;</span><br><span class="line">q.push(root);</span><br><span class="line">bool isfirst = true;</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">TreeNode* node = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(isfirst)&#123;</span><br><span class="line">cout &lt;&lt; node-&gt;val;</span><br><span class="line">isfirst = false;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">cout &lt;&lt;  &quot; &quot; &lt;&lt; node-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line">if(node-&gt;left) &#123;</span><br><span class="line">q.push(node-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line">if(node-&gt;right) &#123;</span><br><span class="line">q.push(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isCST(TreeNode* root)&#123;</span><br><span class="line">bool leaf = false;</span><br><span class="line">queue&lt;TreeNode*&gt; q;</span><br><span class="line">q.push(root);</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">TreeNode* node = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(node-&gt;right &amp;&amp; !node-&gt;left) return false;</span><br><span class="line">if(leaf &amp;&amp; (node-&gt;left || node-&gt;right)) return false;</span><br><span class="line">if(!node-&gt;right &amp;&amp; !leaf)&#123;</span><br><span class="line">leaf = true;</span><br><span class="line">&#125;</span><br><span class="line">if(node-&gt;left) &#123;</span><br><span class="line">q.push(node-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line">if(node-&gt;right) &#123;</span><br><span class="line">q.push(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printTree(TreeNode* root)&#123;</span><br><span class="line">if(!root) return;</span><br><span class="line">printTree(root-&gt;left);</span><br><span class="line">cout &lt;&lt; &quot; &quot; &lt;&lt; root-&gt;val;</span><br><span class="line">printTree(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int c;</span><br><span class="line">cin &gt;&gt; c;</span><br><span class="line">int rootval;</span><br><span class="line">cin &gt;&gt; rootval;</span><br><span class="line">TreeNode* root = new TreeNode(rootval);</span><br><span class="line">for(int i = 1; i &lt; c; i++)&#123;</span><br><span class="line">int nodeval;</span><br><span class="line">cin &gt;&gt; nodeval;</span><br><span class="line">insertNode(root, nodeval);</span><br><span class="line">&#125;</span><br><span class="line">levelOrder(root);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">if(isCST(root))&#123;</span><br><span class="line">cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-5. 最长回文子串（待补充）</title>
      <link href="/2019/03/16/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></p><h5 id="给定一个字符串-s，找到-s-中最长的回文子串。你可以假设-s-的最大长度为-1000。"><a href="#给定一个字符串-s，找到-s-中最长的回文子串。你可以假设-s-的最大长度为-1000。" class="headerlink" title="给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。"></a>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</h5><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><a id="more"></a><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">        <span class="keyword">while</span>(L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.size() &amp;&amp; s[L] == s[R])&#123;</span><br><span class="line">            L--;</span><br><span class="line">            R++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R - L - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( s.size() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="comment">//以i为中心点开始探测。</span></span><br><span class="line">            <span class="keyword">int</span> len1 = expandAroundCenter(s,i,i);</span><br><span class="line">            <span class="comment">//以i与i+1位置的之间开始探测。</span></span><br><span class="line">            <span class="keyword">int</span> len2 = expandAroundCenter(s,i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = max(len1,len2);</span><br><span class="line">            <span class="keyword">if</span>(len &gt; end-start)&#123;</span><br><span class="line">                start = i - (len<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                end = i + len/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start,end-start+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>只想到了O(n3)复杂度的暴力解法。看题解做的。</p><p>由于回文串的两侧互为镜像，所以可以从中心向两侧展开进行探测。一共会有2n-1个中心点（一个点为中心，两点之间也可以看作一个中点）。<br>时间复杂度为O(n2);</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-105. 从前序与中序遍历序列构造二叉树（待补充）</title>
      <link href="/2019/03/16/LeetCode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></p><h4 id="根据一棵树的前序遍历与中序遍历构造二叉树。"><a href="#根据一棵树的前序遍历与中序遍历构造二叉树。" class="headerlink" title="根据一棵树的前序遍历与中序遍历构造二叉树。"></a>根据一棵树的前序遍历与中序遍历构造二叉树。</h4><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 </span><br><span class="line">    preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 </span><br><span class="line">    inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><h3 id="Solution1（递归版）："><a href="#Solution1（递归版）：" class="headerlink" title="Solution1（递归版）："></a>Solution1（递归版）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> buildNode(preorder, s, inorder, <span class="number">0</span>, inorder.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildNode</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> &amp;preindex, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> inIndex = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(inorder[i] == preorder[preindex]) &#123;</span><br><span class="line">                    inIndex = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(inIndex &lt; start || inIndex &gt; end) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> TreeNode(preorder[preindex++]);</span><br><span class="line">            node-&gt;left = buildNode(preorder, preindex, inorder, start, inIndex<span class="number">-1</span>);</span><br><span class="line">            node-&gt;right = buildNode(preorder,preindex , inorder, inIndex+<span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>在前序遍历中，根结点是第一个元素。在中序遍历中，根节点之前的元素都在根结点的左子树上。根节点之后的元素都在根节点的右子树上。<br>对于其他的结点，与根节点构建的方式一样。所以可以使用递归。</p><p>所以重点就是找到根节点在中序遍历中的位置。</p><p>每次找到前序遍历中的一个结点，在中序遍历中找到该结点的位置，建立该结点。然后给该结点之下的结点（子树）划分区域。继续递归下去，直到区域缩小为0为止。</p><h3 id="Solution2（迭代版）"><a href="#Solution2（迭代版）" class="headerlink" title="Solution2（迭代版）:"></a>Solution2（迭代版）:</h3>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-958. 二叉树的完全性检验（待补充）</title>
      <link href="/2019/03/16/LeetCode-958-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%8C%E5%85%A8%E6%80%A7%E6%A3%80%E9%AA%8C%EF%BC%88%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/" target="_blank" rel="noopener">958. 二叉树的完全性检验</a></p><h4 id="给定一个二叉树，确定它是否是一个完全二叉树。"><a href="#给定一个二叉树，确定它是否是一个完全二叉树。" class="headerlink" title="给定一个二叉树，确定它是否是一个完全二叉树。"></a>给定一个二叉树，确定它是否是一个完全二叉树。</h4><p>若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）<br><a id="more"></a></p><h3 id="Solution1（迭代版）："><a href="#Solution1（迭代版）：" class="headerlink" title="Solution1（迭代版）："></a>Solution1（迭代版）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> havenullnode = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode* node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">                havenullnode = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(havenullnode) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>使用层序遍历，完全二叉树的遍历结果为只要遇到了null结点，之后的结点也都为null结点，否则就不是完全二叉树。</p><h3 id="Solution2（递归版）"><a href="#Solution2（递归版）" class="headerlink" title="Solution2（递归版）:"></a>Solution2（递归版）:</h3>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-34. 在排序数组中查找元素的第一个和最后一个位置</title>
      <link href="/2019/03/02/LeetCode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><h4 id="给定一个按照升序排列的整数数组-nums，和一个目标值-target。找出给定目标值在数组中的开始位置和结束位置。"><a href="#给定一个按照升序排列的整数数组-nums，和一个目标值-target。找出给定目标值在数组中的开始位置和结束位置。" class="headerlink" title="给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。"></a>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</h4><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 <strong>[-1, -1]</strong>。<br><a id="more"></a><br>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: [3,4]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.push_back(left_bound(nums,target));</span><br><span class="line">        res.push_back(right_bound(nums,target));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt;= hi)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mid == <span class="number">0</span> || nums[mid<span class="number">-1</span>] &lt; target) <span class="keyword">return</span> mid;</span><br><span class="line">                hi = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                lo = mid +<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hi = mid <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt;= hi)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target &amp;&amp; (mid == nums.size()<span class="number">-1</span> || nums[mid+<span class="number">1</span>] &gt; target))&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt;= target)&#123;</span><br><span class="line">                lo = mid +<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hi = mid <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>遍历两个函数，分别寻找左右界。</p><p>具体就是要<strong>找到最接近target值的位置</strong>。每次缩小范围。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-35. 搜索插入位置</title>
      <link href="/2019/03/02/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></p><h4 id="给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。"><a href="#给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。" class="headerlink" title="给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。"></a>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</h4><p>你可以假设数组中无重复元素。<br><a id="more"></a><br>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当小于第一个元素时，low会停在0，hi会是-1；</span></span><br><span class="line">        <span class="comment">//当在数组区间时，low=hi在期望的位置。</span></span><br><span class="line">        <span class="comment">//当大于最后一个元素是，low = nums.size(), hi = nums.size();</span></span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二分的初步题。</p><p>要十分深刻的了解指针的运行状态才能写出简洁的代码。</p><p>比如自己写的最终版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; nums[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt;= hi)&#123;</span><br><span class="line"></span><br><span class="line">            mid = (lo + hi)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) lo = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) hi = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[hi] &gt; target ? hi : hi+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没有上面的简洁。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT《团体程序设计天梯赛-练习集》-L3-016 二叉搜索树的结构 （30 分）</title>
      <link href="/2019/02/28/PAT%E3%80%8A%E5%9B%A2%E4%BD%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E7%BB%83%E4%B9%A0%E9%9B%86%E3%80%8B-L3-016-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84-%EF%BC%8830-%E5%88%86%EF%BC%89/"/>
      <content type="html"><![CDATA[<p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805047903240192" target="_blank" rel="noopener">L3-016 二叉搜索树的结构 （30 分）</a></p><h4 id="二叉搜索树或者是一棵空树，或者是具有下列性质的二叉树：-若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。（摘自百度百科）"><a href="#二叉搜索树或者是一棵空树，或者是具有下列性质的二叉树：-若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。（摘自百度百科）" class="headerlink" title="二叉搜索树或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。（摘自百度百科）"></a>二叉搜索树或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。（摘自百度百科）</h4><a id="more"></a><p>给定一系列互不相等的整数，将它们顺次插入一棵初始为空的二叉搜索树，然后对结果树的结构进行描述。你需要能判断给定的描述是否正确。例如将{ 2 4 1 3 0 }插入后，得到一棵二叉搜索树，则陈述句如“2是树的根”、“1和4是兄弟结点”、“3和0在同一层上”（指自顶向下的深度相同）、“2是4的双亲结点”、“3是4的左孩子”都是正确的；而“4是2的左孩子”、“1和3是兄弟结点”都是不正确的。</p><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>输入在第一行给出一个正整数N（≤100），随后一行给出N个互不相同的整数，数字间以空格分隔，要求将之顺次插入一棵初始为空的二叉搜索树。之后给出一个正整数M（≤100），随后M行，每行给出一句待判断的陈述句。陈述句有以下6种：</p><ul><li>A is the root，即”A是树的根”；</li><li>A and B are siblings，即”A和B是兄弟结点”；</li><li>A is the parent of B，即”A是B的双亲结点”；</li><li>A is the left child of B，即”A是B的左孩子”；</li><li>A is the right child of B，即”A是B的右孩子”；</li><li>A and B are on the same level，即”A和B在同一层上”。<br>题目保证所有给定的整数都在整型范围内。</li></ul><h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>对每句陈述，如果正确则输出Yes，否则输出No，每句占一行。</p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode* left;</span><br><span class="line">TreeNode* right;</span><br><span class="line">TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>)&#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rootval;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;val &gt; val)&#123;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">insertNode(root-&gt;left,val);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">TreeNode* t = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">root-&gt;left = t; </span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; val)&#123;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">insertNode(root-&gt;right,val);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">TreeNode* t = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">root-&gt;right = t; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isContainNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;val == val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;val &gt; val) <span class="keyword">return</span> isContainNode(root-&gt;left,val);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> isContainNode(root-&gt;right,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt;<span class="string">""</span>;</span><br><span class="line">printTree(root-&gt;left);</span><br><span class="line">printTree(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRoot</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val == rootval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">parent</span><span class="params">(TreeNode *root, <span class="keyword">int</span> child)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!isContainNode(root,child) || root-&gt;val == child) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">TreeNode* res = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>((root-&gt;left &amp;&amp; root-&gt;left-&gt;val == child) || (root-&gt;right &amp;&amp; root-&gt;right-&gt;val == child))&#123;</span><br><span class="line">res = root;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &gt; child)&#123;</span><br><span class="line">root = root-&gt;left;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; child)&#123;</span><br><span class="line">root = root-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSibling</span><span class="params">(TreeNode* root, <span class="keyword">int</span> valA, <span class="keyword">int</span> valB)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(valA == root-&gt;val || valB == root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//找到A的父亲</span></span><br><span class="line">TreeNode* t = parent(root, valA); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(t)&#123;</span><br><span class="line"><span class="keyword">if</span>(t-&gt;left &amp;&amp; t-&gt;left-&gt;val == valA )&#123;</span><br><span class="line"><span class="keyword">return</span> t-&gt;right &amp;&amp; t-&gt;right-&gt;val == valB;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;right &amp;&amp; t-&gt;right-&gt;val == valA )&#123;</span><br><span class="line"><span class="keyword">return</span> t-&gt;left &amp;&amp; t-&gt;left-&gt;val == valB;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(root-&gt;val == val) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;val &gt; val) <span class="keyword">return</span> <span class="number">1</span> + getDepth(root-&gt;left,val);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span> + getDepth(root-&gt;right,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameLevel</span><span class="params">(TreeNode* root, <span class="keyword">int</span> A, <span class="keyword">int</span> B)</span></span>&#123;</span><br><span class="line"><span class="comment">//A != B &amp;&amp; </span></span><br><span class="line"><span class="keyword">return</span> isContainNode(root,A) &amp;&amp; isContainNode(root,B) &amp;&amp; getDepth(root, A) == getDepth(root, B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pirntMassage</span><span class="params">(<span class="keyword">bool</span> info)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(info)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isParent</span><span class="params">(TreeNode* root, <span class="keyword">int</span> parentVal, <span class="keyword">int</span> childVal)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(parent(root, childVal) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> parentVal == parent(root, childVal)-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeftChild</span><span class="params">(TreeNode* root, <span class="keyword">int</span> parentVal, <span class="keyword">int</span> leftChildVal)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(parent(root, leftChildVal) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">TreeNode* p = parent(root, leftChildVal);</span><br><span class="line"><span class="keyword">return</span> parentVal == p-&gt;val &amp;&amp; p-&gt;left-&gt;val == leftChildVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRightChild</span><span class="params">(TreeNode* root, <span class="keyword">int</span> parentVal, <span class="keyword">int</span> rightChildVal)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(parent(root, rightChildVal) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">TreeNode* p = parent(root, rightChildVal);</span><br><span class="line"><span class="keyword">return</span> parentVal == p-&gt;val &amp;&amp; p-&gt;right-&gt;val == rightChildVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span>(c &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; rootval;</span><br><span class="line">TreeNode* root = <span class="keyword">new</span> TreeNode(rootval);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; c; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">insertNode(root, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">int</span> rootV,siblingA,siblingB, parentv, childv,leftchildv,rightchildv,samelevelA,samelevelB;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; c; i++)&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> state[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>((ch = getchar()) != <span class="string">'\n'</span>) state[q++] = ch;</span><br><span class="line">state[q] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strstr</span>(state,<span class="string">"root"</span>))&#123;</span><br><span class="line"><span class="built_in">sscanf</span>(state,<span class="string">"%d is the root"</span>,&amp;rootV);</span><br><span class="line">pirntMassage(isRoot(rootV));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(state,<span class="string">"siblings"</span>))&#123;</span><br><span class="line"><span class="built_in">sscanf</span>(state,<span class="string">"%d and %d are siblings"</span>,&amp;siblingA,&amp;siblingB);</span><br><span class="line">pirntMassage(isSibling(root,siblingA,siblingB));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(state,<span class="string">"same"</span>))&#123;</span><br><span class="line"><span class="built_in">sscanf</span>(state,<span class="string">"%d and %d are on the same level"</span>,&amp;samelevelA,&amp;samelevelB);</span><br><span class="line">pirntMassage(isSameLevel(root,samelevelA,samelevelB));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(state,<span class="string">"parent"</span>))&#123;</span><br><span class="line"><span class="built_in">sscanf</span>(state,<span class="string">"%d is the parent of %d"</span>,&amp;parentv,&amp;childv);</span><br><span class="line">pirntMassage(isParent(root,parentv,childv));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(state,<span class="string">"left"</span>))&#123;</span><br><span class="line"><span class="built_in">sscanf</span>(state,<span class="string">"%d is the left child of %d"</span>,&amp;leftchildv,&amp;parentv);</span><br><span class="line">pirntMassage(isLeftChild(root,parentv,leftchildv));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(state,<span class="string">"right"</span>))&#123;</span><br><span class="line"><span class="built_in">sscanf</span>(state,<span class="string">"%d is the right child of %d"</span>,&amp;rightchildv,&amp;parentv);</span><br><span class="line">pirntMassage(isRightChild(root,parentv,rightchildv));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pirntMassage(isRoot(2));</span></span><br><span class="line"><span class="comment">//pirntMassage(isSibling(root,1,1));</span></span><br><span class="line"><span class="comment">//pirntMassage(isSameLevel(root, 0,3));</span></span><br><span class="line"><span class="comment">//pirntMassage(isParent(root, 3,0));</span></span><br><span class="line"><span class="comment">//pirntMassage(isLeftChild(root, 2,1));</span></span><br><span class="line"><span class="comment">//pirntMassage(isRightChild(root, 2,4));</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次写这么多功能的代码，很考验耐力。<br>没什么大的难点，注意考虑代码的重用性。</p><p>第一次用sscanf，还不太熟。</p><blockquote><p>有一坑：它认为 3 and 3 are on the same level。我开始写的时候，直接把这种情况否定掉了。看来盲目做条件判断也不是好事。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PAT《团体程序设计天梯赛-练习集》-L3-010 是否完全二叉搜索树 （30 分）</title>
      <link href="/2019/02/27/PAT%E3%80%8A%E5%9B%A2%E4%BD%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E7%BB%83%E4%B9%A0%E9%9B%86%E3%80%8B-L3-010-%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-%EF%BC%8830-%E5%88%86%EF%BC%89/"/>
      <content type="html"><![CDATA[<p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805049870368768" target="_blank" rel="noopener">L3-010 是否完全二叉搜索树 </a>（30 分）</p><h3 id="将一系列给定数字顺序插入一个初始为空的二叉搜索树（定义为左子树键值大，右子树键值小），你需要判断最后的树是否一棵完全二叉树，并且给出其层序遍历的结果。"><a href="#将一系列给定数字顺序插入一个初始为空的二叉搜索树（定义为左子树键值大，右子树键值小），你需要判断最后的树是否一棵完全二叉树，并且给出其层序遍历的结果。" class="headerlink" title="将一系列给定数字顺序插入一个初始为空的二叉搜索树（定义为左子树键值大，右子树键值小），你需要判断最后的树是否一棵完全二叉树，并且给出其层序遍历的结果。"></a>将一系列给定数字顺序插入一个初始为空的二叉搜索树（定义为左子树键值大，右子树键值小），你需要判断最后的树是否一棵完全二叉树，并且给出其层序遍历的结果。</h3><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>输入第一行给出一个不超过20的正整数N；第二行给出N个互不相同的正整数，其间以空格分隔。</p><h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>将输入的N个正整数顺序插入一个初始为空的二叉搜索树。在第一行中输出结果树的层序遍历结果，数字间以1个空格分隔，行的首尾不得有多余空格。第二行输出YES，如果该树是完全二叉树；否则输出NO。</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">38 45 42 24 58 30 67 12 51</span><br></pre></td></tr></table></figure><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">38 45 24 58 42 30 12 67 51</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">38 24 12 45 58 67 42 51</span><br></pre></td></tr></table></figure><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">38 45 24 58 42 12 67 51</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><p>一道考察二叉树插入方法例程，层序遍历，判断是否为一棵完全二叉树的综合题。</p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode *left;</span><br><span class="line">TreeNode *right;</span><br><span class="line">TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;val &lt; val)&#123;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>)&#123;</span><br><span class="line">TreeNode* now = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">root-&gt;left = now;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">insertNode(root-&gt;left, val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &gt; val)&#123;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">TreeNode* now = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">root-&gt;right = now;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">insertNode(root-&gt;right, val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">q.push(root);</span><br><span class="line"><span class="keyword">bool</span> isfirst = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">TreeNode* node = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span>(isfirst)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; node-&gt;val;</span><br><span class="line">isfirst = <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;  <span class="string">" "</span> &lt;&lt; node-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;left) &#123;</span><br><span class="line">q.push(node-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">q.push(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCST</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> leaf = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">q.push(root);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">TreeNode* node = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span>(node-&gt;right &amp;&amp; !node-&gt;left) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(leaf &amp;&amp; (node-&gt;left || node-&gt;right)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!node-&gt;right &amp;&amp; !leaf)&#123;</span><br><span class="line">leaf = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;left) &#123;</span><br><span class="line">q.push(node-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">q.push(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">printTree(root-&gt;left);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; root-&gt;val;</span><br><span class="line">printTree(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line"><span class="keyword">int</span> rootval;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; rootval;</span><br><span class="line">TreeNode* root = <span class="keyword">new</span> TreeNode(rootval);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; c; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> nodeval;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; nodeval;</span><br><span class="line">insertNode(root, nodeval);</span><br><span class="line">&#125;</span><br><span class="line">levelOrder(root);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span>(isCST(root))&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-240. 搜索二维矩阵 II</title>
      <link href="/2019/02/27/LeetCode-240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii" target="_blank" rel="noopener">240. 搜索二维矩阵 II</a></p><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。</li></ul><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = matrix[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; matrix.size() &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == matrix[i][j]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[i][j]) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; matrix[i][j]) j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p> 从矩阵的左上角出发，如果比目标值大，向左移，如果比目标值小，向下移。出界或找到则结束。</p><p> 对于一列，如果比当前值小，说明不在当前列中，列减一（缩小搜索范围）。<br> 对于一行，如果比当前值小，则往前移动一个位置。</p><p> 经过不断缩小范围（以经过的点划矩形），就可以得知目标值是否存在矩阵中。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 二维矩阵 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-46. 全排列</title>
      <link href="/2019/02/23/LeetCode-46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></p><h5 id="给定一个没有重复数字的序列，返回其所有可能的全排列。"><a href="#给定一个没有重复数字的序列，返回其所有可能的全排列。" class="headerlink" title="给定一个没有重复数字的序列，返回其所有可能的全排列。"></a>给定一个没有重复数字的序列，返回其所有可能的全排列。</h5><p>示例:</p><blockquote><p>输入: [1,2,3]</p><p>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p></blockquote><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; isVisit(len,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        DFS(nums,isVisit,res,temp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;isVisit, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.size() == nums.size())&#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isVisit[i]) <span class="keyword">continue</span>;</span><br><span class="line">            temp.push_back(nums[i]);</span><br><span class="line">            isVisit[i] = <span class="literal">true</span>;</span><br><span class="line">            DFS(nums,isVisit,res,temp);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">            isVisit[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>对于每一个数在一个排列中出现且仅出现一次。所以需要定义一个记录该数是否访问过的与原数组相同长度的数组——isVisit。</p><p>首先限定递归层数，当temp数组的长度已经和原数组的长度相同，就将数组保存下来。</p><p>然后开始遍历数组中的每一个数，遇到一个数，就将该数标记为已访问，并且将该数添加到temp数组中。继续下一层递归。</p><h5 id="回溯："><a href="#回溯：" class="headerlink" title="回溯："></a>回溯：</h5><p>当每一个数访问完后，将该数从temp中pop掉，然后接着探寻下一个数是不是符合条件。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 回溯 </tag>
            
            <tag> 排列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-107. 二叉树的层次遍历 II</title>
      <link href="/2019/02/23/LeetCode-107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-II/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">107. 二叉树的层次遍历 II</a></p><h5 id="给定一个二叉树，返回其节点值自底向上的层次遍历。-（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）"><a href="#给定一个二叉树，返回其节点值自底向上的层次遍历。-（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）" class="headerlink" title="给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）"></a>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</h5><p>该题为 <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal" target="_blank" rel="noopener">102. 二叉树的层次遍历</a>的进阶版。</p><p>有关<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal" target="_blank" rel="noopener">102. 二叉树的层次遍历</a>的题解，请参考<a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/submissions/" target="_blank" rel="noopener">429. N叉树的层序遍历</a>，具体思路是一样的，不再赘述。</p><h3 id="Solution1（迭代版）："><a href="#Solution1（迭代版）：" class="headerlink" title="Solution1（迭代版）："></a>Solution1（迭代版）：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curLayerNodes;</span><br><span class="line">            TreeNode* t;</span><br><span class="line">            <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">                t = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                curLayerNodes.push_back(t-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.emplace(res.begin(),curLayerNodes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution2（递归版）："><a href="#Solution2（递归版）：" class="headerlink" title="Solution2（递归版）："></a>Solution2（递归版）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        preorder(root,<span class="number">1</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* node, <span class="keyword">int</span> depth, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.size() &lt; depth)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">            t.push_back(node-&gt;val);</span><br><span class="line">            res.emplace(res.begin(), t);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[res.size()-depth].push_back(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        preorder(node-&gt;left, depth+<span class="number">1</span>, res);</span><br><span class="line">        preorder(node-&gt;right, depth+<span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具体思路就是增加一层，就将该层放到头位置。</p><blockquote><p>vector.emplace()配合vector.begin()实现插到头位置。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-199. 二叉树的右视图</title>
      <link href="/2019/02/23/LeetCode-199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></p><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><h3 id="Solution1（迭代版）："><a href="#Solution1（迭代版）：" class="headerlink" title="Solution1（迭代版）："></a>Solution1（迭代版）：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        q.push(root);</span><br><span class="line">        TreeNode* t = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="keyword">while</span>(len)&#123;</span><br><span class="line">                t = q.front();q.pop();</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(t-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一种比较符合直觉的就是使用层序遍历，将每一层的最后一个留下。</p><h3 id="Solution2（递归版）："><a href="#Solution2（递归版）：" class="headerlink" title="Solution2（递归版）："></a>Solution2（递归版）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        preorder(root, <span class="number">1</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* node, <span class="keyword">int</span> depth, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.size() &lt; depth)&#123;</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[depth<span class="number">-1</span>] = node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        preorder(node-&gt;left,depth+<span class="number">1</span>, res);</span><br><span class="line">        preorder(node-&gt;right,depth+<span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用前序遍历，并且传入层级信息，每到一层，就将该层的信息更新。如果该层没有数据，则新增一层。遍历到最后就会更新为正确的数据。</p><h3 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        preorder(root, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* node, <span class="keyword">int</span> depth, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.size() == depth)&#123;</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        preorder(node-&gt;right,depth+<span class="number">1</span>, res);</span><br><span class="line">        preorder(node-&gt;left,depth+<span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>仔细观察发现，并没有必要先push进去左节点，碰到右节点再将左节点覆盖掉，而是一开始就直接push进右节点。到左节点的时候就什么事情也不需要做。</p><p>每到一个结点<strong>优先遍历右节点</strong>，res的size++。在遍历左节点的时候直接会跳过。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-191. 位1的个数 &amp;&amp;  231. 2的幂</title>
      <link href="/2019/02/21/LeetCode-191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0-231-2%E7%9A%84%E5%B9%82/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">191. 位1的个数</a></p><h3 id="编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为-‘1’-的个数（也被称为汉明重量）。"><a href="#编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为-‘1’-的个数（也被称为汉明重量）。" class="headerlink" title="编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。"></a>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</h3><h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            cot += n&amp;<span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>将每一位移到最后一位检查是否为1，到0为止，最后返回个数。</p><p>由于是无符号整型，每次都会执行32次，所以时间复杂度是O(1)。</p><h3 id="Solution2（优化）："><a href="#Solution2（优化）：" class="headerlink" title="Solution2（优化）："></a>Solution2（优化）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            n &amp;= (n<span class="number">-1</span>);</span><br><span class="line">            cot++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看了官方题解，这种方法是每一次将最后一个1给消除。这样顶多执行k次，k就为1的个数。这样就又优化了一点点计算。</p><blockquote><p>eg：</p><p>11010 &amp; 11001 = 11000</p><p>11000 &amp; 10111 = 10000</p><p>10000 &amp; 01111 = 0</p></blockquote><h3 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231. 2的幂"></a>231. 2的幂</h3><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p><p>有了上面的思路：</p><p>这道题就可以写成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; !(n &amp; (n<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2的n次方在二进制中就是只有1个位置是1，其他全是0（对于正数）。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-129. 求根到叶子节点数字之和</title>
      <link href="/2019/02/21/LeetCode-129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers" target="_blank" rel="noopener">129. 求根到叶子节点数字之和</a></p><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p><p>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。</p><p>计算从根到叶子节点生成的所有数字之和。</p><blockquote><p>说明: 叶子节点是指没有子节点的节点。<br><a id="more"></a></p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sumVal(root,<span class="number">0</span>,sum);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sumVal</span><span class="params">(TreeNode* root, <span class="keyword">int</span> pathsum,<span class="keyword">int</span>&amp;sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">         sum += pathsum*<span class="number">10</span> + root-&gt;val;  </span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) sumVal(root-&gt;left, pathsum*<span class="number">10</span> + root-&gt;val, sum);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) sumVal(root-&gt;right, pathsum*<span class="number">10</span> + root-&gt;val, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>这道题由于是到叶子节点的路径，并且要将其中走过的节点的值加起来，所以不能到空节点才停止（无法确定加值的时机），这里是到叶子节点就停止，并且把值加到sum中。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-114. 二叉树展开为链表</title>
      <link href="/2019/02/19/LeetCode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表</a></p><p>给定一个二叉树，<strong>原地</strong>将它展开为链表。</p><h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right) <span class="keyword">return</span> node;</span><br><span class="line">        TreeNode* lastLeft = <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* lastRight = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">            lastLeft = dfs(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">            lastRight = dfs(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lastLeft)&#123;</span><br><span class="line">            lastLeft-&gt;right = node-&gt;right;</span><br><span class="line">            node-&gt;right = node-&gt;left;</span><br><span class="line">            node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(lastRight) <span class="keyword">return</span> lastRight;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> lastLeft;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>从叶子结点开始，向上展开。每到一层，分别获得左子树和右子树的最后节点，将左子树的最后节点与当前节点的右子树的开始节点连接，将当前节点的右节点指向左子树的开始节点，左子树置空。</p><p>接着返回当前子树的最后节点，作为上一层的相应结点做相应的处理。</p><h3 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* lastLeft;</span><br><span class="line">        TreeNode* lastRight;</span><br><span class="line">        lastLeft = dfs(node-&gt;left);</span><br><span class="line">        lastRight = dfs(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(lastLeft)&#123;</span><br><span class="line">            lastLeft-&gt;right = node-&gt;right;</span><br><span class="line">            node-&gt;right = node-&gt;left;</span><br><span class="line">            node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastRight ? lastRight : lastLeft ? lastLeft : node ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将空节点做一般化考虑，在返回的时候做相应的处理。</p><p>分几种情况：</p><ul><li><p>有lastRight，优先返回lastRight，</p></li><li><p>没有lastRight，有lastLeft，此时由于之上的代码已经将子树展开为链表并转换到了右子树上面，这时返回lastLeft。</p></li><li>lastRight 和 lastLeft 都没有，这时为叶子节点，直接返回该节点即可。</li></ul><h3 id="Solution2（终极版）："><a href="#Solution2（终极版）：" class="headerlink" title="Solution2（终极版）："></a>Solution2（终极版）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        flatten(root-&gt;right);</span><br><span class="line">        flatten(root-&gt;left);</span><br><span class="line">        root-&gt;right = prev;</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        prev = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看到评论区大神写的这段代码，我觉得我被虐的体无完肤。</p><p>首先，设置一个全局变量，该变量用来记录已经翻转过的开始结点。<br>接着，递归是首先下到最右边，从最右边开始的，这就保证了只需要关心已经展开链表的头结点，尾结点没必要再关心了。每次到达一个子树，从最右的结点开始，每个节点接到全局变量上。全局变量刷新为新的展开链表的头。如此一直到达根节点。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-110. 平衡二叉树</title>
      <link href="/2019/02/19/LeetCode-110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/balanced-binary-tree" target="_blank" rel="noopener">110. 平衡二叉树</a></p><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p></blockquote><h3 id="Solution（递归版）："><a href="#Solution（递归版）：" class="headerlink" title="Solution（递归版）："></a>Solution（递归版）：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">std</span>::<span class="built_in">abs</span>(depth(root-&gt;left)-depth(root-&gt;right)) &gt; <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">std</span>::max(depth(root-&gt;left),depth(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>依次向下判断每一个节点的下左右子树的高度差。如果大于1，返回false，否则继续向下判断。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-144. 二叉树的前序遍历</title>
      <link href="/2019/02/18/LeetCode-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></p><p>给定一个二叉树，返回它的<strong>前序</strong>遍历。</p><h3 id="Solution1（递归版）："><a href="#Solution1（递归版）：" class="headerlink" title="Solution1（递归版）："></a>Solution1（递归版）：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        preorder(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        res.push_back(node-&gt;val);</span><br><span class="line">        preorder(node-&gt;left, res);</span><br><span class="line">        preorder(node-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution2（迭代版）："><a href="#Solution2（迭代版）：" class="headerlink" title="Solution2（迭代版）："></a>Solution2（迭代版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if(!root) return res;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        s.push(root);</span><br><span class="line">        while(!s.empty())&#123;</span><br><span class="line">            cur = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            res.push_back(cur-&gt;val);</span><br><span class="line">            if(cur-&gt;right) s.push(cur-&gt;right);</span><br><span class="line">            if(cur-&gt;left) s.push(cur-&gt;left);</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前序遍历的顺序为先处理当前节点，再处理左节点，最后处理右节点。</p><p>对于栈来说。首先处理当前节点。然后先把右节点压入栈中，转而处理左节点。</p><h3 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; toVisit;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* current = root;</span><br><span class="line">        <span class="keyword">while</span>(current || !toVisit.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                result.push_back(current-&gt;val);</span><br><span class="line">                toVisit.push(current-&gt;right);</span><br><span class="line">                current = current-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = toVisit.top();</span><br><span class="line">                toVisit.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-94. 二叉树的中序遍历</title>
      <link href="/2019/02/18/LeetCode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></p><p>给定一个二叉树，返回它的<strong>中序</strong>遍历。</p><h3 id="Solution1（递归版）："><a href="#Solution1（递归版）：" class="headerlink" title="Solution1（递归版）："></a>Solution1（递归版）：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        inorder(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        inorder(node-&gt;left, res);</span><br><span class="line">        res.push_back(node-&gt;val);</span><br><span class="line">        inorder(node-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution2（迭代版）："><a href="#Solution2（迭代版）：" class="headerlink" title="Solution2（迭代版）："></a>Solution2（迭代版）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; ss;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur || !ss.empty())&#123;</span><br><span class="line">            <span class="comment">//优先把左节点push进栈。</span></span><br><span class="line">            <span class="keyword">if</span>(cur)&#123;</span><br><span class="line">                ss.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//该节点没有左节点，此时就该存储起来了。然后继续对右节点的操作。（自底向上的访问右节点）</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = ss.top();</span><br><span class="line">                ss.pop();</span><br><span class="line">                res.push_back(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>中序遍历的特点就是优先遍历左节点，之后是当前节点，最后是右节点。</p><p>所以遇到一个节点。先存储在栈内。考虑以下两点：</p><ul><li>有左节点，继续加入栈。</li><li>没有左节点，处理该节点，并将该节点从栈中弹出，继续考虑该节点的右节点。</li></ul><blockquote><p>这里我在思考的时候，逻辑没有问题，在coding的时候，关注的是父节点与子节点的关系，这样写出来的代码很容易导致死循环（在左子节点判断玩后，无法弹出栈，下一层循环又继续进行左子节点的判断了）。看到评论是将每一个节点提出来作为观察对象。更加直接。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-111. 二叉树的最小深度</title>
      <link href="/2019/02/14/LeetCode-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><blockquote><p>说明: 叶子节点是指没有子节点的节点。</p></blockquote><h3 id="Solution1（递归版）："><a href="#Solution1（递归版）：" class="headerlink" title="Solution1（递归版）："></a>Solution1（递归版）：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> depth(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = INT_MAX, r = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            l =  <span class="number">1</span> + depth(root-&gt;left);</span><br><span class="line">        &#125;<span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            r = <span class="number">1</span> + depth(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(l,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归到叶子节点就停止。</p><p>如果不是叶子结点。则向下递归，找到最小值即可。</p><h3 id="Solution2（迭代版）："><a href="#Solution2（迭代版）：" class="headerlink" title="Solution2（迭代版）："></a>Solution2（迭代版）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode* t = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span>(!t-&gt;left &amp;&amp; !t-&gt;right) &#123;</span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left)q.push(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right)q.push(t-&gt;right);</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>层次遍历二叉树，每次弹出一层，如果该层有叶子节点，直接返回当前记录的深度。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-74. 搜索二维矩阵</title>
      <link href="/2019/02/14/LeetCode-74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">74. 搜索二维矩阵</a></p><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。<a id="more"></a><h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = matrix.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = matrix[i].size();</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][k<span class="number">-1</span>] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][k<span class="number">-1</span>] &lt; target) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> hasNumInArray(matrix[i], target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNumInArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = a.size();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (i + j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[mid] == num) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; a[mid])&#123;</span><br><span class="line">                i = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先检查每一行的<strong>最后一个元素</strong>。如果等于直接返回，如果小于目标值，说明不在该行，继续进行下一行的检查。当上一行的最后一个元素比目标值大，当前行最后一个元素比目标值小时，就只在该行进行搜索（二分）。如果能够搜索到则返回true，找不到则说明整个矩阵内没有目标值。</p><blockquote><p>待优化的点： 在进行对每一列的检查时，也可以使用二分来加速范围的选择。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 二维矩阵 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-59. 螺旋矩阵 II</title>
      <link href="/2019/02/14/LeetCode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">59. 螺旋矩阵 II</a></p><p>给定一个正整数 n，生成一个包含 1 到 n² 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>与<a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. 螺旋矩阵</a>类似。</p><p>只需要依次给新数组中的相应元素赋值即可。</p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n<span class="number">-1</span>, up = <span class="number">0</span>, down = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; up &lt; down)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i = left, j = up;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; right)&#123;</span><br><span class="line">                res[j][i] = k++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">while</span>(j &lt; down)&#123;</span><br><span class="line">                res[j][i] = k++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &gt; left)&#123;</span><br><span class="line">                res[j][i] = k++;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; up)&#123;</span><br><span class="line">                res[j][i] = k++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            up++;</span><br><span class="line">            down--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//形不成圈（单列或者单行）</span></span><br><span class="line">        <span class="keyword">if</span>(up == down)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">                res[up][left++] = k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(up &lt;= down)&#123;</span><br><span class="line">                res[up++][left] = k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 二维矩阵 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-54. 螺旋矩阵</title>
      <link href="/2019/02/14/LeetCode-54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. 螺旋矩阵</a></p><p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。<br><a id="more"></a></p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,up = <span class="number">0</span>, right = matrix[<span class="number">0</span>].size()<span class="number">-1</span>, down = matrix.size()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; up &lt; down)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i = left, j = up;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; right)&#123;</span><br><span class="line">                res.push_back(matrix[j][i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">while</span>(j &lt; down)&#123;</span><br><span class="line">                res.push_back(matrix[j][i]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &gt; left)&#123;</span><br><span class="line">                res.push_back(matrix[j][i]);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; up)&#123;</span><br><span class="line">                res.push_back(matrix[j][i]);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            up++;</span><br><span class="line">            down--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//形不成圈（单列或者单行）</span></span><br><span class="line">        <span class="keyword">if</span>(up == down)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">                res.push_back(matrix[up][left++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(up &lt;= down)&#123;</span><br><span class="line">                res.push_back(matrix[up++][left]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>每次将矩阵的外围当做一个圈来处理，然后缩小圈的范围。</p><p>直到形不成圈，此时要么是单行，要么是单列，要么是中心点（看做单行，单列都可行），然后单独处理即可。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 二维矩阵 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-922. 按奇偶排序数组 II</title>
      <link href="/2019/02/14/LeetCode-922-%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/submissions/" target="_blank" rel="noopener">922. 按奇偶排序数组 II</a></p><p>给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。</p><p>对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortArrayByParityII(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = A.size();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; len &amp;&amp; (A[i] &amp; <span class="number">1</span>) == <span class="number">0</span>) i+=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; len &amp;&amp; (A[j] &amp; <span class="number">1</span>) != <span class="number">0</span>) j+=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= len || j &gt;= len) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">std</span>::swap(A[i],A[j]);</span><br><span class="line">            i+=<span class="number">2</span>;</span><br><span class="line">            j+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>设置两个指针。<br>一个指针只走奇数下标，一个指针只走偶数下标。<br>当碰到不符合条件（奇数下标的值不是奇数，偶数下标的值不是偶数）就停下并交换两个值，之后接着走，直到指针越界为止。</p><blockquote><p>看评论有人用栈或者另外准备两个数组的，速度比原地交换还快，不知道为什么。实现也比较简单，就不赘述了。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-559. N叉树的最大深度</title>
      <link href="/2019/02/09/LeetCode-559-N%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/" target="_blank" rel="noopener">559. N叉树的最大深度</a></p><p>给定一个 N 叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><a id="more"></a><h3 id="Solution1（递归版）："><a href="#Solution1（递归版）：" class="headerlink" title="Solution1（递归版）："></a>Solution1（递归版）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(Node* node, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node-&gt;children.size(); i++)&#123;</span><br><span class="line">            max = <span class="built_in">std</span>::max(dfs(node-&gt;children[i], m+<span class="number">1</span>), max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归版本。</p><p>我的写法为：</p><p>定义空节点的深度为0，这样在做最大值比较的时候返回的是其父节点的深度。</p><p>这样做可以在root为空的时候不用做特殊处理。直接会返回0。</p><p>评论区有人是这样写的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;    <span class="comment">//DFS递归写法</span></span><br><span class="line">    <span class="keyword">if</span>(root == null)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;root.children.size();i++)&#123;</span><br><span class="line">        depth = Math.max(depth,maxDepth(root.children.get(i)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由下至上来确定最大深度，但是需要额外判断根节点为空的情况。</p><h3 id="Solution2（迭代版）："><a href="#Solution2（迭代版）：" class="headerlink" title="Solution2（迭代版）："></a>Solution2（迭代版）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> maxDep = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">            q.push(root);</span><br><span class="line">            <span class="comment">//队列中始终保持存储的节点都为同一层。</span></span><br><span class="line">            <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> n = q.size();</span><br><span class="line">                <span class="comment">//当前层有结点。</span></span><br><span class="line">                maxDep++;</span><br><span class="line">                <span class="comment">//将当前层所有元素pop掉。</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ;i++)&#123;</span><br><span class="line">                    Node* t = q.front(); q.pop();</span><br><span class="line">                    <span class="comment">//将子节点push进队列。</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t-&gt;children.size(); j++)&#123;</span><br><span class="line">                        q.push(t-&gt;children[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxDep;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代版利用层次遍历。</p><p>每到一层，深度加1。然后将该层的所有结点pop掉。继续将下一层的结点push进来。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-101. 对称二叉树</title>
      <link href="/2019/02/09/LeetCode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></p><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><h3 id="Solution1（递归版）："><a href="#Solution1（递归版）：" class="headerlink" title="Solution1（递归版）："></a>Solution1（递归版）：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode* t1, TreeNode* t2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//都为NULL</span></span><br><span class="line">        <span class="keyword">if</span>(!t1 &amp;&amp; !t2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//有一个结点为NULL，另一个不为NULL</span></span><br><span class="line">        <span class="keyword">if</span>(!t1 || !t2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (t1-&gt;val == t2-&gt;val) &amp;&amp; isMirror(t1-&gt;left, t2-&gt;right)</span><br><span class="line">            &amp;&amp; isMirror(t1-&gt;right, t2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看的官方题解。</p><p>把一棵对称树分成左子树和右子树。</p><p>如果左子树和右子树对称，则该数相同。</p><p>扩展到一般概念就是：</p><ul><li>有两棵树。</li><li>两棵树的根节点相同。</li><li>每个树的右子树都与另一个树的左子树镜像对称。</li></ul><p>翻译为递推公式就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* t1,t2;</span><br><span class="line">t1-&gt;val == t2-&gt;val;</span><br><span class="line">t1-&gt;left == t2-&gt;right;</span><br><span class="line">t1-&gt;right = t2-&gt;left;</span><br></pre></td></tr></table></figure><p>结束条件为两棵树为空。</p><p>整理可得上述代码。</p><h3 id="Solution2（迭代版）："><a href="#Solution2（迭代版）：" class="headerlink" title="Solution2（迭代版）："></a>Solution2（迭代版）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode* t1 = q.front(); q.pop();</span><br><span class="line">            TreeNode* t2 = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!t1 &amp;&amp; !t2) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!t1 || !t2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(t1-&gt;val != t2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            q.push(t1-&gt;left);</span><br><span class="line">            q.push(t2-&gt;right);</span><br><span class="line">            q.push(t2-&gt;left);</span><br><span class="line">            q.push(t1-&gt;right);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>翻译为了迭代版，只不过根本的思想是一样的。都是将一棵树化为两棵树来进行判断的。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-590. N叉树的后序遍历</title>
      <link href="/2019/02/09/LeetCode-590-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">590. N叉树的后序遍历</a></p><p>给定一个 N 叉树，返回其节点值的后序遍历。</p><p>与<a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/submissions/" target="_blank" rel="noopener">589. N叉树的前序遍历</a>相对应。</p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorder(Node* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">        lastord(root,data);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lastord</span><span class="params">(Node* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;children.size(); i++)&#123;</span><br><span class="line">            lastord(root-&gt;children[i], data);</span><br><span class="line">        &#125;</span><br><span class="line">        data.push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基础题。</p><p>先访问子节点，等全部子节点访问完毕再将该节点的信息存储起来即可。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-589. N叉树的前序遍历</title>
      <link href="/2019/02/09/LeetCode-589-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal" target="_blank" rel="noopener">589. N叉树的前序遍历</a></p><p>给定一个 N 叉树，返回其节点值的前序遍历。<br><a id="more"></a></p><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder(Node* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">        preord(root,data);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preord</span><span class="params">(Node* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        data.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;children.size(); i++)&#123;</span><br><span class="line">            preord(root-&gt;children[i], data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基础题。</p><p>在访问子节点之前将该节点的信息存储起来即可。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-429. N叉树的层序遍历</title>
      <link href="/2019/02/09/LeetCode-429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/submissions/" target="_blank" rel="noopener">429. N叉树的层序遍历</a></p><p>给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。<br><a id="more"></a></p><h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(Node* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; data;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> data;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        <span class="comment">// 从节点开始。</span></span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="comment">//遍历目前队列中的节点，将他们逐一push进数组中。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">                Node* n = q.front();</span><br><span class="line">                <span class="comment">//将当前元素从队列中移除。</span></span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="comment">//存储数据</span></span><br><span class="line">                t.push_back(n-&gt;val);</span><br><span class="line">                <span class="comment">// 将每个元素下面的子节点push进队列中。</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-&gt;children.size(); j++)&#123;</span><br><span class="line">                    q.push(n-&gt;children[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            data.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用队列进行层序遍历。</p><p>每走到一层，记录该层有多少节点。对于该层的每一个节点都做</p><ul><li>将该节点的数据存储起来。</li><li>将该节点从队列中移除。</li><li>将该节点下的所有子节点都push进入队列中。</li></ul><p>当一层节点操作完毕后，队列中存储的就为下一层的全部节点。队列的个数就为当前所在层的节点的个数。</p><h3 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(Node* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; data;</span><br><span class="line">        dfs(root, data, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node* node, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;data, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果当前层还没有初始化。</span></span><br><span class="line">        <span class="keyword">if</span>(data.size()&lt;= level)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">            t.push_back(node-&gt;val);</span><br><span class="line">            data.push_back(t);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            data[level].push_back(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node-&gt;children.size(); i++)&#123;</span><br><span class="line">            dfs(node-&gt;children[i], data, level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归版本。</p><p>记录当前的层数。当前节点属于哪一层就往哪一层里push元素。</p><p>初始化小技巧：</p><p>当使用双层vector时，必须先初始化每一层vector。</p><p>可以利用size巧妙的进行初始化，每走到一层，将size与当前层作比较，size总是比当前层大1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span>(data.size()&lt;= level)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">    t.push_back(node-&gt;val);</span><br><span class="line">    data.push_back(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-236. 二叉树的最近公共祖先</title>
      <link href="/2019/02/02/LeetCode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <content type="html"><![CDATA[<p><a href="https://note.youdao.com/https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/submissions/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><strong>最近公共祖先</strong>的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><a id="more"></a><h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.找到从根节点到某一结点的路径。存储在栈内。</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; a;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; b;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        path(root,p,a);</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        path(root,q,b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.比较两个栈的栈顶，一样，返回，不一样，弹出较长的那个。如果长度一样，同时弹出。</span></span><br><span class="line">        TreeNode* t = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.top() == b.top())&#123;</span><br><span class="line">                t = a.top();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a.size() &gt; b.size())&#123;</span><br><span class="line">                a.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.size() &lt; b.size())&#123;</span><br><span class="line">                b.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                a.pop();</span><br><span class="line">                b.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(TreeNode* root, TreeNode* p, <span class="built_in">stack</span>&lt;TreeNode*&gt; &amp;a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || flag == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        a.push(root);</span><br><span class="line">        <span class="keyword">if</span>(root == p)&#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        path(root-&gt;left,p,a);</span><br><span class="line">        path(root-&gt;right,p,a);</span><br><span class="line">        <span class="keyword">if</span>(flag != <span class="number">1</span>)&#123;</span><br><span class="line">            a.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="先寻找从根节点到给定结点的路径，并存储在栈中。"><a href="#先寻找从根节点到给定结点的路径，并存储在栈中。" class="headerlink" title="先寻找从根节点到给定结点的路径，并存储在栈中。"></a>先寻找从根节点到给定结点的路径，并存储在栈中。</h5><h5 id="再将两栈比较，找到第一个相同结点即为最近公共祖先。"><a href="#再将两栈比较，找到第一个相同结点即为最近公共祖先。" class="headerlink" title="再将两栈比较，找到第一个相同结点即为最近公共祖先。"></a>再将两栈比较，找到第一个相同结点即为最近公共祖先。</h5><p>由于需要找最近相同的结点。<br>所以在遍历二叉树时，要使用<strong>前序遍历</strong>，先将结点保存在栈中，再考虑其子节点。<br>得到两个存储路径的栈（根节点在栈底）。</p><p>由于路径与层有关，路径越长的结点，所在的层也越低。所以寻找公共结点首先把较大的栈缩小到与较小的栈长度一致，然后比较栈顶，当遇到相同结点时，就为最近公共祖先。</p><h3 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找到最近符合条件的结点。</span></span><br><span class="line">        <span class="keyword">if</span>(!root || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left = lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        TreeNode* right = lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">        <span class="comment">// 如果找到了两个结点，不在一个位置。返回该结点（该结点是两个结点的公共祖先）。</span></span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果在该结点的下面，只找到了一个，先将该结点返回，交给上一级处理。（为了递归）</span></span><br><span class="line">        <span class="keyword">if</span>(left) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> right;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归版本。</p><p>看了评论区大神写的。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-226. 翻转二叉树</title>
      <link href="/2019/02/02/LeetCode-226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树</a></p><p>翻转一棵二叉树。</p><a id="more"></a><h3 id="Solution1（递归版）："><a href="#Solution1（递归版）：" class="headerlink" title="Solution1（递归版）："></a>Solution1（递归版）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) invertTree(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) invertTree(root-&gt;right);</span><br><span class="line">        TreeNode* temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>依次从叶子结点向上翻转。</p><h3 id="Solution2（层次遍历版）："><a href="#Solution2（层次遍历版）：" class="headerlink" title="Solution2（层次遍历版）："></a>Solution2（层次遍历版）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            TreeNode* node = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            TreeNode* nodeleft = node-&gt;left;</span><br><span class="line">            node-&gt;left = node-&gt;right;</span><br><span class="line">            node-&gt;right = nodeleft;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>层次遍历，每到一个结点，就讲该结点下的子结点交换。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-90. 子集 II</title>
      <link href="/2019/01/24/LeetCode-90-%E5%AD%90%E9%9B%86-II/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/subsets-ii/submissions/" target="_blank" rel="noopener">90. 子集 II</a></p><p>该题为<a href="https://leetcode-cn.com/problems/subsets/comments/" target="_blank" rel="noopener">78. 子集</a>的升级版</p><h3 id="给定一个可能包含重复元素的整数数组-nums，返回该数组所有可能的子集（幂集）。"><a href="#给定一个可能包含重复元素的整数数组-nums，返回该数组所有可能的子集（幂集）。" class="headerlink" title="给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。"></a>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</h3><a id="more"></a><blockquote><p>说明：解集不能包含重复的子集。</p><p>示例:</p><p>输入: [1,2,2]<br>输出:<br>[<br>  [2],<br>  [1],<br>  [1,2,2],<br>  [2,2],<br>  [1,2],<br>  []<br>]</p></blockquote><h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; item;</span><br><span class="line">        result.push_back(item);</span><br><span class="line">        <span class="comment">//去重所使用的集合</span></span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; item_set;</span><br><span class="line">        <span class="comment">//对nums进行排序。</span></span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        putitem(<span class="number">0</span>, nums, result, item, item_set);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putitem</span><span class="params">(<span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;item, <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;item_set)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= nums.size()) <span class="keyword">return</span>;</span><br><span class="line">        item.push_back(nums[i]);</span><br><span class="line">        <span class="comment">//如果没有重复，就加入到最终的集合里。</span></span><br><span class="line">        <span class="keyword">if</span>(item_set.find(item) == item_set.end())&#123;</span><br><span class="line">            result.push_back(item);</span><br><span class="line">            <span class="comment">//加入去重集合中。</span></span><br><span class="line">            item_set.insert(item);</span><br><span class="line">        &#125;</span><br><span class="line">        putitem(i+<span class="number">1</span>, nums, result, item, item_set);</span><br><span class="line">        item.pop_back();</span><br><span class="line">        putitem(i+<span class="number">1</span>, nums, result, item, item_set);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用一个set来先存储集合。<br>每当在添加的时候，先检查set中是否已经包含，再决定放入。</p><p>由于该题中有重复元素，<br><strong>为了避免形如[2,3,3,2]与[3,2,2,3]，先进行排序插入</strong></p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 排列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 452. 用最少数量的箭引爆气球</title>
      <link href="/2019/01/17/LeetCode-452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">452. 用最少数量的箭引爆气球</a></p><p>维护一个射击区间。<br>如果下一个区间的开始位置比当前区间的开始位置大，则需要更新。<br>同理，结束位置也一样。</p><p>也是就是说，<strong>保持在这个射击区间内，每一个气球都能被射中（求射击区间内所有球的交集）</strong>。</p><a id="more"></a><p>如果气球不再能被这个射击区间所容纳，则在增加一个射击区间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对气球从左端点开始排序。</span></span><br><span class="line">        sort(points.begin(),points.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> arrow = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> startindex = points[<span class="number">0</span>].first;</span><br><span class="line">        <span class="keyword">int</span> endindex = points[<span class="number">0</span>].second;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.size(); i++)&#123;</span><br><span class="line">            <span class="comment">//更新最小区间。</span></span><br><span class="line">            <span class="keyword">if</span>(points[i].first &gt; startindex &amp;&amp; points[i].first &lt;= endindex)&#123;</span><br><span class="line">                startindex = points[i].first;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(points[i].second &lt; endindex &amp;&amp; points[i].second &gt;= startindex)&#123;</span><br><span class="line">                endindex = points[i].second;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//继续下一轮。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(points[i].first &gt; startindex)&#123;</span><br><span class="line">                startindex = points[i].first;</span><br><span class="line">                endindex = points[i].second;</span><br><span class="line">                arrow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-45- 跳跃游戏 II</title>
      <link href="/2019/01/17/LeetCode-45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></p><p>此题<a href="https://leetcode-cn.com/problems/jump-game/comments/" target="_blank" rel="noopener">55. 跳跃游戏</a>的进阶版</p><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br><a id="more"></a></p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>按照前面题的思路，依然是从后往前搜索。<strong>每次搜索能跳到当前位置的最远位置。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 选择当前能跳到当前点的最远的距离。</span></span><br><span class="line">        <span class="keyword">int</span> max_index = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> current_max_index = max_index;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当没有到达开头位置，进行循环。</span></span><br><span class="line">        <span class="keyword">while</span>(max_index &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//记录能跳到当前数组的最前面的点。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = max_index<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i + nums[i] &gt;= max_index)&#123;</span><br><span class="line">                    current_max_index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">//更新能跳的最远的点。</span></span><br><span class="line">            max_index = current_max_index;</span><br><span class="line">            <span class="comment">//步数更新</span></span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用了两层循环，发现能ac，但是又排在了末名。</p><p>看了大神的代码，写出了下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size() &lt; 2)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //当前可到达的最远距离。</span><br><span class="line">        int current_max_index = nums[0];</span><br><span class="line">        //遍历各个位置中，可到达的最远距离。</span><br><span class="line">        int pre_max_max_index = nums[0];</span><br><span class="line">        int jump = 1;</span><br><span class="line">        </span><br><span class="line">        for(int i = 1; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            //更新当前可达到的最远距离。</span><br><span class="line">            if(i &gt; current_max_index)&#123;</span><br><span class="line">                jump++;</span><br><span class="line">                current_max_index = pre_max_max_index;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pre_max_max_index &lt; nums[i] + i)&#123;</span><br><span class="line">                //更新</span><br><span class="line">                pre_max_max_index = nums[i] + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return jump;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>跳到当前所能跳到的最远的位置所在的位置中</strong>。</p><p>记录当前位置所能到达的最远的位置。</p><p>如果做到了该最远位置，更新一下。继续走。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-402-移掉K位数字</title>
      <link href="/2019/01/17/LeetCode-402-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">402. 移掉K位数字</a></p><h3 id="给定一个以字符串表示的非负整数-num，移除这个数中的-k-位数字，使得剩下的数字最小。"><a href="#给定一个以字符串表示的非负整数-num，移除这个数中的-k-位数字，使得剩下的数字最小。" class="headerlink" title="给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。"></a>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</h3><p>在保持顺序的情况下，尽可能让较小的数充当较高位。</p><p>用一个栈来计较。<br>如果要进的数字比栈顶要大，并且可以删。直接将该数字丢弃。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在保持顺序的情况下，尽可能让较小的数充当较高位。</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> number = num[i]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="comment">//比当前栈顶元素大，并且能删除（k&gt;0）,直接丢弃。</span></span><br><span class="line">            <span class="keyword">while</span>(S.size() != <span class="number">0</span> &amp;&amp; S[S.size()<span class="number">-1</span>] &gt; number &amp;&amp; k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                S.pop_back();</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//0 不能在第一个位置。即不允许“0132”</span></span><br><span class="line">            <span class="keyword">if</span>(number != <span class="number">0</span> || S.size()!= <span class="number">0</span>)&#123;</span><br><span class="line">                S.push_back(number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理“123456789”的情况。</span></span><br><span class="line">        <span class="keyword">while</span>(S.size() != <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            S.pop_back();</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.size(); i++)&#123;</span><br><span class="line">            result.append(<span class="number">1</span>,<span class="string">'0'</span>+S[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="string">""</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeeCode-455-分发饼干</title>
      <link href="/2019/01/17/LeetCode-455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">455. 分发饼干</a></p><a id="more"></a><blockquote><p>输入: [1,2,3], [1,1]</p><p>输出: 1</p><p>解释:<br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。</p></blockquote><p><strong>尽量让胃口小的孩子分到尽量少的饼干。</strong></p><p>先排序。在饼干的循环中，如果孩子的胃口大于等于饼干，孩子加一。</p><p>###Solution:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先将两组数据排序。</span></span><br><span class="line">        <span class="built_in">std</span>::sort(g.begin(),g.end());</span><br><span class="line">        <span class="built_in">std</span>::sort(s.begin(),s.end());</span><br><span class="line">        <span class="comment">//记录被满足的孩子和饼干</span></span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cookie = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cookie &lt; s.size() &amp;&amp; child &lt; g.size())&#123;</span><br><span class="line">            <span class="comment">//饼干可以满足该孩子。</span></span><br><span class="line">            <span class="keyword">if</span>(g[child] &lt;= s[cookie])&#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            cookie++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-295-数据流的中位数</title>
      <link href="/2019/01/17/LeetCode-295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. 数据流的中位数</a></p><p>利用堆的堆顶可以随时保持最大（小）元素的特性。使用两个堆来存储数据。</p><p>由于需要取中位数。要保持两个堆堆顶为中间的元素。<br>所以：</p><a id="more"></a><ul><li>构建一个最小堆用来存放较大的数。</li></ul><ul><li>构建一个最大堆用来存放较小的数。</li></ul><p>（比较绕，需要用心思考一下）</p><p><strong>要随时保持两个堆的高度平衡</strong>。</p><p>这时，两堆堆顶就是数据中的中位数了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">        MedianFinder() &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(smallNums.empty())&#123;</span><br><span class="line">                <span class="comment">//往存放小元素的最大堆添加数据。</span></span><br><span class="line">                smallNums.push(num);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果两个堆的高度相同。优先push进当前堆顶元素更大的那一个。</span></span><br><span class="line">            <span class="keyword">if</span>(largeNums.size() == smallNums.size())&#123;</span><br><span class="line">                <span class="keyword">if</span>(smallNums.top() &gt; num)&#123;</span><br><span class="line">                    smallNums.push(num);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    largeNums.push(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//为了保持两个堆的平衡 。如果两堆高度不一致，分两种情况讨论</span></span><br><span class="line">            <span class="comment">//1.存放较大元素的最小堆的高度大于存放较小元素的最大堆的高度达。</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(largeNums.size() &gt; smallNums.size())&#123;</span><br><span class="line">                <span class="comment">// 该数比存放较大元素的最小堆的堆顶要大。</span></span><br><span class="line">                <span class="comment">// 首先将该堆堆顶元素push进存放较小元素的最大堆中。</span></span><br><span class="line">                <span class="comment">// 再将该数push进存放较大元素的最小堆</span></span><br><span class="line">                <span class="keyword">if</span>(num &gt; largeNums.top())&#123;</span><br><span class="line">                    smallNums.push(largeNums.top());</span><br><span class="line">                    largeNums.pop();</span><br><span class="line">                    largeNums.push(num);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 该数比存放较大元素的最小堆的堆顶要小。</span></span><br><span class="line">                <span class="comment">// 直接push进存放较小元素的最大堆。</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    smallNums.push(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.存放较大元素的最小堆的高度小于存放较小元素的最大堆的高度达。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(largeNums.size() &lt; smallNums.size())&#123;</span><br><span class="line">                <span class="comment">// 该数比存放较小元素的最大堆的堆顶要小。（该数一定要进该堆）</span></span><br><span class="line">                <span class="comment">// 首先将该堆堆顶元素push进存放较大元素的最小堆中。</span></span><br><span class="line">                <span class="comment">// 再将该数push进存放较小元素的最大堆中。</span></span><br><span class="line">                <span class="keyword">if</span>(num &lt; smallNums.top())&#123;</span><br><span class="line">                    largeNums.push(smallNums.top());</span><br><span class="line">                    smallNums.pop();</span><br><span class="line">                    smallNums.push(num);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 该数比存放较小元素的最大堆的堆顶要大。</span></span><br><span class="line">                <span class="comment">// 直接push进存放较大元素的最小堆。</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    largeNums.push(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 两堆平衡，取中位数。</span></span><br><span class="line">            <span class="keyword">if</span>(smallNums.size() == largeNums.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> (((<span class="keyword">double</span>)smallNums.top() + largeNums.top())/<span class="number">2</span> );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不平衡，谁高取谁的堆顶。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(smallNums.size() &gt; largeNums.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> smallNums.top();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> largeNums.top();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="comment">// 存放较大元素的最小堆</span></span><br><span class="line">        <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt; &gt; largeNums;</span><br><span class="line">        <span class="comment">// 存放较小元素的最大堆</span></span><br><span class="line">        <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>&gt; smallNums;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-55- 跳跃游戏</title>
      <link href="/2019/01/17/LeetCode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/jump-game/comments/" target="_blank" rel="noopener">55. 跳跃游戏</a></p><h3 id="给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。"><a href="#给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。" class="headerlink" title="给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。"></a>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。</h3><p>示例 1:</p><a id="more"></a><blockquote><p>输入: [2,3,1,1,4]<br>输出: true<br>解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。</p></blockquote><p>示例 2:</p><blockquote><p>输入: [3,2,1,0,4]<br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p></blockquote><p>首先想到的是将所有能达到的步数全部跑一遍，如果能到达返回true。结果TLE。</p><p>然后分析，在大部分情况下都做的是重复操作。需要剪枝。<br>用了一个辅助表。用于记录该点能否到达的了最后一个位置。不能就标记一下，查找的时候先从表里查找。如果标记过，就不需要再进行遍历了。</p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> index,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; q)</span></span>&#123;</span><br><span class="line">        <span class="comment">//可以达到最后一个位置，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= nums.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在表中能查到，说明该点不能达到。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q[index] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从该点开始，到该点所能到达的最后一个元素，依次搜索。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums[index]; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (jump(nums, index + i,q)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不能达到，在表中标记。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index + i &lt; q.size())&#123;</span><br><span class="line">                q[index + i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//建一个辅助表</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            q.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jump(nums,<span class="number">0</span>,q);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果能通过。但是排在了最后。</p><p>然后看了小象学院的视频。<br>思路是先记录下每一步能跳的最大距离，</p><p>遍历这个表。用一个变量记录步数，一个变量记录能走到的最大位置。<br>当步数小于这个最大位置，并且该步数不是最后一个位置时，说明这个数组中不能到达最后一个位置。返回false。</p><p>如果步数能走到数组的末尾，说明能走到。返回true。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存储该位置能跳到哪个位置（下标）。</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            index.push_back(i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//能够跳跃的位置。</span></span><br><span class="line">        <span class="keyword">int</span> jump = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前最远的位置。</span></span><br><span class="line">        <span class="keyword">int</span> max_index = index[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(jump &lt; index.size() &amp;&amp; jump &lt;= max_index)&#123;</span><br><span class="line">            <span class="comment">//更新最远位置</span></span><br><span class="line">            <span class="keyword">if</span>(max_index &lt; index[jump])&#123;</span><br><span class="line">                max_index = index[jump];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//前进一步</span></span><br><span class="line">            jump++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到了数组末尾。</span></span><br><span class="line">        <span class="keyword">if</span>(jump == index.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看了评论区大神的代码。<br>发现是从后往前开始判断的，依次判断是否能到达最远的距离。如果能到达，把最远的距离更新为现在所在位置。<br>于是写出了如下代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//能到达最远位置坐标</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//从该点可以达到终点坐标，则将最远位置的坐标更新为该点的坐标。</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] + i &gt;= n)&#123;</span><br><span class="line">                n = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//能够到达头部。</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-215-数组中的第K个最大元素</title>
      <link href="/2019/01/17/LeetCode-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a></p><h3 id="在未排序的数组中找到第-k-个最大的元素。请注意，你需要找的是数组排序后的第-k-个最大的元素，而不是第-k-个不同的元素。"><a href="#在未排序的数组中找到第-k-个最大的元素。请注意，你需要找的是数组排序后的第-k-个最大的元素，而不是第-k-个不同的元素。" class="headerlink" title="在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。"></a>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</h3><h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.size()-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>直接使用sort()函数。将倒数第K的元素直接返回。<br>这样做的复杂度就为sort函数的复杂度。</p><h3 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt; &gt; Q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Q.size() &lt; k)&#123;</span><br><span class="line">                Q.push(nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Q.top() &lt; nums[i])&#123;</span><br><span class="line">                Q.pop();</span><br><span class="line">                Q.push(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Q.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路：<br>使用最小堆。</p><p><strong>维护一个K大小的最小堆。</strong><br>最小堆的堆顶始终为最小元素。当有比堆顶更大的时候，让更大的元素进堆，堆顶的元素出堆。这样遍历一遍后。第K大的元素就到了堆顶。直接弹出即可。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 224. 基本计算器</title>
      <link href="/2019/01/05/LeetCode-224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/basic-calculator/" target="_blank" rel="noopener">224. 基本计算器</a></p><h3 id="实现一个基本的计算器来计算一个简单的字符串表达式的值。"><a href="#实现一个基本的计算器来计算一个简单的字符串表达式的值。" class="headerlink" title="实现一个基本的计算器来计算一个简单的字符串表达式的值。"></a>实现一个基本的计算器来计算一个简单的字符串表达式的值。</h3><p>字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格。</p><a id="more"></a><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; &amp;number_stack, <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; &amp;operation_stack)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number_stack.size() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num2 = number_stack.top();</span><br><span class="line">        number_stack.pop();</span><br><span class="line">        <span class="keyword">int</span> num1 = number_stack.top();</span><br><span class="line">        number_stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(operation_stack.top() == <span class="string">'+'</span>)&#123;</span><br><span class="line">            number_stack.push(num1 + num2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(operation_stack.top() == <span class="string">'-'</span>)&#123;</span><br><span class="line">            number_stack.push(num1 - num2);</span><br><span class="line">        &#125;</span><br><span class="line">        operation_stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> STATE_BEGIN = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NUMBER_STATE = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> OPERATION_STATE = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; number_stack;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; operation_stack;</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> STATE = STATE_BEGIN;</span><br><span class="line">        <span class="keyword">int</span> compuate_flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">switch</span>(STATE)&#123;</span><br><span class="line">                <span class="keyword">case</span> STATE_BEGIN:</span><br><span class="line">                    <span class="keyword">if</span>(s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                        STATE = NUMBER_STATE;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        STATE = OPERATION_STATE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> NUMBER_STATE:</span><br><span class="line">                    <span class="keyword">if</span>(s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                        number = number * <span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        number_stack.push(number);</span><br><span class="line">                        <span class="keyword">if</span>(compuate_flag == <span class="number">1</span>)&#123;</span><br><span class="line">                            compute(number_stack,operation_stack);</span><br><span class="line">                        &#125;</span><br><span class="line">                        number = <span class="number">0</span>;</span><br><span class="line">                        i--;</span><br><span class="line">                        STATE = OPERATION_STATE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> OPERATION_STATE:</span><br><span class="line">                    <span class="keyword">if</span>(s[i] == <span class="string">'+'</span> || s[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">                        operation_stack.push(s[i]);</span><br><span class="line">                        compuate_flag = <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)&#123;</span><br><span class="line">                        STATE = NUMBER_STATE;</span><br><span class="line">                        compuate_flag = <span class="number">0</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                        STATE = NUMBER_STATE;</span><br><span class="line">                        i--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                        compute(number_stack,operation_stack);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(number != <span class="number">0</span>)&#123;</span><br><span class="line">            number_stack.push(number);</span><br><span class="line">            compute(number_stack,operation_stack);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(number == <span class="number">0</span> &amp;&amp; number_stack.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number_stack.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先，数据用两个栈来存储。一个存数字，一个存操作符。</p><p>其次，建立一个状态机，来描述指针的走向状态。根据状态来做相应的操作。</p><p><img src="http://pkjge38r4.bkt.clouddn.com/19-1-5/97910766.jpg" alt="加减状态机"></p><p>刚开始有一个开始状态。检测下一个字符是数字还是字母。然后转换为相应的状态。</p><p>我们先讨论<strong>数字与操作符的存储时机</strong>：</p><ul><li>当指针指向数字时，先将数字暂存起来，继续检查下一位置，还是数字，继续与暂存的数字融合。当指针指向的不是数字时，这时就需要把这个数字存起来。</li><li>字符的存储时机就为该位置为+、-时进行存储。</li></ul><p>接下来讨论<strong>计算的时机</strong>。</p><p>首先是检测操作符，如果操作符后面是数字，则在该数字进行存储完成之后立马进行计算。</p><p>如果操作符之后是” ( “ 就要等下一个相应的” ) “出现。之后再进行计算。</p><p>所以<strong>设置一个计算标志</strong>。如果检测到操作符，把计算标志置为可计算，接着继续下一位的检测，如果是数字，就在存储后进行计算。如果是” ( “，就需要取消计算标志。</p><p><strong>一定要注意退格操作！！！</strong></p><p>退格发生在<strong>下一位置不再是数字</strong>或者<strong>在操作符之后的检测是不是数字</strong>的时候。</p><p>最后就是将描述翻译成代码的工作了。</p><p>这里注意，在表达式的最后通常是数字，这时也需要将数字存储起来再进行一次运算。</p><p>如果表达式正确，存储数字的栈的长度一定是1，直接返回栈顶。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 状态机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 232. 用栈实现队列</title>
      <link href="/2019/01/02/LeetCode-232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/submissions/" target="_blank" rel="noopener">232. 用栈实现队列</a></p><h3 id="使用栈实现队列的下列操作："><a href="#使用栈实现队列的下列操作：" class="headerlink" title="使用栈实现队列的下列操作："></a>使用栈实现队列的下列操作：</h3><ul><li>push(x) – 将一个元素放入队列的尾部。</li><li>pop() – 从队列首部移除元素。</li><li>peek() – 返回队列首部的元素。</li><li>empty() – 返回队列是否为空。</li></ul><a id="more"></a><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** push all element of _s1 to _s2*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushTos2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_s1.empty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span>(!_s1.empty())&#123;</span><br><span class="line">            _s2.push(_s1.top());</span><br><span class="line">            _s1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _s1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_s2.empty()) pushTos2();</span><br><span class="line">        <span class="keyword">int</span> a = _s2.top();</span><br><span class="line">        _s2.pop();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_s2.empty()) pushTos2();</span><br><span class="line">        <span class="keyword">return</span> _s2.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _s1.empty() &amp;&amp; _s2.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; _s1;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; _s2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用两个栈来实现堆。</p><ul><li>在做push操作的时候，直接push进第一个栈。</li><li>当要pop时，先检查第二栈是否为空，如果为空，就把第一个栈的元素全push进第二个栈，这是原本在第一个栈栈底的元素，就到了第二个栈的栈顶（相当于翻了个个)。这时就可以pop出去了。</li></ul><p>下面的函数实现的就是专门将第一个栈的元素全部push进第二栈的功能。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** push all element of _s1 to _s2*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushTos2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_s1.empty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span>(!_s1.empty())&#123;</span><br><span class="line">            _s2.push(_s1.top());</span><br><span class="line">            _s1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>当peek时，如果第二个栈已经没有元素。 也需要把第一个栈的元素“倒”进来，再进行peek();</li><li>empty：当两个栈都没有元素才算空。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 225. 用队列实现栈</title>
      <link href="/2019/01/02/LeetCode-225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/submissions/" target="_blank" rel="noopener">225. 用队列实现栈</a></p><h3 id="使用队列实现栈的下列操作："><a href="#使用队列实现栈的下列操作：" class="headerlink" title="使用队列实现栈的下列操作："></a>使用队列实现栈的下列操作：</h3><ul><li>push(x) – 元素 x 入栈</li><li>pop() – 移除栈顶元素</li><li>top() – 获取栈顶元素</li><li>empty() – 返回栈是否为空</li></ul><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyStack() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; temp_queue;</span><br><span class="line">        temp_queue.push(x);</span><br><span class="line">        <span class="keyword">while</span>(!data_queue.empty())&#123;</span><br><span class="line">            temp_queue.push(data_queue.front());</span><br><span class="line">            data_queue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!temp_queue.empty())&#123;</span><br><span class="line">            data_queue.push(temp_queue.front());</span><br><span class="line">            temp_queue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = data_queue.front();</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data_queue.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data_queue.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; data_queue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="核心思想：让新进来的元素始终在队列的头位置。"><a href="#核心思想：让新进来的元素始终在队列的头位置。" class="headerlink" title="核心思想：让新进来的元素始终在队列的头位置。"></a>核心思想：让新进来的元素始终在队列的头位置。</h5><p>所以需要一个临时的队列。先让push进来的元素进去临时队列里。再让原来的队列的元素全进去临时队列，这样就保证了队列的头位置始终是新进来的元素。再将临时队列的所有元素push回原队列。</p><p><img src="http://pkjge38r4.bkt.clouddn.com/19-1-2/16566427.jpg" alt="push操作"></p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 61. 旋转链表</title>
      <link href="/2019/01/01/LeetCode-61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">61. 旋转链表</a></p><h3 id="给定一个链表，旋转链表，将链表每个节点向右移动-k-个位置，其中-k-是非负数。"><a href="#给定一个链表，旋转链表，将链表每个节点向右移动-k-个位置，其中-k-是非负数。" class="headerlink" title="给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。"></a>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</h3><p>Example:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</p><p>输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getListNodeLength</span><span class="params">(struct ListNode * head)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">head1</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head1)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        head1 = head1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct ListNode*  <span class="title">getPosition</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">head1</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(index)&#123;</span><br><span class="line">        head1 = head1-&gt;next;</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">rotateRight</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = getListNodeLength(head);</span><br><span class="line">    <span class="keyword">if</span>(len &lt;=<span class="number">1</span> || (k %= len) &lt; <span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">int</span> position = len-k<span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">oldlast</span> = <span class="title">getPosition</span>(<span class="title">head</span>,<span class="title">len</span>-1);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newhead</span> = <span class="title">getPosition</span>(<span class="title">head</span>,<span class="title">position</span>+1);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newlast</span> = <span class="title">getPosition</span>(<span class="title">head</span>,<span class="title">position</span>);</span></span><br><span class="line">    oldlast-&gt;next = head;</span><br><span class="line">    newlast-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h5><p>该题看似是循环n次，实则将后K个元素移至头结点的位置。</p><p>直接找到最后一个元素，将它指向开始的位置。将倒数第k+1个元素指向NULL。</p><blockquote><p>k可以大于链表的长度，所以要对链表长度取模。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 24. 两两交换链表中的节点</title>
      <link href="/2019/01/01/LeetCode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></p><h3 id="给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。"><a href="#给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。" class="headerlink" title="给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。"></a>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</h3><h4 id="Example："><a href="#Example：" class="headerlink" title="Example："></a>Example：</h4><p>给定 1-&gt;2-&gt;3-&gt;4，你应该返回 2-&gt;1-&gt;4-&gt;3。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">swapPairs</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置头结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">first</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    first-&gt;next = head;</span><br><span class="line">    <span class="comment">//备份</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">first1</span> = <span class="title">first</span>;</span></span><br><span class="line">    <span class="comment">// 如果头结点后有两个结点</span></span><br><span class="line">    <span class="keyword">while</span>(first-&gt;next &amp;&amp; first-&gt;next-&gt;next)&#123;</span><br><span class="line">        <span class="comment">//两个结点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">one</span> = <span class="title">first</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">two</span> = <span class="title">first</span>-&gt;<span class="title">next</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">        <span class="comment">//交换两个结点。</span></span><br><span class="line">        one-&gt;next = two-&gt;next;</span><br><span class="line">        first-&gt;next = two;</span><br><span class="line">        two-&gt;next = one;</span><br><span class="line">        first = one;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> first1-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>用一个指针从开始读，如果可以读到该节点与下个节点，就将这两个结点交换位置，这时需要注意与前后的结点连接。</p><p>为了方便，用一个头结点来完成这个连接的工作。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 86. 分隔链表</title>
      <link href="/2019/01/01/LeetCode-86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">86. 分隔链表</a></p><h3 id="给定一个链表和一个特定值-x，对链表进行分隔，使得所有小于-x-的节点都在大于或等于-x-的节点之前。你应当保留两个分区中每个节点的初始相对位置。"><a href="#给定一个链表和一个特定值-x，对链表进行分隔，使得所有小于-x-的节点都在大于或等于-x-的节点之前。你应当保留两个分区中每个节点的初始相对位置。" class="headerlink" title="给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。你应当保留两个分区中每个节点的初始相对位置。"></a>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。你应当保留两个分区中每个节点的初始相对位置。</h3><h4 id="Example："><a href="#Example：" class="headerlink" title="Example："></a>Example：</h4><p>给定 head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2， x = 3。</p><p>你应该返回 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5。</p><a id="more"></a><h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建两个头结点</span></span><br><span class="line">        <span class="function">ListNode <span class="title">less_head</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">ListNode <span class="title">more_head</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode *less_ptr = &amp;less_head;</span><br><span class="line">        ListNode *more_ptr = &amp;more_head;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            <span class="comment">//将val小于x的分进less_ptr，大于等于的分进more_ptr;</span></span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val &lt; x)&#123;</span><br><span class="line">                less_ptr-&gt;next = head;</span><br><span class="line">                less_ptr = less_ptr-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                more_ptr-&gt;next = head;</span><br><span class="line">                more_ptr = more_ptr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//连接两个指针。</span></span><br><span class="line">        less_ptr-&gt;next = more_head.next;</span><br><span class="line">        more_ptr-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> less_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>用双指针。<br>创建两个头结点。比x小的划到第一个里面，否则划到第二个里面，最后将两个链表链接返回。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 138. 复制带随机指针的链表</title>
      <link href="/2019/01/01/LeetCode-138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">138. 复制带随机指针的链表</a></p><h3 id="给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深度拷贝。"><a href="#给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深度拷贝。" class="headerlink" title="给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深度拷贝。"></a>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深度拷贝。</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    RandomListNode *copyRandomList(RandomListNode *head) &#123;</span><br><span class="line">        //建立结点与当前位置的映射</span><br><span class="line">        std::map&lt;RandomListNode *, int&gt; node_map;</span><br><span class="line">        //存放copy了的所有结点。按位置。</span><br><span class="line">        std::vector&lt;RandomListNode *&gt; node_vec;</span><br><span class="line">        RandomListNode *ptr = head;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(ptr)&#123;</span><br><span class="line">            //创建与旧链表相等的结点。copy其中的值。</span><br><span class="line">            node_vec.push_back(new RandomListNode(ptr-&gt;label));</span><br><span class="line">            // 建立结点与当前位置的映射。</span><br><span class="line">            node_map[ptr] = i;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        //push尾结点</span><br><span class="line">        node_vec.push_back(0);</span><br><span class="line">        ptr = head;</span><br><span class="line">        i = 0;</span><br><span class="line">        while(ptr)&#123;</span><br><span class="line">            //将依次排列的结点的next相连接。</span><br><span class="line">            node_vec[i]-&gt;next = node_vec[i+1];</span><br><span class="line">            if(ptr-&gt;random)&#123;</span><br><span class="line">                //找到该结点对应所指向的random所映射的位置。然后赋给当前结点。</span><br><span class="line">                int id = node_map[ptr-&gt;random];</span><br><span class="line">                node_vec[i]-&gt;random = node_vec[id];</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        //返回首结点</span><br><span class="line">        return node_vec[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h3><p>如果没有random域，copy链表只要依次创建结点，并将当前结点的next指向下一个结点就完成了。</p><p>有random域会比较麻烦一些。需要通过<strong>建立一张结点与其位置的表</strong>来完成。</p><p>当需要填充random指向时，通过<strong>原链表的random域在表中的位置</strong>来将<strong>vector中这一位置的结点地址</strong>赋给random域。</p><h3 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为每个节点添加一个副本，链接在当前节点之后。</span></span><br><span class="line">        RandomListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            RandomListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> RandomListNode(cur-&gt;label);</span><br><span class="line">            cur-&gt;next-&gt;next = next;</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//copy随机指针</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            RandomListNode* random = cur-&gt;random;</span><br><span class="line">            <span class="comment">//如果随机指针不为空</span></span><br><span class="line">            <span class="keyword">if</span>(random) cur-&gt;next-&gt;random = random-&gt;next;</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="comment">// 新链表的头节点</span></span><br><span class="line">        RandomListNode* copyhead = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</span><br><span class="line">        RandomListNode* copyhead1 = copyhead;</span><br><span class="line">        <span class="comment">//split为两个链表</span></span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            copyhead-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            </span><br><span class="line">            copyhead = copyhead-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        copyhead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> copyhead1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><ul><li><p><strong>第一遍遍历：</strong><br>将每个节点copy出来之后连接到该结点的后面。<br>这样得到了两倍原本链表长度的链表。</p></li><li><p><strong>第二遍遍历：</strong><br>将每个原节点的random域复制到它之后的copy节点。</p></li><li><p><strong>第三遍遍历：</strong><br>将两个链表分离。<br>原节点重新相链接，copy后的结点相链接。</p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 23. 合并K个排序链表</title>
      <link href="/2019/01/01/LeetCode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个排序链表</a></p><h3 id="合并-k-个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。"><a href="#合并-k-个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。" class="headerlink" title="合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。"></a>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</h3><h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> ListNode* a,<span class="keyword">const</span> ListNode *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;val &lt; b-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ListNode*&gt; node_vec;</span><br><span class="line">        <span class="comment">//将每个结点push到vec中。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.size(); i++)&#123;</span><br><span class="line">            ListNode* head = lists[i];</span><br><span class="line">            <span class="keyword">while</span>(head)&#123;</span><br><span class="line">                node_vec.push_back(head);</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node_vec.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将vec中的元素按val域排序。</span></span><br><span class="line">        <span class="built_in">std</span>::sort(node_vec.begin(),node_vec.end(),cmp);</span><br><span class="line">        <span class="comment">//链接各个结点。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; node_vec.size();i++)&#123;</span><br><span class="line">            node_vec[i<span class="number">-1</span>]-&gt;next = node_vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个结点指向NULL</span></span><br><span class="line">        node_vec[node_vec.size()<span class="number">-1</span>]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> node_vec[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该方法比较粗暴。将所有的结点存入一个vector中，按结点中的值排序，然后依次将每个结点链接，最后返回。</p><h3 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode p0 = ListNode(0);</span><br><span class="line">        ListNode* p = &amp;p0;</span><br><span class="line">        ListNode* p1 = p;</span><br><span class="line">        while(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            if(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                p-&gt;next = new ListNode(l1-&gt;val);</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                new ListNode(l2-&gt;val);</span><br><span class="line">                p-&gt;next = new ListNode(l2-&gt;val);</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = (l1!=NULL) ? l1 :(l2!=NULL) ? l2 : NULL;</span><br><span class="line">        return p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;</span><br><span class="line">        //两个终止条件。</span><br><span class="line">        if(lists.size() == 0)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        if(lists.size() == 1)&#123;</span><br><span class="line">            return lists[0];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //将lists拆分成两个子lists;</span><br><span class="line">        int mid = lists.size()/2;</span><br><span class="line">        std::vector&lt;ListNode*&gt; sub1_lists;</span><br><span class="line">        std::vector&lt;ListNode*&gt; sub2_lists;</span><br><span class="line">        for(int i = 0; i &lt; mid; i++)&#123;</span><br><span class="line">            sub1_lists.push_back(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = mid; i &lt; lists.size(); i++)&#123;</span><br><span class="line">            sub2_lists.push_back(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        //递归调用</span><br><span class="line">        ListNode *l1 = mergeKLists(sub1_lists);</span><br><span class="line">        ListNode *l2 = mergeKLists(sub2_lists);</span><br><span class="line">        //返回两个链表合并的结果。</span><br><span class="line">        return mergeTwoLists(l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h5><p>（归并思想）递归算法。<br>将k个链表分割为独立的链表，再向上两两合并。</p><p>合并两个有序链表的子问题参照：<br><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/submissions/" target="_blank" rel="noopener">21. 合并两个排序链表</a></p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 归并 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 155. 最小栈</title>
      <link href="/2019/01/01/LeetCode-155-%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></p><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li>push(x) – 将元素 x 推入栈中。</li><li>pop() – 删除栈顶的元素。</li><li>top() – 获取栈顶元素。</li><li>getMin() – 检索栈中的最小元素。</li></ul><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">        MinStack() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            _data.push(x);</span><br><span class="line">            <span class="comment">// 更新当前的最小值状态。</span></span><br><span class="line">            <span class="keyword">if</span>(_min.empty() || _min.top() &gt;= x )&#123;</span><br><span class="line">                _min.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果是要弹出当前的最小值。将min中的值也一并弹出。</span></span><br><span class="line">            <span class="keyword">if</span>(_data.top() == _min.top())&#123;</span><br><span class="line">                _min.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            _data.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _data.top();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//返回最小栈的栈顶</span></span><br><span class="line">            <span class="keyword">return</span> _min.top();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; _data;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; _min;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h5><p>原来想用一个变量来记录最小值，这在push的时候没什么问题，但是当执行pop操作的时候，就不知道怎么更新了。</p><p>所以需要将每次一更新最小值都记录下来。</p><p><strong>使用另一个栈记录最小值的变更状态。</strong></p><p>每插入一个值，与之比较最小栈的栈顶的元素，如果比栈顶的元素小，就更新其状态，如果与栈顶元素相等，也需要插入。</p><p>当出栈的时候，如果与最小栈栈顶元素相等，最小栈也出栈。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 设计，栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 92. 反转链表 II</title>
      <link href="/2019/01/01/LeetCode-92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a></p><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><p>###Solution：<br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">reverseBetween</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> chang_len = n-m+<span class="number">1</span>;<span class="comment">//逆置的结点个数。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prevHead</span> = <span class="title">NULL</span>;</span><span class="comment">//记录开始逆置结点的前驱。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">result</span> = <span class="title">head</span>;</span><span class="comment">//用于最后返回。</span></span><br><span class="line">    <span class="keyword">while</span>(head &amp;&amp; --m)&#123; <span class="comment">//到达开始逆置的位置。</span></span><br><span class="line">        prevHead = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">modify_list_tail</span> = <span class="title">head</span>;</span><span class="comment">//将该结点之前当前开始逆置的结点。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">newHead</span> = <span class="title">NULL</span>;</span><span class="comment">//用于逆置结点。</span></span><br><span class="line">    <span class="keyword">while</span>(head &amp;&amp; chang_len)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">next</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">        head-&gt;next = newHead;</span><br><span class="line">        newHead = head;</span><br><span class="line">        head = next;</span><br><span class="line">        chang_len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时head就到了n处，modify_list_tail就到了逆置段的最后一个结点。</span></span><br><span class="line">    <span class="comment">//将modify_list_tail 与 head连接。</span></span><br><span class="line">    modify_list_tail-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(prevHead)&#123; <span class="comment">//如果prevHead不为空，说明不是从第一个几点开始逆置的。 m &gt; 1。</span></span><br><span class="line">        prevHead-&gt;next = newHead;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = newHead; <span class="comment">//如果prevHead为空， 则说明是从第一个就开始逆置，直接将逆置后的头结点赋值给res，m=1。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>解决这个问题主要是要找关键节点。</p><p>这个题的关键节点为：</p><ul><li>要逆置的结点的前一个结点（prevHead）。</li><li>要逆置的第一个结点。（直接用head来探测）。</li><li>要逆置的最后一个结点。（此结点为逆置前的第一个结点，逆置后就变为了最后一个结点）</li><li>要逆置的最后一个结点的后一个结点。（在用head逆置后，head就到了逆置后的这个结点。）</li></ul><ol><li>找到前两个结点。</li><li>从m开始，到n，一共需要n-m+1个结点需要逆置。所以要逆置n-m+1次。</li><li>将逆置后的尾结点 与 逆置段后面一个结点相连。</li><li>如果结点是从开始逆置，将逆置后的头结点返回。否则，将前面的结点与逆置后的头结点链接返回。</li></ol>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 160. 相交链表</title>
      <link href="/2019/01/01/LeetCode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
      <content type="html"><![CDATA[<p><a href="http://https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a></p><h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;ListNode*&gt; node_set;</span><br><span class="line">        <span class="keyword">while</span>(headA)&#123;</span><br><span class="line">            node_set.insert(headA);</span><br><span class="line">            headA = headA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(headB)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node_set.find(headB)!=node_set.end())&#123;</span><br><span class="line">                <span class="keyword">return</span> headB;</span><br><span class="line">            &#125;</span><br><span class="line">            headB = headB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>这种思路很简单。就是先将链表A的每个元素存入set中，在链表B的元素逐个去set中查找。找到就返回。<br>缺点：<br>使用了O(n)的空间。</p><hr><h3 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得链表的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_list_length</span><span class="params">(ListNode * head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将长的链表移动多余的步数；以致两个链表到了相等的长度。</span></span><br><span class="line"><span class="function">ListNode* <span class="title">forward_long_list</span><span class="params">(<span class="keyword">int</span> long_len, <span class="keyword">int</span> short_len, ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> step = long_len-short_len;</span><br><span class="line">    <span class="keyword">while</span>(head &amp;&amp; step)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        step--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> headA_len = get_list_length(headA);</span><br><span class="line">        <span class="keyword">int</span> headB_len = get_list_length(headB);</span><br><span class="line">        <span class="comment">//先移动较长的链表至两个链表的长度相等。</span></span><br><span class="line">        <span class="keyword">if</span>(headA_len&gt;headB_len)&#123;</span><br><span class="line">            headA = forward_long_list(headA_len,headB_len,headA);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            headB = forward_long_list(headB_len,headA_len,headB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再同时开始移动。如果这两个结点相等了，就找到了</span></span><br><span class="line">        <span class="keyword">while</span>(headA &amp;&amp; headB)&#123;</span><br><span class="line">            <span class="keyword">if</span>(headA == headB)&#123;</span><br><span class="line">                <span class="keyword">return</span> headA;</span><br><span class="line">            &#125;</span><br><span class="line">            headA = headA-&gt;next;</span><br><span class="line">            headB = headB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>由于后面的结点是两个链表共享的，所以链表在相交结点之前有可能长度不相等。</p><p>我们先将长的链表移动到与短链表相同的长度，然后两个链表同时移动，当两个结点变得相同时，就得到了相同结点。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 141. 环形链表</title>
      <link href="/2018/12/30/LeetCode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></p><h3 id="题目描述：给定一个链表，判断链表中是否有环。"><a href="#题目描述：给定一个链表，判断链表中是否有环。" class="headerlink" title="题目描述：给定一个链表，判断链表中是否有环。"></a>题目描述：给定一个链表，判断链表中是否有环。</h3><h5 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h5><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;ListNode*&gt; node_set;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node_set.find(head) == node_set.end())&#123;</span><br><span class="line">                node_set.insert(head);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>使用set。<br>将每一个结点在set中检查，如果没有，就插入该结点。如果找到了，就说明有环。如果到头了，说明没环，返回false；</p><p>该方法由于使用了set，所以空间复杂度为O(n);</p><hr><h5 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bool hasCycle(struct ListNode *head) &#123;</span><br><span class="line">    struct ListNode *slow = head;</span><br><span class="line">    struct ListNode *fast = head;</span><br><span class="line">    while(fast)&#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        if(fast)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(slow == fast)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>使用双指针。<br>用两个移动速度快慢不相同的指针来判断是否有环。如果有环，两个指针终会相遇，返回true。</p><p>由于快指针一定在慢指针的前面，所以在移动指针时，只要判断快指针是否为空，如果是，就说明没有环。返回false；</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 234.回文链表</title>
      <link href="/2018/12/30/leetcode-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/submissions/" target="_blank" rel="noopener">234.回文链表</a></p><h3 id="请判断一个链表是否为回文链表。"><a href="#请判断一个链表是否为回文链表。" class="headerlink" title="请判断一个链表是否为回文链表。"></a>请判断一个链表是否为回文链表。</h3><h5 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h5><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getListLength</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* head1 = head;</span><br><span class="line">        <span class="keyword">int</span> listlen = getListLength(head1);</span><br><span class="line">        <span class="keyword">if</span>(listlen &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = listlen/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(mid &amp;&amp; head)&#123;</span><br><span class="line">            s.push(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            mid--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(listlen%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val != s.top())&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            s.pop();</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h5><p>借助stack。</p><p>将mid之前的元素值都push进stack中，然后到mid之后，将每个元素与栈顶值比较。不相等退出，相等继续下一轮。</p><hr><h5 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getListLength</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据位置与所给链表，向后移动position步。</span></span><br><span class="line"><span class="function">ListNode* <span class="title">getNodeByPosition</span><span class="params">(ListNode* head,<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(position&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        position--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存储头结点。</span></span><br><span class="line">        ListNode* first = head;</span><br><span class="line">        ListNode* head1 = head;</span><br><span class="line">        <span class="keyword">int</span> listlen = getListLength(head);</span><br><span class="line">        <span class="keyword">int</span> midposition = listlen/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//如果链表长度&lt;=1，直接返回true;</span></span><br><span class="line">        <span class="keyword">if</span>(listlen &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//到达需要翻转的长度，对于偶数，为（listlen/2）+1，对于奇数，为listlen/2;</span></span><br><span class="line">        ListNode* mid = getNodeByPosition(head1,midposition);</span><br><span class="line">        <span class="comment">//翻转mid之后的指针。</span></span><br><span class="line">        ListNode * newHead = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> position = listlen-midposition;</span><br><span class="line">        <span class="keyword">while</span>(mid &amp;&amp; position)&#123;</span><br><span class="line">            ListNode* next = mid-&gt;next;</span><br><span class="line">            mid-&gt;next = newHead;</span><br><span class="line">            newHead = mid;</span><br><span class="line">            mid = next;</span><br><span class="line">            position--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将翻转之后的链表与开头的链表的内容比较，向后比较listlen/2;</span></span><br><span class="line">        <span class="comment">//如果是偶数，则元素都会比较到，如果是奇数，最后一个元素不会比较到。他在原来的链表中就处于中心位置，不必比较。</span></span><br><span class="line">        <span class="keyword">while</span>(first &amp;&amp; newHead &amp;&amp; midposition)&#123;</span><br><span class="line">            <span class="comment">//只要不相等，就为false;</span></span><br><span class="line">            <span class="keyword">if</span>(first-&gt;val != newHead-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            newHead = newHead-&gt;next;</span><br><span class="line">            midposition--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>将链表的后半段翻转，从翻转位置开始与从头结点开始，依次比较（listlen/2次）。</p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 142. 环形链表 II</title>
      <link href="/2018/12/30/leetcode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/"/>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></p><h3 id="给定一个链表，返回链表开始入环的第一个节点。-如果链表无环，则返回-null。"><a href="#给定一个链表，返回链表开始入环的第一个节点。-如果链表无环，则返回-null。" class="headerlink" title="给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。"></a>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</h3><a id="more"></a><h5 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;ListNode*&gt; node_set;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node_set.find(head) == node_set.end())&#123;</span><br><span class="line">                node_set.insert(head);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与141号问题的Solutions1一个思路，直接使用set。只不过返回的是结点不是boolean值罢了。</p><hr><h5 id="Solutions2"><a href="#Solutions2" class="headerlink" title="Solutions2:"></a>Solutions2:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode * head1 = head;</span><br><span class="line">        ListNode * slow = head;</span><br><span class="line">        ListNode * fast = head;</span><br><span class="line">        //fast走一步，slow走两步</span><br><span class="line">        while(fast)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            if(fast)&#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;else&#123; //没有环退出</span><br><span class="line">                return NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            //有环退出循环</span><br><span class="line">            if(fast == slow)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //说明有环</span><br><span class="line">        while(head1 &amp;&amp; fast)&#123;</span><br><span class="line">            if(head1 == fast)&#123;</span><br><span class="line">                return fast;</span><br><span class="line">            &#125;</span><br><span class="line">            head1 = head1-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        //不会走到这步，只是为了保证函数正常运行</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>这种方法只会使用O(1)的空间。</p><p>该方法的思路需要一点数学基础：</p><p>在一个有环的链表中，slow指针与fast指针相遇，从该相遇的位置开始，与链表的头位置开始，两者走同样的步数，如果两者相交，就走到了环的开始位置。</p><p><img src="http://pkjge38r4.bkt.clouddn.com/18-12-30/36603912.jpg" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一文学会Git</title>
      <link href="/2018/10/03/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9Agit/"/>
      <content type="html"><![CDATA[<h3 id="一、GIT下载、安装与配置"><a href="#一、GIT下载、安装与配置" class="headerlink" title="一、GIT下载、安装与配置"></a>一、GIT下载、安装与配置</h3><h4 id="1-下载与安装"><a href="#1-下载与安装" class="headerlink" title="1.下载与安装"></a>1.下载与安装</h4><p>下载git只需要直接在官网下载就可以了，它会自动下载适合你电脑配置的版本。<br>    <a href="https://git-scm.com//" target="_blank" rel="noopener">官网</a></p><p>安装就一直下一步就可以了。</p><a id="more"></a><h4 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h4><p>安装完成之后右键菜单就会自动添加两个选项：</p><ul><li>Git GUI</li><li>Git Bash</li></ul><p>在任意目录下右键点击 Git Bash 打开Git 命令行，输入一下两条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;USERNAME&quot;</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;xxx@xx.com&quot;</span><br></pre></td></tr></table></figure><blockquote><p><em>“USERNAME”填写你的用户名</em><br><em>“xxx@xx.com”填写你的邮箱</em></p></blockquote><p>这样配置完后你之后所创建的仓库都会默认创建在你的名下。</p><p>查看你的配置，输入下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>其中有两条条目为user.name和user.email即为你所配置的。</p><h3 id="二、Git基本操作"><a href="#二、Git基本操作" class="headerlink" title="二、Git基本操作"></a>二、Git基本操作</h3><h4 id="1、新建仓库"><a href="#1、新建仓库" class="headerlink" title="1、新建仓库"></a>1、新建仓库</h4><p>进入一个你要进行Git的目录（通常是你的工程目录）然后在右键菜单中进入Git Bash，键入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>它会在当前目录下创建一个.git的隐藏文件夹用来保存与git操作有关的相关信息。</p><h4 id="2、向仓库暂存区里添加文件"><a href="#2、向仓库暂存区里添加文件" class="headerlink" title="2、向仓库暂存区里添加文件"></a>2、向仓库暂存区里添加文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add FILENAME</span><br></pre></td></tr></table></figure><p>命令可以将文件添加到你所创建的仓库的暂存区中。</p><p>关于add命令有俩点需要注意：</p><blockquote><p>1.add现在还没有真正添加到仓库中，而是作为预备项来决定是否最终添加到仓库中。</p><p>2.这里的添加文件并不是你所在仓库的文件有了这个文件就可以了。仓库创建好后并不等于你所在文件夹中的所有文件也同样包含于仓库中，你需要手动告诉Git你要添加当前目录下的哪些文件到它的仓库中。</p></blockquote><p>你可以用以下命令来将所在文件夹下属的所有文件或者文件夹添加到暂存区中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add --all/-A</span><br><span class="line">or</span><br><span class="line">git add *</span><br></pre></td></tr></table></figure></p><h4 id="3、向仓库中提交文件"><a href="#3、向仓库中提交文件" class="headerlink" title="3、向仓库中提交文件"></a>3、向仓库中提交文件</h4><p>我们已经把文件添加到了暂存区，那么怎样让文件真正进去仓库呢？用commit命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;you need to record something&quot;</span><br></pre></td></tr></table></figure><p>这个命令可以让你将暂存区中的文件添加到仓库中。</p><blockquote><p>-m 选项是必选项，它需要你在提交时给他一下信息用于记录你的提交的原因。当然我们也提倡这样做。</p></blockquote><h4 id="4、一次性从工作区提交到仓库中"><a href="#4、一次性从工作区提交到仓库中" class="headerlink" title="4、一次性从工作区提交到仓库中"></a>4、一次性从工作区提交到仓库中</h4><p>有时候修改完文件要提交仓库中，要先添加到暂存区后再提交，很麻烦怎么办？给 git commit 加上 -a 选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m &quot;say something&quot;</span><br></pre></td></tr></table></figure><h4 id="5、查看git状态"><a href="#5、查看git状态" class="headerlink" title="5、查看git状态"></a>5、查看git状态</h4><p>不知道你的文件现在处于未跟踪状态还是处在暂存区，或者是一提交状态？用status命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>它会告诉你当前文件夹中的文件的状态和分支情况。</p><h4 id="6、从暂存区或仓库中移除文件"><a href="#6、从暂存区或仓库中移除文件" class="headerlink" title="6、从暂存区或仓库中移除文件"></a>6、从暂存区或仓库中移除文件</h4><p>如果你想删除一个文件，但是已经将它放入了暂存区中，如何去删除暂存区中的文件呢？<br>先将本地文件删除，再使用下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm FILENAME</span><br></pre></td></tr></table></figure></p><p>就可以将暂存区中的文件移除了。<br>当然，直接一同删除本地文件和暂存区文件也可以，添加 -f 选项。</p><p>那如果已经提交到仓库中了怎么办？<br>从仓库中删除文件可以在上条命令的基础上添加–cached选项。</p><blockquote><p>注意：如果之前你的本地目录中有该文件，从仓库中删除并不会把本地文件一并删除，所删除的文件在本地中会重新变为未跟踪状态。</p></blockquote><p>那么我不想删除本地文件，又不想把它提交到仓库中，该怎么办呢？</p><h4 id="7、添加忽略列表"><a href="#7、添加忽略列表" class="headerlink" title="7、添加忽略列表"></a>7、添加忽略列表</h4><p>可以在本地目录中添加一个名为 .gitignore 的文件，用来记录哪些文件需要被忽略。<br>直接在.gitignore文件中添加你不想被跟踪的文件即可。</p><p>github上有一个项目列举了各种忽略列表<a href="https://github.com/github/gitignore/blob/master/" target="_blank" rel="noopener">：ignore</a></p><h4 id="8、重命名文件"><a href="#8、重命名文件" class="headerlink" title="8、重命名文件"></a>8、重命名文件</h4><p>你可以中暂存区和仓库中修改文件的名字。<br>使用下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv FILE_FROM FILE_TO</span><br></pre></td></tr></table></figure><p>实际上，git并不会直接将名字修改，mv命令相当于下面三条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv README.md README</span><br><span class="line">git rm README.md</span><br><span class="line">git add README</span><br></pre></td></tr></table></figure><h4 id="9、查看提交历史"><a href="#9、查看提交历史" class="headerlink" title="9、查看提交历史"></a>9、查看提交历史</h4><p>在提交了若干更新，又或者克隆了某个项目之后，如果查看提交历史呢？<br>使用下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></p><p>它会按照时间线（由近及远）列出你的提交历史，包括SHA-1 校验、日期、提交者以及提交说明。</p><p>log命令有很多选项，他可以满足你的各种查看需求：</p><p><strong>-p</strong>，用来显示每次提交的内容差异。 你也可以加上 <strong>-NUMBER</strong> 来仅显示最近两次提交：<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p -2</span><br></pre></td></tr></table></figure></p><p>来查看近俩次提交之间的差异。</p><p><strong>–stat</strong>选项可以看到每次提交的简略的统计信息。</p><p><strong>–pretty</strong>选项可以指定不同的显示格式。<br>    其下有各种子选项：short、oneline、full、fuller、format等。</p><p>使用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure></p><p>会将每次提交在各自独自的一行中显示。</p><p>pretty选项中的format选项可以自定义选项格式：<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=format:&quot;%h - %an, %ar : %s&quot;</span><br></pre></td></tr></table></figure></p><p>完成的选项如下图：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>%H</td><td>提交对象（commit）的完整哈希字串</td></tr><tr><td>%h</td><td>提交对象的简短哈希字串</td></tr><tr><td>%T</td><td>树对象（tree）的完整哈希字串</td></tr><tr><td>%t</td><td>树对象的简短哈希字串</td></tr><tr><td>%P</td><td>父对象（parent）的完整哈希字串</td></tr><tr><td>%p</td><td>父对象的简短哈希字串</td></tr><tr><td>%an</td><td>作者（author）的名字</td></tr><tr><td>%ae</td><td>作者的电子邮件地址</td></tr><tr><td>%ad</td><td>作者修订日期（可以用 –date= 选项定制格式）</td></tr><tr><td>%ar</td><td>作者修订日期，按多久以前的方式显示</td></tr><tr><td>%cn</td><td>提交者（committer）的名字</td></tr><tr><td>%ce</td><td>提交者的电子邮件地址</td></tr><tr><td>%cd</td><td>提交日期</td></tr><tr><td>%cr</td><td>提交日期，按多久以前的方式显示</td></tr><tr><td>%s</td><td>提交说明</td></tr></tbody></table><hr><p><strong>–graph</strong> 显示 ASCII 图形表示的分支合并历史。</p><p>下面列举了一些常见的log下的选项：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-p</td><td>按补丁格式显示每个更新之间的差异。</td></tr><tr><td>–stat</td><td>显示每次更新的文件修改统计信息。</td></tr><tr><td>–shortstat</td><td>只显示 –stat 中最后的行数修改添加移除统计。</td></tr><tr><td>–name-only</td><td>仅在提交信息后显示已修改的文件清单。</td></tr><tr><td>–name-status</td><td>显示新增、修改、删除的文件清单。</td></tr><tr><td>–abbrev-commit</td><td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td></tr><tr><td>–relative-date</td><td>使用较短的相对时间显示（比如，“2 weeks ago”）。</td></tr><tr><td>–graph</td><td>显示 ASCII 图形表示的分支合并历史。</td></tr><tr><td>–pretty</td><td>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td></tr></tbody></table><p>你还可以限制输出的长度，包括按条目个数、时间和提交者等。这里就不一一列举了，需要的时候查一下即可。</p><h4 id="10、回滚版本"><a href="#10、回滚版本" class="headerlink" title="10、回滚版本"></a>10、回滚版本</h4><p>接下来我们学习git最核心的操作————回滚。<br>我们学会了通过git log 来查看提交信息，会发现每次commit之后都有一串数字和字母的组合，而这串字符串是系统自动生成的唯一的代表了这次提交请求的一个ID，我们可以通过这串字符串来任意回滚到之前某一次提交上去。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 9643a881f</span><br></pre></td></tr></table></figure></p><p>将回退到这串字符串所代表的那次提交的状态上。</p><blockquote><p>回滚的时候，并不需要将整个字符串都复制下来，从开头的一部分去截取也是可以的。</p></blockquote><h4 id="11、撤销操作"><a href="#11、撤销操作" class="headerlink" title="11、撤销操作"></a>11、撤销操作</h4><h5 id="（1）撤销提交后的操作"><a href="#（1）撤销提交后的操作" class="headerlink" title="（1）撤销提交后的操作"></a>（1）撤销提交后的操作</h5><p>当我们提交到了仓库文件以后，发现有一些文件漏添加了，或者提交信息写错了，这时就需要撤销操作。</p><p>先将你需要的文件添加到暂存区，然后使用下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend -m &quot;say something&quot;</span><br></pre></td></tr></table></figure></p><p>来覆盖你之前的那次提交，之前的那次提交不会出现在你提交的历史中。也就是说最终你只用最后一次的提交结果。</p><h5 id="（2）撤销暂存区中的操作"><a href="#（2）撤销暂存区中的操作" class="headerlink" title="（2）撤销暂存区中的操作"></a>（2）撤销暂存区中的操作</h5><p>如果不小心把不想放入暂存区的文件放入了暂存区，那么如何来撤销暂存区中的记录呢？<br>使用下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD FILENAME</span><br></pre></td></tr></table></figure></p><p>执行之后你会发现原本在暂存区中的文件，已经变成 了未跟踪状态。</p><h5 id="（3）撤销已修改文件的操作"><a href="#（3）撤销已修改文件的操作" class="headerlink" title="（3）撤销已修改文件的操作"></a>（3）撤销已修改文件的操作</h5><p>如果你修改了文件，却想撤回。此时文件并没有放入暂存区中，只是单纯的在工作环境中做了修改，那该怎么撤销呢？</p><p>其实git status命令已经告诉你了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br></pre></td></tr></table></figure><p>我们来使用下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --FIIENAME</span><br></pre></td></tr></table></figure><p>这时你发现原本修改过的操作变成了之前未更改的状态。</p><h4 id="12、给Git起别名"><a href="#12、给Git起别名" class="headerlink" title="12、给Git起别名"></a>12、给Git起别名</h4><p>如果不想使用Git本身的起名方式，那么可以通过起别名的方式来替换到Git默认的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.ci commit</span><br></pre></td></tr></table></figure></p><p>会将commit命令替换为ci，下次提交时，只要输入git ci就ok了。</p><p>当然，你也可以将常用的组合命令替换为一个命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.last &apos;log -1 HEAD&apos;</span><br></pre></td></tr></table></figure></p><p>输入git last将会看到最后一次提交。</p><h3 id="三、标签管理"><a href="#三、标签管理" class="headerlink" title="三、标签管理"></a>三、标签管理</h3><p>Git可以给历史中的某一次提交打上一个标签，用来标识这次提交，它相当于那次提交的引用，同样可以使用标签来回滚到所代表的提交。</p><h4 id="1、创建标签"><a href="#1、创建标签" class="headerlink" title="1、创建标签"></a>1、创建标签</h4><p>如何在当前提交上打标签呢？使用下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.9 -m &quot;some message&quot;</span><br></pre></td></tr></table></figure><p><strong>-a</strong>选项表示创建一个新的标签。</p><p><strong>-m</strong>和commit命令中的一样，为必填项，为标签添加一些注释。</p><p>还有一种轻量打标签的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.1.1</span><br></pre></td></tr></table></figure></p><p>这种不需要选项而直接给当前的提交打上标签。</p><h4 id="4、查看标签"><a href="#4、查看标签" class="headerlink" title="4、查看标签"></a>4、查看标签</h4><p>使用下面的命令来查看所有标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure></p><p>当然，在log命令中，你打的标签也会出现在提交的右边。</p><p>你也可以加<strong>-l</strong> 来进行特定的模式查找标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l v1.*</span><br></pre></td></tr></table></figure></p><p>将列出tags中以v1.开头的标签。</p><p>你也可以查看某一标签所代表的提交，使用下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show v1.1</span><br></pre></td></tr></table></figure><p>将显示打标签者，标签信息，时间和哪一次提交。</p><h4 id="5、给之前的提交打标签"><a href="#5、给之前的提交打标签" class="headerlink" title="5、给之前的提交打标签"></a>5、给之前的提交打标签</h4><p>如何给之前的提交打标签呢？<br>只要看一下那次提交的ID字符串就可以了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.2 9fceb02</span><br></pre></td></tr></table></figure></p><p>将会给那次提交打上一个标签。</p><h4 id="6、给远程仓库打标签"><a href="#6、给远程仓库打标签" class="headerlink" title="6、给远程仓库打标签"></a>6、给远程仓库打标签</h4><p>由于默认情况下，<strong>git push</strong>命令不会将标签传输到远程仓库，你需要显示的将标签传送到远程仓库中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin TAGNAME</span><br></pre></td></tr></table></figure></p><p>当然如果想传送的标签很多，可以使用带有<strong>–tags</strong>选项将所有标签全部传送到远程仓库中。</p><h3 id="四、使用远程仓库"><a href="#四、使用远程仓库" class="headerlink" title="四、使用远程仓库"></a>四、使用远程仓库</h3><p>我相信有相当大的一部分人，是想学习github的使用，之后才了解到了Git。这两者不是一种东西，git和github的关系，相当于球与球场的关系。git创建的是本地仓库，而github上存放了好多远程的仓库。这些仓库都是用户将自己的仓库上传到服务器上，让github来托管这些仓库。那么如何建立远程仓库以及让本地仓库与远程仓库关联起来呢？</p><h4 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h4>]]></content>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
