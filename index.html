<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  
  
  <title>  BeckoninGshy </title>

 
  
    <link rel="icon" href="/images/logo.png">
  


  <link rel="stylesheet" href="/nayo.min.css"> 
</head>  
  <body>   
    
      <header class="header">
	
  <nav class="header-inner">        

    <span class="iconfont icon-menu mobile-toggle"></span>   	

    <div class="header-logo">
      <a href="/">
        <img class="header-logo-img" src="/images/logo.png">
      </a>
    </div>

    <div class="header-menu">          
              
          
            <a class="header-menu-link" id="header-menu-home" href="/">
              <i class="iconfont icon-home">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-archives" href="/archives">
              <i class="iconfont icon-archives">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-tags" href="/tags">
              <i class="iconfont icon-tags">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-about" href="/about">
              <i class="iconfont icon-about">  
            </i></a>     
          
              
          
              <a class="header-menu-link" id="header-menu-search">
                <i class="iconfont icon-search">  
              </i></a>
          
                  
    </div>  
    
  </nav>
</header>

   

      <div class="container">       
          
          
            <div class="container-inner">  
          

          




<div class="profile sildeUpMin">
	
		<img class="avatar" src="/images/logo.png">

		<p class="author">Welcome to BeckoninGshy&#39;s Bolg</p>
		
		<div class="social">
   		      	
			<a target="_blank" class="social-links" href="https://github.com/yangzebin001">		
				<i class="iconfont icon-Github">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="">		
				<i class="iconfont icon-Facebook">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="">		
				<i class="iconfont icon-Instagram">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="https://music.163.com/#/user/home?id=117201882">		
				<i class="iconfont icon-Neteasemusic">
			</i></a>	
	    
    	</div>		
</div>


    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2020/12/22/使用python实现一个ping小程序/">使用python实现一个ping小程序</a>  
	       
		 

		<div class="article-meta">
			<time>12月 22, 2020</time>
			
				<span class="iconfont icon-star"></span>
				            
						<a class="article-tag" href="/tags/network/">network</a>           
				
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p>在看《计算机网络：自顶向下方法》第四章的时候，有一个编程作业是用python编写一个ping小程序，我在实现的时候加深了一写对python的了解和对IP报文头部和ICMP报文头部信息有了一定理解，故记录一下。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">ICMP_ECHO_REQUEST = <span class="number">8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checksum</span><span class="params">(strr)</span>:</span></span><br><span class="line">	csum = <span class="number">0</span></span><br><span class="line">	countTo = (len(strr) / <span class="number">2</span>) * <span class="number">2</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> count &lt; countTo:</span><br><span class="line">		thisVal = strr[count+<span class="number">1</span>] * <span class="number">256</span> + strr[count]</span><br><span class="line">		csum = csum + thisVal</span><br><span class="line">		csum = csum &amp; <span class="number">0xffffffff</span></span><br><span class="line">		count = count + <span class="number">2</span></span><br><span class="line">	<span class="keyword">if</span> countTo &lt; len(strr):</span><br><span class="line">		csum = csum + str[len(strr) - <span class="number">1</span>]</span><br><span class="line">		csum = csum &amp; <span class="number">0xffffffff</span></span><br><span class="line">	csum = (csum &gt;&gt; <span class="number">16</span>) + (csum &amp; <span class="number">0xffff</span>)</span><br><span class="line">	csum = csum + (csum &gt;&gt; <span class="number">16</span>)</span><br><span class="line">	answer = ~csum</span><br><span class="line">	answer = answer &amp; <span class="number">0xffff</span></span><br><span class="line">	answer = answer &gt;&gt; <span class="number">8</span> | (answer &lt;&lt; <span class="number">8</span> &amp; <span class="number">0xff00</span>)</span><br><span class="line">	<span class="keyword">return</span> answer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receiveOnePing</span><span class="params">(mySocket, ID, timeout, destAddr)</span>:</span></span><br><span class="line">	timeLeft = timeout</span><br><span class="line">	<span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">		startedSelect = time.time()</span><br><span class="line">		whatReady = select.select([mySocket], [], [], timeLeft)</span><br><span class="line">		howLongInSelect = (time.time() - startedSelect)</span><br><span class="line">		<span class="keyword">if</span> whatReady[<span class="number">0</span>] == []: <span class="comment"># Timeout</span></span><br><span class="line">			<span class="keyword">return</span> <span class="string">"请求超时。"</span></span><br><span class="line">		timeReceived = time.time()</span><br><span class="line">		recPacket, addr = mySocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">		<span class="comment">#Fill in start</span></span><br><span class="line">		<span class="comment">#Fetch the ICMP header from the IP packet</span></span><br><span class="line">		t, c, checksum, recID, seq = struct.unpack(<span class="string">"bbHHh"</span>, recPacket[<span class="number">20</span>:<span class="number">28</span>])</span><br><span class="line">		ttl, = struct.unpack(<span class="string">"b"</span>, recPacket[<span class="number">8</span>:<span class="number">9</span>])</span><br><span class="line">		<span class="keyword">if</span> t == <span class="number">3</span>:</span><br><span class="line">			<span class="keyword">if</span> c == <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">"Destination Network Unreachable."</span></span><br><span class="line">			<span class="keyword">elif</span> c == <span class="number">1</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">"Destination Host Unreachable."</span></span><br><span class="line">		<span class="keyword">if</span> t != <span class="number">0</span> <span class="keyword">or</span> c != <span class="number">0</span> <span class="keyword">or</span> recID != ID <span class="keyword">or</span> seq != <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"Recieve error."</span></span><br><span class="line">		<span class="comment">#Fill in end</span></span><br><span class="line">		timeLeft = timeLeft - howLongInSelect</span><br><span class="line">		<span class="keyword">if</span> timeLeft &lt;= <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"请求超时。"</span></span><br><span class="line">		<span class="keyword">return</span> [<span class="number">1</span>-timeLeft, ttl, len(recPacket)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendOnePing</span><span class="params">(mySocket, destAddr, ID)</span>:</span></span><br><span class="line">	<span class="comment"># Header is type (8), code (8), checksum (16), id (16), sequence (16)</span></span><br><span class="line">	myChecksum = <span class="number">0</span></span><br><span class="line">	<span class="comment"># Make a dummy header with a 0 checksum.</span></span><br><span class="line">	<span class="comment"># struct -- Interpret strings as packed binary data</span></span><br><span class="line">	header = struct.pack(<span class="string">"bbHHh"</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, <span class="number">1</span>)</span><br><span class="line">	data = struct.pack(<span class="string">"d"</span>, time.time())</span><br><span class="line">	<span class="comment"># Calculate the checksum on the data and the dummy header.</span></span><br><span class="line">	myChecksum = checksum(header + data)</span><br><span class="line">	<span class="comment"># Get the right checksum, and put in the header</span></span><br><span class="line">	<span class="keyword">if</span> sys.platform == <span class="string">'darwin'</span>:</span><br><span class="line">		myChecksum = htons(myChecksum) &amp; <span class="number">0xffff</span></span><br><span class="line">		<span class="comment">#Convert 16-bit integers from host to network byte order.</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		myChecksum = htons(myChecksum)</span><br><span class="line">	header = struct.pack(<span class="string">"bbHHh"</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, <span class="number">1</span>)</span><br><span class="line">	packet = header + data</span><br><span class="line">	mySocket.sendto(packet, (destAddr, <span class="number">1</span>)) <span class="comment"># AF_INET address must be tuple, not str</span></span><br><span class="line">	<span class="comment">#Both LISTS and TUPLES consist of a number of objects</span></span><br><span class="line">	<span class="comment">#which can be referenced by their position number within the object</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doOnePing</span><span class="params">(destAddr, timeout)</span>:</span></span><br><span class="line">	icmp = getprotobyname(<span class="string">"icmp"</span>)</span><br><span class="line">	<span class="comment">#SOCK_RAW is a powerful socket type. For more details see: http://sock-raw.org/papers/sock_raw</span></span><br><span class="line">	<span class="comment">#Fill in start</span></span><br><span class="line">	mySocket = socket(AF_INET, SOCK_RAW, icmp)</span><br><span class="line">	<span class="comment">#Fill in end</span></span><br><span class="line">	myID = os.getpid() &amp; <span class="number">0xFFFF</span> <span class="comment">#Return the current process i</span></span><br><span class="line">	sendOnePing(mySocket, destAddr, myID)</span><br><span class="line">	delay = receiveOnePing(mySocket, myID, timeout, destAddr)</span><br><span class="line">	mySocket.close()</span><br><span class="line">	<span class="keyword">return</span> delay</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(host, timeout=<span class="number">1</span>)</span>:</span></span><br><span class="line">	dest = gethostbyname(host)</span><br><span class="line">	print(<span class="string">"Pinging "</span> + dest + <span class="string">" using Python:"</span>)</span><br><span class="line">	print()</span><br><span class="line">	pingTimes = <span class="number">4</span></span><br><span class="line">	lost = <span class="number">0</span></span><br><span class="line">	delayList = []</span><br><span class="line">	<span class="comment">#Send ping requests to a server separated by approximately one second</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(pingTimes):</span><br><span class="line">		res = doOnePing(dest, timeout)</span><br><span class="line">		<span class="keyword">if</span> type(res) == str:</span><br><span class="line">			lost+=<span class="number">1</span>;</span><br><span class="line">			print(res)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		delay, TTL, packetSize = res</span><br><span class="line">		delay = int(delay * <span class="number">1000</span>)</span><br><span class="line">		delayList.append(delay)</span><br><span class="line">		print(<span class="string">"来自"</span>,dest,<span class="string">"的回复: 字节="</span>,packetSize,<span class="string">" 时间="</span>,delay,<span class="string">"ms TTL="</span>,TTL)</span><br><span class="line">		time.sleep(<span class="number">1</span>)<span class="comment"># one second</span></span><br><span class="line">	</span><br><span class="line">	print(dest + <span class="string">" 的 Ping 统计信息:"</span>)</span><br><span class="line">	print(<span class="string">"        数据包: 已发送 = "</span>,pingTimes,<span class="string">" ，已接收 = "</span>,pingTimes-lost,<span class="string">" ，丢失 = "</span>,lost, <span class="string">" ( "</span>,lost/pingTimes*<span class="number">100</span>,<span class="string">"% 丢失)"</span>)</span><br><span class="line">	<span class="keyword">if</span> len(delayList) &gt; <span class="number">0</span>:</span><br><span class="line">		print(<span class="string">"往返行程的估计时间(以毫秒为单位):"</span>)</span><br><span class="line">		print(<span class="string">"最短 = "</span>,min(delayList),<span class="string">"ms，最长 = "</span>,max(delayList),<span class="string">"ms，平均 = "</span>,sum(delayList)/len(delayList),<span class="string">"ms"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &lt;= <span class="number">1</span>:</span><br><span class="line">	print(<span class="string">"请输入要ping的主机地址!"</span>)</span><br><span class="line">	exit()</span><br><span class="line">ping(sys.argv[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>作业中主要填写两个空，一个在doOnePing函数中，一个在receiveOnePing函数中。</p>
<p>首先看doOnePing函数，根据上下文可以猜测出这里需要定义一个socket变量，然后我们在第二章中做的实验知道，创建TCP类型的socket的语句是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket(AF_INET, SOCK_STREAM)</span><br></pre></td></tr></table></figure></p>
<p>创建UDP类型的socket的语句是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket(AF_INET, SOCK_DGRAM)</span><br></pre></td></tr></table></figure></p>
<p>而我们要发送的是ICMP报文，要知道ICMP工作在网络层，所以不能用传输层的协议来传输，进一步根据注释知道了使用SOCK_RAW来创建一个原始套接字，通过查API知道创建包含ICMP协议的原始套接字的语句是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">icmp = getprotobyname(&quot;icmp&quot;)</span><br><span class="line">mySocket = socket(AF_INET, SOCK_RAW, icmp)</span><br></pre></td></tr></table></figure></p>
<p>第一个空完成！</p>
<hr>
<p>接下来做receiveOnePing函数中的空。</p>
<p>这个函数要结合着sendOnePing函数看，因为一个是从当前主机往目标主机发数据，一个是从目标主机往当前主机接收数据，所以用什么方法打包数据，就要用同样的方法反向解包。</p>
<p>可以看到sendOnePing函数是通过struct.pack()来将header和data打包起来发送的，所以在receiveOnePing函数使用struct.unpack()来进行解包。注意这里recPacket是IP报文数据，又因为一般的IP首部占20个字节，所以从第20个字节开始才是ICMP报文。所以 recPacket[20:28] 就是ICMP的报文头，然后用struct.unpack()来把数据解包。注释中 Header is type (8), code (8), checksum (16), id (16), sequence (16) 可以帮助理解ICMP的报文头部信息。根据ICMP报文头部的信息确定ICMP的类型，我们需要的是TYPE为0，CODE为0，该报文类型为Echo Reply——回显应答（Ping应答），到这里我们解析ICMP报文的任务就完成了。</p>
<p>为了做的和windows中自带的ping看起来更像一些，我适当的做了一些修改。</p>
<p>比如字节数和TTL，由于TTL是在IP报文头部的第八个字节中存储的，所以也单独的提取出来。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2020/12/22/使用python实现一个ping小程序/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2020/09/04/使用信号量实现生产者消费者模型/">使用信号量实现生产者消费者模型</a>  
	       
		 

		<div class="article-meta">
			<time>9月 04, 2020</time>
			
				<span class="iconfont icon-star"></span>
				            
						<a class="article-tag" href="/tags/并发/">并发</a>           
				            
						<a class="article-tag" href="/tags/锁/">锁</a>           
				            
						<a class="article-tag" href="/tags/信号量/">信号量</a>           
				            
						<a class="article-tag" href="/tags/生产者消费者/">生产者消费者</a>           
				
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		
			<p>上一篇已经介绍过生产者消费者模型，这次使用信号量来解决该问题。</p>
<h4 id="使用信号量实现生产者消费者模型："><a href="#使用信号量实现生产者消费者模型：" class="headerlink" title="使用信号量实现生产者消费者模型："></a>使用信号量实现生产者消费者模型：</h4><p>我们用两个信号量empty和fill来分别表示缓冲区空或者填入数据项。</p>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2020/09/04/使用信号量实现生产者消费者模型/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2020/09/02/使用锁+条件变量实现生产者消费者模型/">使用锁+条件变量实现生产者消费者模型</a>  
	       
		 

		<div class="article-meta">
			<time>9月 02, 2020</time>
			
				<span class="iconfont icon-star"></span>
				            
						<a class="article-tag" href="/tags/并发/">并发</a>           
				            
						<a class="article-tag" href="/tags/锁/">锁</a>           
				            
						<a class="article-tag" href="/tags/生产者消费者/">生产者消费者</a>           
				            
						<a class="article-tag" href="/tags/条件变量/">条件变量</a>           
				
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		
			<h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><p>假设有一个或多个生产者线程和一个或多个消费者线程。生产者把生成的数据项放入缓冲区，消费者从缓冲区取走数据项，以某种方式消费。</p>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2020/09/02/使用锁+条件变量实现生产者消费者模型/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2020/09/02/并发数据结构——懒惰计数器/">并发数据结构——懒惰计数器</a>  
	       
		 

		<div class="article-meta">
			<time>9月 02, 2020</time>
			
				<span class="iconfont icon-star"></span>
				            
						<a class="article-tag" href="/tags/并发/">并发</a>           
				            
						<a class="article-tag" href="/tags/数据结构/">数据结构</a>           
				
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		
			<blockquote>
<p>懒惰计数器是并发数据结构，它是性能与准确度折中的结果。</p>
</blockquote>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2020/09/02/并发数据结构——懒惰计数器/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2020/08/27/JVM OOM异常种类测试和解决方案总结/">JVM OOM异常种类测试和解决方案总结</a>  
	       
		 

		<div class="article-meta">
			<time>8月 27, 2020</time>
			
				<span class="iconfont icon-star"></span>
				            
						<a class="article-tag" href="/tags/JVM/">JVM</a>           
				
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		
			<blockquote>
<p>本文为学习《深入理解java虚拟机》书中2.4节实战部分的整理总结。</p>
</blockquote>
<p>jvm中能引起Out of memory Error 的运行时内存存储区域大致可以分为：</p>
<ul>
<li>java堆区溢出</li>
<li>java虚拟机栈和本地方法栈溢出</li>
<li>方法区和运行时常量池溢出</li>
<li>本机直接内存溢出</li>
</ul>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2020/08/27/JVM OOM异常种类测试和解决方案总结/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2020/08/24/Pinning a thread —— 如何让线程运行在特定的CPU上/">Pinning a thread —— 如何让线程运行在特定的CPU上</a>  
	       
		 

		<div class="article-meta">
			<time>8月 24, 2020</time>
			
				<span class="iconfont icon-star"></span>
				            
						<a class="article-tag" href="/tags/Linux/">Linux</a>           
				            
						<a class="article-tag" href="/tags/线程/">线程</a>           
				            
						<a class="article-tag" href="/tags/cpu/">cpu</a>           
				
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		
			<p>在看OSTEP的TLB部分时，作业中有一个问题是：<strong>如何让线程运行在特定的CPU上</strong>，觉得挺有趣的问题，随后通过STFW找到了答案。</p>
<p>主要用到两个 <code>pthread_setaffinity_np</code> 和 <code>pthread_getaffinity_np</code> api。</p>
<p>通过 RTFM<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man pthread_setaffinity_np</span><br></pre></td></tr></table></figure></p>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2020/08/24/Pinning a thread —— 如何让线程运行在特定的CPU上/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2020/01/30/LeetCode-10-正则表达式匹配/">LeetCode-10-正则表达式匹配</a>  
	       
		 

		<div class="article-meta">
			<time>1月 30, 2020</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. 正则表达式匹配</a></p>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;.&apos; 匹配任意单个字符</span><br><span class="line">&apos;*&apos; 匹配零个或多个前面的那一个元素</span><br></pre></td></tr></table></figure>
<p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<p>说明:</p>
<ul>
<li>s 可能为空，且只包含从 a-z 的小写字母。</li>
<li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。</span><br></pre></td></tr></table></figure>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。</span><br></pre></td></tr></table></figure>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4:"></a>示例 4:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure>
<h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5:"></a>示例 5:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>可以使用动态规划来解此题。</p>
<p>首先定义状态，有过求LCS和LIC的经验，我们很轻易类似的写出该题的状态定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] 串S以i结尾，串P以j结尾是否能够匹配。</span><br></pre></td></tr></table></figure>
<p>我们考虑状态转移方程：<br>先分类考虑：</p>
<ul>
<li><p>s[i] != p[j] &amp;&amp; p[j] != ‘.’ &amp;&amp; p[j] != ‘*’</p>
</li>
<li><p>s[i] == p[j]</p>
</li>
</ul>
<ul>
<li>p[j] == ‘.’</li>
</ul>
<ul>
<li>p[j] == ‘*’</li>
</ul>
<p>第一种情况显然是false。</p>
<p>第二种情况是说明可以匹配，所以由S前i-1，P前j-1匹配的情况决定。</p>
<p>第三种情况把’.’看做s[i]可以和第二种情况合并</p>
<p>重点是第四种情况，p[j]为’*’ 的情况：</p>
<p>单独一个‘ <em> ’是不构成语义的，所以出现‘ </em> ’就要看前一个字符，而前面有可能出现的又有‘.’和字母两种情况。<br>前面说过了，我们遇见‘.’直接把他当作与s[i]相等的字符即可。不需要做特殊处理。</p>
<p>所以就只剩下了‘*’ 前面是字母的<br>而分成的两种情况：</p>
<ul>
<li>‘*’前面的字母和s[i-1]不匹配。</li>
</ul>
<ul>
<li>‘*’前面的字母和s[i-1]匹配。</li>
</ul>
<p>第一种情况由于’*’可以代表零个之前的字符。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aabc</span><br><span class="line">ad*abc</span><br></pre></td></tr></table></figure>
<p>是可以匹配的。<br>所以我们遇到’*’前面的字母和s[i-1]不匹配就可以跳过这两个字符。即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i][j-2]</span><br></pre></td></tr></table></figure>
<p>最后’*’前面的字母和s[i-1]匹配：</p>
<p>那么就有按照‘*’的语义，又需要划分三种情况：</p>
<ul>
<li>*加上前面的字符不与s[i-1]匹配。</li>
<li><em>加上前面的字符只与s[i-1]匹配 即 </em> 作废。</li>
<li>*加上前面的字符可以与多个s[i-1]匹配。</li>
</ul>
<p>前两种情况其实与我们之前分析的不加‘*’的情况基本一致。<br>那么与多个字符匹配怎么转移呢？</p>
<p>我们确定匹配多个字符可以一个一个来，只要dp[i-1][j]可以匹配。那么只要[j]是<em>，则dp[i][j]一定可以匹配上。（别忘了，我们的前提条件是 </em> 和之前的字母匹配）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###b</span><br><span class="line">###b* </span><br><span class="line">匹配。</span><br><span class="line"></span><br><span class="line">###bb</span><br><span class="line">###b*</span><br><span class="line">一定能匹配。</span><br></pre></td></tr></table></figure>
<p>至此我们就将所有情况分析完毕。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">        int n = s.size(), m = p.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(m+1));</span><br><span class="line">        dp[0][0] = 1;</span><br><span class="line">        //处理 aa 和c*c*c*aa 匹配的情况。前缀可以忽略。</span><br><span class="line">        for(int i = 1; i &lt;= m; i++)&#123;</span><br><span class="line">            if(i-2 &gt;= 0 &amp;&amp; dp[0][i-2] &amp;&amp; p[i-1] == &apos;*&apos;) dp[0][i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            for(int j = 1; j &lt;= m; j++)&#123;</span><br><span class="line">                //单个字符匹配。</span><br><span class="line">                if(s[i-1] == p[j-1] || (p[j-1] == &apos;.&apos;))&#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1];</span><br><span class="line">                //单个字符不匹配</span><br><span class="line">                &#125;else if(p[j-1] == &apos;*&apos;)&#123;</span><br><span class="line">                    // baa bc*aa 形式</span><br><span class="line">                    if(p[j-2] != s[i-1] &amp;&amp; p[j-2] != &apos;.&apos;)&#123;</span><br><span class="line">                        dp[i][j] = dp[i][j-2];</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                    // 否则是前一个字符可以匹配</span><br><span class="line">                    // 三种情况，</span><br><span class="line">                    // 忽略这个匹配的字符，dp[i][j] = dp[i][j-2];</span><br><span class="line">                    // 只匹配这个字符 dp[i][j] = dp[i][j-1];</span><br><span class="line">                    // 匹配多个字符，即看i之前的字符和当前能不能匹配上，dp[i][j] = dp[i-1][j];</span><br><span class="line">                    // ###b 和 ###b* 如果能匹配上， ###bb 和 ###b* 也能匹配上。</span><br><span class="line">                        dp[i][j] = (dp[i][j-2] || dp[i][j-1] || dp[i-1][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里有一个点必须初始化，因为下标是从1开始的，无法访问到0，当遇到处理 aa 和c <em> c </em> c* aa 匹配的情况时，是需要访问到0的位置的，所以需要预处理。前缀可以为空的情况。</p>
</blockquote>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2020/01/30/LeetCode-10-正则表达式匹配/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2020/01/25/HDOJ102-Ma-Su-Plu-Plus/">HDOJ102-Ma-Su-Plu-Plus</a>  
	       
		 

		<div class="article-meta">
			<time>1月 25, 2020</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1024" target="_blank" rel="noopener">Max Sum Plus Plus</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Now I think you have got an AC in Ignatius.L’s “Max Sum” problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem.</p>
<p>Given a consecutive number sequence S1, S2, S3, S4 … Sx, … Sn (1 ≤ x ≤ n ≤ 1,000,000, -32768 ≤ Sx ≤ 32767). We define a function sum(i, j) = Si + … + Sj (1 ≤ i ≤ j ≤ n).</p>
<p>Now given an integer m (m &gt; 0), your task is to find m pairs of i and j which make sum(i1, j1) + sum(i2, j2) + sum(i3, j3) + … + sum(im, jm) maximal (ix ≤ iy ≤ jx or ix ≤ jy ≤ jx is not allowed).</p>
<p>But I`m lazy, I don’t want to write a special-judge module, so you don’t have to output m pairs of i and j, just output the maximal summation of sum(ix, jx)(1 ≤ x ≤ m) instead. ^_^</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>Each test case will begin with two integers m and n, followed by n integers S1, S2, S3 … Sn.<br>Process to the end of file.</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>Output the maximal summation described above in one line.</p>
<h3 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h3><p>1 3 1 2 3<br>2 6 -1 4 -2 3 -2 3</p>
<h3 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h3><p>6<br>8</p>
<p>Hint</p>
<p>Huge input, scanf and dynamic programming is recommended.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定n个数，让其划分为k个不重叠的区间（不要求连续），求其中的最大值。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>因为给定一个区间，它的最大值是确定的，所以具有无后效性，所以我们考虑使用dp来解此题。</p>
<p>我们首先定义状态表示，很自然的想到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i][j] 表示将前i个数字分成j段的最大子段和。</span><br></pre></td></tr></table></figure>
<p>接下来考虑状态转移方程：</p>
<p>我们将状态转移分为：</p>
<ul>
<li>与前面划分的区间不合并，即自成一组。</li>
<li>与前面划分的区间合并为一组。</li>
</ul>
<p>第二种转移方程比较好考虑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + v[i];</span><br></pre></td></tr></table></figure>
<p>自成一组需要找上一组从哪里转移。由于不需要保证连续性，所以就需要从第一段一直到j-1段都要考虑到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max&#123;dp[k][j-1](1 &lt;= k &lt; i)&#125;</span><br></pre></td></tr></table></figure>
<p>由于只有k个长度的字符才能分成k段。所以这里取值范围应该改为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max&#123;dp[k][j-1](j-1 &lt;= k &lt; i)&#125; + v[i]</span><br></pre></td></tr></table></figure>
<p>综合一下就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] =max( dp[i-1][j], max&#123;dp[k][j-1](j-1 &lt;= k &lt; i)&#125; ) + v[i]</span><br></pre></td></tr></table></figure>
<p>分析工作准备完毕，我们准备写代码时发现，这个数组范围比较大，会O（n2）的算法会超时，所以要优化。</p>
<p>第二种转移方程没什么好优化的，我们转移到第一种上，它在转移上依赖了他之上的好多行的数组，列却只依赖一列。这里想象为二维数组，我们把行，列的含义互换，想象这个二维数组逆时针旋转了90度。<br>就得到了如下的转移方程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i][j] 表示将前j个数字分成i段的最大子段和。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] =max( dp[i][j-1], max&#123;dp[i-1][k](i-1 &lt;= k &lt; j)&#125; ) + v[j]</span><br></pre></td></tr></table></figure>
<p>我们可以将 max{dp[i-1]<a href="i-1 &lt;= k &lt; j">k</a>} 这个O(n)的时间，在上一层的d[i-1][j]计算结果时用一个变量来记录，使其优化为O(1)。</p>
<p>具体编程还是有些难度，需要好好思考。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Date: 2020-01-24 10:42:12</span><br><span class="line"> * @LastEditors  : BeckoninGshy</span><br><span class="line"> * @LastEditTime : 2020-01-25 11:37:00</span><br><span class="line"> */</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN =1e6+10;</span><br><span class="line">int dp[MAXN],v[MAXN],numax[MAXN]; //保存上一层dp的最大值。</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int k,n;</span><br><span class="line">    while(cin &gt;&gt; k &gt;&gt; n)&#123;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; v[i];</span><br><span class="line">            dp[i] = numax[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0] = numax[0] = 0;</span><br><span class="line">        int lastmax = INT_MIN;</span><br><span class="line">        for(int i = 1; i &lt;= k; i++)&#123;</span><br><span class="line">            lastmax = INT_MIN; //保存上一层dp的最大值</span><br><span class="line">            for(int j = i; j &lt;= n; j++)&#123;</span><br><span class="line">            	//先利用之前的上一层最大值更新当前状态， </span><br><span class="line">                dp[j] = max(dp[j-1],numax[j-1]) + v[j];</span><br><span class="line">                //再将j-1的最大值更新到上一层的最大值数组中， 将在i+1层循环中使用，当前循环不使用</span><br><span class="line">                numax[j-1] = lastmax;</span><br><span class="line">                //存储当前层的最大值 </span><br><span class="line">                lastmax = max(lastmax,dp[j]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; lastmax &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2020/01/25/HDOJ102-Ma-Su-Plu-Plus/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2020/01/20/LeetCode-1320-二指输入的的最小距离/">LeetCode-1320-二指输入的的最小距离</a>  
	       
		 

		<div class="article-meta">
			<time>1月 20, 2020</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/minimum-distance-to-type-a-word-using-two-fingers/" target="_blank" rel="noopener">1320. 二指输入的的最小距离</a></p>
<p>二指输入法定制键盘在 XY 平面上的布局如上图所示，其中每个大写英文字母都位于某个坐标处，例如字母 A 位于坐标 (0,0)，字母 B 位于坐标 (0,1)，字母 P 位于坐标 (2,3) 且字母 Z 位于坐标 (4,1)。</p>
<p>给你一个待输入字符串 word，请你计算并返回在仅使用两根手指的情况下，键入该字符串需要的最小移动总距离。坐标 (x1,y1) 和 (x2,y2) 之间的距离是 |x1 - x2| + |y1 - y2|。 </p>
<p>注意，两根手指的起始位置是零代价的，不计入移动总距离。你的两根手指的起始位置也不必从首字母或者前两个字母开始。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：word = &quot;CAKE&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释：<br>使用两根手指输入 “CAKE” 的最佳方案之一是：<br>手指 1 在字母 ‘C’ 上 -&gt; 移动距离 = 0<br>手指 1 在字母 ‘A’ 上 -&gt; 移动距离 = 从字母 ‘C’ 到字母 ‘A’ 的距离 = 2<br>手指 2 在字母 ‘K’ 上 -&gt; 移动距离 = 0<br>手指 2 在字母 ‘E’ 上 -&gt; 移动距离 = 从字母 ‘K’ 到字母 ‘E’ 的距离  = 1<br>总距离 = 3</p>
<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：word = &quot;HAPPY&quot;</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释：<br>使用两根手指输入 “HAPPY” 的最佳方案之一是：<br>手指 1 在字母 ‘H’ 上 -&gt; 移动距离 = 0<br>手指 1 在字母 ‘A’ 上 -&gt; 移动距离 = 从字母 ‘H’ 到字母 ‘A’ 的距离 = 2<br>手指 2 在字母 ‘P’ 上 -&gt; 移动距离 = 0<br>手指 2 在字母 ‘P’ 上 -&gt; 移动距离 = 从字母 ‘P’ 到字母 ‘P’ 的距离 = 0<br>手指 1 在字母 ‘Y’ 上 -&gt; 移动距离 = 从字母 ‘A’ 到字母 ‘Y’ 的距离 = 4<br>总距离 = 6</p>
<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：word = &quot;NEW&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a>示例 4：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：word = &quot;YEAR&quot;</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：<br>2 &lt;= word.length &lt;= 300<br>每个 word[i]。都是一个大写英文字母。</p>
</blockquote>
<h3 id="Solution1（记忆化）："><a href="#Solution1（记忆化）：" class="headerlink" title="Solution1（记忆化）："></a>Solution1（记忆化）：</h3><p>我们首先要定义一个递归方程，思考后发现有两类主要元素：第一类是要记录到哪个字符，第二类是两个手指当前的位置。</p>
<p>然后发现“记录到哪个字符”这个状态不太好与两个手指进行关联（只能和一个手指进行绑定），所以我们转化一下思路，将记录到哪个字符转变为从第i个字符起，到字符串的末尾这整个区间，然后记录两个手指的状态。这样就得到了如下的递归函数参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// i: [i:w.size()]区间内花费的最小距离，</span><br><span class="line">// l: 上一个第一个手指的位置。</span><br><span class="line">// r: 上一个第二个手指的位置</span><br><span class="line">dfs(int i, int l, int r)</span><br></pre></td></tr></table></figure>
<p>转移方程为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs(i,l,c) = min(dfs(i+1,l,c)+cost(r,c),dfs(i+1,c,r)+cost(l,c));</span><br></pre></td></tr></table></figure>
<p>然后添加记忆化数组，整理就得到了下面的解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    int mem[310][27][27];</span><br><span class="line">    int cost(int i, int j)&#123;</span><br><span class="line">        if(i == 26 || j == 26) return 0;</span><br><span class="line">        return abs(i/6-j/6)+abs(i%6-j%6);</span><br><span class="line">    &#125;</span><br><span class="line">    string w;</span><br><span class="line">    // i: [i:w.size()]区间内花费的最小距离，</span><br><span class="line">    // l: 上一个第一个手指的位置。</span><br><span class="line">    // r: 上一个第二个手指的位置。</span><br><span class="line">    int dfs(int i, int l, int r)&#123;</span><br><span class="line">        if(i == w.size()) return 0;</span><br><span class="line">        if(mem[i][l][r]) return mem[i][l][r];</span><br><span class="line">        int c = w[i]-&apos;A&apos;;</span><br><span class="line">        return mem[i][l][r] = min(dfs(i+1,l,c)+cost(r,c),dfs(i+1,c,r)+cost(l,c));</span><br><span class="line">    &#125;</span><br><span class="line">    int minimumDistance(string word) &#123;</span><br><span class="line">        w = word;</span><br><span class="line">        //计算整个字符串的区间，初始两指从悬空状态开始。</span><br><span class="line">        return dfs(0,26,26);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Solution2（DP）："><a href="#Solution2（DP）：" class="headerlink" title="Solution2（DP）："></a>Solution2（DP）：</h3><p>我们可以试着将记忆化搜索转化为dp求解，很明显，状态表示和递归函数的状态是一致的，都是三维表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int dp[i][j][k]; //第一个手指一动到i，第二个手指移动到j，已经移动了k个字符的最小代价。</span><br></pre></td></tr></table></figure>
<p>这里与记忆化搜索定义的字符区间范围正好相反，递归中用的是从i到n的区间，而这里由于天然的记忆化过程，可以直接表示从0到k。</p>
<p>接着写状态转移方程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//从上一个字符移动到当前字符使用第一个手指，计算的最小价值。</span><br><span class="line">dp[c][j][k] = min(dp[c][j][k],dp[i][j][k-1] + cost);</span><br><span class="line">//从上一个字符移动到当前字符使用第二个手指，计算的最小价值。</span><br><span class="line">dp[i][c][k] = min(dp[i][c][k],dp[i][j][k-1] + cost);</span><br></pre></td></tr></table></figure>
<p>最后我们查看手指停在任何字符上的代价取最小即为答案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Cost(int i, int j)&#123;</span><br><span class="line">        //悬空状态，代价为0</span><br><span class="line">        if(i == 26 || j == 26) return 0;</span><br><span class="line">        return abs(i/6-j/6)+abs(i%6-j%6);</span><br><span class="line">    &#125;</span><br><span class="line">    int dp[27][27][301]; //第一个手指一动到i，第二个手指移动到j，已经移动了k个字符的最小代价。</span><br><span class="line">    int minimumDistance(string word) &#123;</span><br><span class="line">        memset(dp,0x3f3f3f3f,sizeof(dp));</span><br><span class="line">        // 初始化悬空状态</span><br><span class="line">        dp[26][26][0] = 0;</span><br><span class="line">        int n = word.size();</span><br><span class="line">        for(int k = 1; k &lt;= n; k++)&#123;</span><br><span class="line">            int c = word[k-1]-&apos;A&apos;;</span><br><span class="line">            //a</span><br><span class="line">            int cost = 0;</span><br><span class="line">            for(int i = 0; i &lt;= 26; i++)&#123;</span><br><span class="line">                for(int j = 0; j &lt;= 26; j++)&#123;</span><br><span class="line">                    cost = Cost(i,c);</span><br><span class="line">                    //从上一个字符移动到当前字符使用第一个手指，计算的最小价值。</span><br><span class="line">                    dp[c][j][k] = min(dp[c][j][k],dp[i][j][k-1] + cost);</span><br><span class="line">                    cost = Cost(j,c);</span><br><span class="line">                    //从上一个字符移动到当前字符使用第二个手指，计算的最小价值。</span><br><span class="line">                    dp[i][c][k] = min(dp[i][c][k],dp[i][j][k-1] + cost);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 0x3f3f3f3f;</span><br><span class="line">        for(int i = 0; i &lt;= 26; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt;= 26; j++)&#123;</span><br><span class="line">                ans = min(ans,dp[i][j][n]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2020/01/20/LeetCode-1320-二指输入的的最小距离/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2020/01/14/LeetCode-89-格雷编码/">LeetCode-89-格雷编码</a>  
	       
		 

		<div class="article-meta">
			<time>1月 14, 2020</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/gray-code/" target="_blank" rel="noopener">89. 格雷编码</a></p>
<p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p>
<p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0,1,3,2]</span><br><span class="line">解释:</span><br><span class="line">00 - 0</span><br><span class="line">01 - 1</span><br><span class="line">11 - 3</span><br><span class="line">10 - 2</span><br></pre></td></tr></table></figure>
<p>对于给定的 n，其格雷编码序列并不唯一。<br>例如，[0,2,3,1] 也是一个有效的格雷编码序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00 - 0</span><br><span class="line">10 - 2</span><br><span class="line">11 - 3</span><br><span class="line">01 - 1</span><br></pre></td></tr></table></figure>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: 0</span><br><span class="line">输出: [0]</span><br><span class="line">解释: 我们定义格雷编码序列必须以 0 开头。</span><br><span class="line">     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。</span><br><span class="line">     因此，当 n = 0 时，其格雷编码序列为 [0]。</span><br></pre></td></tr></table></figure>
<h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><p>动态规划法：</p>
<p>格雷码可以通过在当前的部分格雷码通过复制这一部分上下翻转次序后，使翻转后的部分通过新增加的最高位都转换为1来得到。</p>
<p>例如当前的部分序列为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00</span><br><span class="line">01</span><br></pre></td></tr></table></figure></p>
<p>翻转后为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">01</span><br><span class="line">00</span><br></pre></td></tr></table></figure></p>
<p>往每个数字前面增加一位前导零组合成新的部分格雷码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000</span><br><span class="line">001</span><br><span class="line">001</span><br><span class="line">000</span><br></pre></td></tr></table></figure></p>
<p>将翻转后的数字的前导零置为1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000</span><br><span class="line">001</span><br><span class="line">101</span><br><span class="line">100</span><br></pre></td></tr></table></figure></p>
<p>这一新的序列也是格雷码序列。</p>
<p>通过翻转n次，将得到长度为n全部的格雷码序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; grayCode(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        ans.push_back(0);</span><br><span class="line">        for(int k = 0; k &lt; n; k++)&#123;</span><br><span class="line">            int c = ans.size();</span><br><span class="line">            for(int j = c, i = 1; j &lt; 2*c; j++, i++)&#123;</span><br><span class="line">                ans.push_back(ans[c-i]|(1&lt;&lt;k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h3><p>直接构造法：</p>
<p>维基百科中生成格雷码的步骤为：</p>
<blockquote>
<p>以二进制为 0 值的格雷码为第零项，第一项改变最右边的位元，第二项改变右起第一个为1的位元的左边位元，第三、四项方法同第一、二项，如此反复，即可排列出n个位元的格雷码。</p>
</blockquote>
<p>以3为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">000 初始值</span><br><span class="line">001 改变右起第一项</span><br><span class="line">011 改变右起第一个为1的位元的左边位元</span><br><span class="line">010 改变右起第一项</span><br><span class="line">110 改变右起第一个为1的位元的左边位元</span><br><span class="line">111 改变右起第一项</span><br><span class="line">101 改变右起第一个为1的位元的左边位元</span><br><span class="line">100 改变右起第一项</span><br></pre></td></tr></table></figure>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; grayCode(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        ans.push_back(0);</span><br><span class="line">        for(int k = 1; k &lt; 1&lt;&lt;n; k++)&#123;</span><br><span class="line">            // 改变右起第一项。</span><br><span class="line">            if(k%2) ans.push_back(ans[k-1]^1);</span><br><span class="line">            // 改变右起第一个为1的位元的左边位元</span><br><span class="line">            else&#123;</span><br><span class="line">                int c = 0;</span><br><span class="line">                int pre = ans[k-1];</span><br><span class="line">                while(((pre&gt;&gt;c) &amp; 1) == 0) c++;</span><br><span class="line">                c++;</span><br><span class="line">                ans.push_back(pre^(1&lt;&lt;c));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="Solution3："><a href="#Solution3：" class="headerlink" title="Solution3："></a>Solution3：</h3><p>公式法：</p>
<p>当前第i项的二进制数的最高位保留，其它位是当前位和它的高一位进行异或操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; grayCode(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line"></span><br><span class="line">        for(int k = 0; k &lt; 1&lt;&lt;n; k++)&#123;</span><br><span class="line">            //每一项与当前数右移后异或得到。</span><br><span class="line">            ans.push_back(k^(k&gt;&gt;1));</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2020/01/14/LeetCode-89-格雷编码/">阅读更多</a> 	
	</div>	
    
</article>     
     	




 
   <nav class="paginator">
    

   <span class="page-number"> Page <strong>1</strong>, Total <strong>125</strong> . </span>

    
        <a class="next" href="/page/2/"> 
            下一页
            <i class="iconfont icon-right"></i>
        </a>
    
  </nav> 

          </div> 
      </div>            
    
    <a id="page-backTop">
      <span>
        <i class="iconfont icon-backtotop"></i>
      </span>
    </a> 

  
    
    <div class="search-container sildeUpMin">
        <div class="search-header">
            <input type="text" placeholder="输入你想搜索的" id="search-input" class="search-input">
            <span class="search-cancel">
                <i class="iconfont icon-cancel">
            </i></span>
        </div>
        <div id="search-result" class="search-result"></div>
    </div>
 
     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon" src="/images/logo.png">   
      

         
            

            <a class="mobile-menu-link" href="/">首页
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">归档
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">标签
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">关于
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">搜索 </a>                 
            
         
      
</div>        
    



     
    




<footer id="footer">	    

		
		<div class="footer-copyright">
		&copy;
				
		2017-
		
		2020		
	
		BeckoninGshy&#39;s Blog
		<br>

		Theme  <a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank">Nayo</a>
		</div>			
	 
</footer>   

    <script src="/nayo.bundle.js"></script>           
  </body>        
</html>