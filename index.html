<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  
  
  <title>  BeckoninGshy </title>

 
  
    <link rel="icon" href="/images/logo.png">
  


  <link rel="stylesheet" href="/nayo.min.css"> 
</head>  
  <body>   
    
      <header class="header">
	
  <nav class="header-inner">        

    <span class="iconfont icon-menu mobile-toggle"></span>   	

    <div class="header-logo">
      <a href="/">
        <img class="header-logo-img" src="/images/logo.png">
      </a>
    </div>

    <div class="header-menu">          
              
          
            <a class="header-menu-link" id="header-menu-home" href="/">
              <i class="iconfont icon-home">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-archives" href="/archives">
              <i class="iconfont icon-archives">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-tags" href="/tags">
              <i class="iconfont icon-tags">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-about" href="/about">
              <i class="iconfont icon-about">  
            </i></a>     
          
              
          
              <a class="header-menu-link" id="header-menu-search">
                <i class="iconfont icon-search">  
              </i></a>
          
                  
    </div>  
    
  </nav>
</header>

   

      <div class="container">       
          
          
            <div class="container-inner">  
          

          




<div class="profile sildeUpMin">
	
		<img class="avatar" src="/images/logo.png">

		<p class="author">Welcome to BeckoninGshy&#39;s Bolg</p>
		
		<div class="social">
   		      	
			<a target="_blank" class="social-links" href="https://github.com/yangzebin001">		
				<i class="iconfont icon-Github">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="">		
				<i class="iconfont icon-Facebook">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="">		
				<i class="iconfont icon-Instagram">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="https://music.163.com/#/user/home?id=117201882">		
				<i class="iconfont icon-Neteasemusic">
			</i></a>	
	    
    	</div>		
</div>


    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2020/01/30/LeetCode-10-正则表达式匹配/">LeetCode-10-正则表达式匹配</a>  
	       
		 

		<div class="article-meta">
			<time>1月 30, 2020</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. 正则表达式匹配</a></p>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;.&apos; 匹配任意单个字符</span><br><span class="line">&apos;*&apos; 匹配零个或多个前面的那一个元素</span><br></pre></td></tr></table></figure>
<p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<p>说明:</p>
<ul>
<li>s 可能为空，且只包含从 a-z 的小写字母。</li>
<li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。</span><br></pre></td></tr></table></figure>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。</span><br></pre></td></tr></table></figure>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4:"></a>示例 4:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure>
<h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5:"></a>示例 5:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>可以使用动态规划来解此题。</p>
<p>首先定义状态，有过求LCS和LIC的经验，我们很轻易类似的写出该题的状态定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] 串S以i结尾，串P以j结尾是否能够匹配。</span><br></pre></td></tr></table></figure>
<p>我们考虑状态转移方程：<br>先分类考虑：</p>
<ul>
<li><p>s[i] != p[j] &amp;&amp; p[j] != ‘.’ &amp;&amp; p[j] != ‘*’</p>
</li>
<li><p>s[i] == p[j]</p>
</li>
</ul>
<ul>
<li>p[j] == ‘.’</li>
</ul>
<ul>
<li>p[j] == ‘*’</li>
</ul>
<p>第一种情况显然是false。</p>
<p>第二种情况是说明可以匹配，所以由S前i-1，P前j-1匹配的情况决定。</p>
<p>第三种情况把’.’看做s[i]可以和第二种情况合并</p>
<p>重点是第四种情况，p[j]为’*’ 的情况：</p>
<p>单独一个‘ <em> ’是不构成语义的，所以出现‘ </em> ’就要看前一个字符，而前面有可能出现的又有‘.’和字母两种情况。<br>前面说过了，我们遇见‘.’直接把他当作与s[i]相等的字符即可。不需要做特殊处理。</p>
<p>所以就只剩下了‘*’ 前面是字母的<br>而分成的两种情况：</p>
<ul>
<li>‘*’前面的字母和s[i-1]不匹配。</li>
</ul>
<ul>
<li>‘*’前面的字母和s[i-1]匹配。</li>
</ul>
<p>第一种情况由于’*’可以代表零个之前的字符。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aabc</span><br><span class="line">ad*abc</span><br></pre></td></tr></table></figure>
<p>是可以匹配的。<br>所以我们遇到’*’前面的字母和s[i-1]不匹配就可以跳过这两个字符。即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i][j-2]</span><br></pre></td></tr></table></figure>
<p>最后’*’前面的字母和s[i-1]匹配：</p>
<p>那么就有按照‘*’的语义，又需要划分三种情况：</p>
<ul>
<li>*加上前面的字符不与s[i-1]匹配。</li>
<li><em>加上前面的字符只与s[i-1]匹配 即 </em> 作废。</li>
<li>*加上前面的字符可以与多个s[i-1]匹配。</li>
</ul>
<p>前两种情况其实与我们之前分析的不加‘*’的情况基本一致。<br>那么与多个字符匹配怎么转移呢？</p>
<p>我们确定匹配多个字符可以一个一个来，只要dp[i-1][j]可以匹配。那么只要[j]是<em>，则dp[i][j]一定可以匹配上。（别忘了，我们的前提条件是 </em> 和之前的字母匹配）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###b</span><br><span class="line">###b* </span><br><span class="line">匹配。</span><br><span class="line"></span><br><span class="line">###bb</span><br><span class="line">###b*</span><br><span class="line">一定能匹配。</span><br></pre></td></tr></table></figure>
<p>至此我们就将所有情况分析完毕。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">        int n = s.size(), m = p.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(m+1));</span><br><span class="line">        dp[0][0] = 1;</span><br><span class="line">        //处理 aa 和c*c*c*aa 匹配的情况。前缀可以忽略。</span><br><span class="line">        for(int i = 1; i &lt;= m; i++)&#123;</span><br><span class="line">            if(i-2 &gt;= 0 &amp;&amp; dp[0][i-2] &amp;&amp; p[i-1] == &apos;*&apos;) dp[0][i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            for(int j = 1; j &lt;= m; j++)&#123;</span><br><span class="line">                //单个字符匹配。</span><br><span class="line">                if(s[i-1] == p[j-1] || (p[j-1] == &apos;.&apos;))&#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1];</span><br><span class="line">                //单个字符不匹配</span><br><span class="line">                &#125;else if(p[j-1] == &apos;*&apos;)&#123;</span><br><span class="line">                    // baa bc*aa 形式</span><br><span class="line">                    if(p[j-2] != s[i-1] &amp;&amp; p[j-2] != &apos;.&apos;)&#123;</span><br><span class="line">                        dp[i][j] = dp[i][j-2];</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                    // 否则是前一个字符可以匹配</span><br><span class="line">                    // 三种情况，</span><br><span class="line">                    // 忽略这个匹配的字符，dp[i][j] = dp[i][j-2];</span><br><span class="line">                    // 只匹配这个字符 dp[i][j] = dp[i][j-1];</span><br><span class="line">                    // 匹配多个字符，即看i之前的字符和当前能不能匹配上，dp[i][j] = dp[i-1][j];</span><br><span class="line">                    // ###b 和 ###b* 如果能匹配上， ###bb 和 ###b* 也能匹配上。</span><br><span class="line">                        dp[i][j] = (dp[i][j-2] || dp[i][j-1] || dp[i-1][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里有一个点必须初始化，因为下标是从1开始的，无法访问到0，当遇到处理 aa 和c <em> c </em> c* aa 匹配的情况时，是需要访问到0的位置的，所以需要预处理。前缀可以为空的情况。</p>
</blockquote>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2020/01/30/LeetCode-10-正则表达式匹配/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2020/01/25/HDOJ102-Ma-Su-Plu-Plus/">HDOJ102-Ma-Su-Plu-Plus</a>  
	       
		 

		<div class="article-meta">
			<time>1月 25, 2020</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1024" target="_blank" rel="noopener">Max Sum Plus Plus</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Now I think you have got an AC in Ignatius.L’s “Max Sum” problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem.</p>
<p>Given a consecutive number sequence S1, S2, S3, S4 … Sx, … Sn (1 ≤ x ≤ n ≤ 1,000,000, -32768 ≤ Sx ≤ 32767). We define a function sum(i, j) = Si + … + Sj (1 ≤ i ≤ j ≤ n).</p>
<p>Now given an integer m (m &gt; 0), your task is to find m pairs of i and j which make sum(i1, j1) + sum(i2, j2) + sum(i3, j3) + … + sum(im, jm) maximal (ix ≤ iy ≤ jx or ix ≤ jy ≤ jx is not allowed).</p>
<p>But I`m lazy, I don’t want to write a special-judge module, so you don’t have to output m pairs of i and j, just output the maximal summation of sum(ix, jx)(1 ≤ x ≤ m) instead. ^_^</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>Each test case will begin with two integers m and n, followed by n integers S1, S2, S3 … Sn.<br>Process to the end of file.</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>Output the maximal summation described above in one line.</p>
<h3 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h3><p>1 3 1 2 3<br>2 6 -1 4 -2 3 -2 3</p>
<h3 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h3><p>6<br>8</p>
<p>Hint</p>
<p>Huge input, scanf and dynamic programming is recommended.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定n个数，让其划分为k个不重叠的区间（不要求连续），求其中的最大值。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>因为给定一个区间，它的最大值是确定的，所以具有无后效性，所以我们考虑使用dp来解此题。</p>
<p>我们首先定义状态表示，很自然的想到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i][j] 表示将前i个数字分成j段的最大子段和。</span><br></pre></td></tr></table></figure>
<p>接下来考虑状态转移方程：</p>
<p>我们将状态转移分为：</p>
<ul>
<li>与前面划分的区间不合并，即自成一组。</li>
<li>与前面划分的区间合并为一组。</li>
</ul>
<p>第二种转移方程比较好考虑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + v[i];</span><br></pre></td></tr></table></figure>
<p>自成一组需要找上一组从哪里转移。由于不需要保证连续性，所以就需要从第一段一直到j-1段都要考虑到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max&#123;dp[k][j-1](1 &lt;= k &lt; i)&#125;</span><br></pre></td></tr></table></figure>
<p>由于只有k个长度的字符才能分成k段。所以这里取值范围应该改为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max&#123;dp[k][j-1](j-1 &lt;= k &lt; i)&#125; + v[i]</span><br></pre></td></tr></table></figure>
<p>综合一下就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] =max( dp[i-1][j], max&#123;dp[k][j-1](j-1 &lt;= k &lt; i)&#125; ) + v[i]</span><br></pre></td></tr></table></figure>
<p>分析工作准备完毕，我们准备写代码时发现，这个数组范围比较大，会O（n2）的算法会超时，所以要优化。</p>
<p>第二种转移方程没什么好优化的，我们转移到第一种上，它在转移上依赖了他之上的好多行的数组，列却只依赖一列。这里想象为二维数组，我们把行，列的含义互换，想象这个二维数组逆时针旋转了90度。<br>就得到了如下的转移方程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i][j] 表示将前j个数字分成i段的最大子段和。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] =max( dp[i][j-1], max&#123;dp[i-1][k](i-1 &lt;= k &lt; j)&#125; ) + v[j]</span><br></pre></td></tr></table></figure>
<p>我们可以将 max{dp[i-1]<a href="i-1 &lt;= k &lt; j">k</a>} 这个O(n)的时间，在上一层的d[i-1][j]计算结果时用一个变量来记录，使其优化为O(1)。</p>
<p>具体编程还是有些难度，需要好好思考。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Date: 2020-01-24 10:42:12</span><br><span class="line"> * @LastEditors  : BeckoninGshy</span><br><span class="line"> * @LastEditTime : 2020-01-25 11:37:00</span><br><span class="line"> */</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN =1e6+10;</span><br><span class="line">int dp[MAXN],v[MAXN],numax[MAXN]; //保存上一层dp的最大值。</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int k,n;</span><br><span class="line">    while(cin &gt;&gt; k &gt;&gt; n)&#123;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; v[i];</span><br><span class="line">            dp[i] = numax[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0] = numax[0] = 0;</span><br><span class="line">        int lastmax = INT_MIN;</span><br><span class="line">        for(int i = 1; i &lt;= k; i++)&#123;</span><br><span class="line">            lastmax = INT_MIN; //保存上一层dp的最大值</span><br><span class="line">            for(int j = i; j &lt;= n; j++)&#123;</span><br><span class="line">            	//先利用之前的上一层最大值更新当前状态， </span><br><span class="line">                dp[j] = max(dp[j-1],numax[j-1]) + v[j];</span><br><span class="line">                //再将j-1的最大值更新到上一层的最大值数组中， 将在i+1层循环中使用，当前循环不使用</span><br><span class="line">                numax[j-1] = lastmax;</span><br><span class="line">                //存储当前层的最大值 </span><br><span class="line">                lastmax = max(lastmax,dp[j]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; lastmax &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2020/01/25/HDOJ102-Ma-Su-Plu-Plus/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2020/01/20/LeetCode-1320-二指输入的的最小距离/">LeetCode-1320-二指输入的的最小距离</a>  
	       
		 

		<div class="article-meta">
			<time>1月 20, 2020</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/minimum-distance-to-type-a-word-using-two-fingers/" target="_blank" rel="noopener">1320. 二指输入的的最小距离</a></p>
<p>二指输入法定制键盘在 XY 平面上的布局如上图所示，其中每个大写英文字母都位于某个坐标处，例如字母 A 位于坐标 (0,0)，字母 B 位于坐标 (0,1)，字母 P 位于坐标 (2,3) 且字母 Z 位于坐标 (4,1)。</p>
<p>给你一个待输入字符串 word，请你计算并返回在仅使用两根手指的情况下，键入该字符串需要的最小移动总距离。坐标 (x1,y1) 和 (x2,y2) 之间的距离是 |x1 - x2| + |y1 - y2|。 </p>
<p>注意，两根手指的起始位置是零代价的，不计入移动总距离。你的两根手指的起始位置也不必从首字母或者前两个字母开始。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：word = &quot;CAKE&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释：<br>使用两根手指输入 “CAKE” 的最佳方案之一是：<br>手指 1 在字母 ‘C’ 上 -&gt; 移动距离 = 0<br>手指 1 在字母 ‘A’ 上 -&gt; 移动距离 = 从字母 ‘C’ 到字母 ‘A’ 的距离 = 2<br>手指 2 在字母 ‘K’ 上 -&gt; 移动距离 = 0<br>手指 2 在字母 ‘E’ 上 -&gt; 移动距离 = 从字母 ‘K’ 到字母 ‘E’ 的距离  = 1<br>总距离 = 3</p>
<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：word = &quot;HAPPY&quot;</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释：<br>使用两根手指输入 “HAPPY” 的最佳方案之一是：<br>手指 1 在字母 ‘H’ 上 -&gt; 移动距离 = 0<br>手指 1 在字母 ‘A’ 上 -&gt; 移动距离 = 从字母 ‘H’ 到字母 ‘A’ 的距离 = 2<br>手指 2 在字母 ‘P’ 上 -&gt; 移动距离 = 0<br>手指 2 在字母 ‘P’ 上 -&gt; 移动距离 = 从字母 ‘P’ 到字母 ‘P’ 的距离 = 0<br>手指 1 在字母 ‘Y’ 上 -&gt; 移动距离 = 从字母 ‘A’ 到字母 ‘Y’ 的距离 = 4<br>总距离 = 6</p>
<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：word = &quot;NEW&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a>示例 4：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：word = &quot;YEAR&quot;</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：<br>2 &lt;= word.length &lt;= 300<br>每个 word[i]。都是一个大写英文字母。</p>
</blockquote>
<h3 id="Solution1（记忆化）："><a href="#Solution1（记忆化）：" class="headerlink" title="Solution1（记忆化）："></a>Solution1（记忆化）：</h3><p>我们首先要定义一个递归方程，思考后发现有两类主要元素：第一类是要记录到哪个字符，第二类是两个手指当前的位置。</p>
<p>然后发现“记录到哪个字符”这个状态不太好与两个手指进行关联（只能和一个手指进行绑定），所以我们转化一下思路，将记录到哪个字符转变为从第i个字符起，到字符串的末尾这整个区间，然后记录两个手指的状态。这样就得到了如下的递归函数参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// i: [i:w.size()]区间内花费的最小距离，</span><br><span class="line">// l: 上一个第一个手指的位置。</span><br><span class="line">// r: 上一个第二个手指的位置</span><br><span class="line">dfs(int i, int l, int r)</span><br></pre></td></tr></table></figure>
<p>转移方程为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs(i,l,c) = min(dfs(i+1,l,c)+cost(r,c),dfs(i+1,c,r)+cost(l,c));</span><br></pre></td></tr></table></figure>
<p>然后添加记忆化数组，整理就得到了下面的解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    int mem[310][27][27];</span><br><span class="line">    int cost(int i, int j)&#123;</span><br><span class="line">        if(i == 26 || j == 26) return 0;</span><br><span class="line">        return abs(i/6-j/6)+abs(i%6-j%6);</span><br><span class="line">    &#125;</span><br><span class="line">    string w;</span><br><span class="line">    // i: [i:w.size()]区间内花费的最小距离，</span><br><span class="line">    // l: 上一个第一个手指的位置。</span><br><span class="line">    // r: 上一个第二个手指的位置。</span><br><span class="line">    int dfs(int i, int l, int r)&#123;</span><br><span class="line">        if(i == w.size()) return 0;</span><br><span class="line">        if(mem[i][l][r]) return mem[i][l][r];</span><br><span class="line">        int c = w[i]-&apos;A&apos;;</span><br><span class="line">        return mem[i][l][r] = min(dfs(i+1,l,c)+cost(r,c),dfs(i+1,c,r)+cost(l,c));</span><br><span class="line">    &#125;</span><br><span class="line">    int minimumDistance(string word) &#123;</span><br><span class="line">        w = word;</span><br><span class="line">        //计算整个字符串的区间，初始两指从悬空状态开始。</span><br><span class="line">        return dfs(0,26,26);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Solution2（DP）："><a href="#Solution2（DP）：" class="headerlink" title="Solution2（DP）："></a>Solution2（DP）：</h3><p>我们可以试着将记忆化搜索转化为dp求解，很明显，状态表示和递归函数的状态是一致的，都是三维表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int dp[i][j][k]; //第一个手指一动到i，第二个手指移动到j，已经移动了k个字符的最小代价。</span><br></pre></td></tr></table></figure>
<p>这里与记忆化搜索定义的字符区间范围正好相反，递归中用的是从i到n的区间，而这里由于天然的记忆化过程，可以直接表示从0到k。</p>
<p>接着写状态转移方程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//从上一个字符移动到当前字符使用第一个手指，计算的最小价值。</span><br><span class="line">dp[c][j][k] = min(dp[c][j][k],dp[i][j][k-1] + cost);</span><br><span class="line">//从上一个字符移动到当前字符使用第二个手指，计算的最小价值。</span><br><span class="line">dp[i][c][k] = min(dp[i][c][k],dp[i][j][k-1] + cost);</span><br></pre></td></tr></table></figure>
<p>最后我们查看手指停在任何字符上的代价取最小即为答案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Cost(int i, int j)&#123;</span><br><span class="line">        //悬空状态，代价为0</span><br><span class="line">        if(i == 26 || j == 26) return 0;</span><br><span class="line">        return abs(i/6-j/6)+abs(i%6-j%6);</span><br><span class="line">    &#125;</span><br><span class="line">    int dp[27][27][301]; //第一个手指一动到i，第二个手指移动到j，已经移动了k个字符的最小代价。</span><br><span class="line">    int minimumDistance(string word) &#123;</span><br><span class="line">        memset(dp,0x3f3f3f3f,sizeof(dp));</span><br><span class="line">        // 初始化悬空状态</span><br><span class="line">        dp[26][26][0] = 0;</span><br><span class="line">        int n = word.size();</span><br><span class="line">        for(int k = 1; k &lt;= n; k++)&#123;</span><br><span class="line">            int c = word[k-1]-&apos;A&apos;;</span><br><span class="line">            //a</span><br><span class="line">            int cost = 0;</span><br><span class="line">            for(int i = 0; i &lt;= 26; i++)&#123;</span><br><span class="line">                for(int j = 0; j &lt;= 26; j++)&#123;</span><br><span class="line">                    cost = Cost(i,c);</span><br><span class="line">                    //从上一个字符移动到当前字符使用第一个手指，计算的最小价值。</span><br><span class="line">                    dp[c][j][k] = min(dp[c][j][k],dp[i][j][k-1] + cost);</span><br><span class="line">                    cost = Cost(j,c);</span><br><span class="line">                    //从上一个字符移动到当前字符使用第二个手指，计算的最小价值。</span><br><span class="line">                    dp[i][c][k] = min(dp[i][c][k],dp[i][j][k-1] + cost);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 0x3f3f3f3f;</span><br><span class="line">        for(int i = 0; i &lt;= 26; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt;= 26; j++)&#123;</span><br><span class="line">                ans = min(ans,dp[i][j][n]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2020/01/20/LeetCode-1320-二指输入的的最小距离/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2020/01/14/LeetCode-89-格雷编码/">LeetCode-89-格雷编码</a>  
	       
		 

		<div class="article-meta">
			<time>1月 14, 2020</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/gray-code/" target="_blank" rel="noopener">89. 格雷编码</a></p>
<p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p>
<p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0,1,3,2]</span><br><span class="line">解释:</span><br><span class="line">00 - 0</span><br><span class="line">01 - 1</span><br><span class="line">11 - 3</span><br><span class="line">10 - 2</span><br></pre></td></tr></table></figure>
<p>对于给定的 n，其格雷编码序列并不唯一。<br>例如，[0,2,3,1] 也是一个有效的格雷编码序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00 - 0</span><br><span class="line">10 - 2</span><br><span class="line">11 - 3</span><br><span class="line">01 - 1</span><br></pre></td></tr></table></figure>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: 0</span><br><span class="line">输出: [0]</span><br><span class="line">解释: 我们定义格雷编码序列必须以 0 开头。</span><br><span class="line">     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。</span><br><span class="line">     因此，当 n = 0 时，其格雷编码序列为 [0]。</span><br></pre></td></tr></table></figure>
<h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><p>动态规划法：</p>
<p>格雷码可以通过在当前的部分格雷码通过复制这一部分上下翻转次序后，使翻转后的部分通过新增加的最高位都转换为1来得到。</p>
<p>例如当前的部分序列为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00</span><br><span class="line">01</span><br></pre></td></tr></table></figure></p>
<p>翻转后为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">01</span><br><span class="line">00</span><br></pre></td></tr></table></figure></p>
<p>往每个数字前面增加一位前导零组合成新的部分格雷码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000</span><br><span class="line">001</span><br><span class="line">001</span><br><span class="line">000</span><br></pre></td></tr></table></figure></p>
<p>将翻转后的数字的前导零置为1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000</span><br><span class="line">001</span><br><span class="line">101</span><br><span class="line">100</span><br></pre></td></tr></table></figure></p>
<p>这一新的序列也是格雷码序列。</p>
<p>通过翻转n次，将得到长度为n全部的格雷码序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; grayCode(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        ans.push_back(0);</span><br><span class="line">        for(int k = 0; k &lt; n; k++)&#123;</span><br><span class="line">            int c = ans.size();</span><br><span class="line">            for(int j = c, i = 1; j &lt; 2*c; j++, i++)&#123;</span><br><span class="line">                ans.push_back(ans[c-i]|(1&lt;&lt;k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h3><p>直接构造法：</p>
<p>维基百科中生成格雷码的步骤为：</p>
<blockquote>
<p>以二进制为 0 值的格雷码为第零项，第一项改变最右边的位元，第二项改变右起第一个为1的位元的左边位元，第三、四项方法同第一、二项，如此反复，即可排列出n个位元的格雷码。</p>
</blockquote>
<p>以3为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">000 初始值</span><br><span class="line">001 改变右起第一项</span><br><span class="line">011 改变右起第一个为1的位元的左边位元</span><br><span class="line">010 改变右起第一项</span><br><span class="line">110 改变右起第一个为1的位元的左边位元</span><br><span class="line">111 改变右起第一项</span><br><span class="line">101 改变右起第一个为1的位元的左边位元</span><br><span class="line">100 改变右起第一项</span><br></pre></td></tr></table></figure>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; grayCode(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        ans.push_back(0);</span><br><span class="line">        for(int k = 1; k &lt; 1&lt;&lt;n; k++)&#123;</span><br><span class="line">            // 改变右起第一项。</span><br><span class="line">            if(k%2) ans.push_back(ans[k-1]^1);</span><br><span class="line">            // 改变右起第一个为1的位元的左边位元</span><br><span class="line">            else&#123;</span><br><span class="line">                int c = 0;</span><br><span class="line">                int pre = ans[k-1];</span><br><span class="line">                while(((pre&gt;&gt;c) &amp; 1) == 0) c++;</span><br><span class="line">                c++;</span><br><span class="line">                ans.push_back(pre^(1&lt;&lt;c));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="Solution3："><a href="#Solution3：" class="headerlink" title="Solution3："></a>Solution3：</h3><p>公式法：</p>
<p>当前第i项的二进制数的最高位保留，其它位是当前位和它的高一位进行异或操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; grayCode(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line"></span><br><span class="line">        for(int k = 0; k &lt; 1&lt;&lt;n; k++)&#123;</span><br><span class="line">            //每一项与当前数右移后异或得到。</span><br><span class="line">            ans.push_back(k^(k&gt;&gt;1));</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2020/01/14/LeetCode-89-格雷编码/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/12/26/LeetCode-394-字符串解码/">LeetCode-394-字符串解码</a>  
	       
		 

		<div class="article-meta">
			<time>12月 26, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394. 字符串解码</a></p>
<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.</span><br><span class="line">s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.</span><br><span class="line">s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;.</span><br></pre></td></tr></table></figure>
<h3 id="Solution1（递归法）："><a href="#Solution1（递归法）：" class="headerlink" title="Solution1（递归法）："></a>Solution1（递归法）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string decodeString(string s) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        string ans = &quot;&quot;;</span><br><span class="line">        while(i &lt; s.size())&#123;</span><br><span class="line">            ans += dfs(s,i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    string dfs(string s, int &amp;i)&#123;</span><br><span class="line">        int num = 0,flag = 0;</span><br><span class="line">        string t = &quot;&quot;, tt = &quot;&quot;;</span><br><span class="line">        while(i &lt; s.size() &amp;&amp; s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;)&#123;</span><br><span class="line">            num = num * 10 + (s[i]-&apos;0&apos;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &lt; s.size() &amp;&amp; s[i] == &apos;[&apos;) flag = 1, i++;</span><br><span class="line">        while(i &lt; s.size() &amp;&amp; s[i] != &apos;]&apos;)&#123;</span><br><span class="line">            if(s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                t += dfs(s,i);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            t += s[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(t.size() &gt; 0)&#123;</span><br><span class="line">            tt = t;</span><br><span class="line">            while(--num &gt; 0) tt += t;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &lt; s.size() &amp;&amp; s[i] == &apos;]&apos;) i++;</span><br><span class="line">        return tt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>很正常的思路就是递归，每遇到数字就递归到下一层，等下一层的结束后，返回到当前层接着处理，在遇到’]’或者走到最后时，结束这一层的处理。</p>
<h3 id="Solution2（栈）："><a href="#Solution2（栈）：" class="headerlink" title="Solution2（栈）："></a>Solution2（栈）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string decodeString(string s) &#123;</span><br><span class="line">        stack&lt;int&gt; numstk;</span><br><span class="line">        stack&lt;string&gt; strstk;</span><br><span class="line">        int num = 0;</span><br><span class="line">        string cur = &quot;&quot;; //当前层可以形成的串</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++)&#123;</span><br><span class="line">            if(s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                num = num * 10 + (s[i]-&apos;0&apos;);</span><br><span class="line">            &#125;else if(s[i] == &apos;[&apos;)&#123;</span><br><span class="line">                //模拟递归，该去下一层了。</span><br><span class="line">                numstk.push(num);</span><br><span class="line">                strstk.push(cur);</span><br><span class="line">                num = 0;</span><br><span class="line">                cur = &quot;&quot;;</span><br><span class="line">            &#125;else if(s[i] == &apos;]&apos;)&#123;</span><br><span class="line">                //这一层已经完成处理</span><br><span class="line">                for(int j = 0; j &lt; numstk.top(); j++)&#123;</span><br><span class="line">                    strstk.top() += cur;  </span><br><span class="line">                &#125;</span><br><span class="line">                //返回上一层</span><br><span class="line">                cur = strstk.top();</span><br><span class="line">                strstk.pop();</span><br><span class="line">                numstk.pop();</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                cur += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>使用栈就是为了能保留当前层的信息，这里的进入下一层的时机和递归版略有差别，在到达’[‘的时候才进入下一层，主要是为了确定num的值和保存之前正处理的串的信息，在’]’的时候要处理完当前层，并且返回上一层。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/12/26/LeetCode-394-字符串解码/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/12/02/LeetCode-117-填充每个节点的下一个右侧节点指-II/">LeetCode-117-填充每个节点的下一个右侧节点指-II</a>  
	       
		 

		<div class="article-meta">
			<time>12月 02, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117. 填充每个节点的下一个右侧节点指针 II</a></p>
<p>此题为<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. 填充每个节点的下一个右侧节点指针</a>的进阶版本。</p>
<p>给定一个二叉树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>进阶：</p>
<ul>
<li>你只能使用常量级额外空间。</li>
<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,null,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,7,#]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li>树中的节点数小于 6000</li>
<li>100 &lt;= node.val &lt;= 100</li>
</ul>
<h3 id="Solution1（迭代版）："><a href="#Solution1（迭代版）：" class="headerlink" title="Solution1（迭代版）："></a>Solution1（迭代版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        if(!root) return NULL;</span><br><span class="line">        Node* head = root;</span><br><span class="line">        Node* pre = NULL;</span><br><span class="line">        while(root)&#123;</span><br><span class="line">            Node* sub = NULL;</span><br><span class="line">            while(pre)&#123;</span><br><span class="line">                if(pre-&gt;left)&#123;</span><br><span class="line">                    if(sub) sub-&gt;next = pre-&gt;left;</span><br><span class="line">                    sub = pre-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                if(pre-&gt;right)&#123;</span><br><span class="line">                    if(sub) sub-&gt;next = pre-&gt;right;</span><br><span class="line">                    sub = pre-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = root;</span><br><span class="line">            while(root)&#123;</span><br><span class="line">                if(root-&gt;left)&#123;</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else if(root-&gt;right)&#123;</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    root = root-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>与上一题类似，先设置下父指针，找到父指针下所有存在的结点相连接，然后找到下一层的第一个结点，将其继续当做父节点。</p>
<h3 id="Solution2（递归版）："><a href="#Solution2（递归版）：" class="headerlink" title="Solution2（递归版）："></a>Solution2（递归版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        </span><br><span class="line">        if(!root || (!root-&gt;left &amp;&amp; !root-&gt;right)) return root;</span><br><span class="line">        //先把当前结点连接</span><br><span class="line">        if(root-&gt;left &amp;&amp; root-&gt;right) root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">        Node* sub = root-&gt;right ? root-&gt;right : root-&gt;left;</span><br><span class="line">        //跳过没有子节点的节点</span><br><span class="line">        Node* head = root-&gt;next;</span><br><span class="line">        while(head &amp;&amp; !head-&gt;left &amp;&amp; !head-&gt;right)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        sub-&gt;next = head ? (head-&gt;left ? head-&gt;left : head-&gt;right) : NULL;</span><br><span class="line">        connect(root-&gt;right);</span><br><span class="line">        connect(root-&gt;left);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>如果是叶子节点或空节点，则直接返回。<br>如果有两个子节点，先把两节点之间连接，把右节点当做下一层要操作的节点。<br>如果只有一个子节点，把该节点当做下一层要操作的节点。</p>
<p>将下一层的节点连接（寻找当前层的非叶子结点，将它的子节点与该结点的下一层节点连接）。</p>
<h5 id="这里注意一定要先构建右子树，再构建左子树，因为寻找父节点的兄弟节点是从左到右遍历的，如果右子树未构建好就遍历，则会出错。"><a href="#这里注意一定要先构建右子树，再构建左子树，因为寻找父节点的兄弟节点是从左到右遍历的，如果右子树未构建好就遍历，则会出错。" class="headerlink" title="这里注意一定要先构建右子树，再构建左子树，因为寻找父节点的兄弟节点是从左到右遍历的，如果右子树未构建好就遍历，则会出错。"></a>这里注意一定要先构建右子树，再构建左子树，因为寻找父节点的兄弟节点是从左到右遍历的，如果右子树未构建好就遍历，则会出错。</h5>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/12/02/LeetCode-117-填充每个节点的下一个右侧节点指-II/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/11/25/LeetCode-116-填充每个节点的下一个右侧节点指针/">LeetCode-116-填充每个节点的下一个右侧节点指针</a>  
	       
		 

		<div class="article-meta">
			<time>11月 25, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<h3 id="Solution1（递归版）："><a href="#Solution1（递归版）：" class="headerlink" title="Solution1（递归版）："></a>Solution1（递归版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        if(!root) return NULL;</span><br><span class="line">        Node* l = root-&gt;left;</span><br><span class="line">        Node* r = root-&gt;right;</span><br><span class="line">        while(l)&#123;</span><br><span class="line">            l-&gt;next = r;</span><br><span class="line">            l = l-&gt;right;</span><br><span class="line">            r = r-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        connect(root-&gt;left);</span><br><span class="line">        connect(root-&gt;right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Solution2（迭代版）："><a href="#Solution2（迭代版）：" class="headerlink" title="Solution2（迭代版）："></a>Solution2（迭代版）：</h3><p>一层一层的考虑，由于每个结点往后连需要用到其父节点的信息，所以我们可以在下一层结点的next指针连接完毕后，在往下一层移动时，父结点就可以利用已经连接好的next指针进行平滑的向右移动了。这样直到最后一层结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        if(!root) return root;</span><br><span class="line">        Node* pre = NULL;</span><br><span class="line">        Node* cur = root;</span><br><span class="line">        while(cur)&#123;</span><br><span class="line">            while(pre)&#123;</span><br><span class="line">                pre-&gt;left-&gt;next = pre-&gt;right;</span><br><span class="line">                if(pre-&gt;next)&#123;</span><br><span class="line">                    pre-&gt;right-&gt;next = pre-&gt;next-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/11/25/LeetCode-116-填充每个节点的下一个右侧节点指针/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/11/25/01背包问题详解/">01背包问题详解</a>  
	       
		 

		<div class="article-meta">
			<time>11月 25, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>有 N 件物品和一个容量是 V的背包。每件物品只能使用一次。</p>
<p>第 i件物品的体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积<strong>不超过</strong>背包容量，且<strong>总价值最大</strong>。<br>输出最大价值。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>拿到这道题目，我们在不用动态规划的情况下，可以枚举这N件物品，每件物品都有选和不选两种情况，所以总的复杂度为O（2^n）。并且在计算过程中，我们发现有很多的重复计算。最直接优化的方法当然是记忆化，将搜到的状态保存下来，以便之后重复调用时直接取值，避免重复计算。</p>
<p>第二种优化方法就是动态规划了。我们对每一次的决策都保留最优解。最终得到问题的最优解。</p>
<p>构建动态规划的关键在于定义状态转移方程。<br>定义状态转移方程要符合两个条件：</p>
<ul>
<li>最优子结构</li>
<li>无后效性</li>
</ul>
<p>我们回到01背包问题具体来看：</p>
<p>由于只有当所有的背包全部考察完，我们才能得到最终的方案，并且对于每一层的背包我都可以选择拿或不拿，这一层的决策不会影响到之前已经得到的结论，所以很自然的要定义一个维度，用来指名当前要考察的背包。</p>
<p>又由于要限制条件为背包的容量，大于背包容量的我们自然永远都不会考虑，但是背包的容量会随着每个背包的选或不选能有变化，所以我们还需要一维信息，由来记录背包的容量变化。<br>所以我们得出来一个二维数组用来记录状态:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] //i是前i个背包，j是容量，dp[i][j]是当前前i个背包，容量是j时，可获得的最大价值。</span><br></pre></td></tr></table></figure>
<p>我们思考下转移方程：<br>在每个背包被考察时，我们先考虑不选当前背包，则方程为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j]</span><br></pre></td></tr></table></figure>
<p>然后考虑选择当前背包：</p>
<p>在选择了背包后容量肯定会变大，对照我们定义的状态，所以会有:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i+1][j+w] = dp[i][j]+v; //这时w,v分别代表第i+1个背包的质量和价值。</span><br></pre></td></tr></table></figure>
<p>转换一下就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-wi]+vi;//这时w,v分别代表第i个背包的质量和价值。</span><br></pre></td></tr></table></figure>
<p>我们要保持当前状态为最大的价值。<br>所以综合起来，方程就变为了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i-1][j],dp[i-1][j-wi]+vi);</span><br></pre></td></tr></table></figure>
<p>整理成代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 1010;</span><br><span class="line">int n,m;</span><br><span class="line">//前i个物体，总体积是j 的最大总价值</span><br><span class="line">int f[MAXN][MAXN];</span><br><span class="line">int V[MAXN],W[MAXN];</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; V[i] &gt;&gt; W[i];</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt;= m; j++)&#123;</span><br><span class="line">            //要么不选</span><br><span class="line">            f[i][j] = f[i-1][j];</span><br><span class="line">            if(j &gt;= V[i])&#123;</span><br><span class="line">                //要么选择该背包，从f[i-1][j-v[i]]过来。</span><br><span class="line">                f[i][j] = max(f[i][j],f[i-1][j-V[i]]+W[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    //在前n个物体中，选价值最大的一个</span><br><span class="line">    for(int i = 0; i &lt;= m; i++)&#123;</span><br><span class="line">        ans = max(ans,f[n][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h4><p>我们再看一下转移方程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i-1][j],dp[i-1][j-wi]+vi);</span><br></pre></td></tr></table></figure>
<p>当前考察背包只会利用到上一个背包计算后的结果。所以我们考虑优化到一维，但是循环的顺序需要变一下，从后往前计算，只有这样我们不会改变了之前的值，而导致计算出错。</p>
<h4 id="一维数组优化"><a href="#一维数组优化" class="headerlink" title="一维数组优化"></a>一维数组优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 1010;</span><br><span class="line">int f[MAXN];</span><br><span class="line">int N,M;</span><br><span class="line">int V[MAXN],W[MAXN];</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;N,&amp;M);</span><br><span class="line">    for(int i = 1; i &lt;= N; i++) scanf(&quot;%d%d&quot;,&amp;V[i],&amp;W[i]);</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)</span><br><span class="line">        //从后往前推，保留i-1的状态</span><br><span class="line">        for(int j = M; j &gt;= V[i]; j--)&#123;</span><br><span class="line">            f[j] = max(f[j],f[j-V[i]]+W[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    printf(&quot;%d&quot;,f[M]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，01背包问题就完美的解决了。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/11/25/01背包问题详解/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/10/26/POJ-3614-Sunscreen/">POJ-3614-Sunscreen</a>  
	       
		 

		<div class="article-meta">
			<time>10月 26, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="http://poj.org/problem?id=3614" target="_blank" rel="noopener">POJ-3614-Sunscreen</a></p>
<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>To avoid unsightly burns while tanning, each of the C (1 ≤ C ≤ 2500) cows must cover her hide with sunscreen when they’re at the beach. Cow i has a minimum and maximum SPF rating (1 ≤ minSPFi ≤ 1,000; minSPFi ≤ maxSPFi ≤ 1,000) that will work. If the SPF rating is too low, the cow suffers sunburn; if the SPF rating is too high, the cow doesn’t tan at all……..</p>
<p>The cows have a picnic basket with L (1 ≤ L ≤ 2500) bottles of sunscreen lotion, each bottle i with an SPF rating SPFi (1 ≤ SPFi ≤ 1,000). Lotion bottle i can cover coveri cows with lotion. A cow may lotion from only one bottle.</p>
<p>What is the maximum number of cows that can protect themselves while tanning given the available lotions?</p>
<h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><ul>
<li><p>Line 1: Two space-separated integers: C and L</p>
</li>
<li><p>Lines 2..C+1: Line i describes cow i’s lotion requires with two integers: minSPFi and maxSPFi</p>
</li>
<li><p>Lines C+2..C+L+1: Line i+C+1 describes a sunscreen lotion bottle i with space-separated integers: SPFi and coveri</p>
</li>
</ul>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>A single line with an integer that is the maximum number of cows that can be protected while tanning</p>
<h3 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">3 10</span><br><span class="line">2 5</span><br><span class="line">1 5</span><br><span class="line">6 2</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure>
<h3 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>有C头牛，每个牛Ci在一个给定的区间上需要涂防晒霜，有L种防晒霜，给出每个防晒霜适合的数值SPF[i]和个数cover[i]，求能最多满足牛的个数。</p>
<h3 id="贪心策略："><a href="#贪心策略：" class="headerlink" title="贪心策略："></a>贪心策略：</h3><p>按区间的开始位置递减排序，依次考虑每头牛。<br>对于每头牛，选取满足在此区间内最大的防晒霜。</p>
<h3 id="Solution1（暴力版）："><a href="#Solution1（暴力版）：" class="headerlink" title="Solution1（暴力版）："></a>Solution1（暴力版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">const int MAXN = 5000+10;</span><br><span class="line">int C,L;</span><br><span class="line">PII p[MAXN];</span><br><span class="line">PII q[MAXN];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;C,&amp;L);</span><br><span class="line">    for(int i = 0; i &lt; C; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;p[i].first,&amp;p[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p,p+C);</span><br><span class="line">    for(int i = 0; i &lt; L; i++)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">        q[i].first = a;</span><br><span class="line">        q[i].second = b;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q,q+L);</span><br><span class="line">	//从开始位置大到小考察每头牛。</span><br><span class="line">    for(int i = C-1; i &gt;= 0; i--)&#123;</span><br><span class="line">		//同样，对于每头牛，考察在该牛区间内最右的防晒霜。</span><br><span class="line">        for(int j = L-1; j &gt;= 0; j--)&#123;</span><br><span class="line">            if(q[j].second &gt; 0 &amp;&amp; q[j].first &gt;= p[i].first &amp;&amp; q[j].first &lt;= p[i].second)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                q[j].second--;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solution2（平衡树版）："><a href="#Solution2（平衡树版）：" class="headerlink" title="Solution2（平衡树版）："></a>Solution2（平衡树版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 2510;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">int N,M;</span><br><span class="line">PII cows[MAXN];</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt;M;</span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        cin &gt;&gt; cows[i].first &gt;&gt; cows[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(cows,cows+N);</span><br><span class="line">    map&lt;int,int&gt; spfa;</span><br><span class="line">    for(int i = 0; i &lt; M; i++)&#123;</span><br><span class="line">        int spa,cover;</span><br><span class="line">        cin &gt;&gt; spa &gt;&gt; cover;</span><br><span class="line">        spfa[spa] += cover;</span><br><span class="line">    &#125;</span><br><span class="line">    spfa[0] = spfa[1001] = N;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = N-1; i &gt;= 0; i--)&#123;</span><br><span class="line">        map&lt;int,int&gt;::iterator it = spfa.upper_bound(cows[i].second);</span><br><span class="line">        --it;</span><br><span class="line">        if(cows[i].first &lt;= it-&gt;first &amp;&amp; cows[i].second &gt;= it-&gt;first)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            if(-- it-&gt;second == 0) spfa.erase(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/10/26/POJ-3614-Sunscreen/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/10/26/AcWin-135-最大子序和/">AcWin-135-最大子序和</a>  
	       
		 

		<div class="article-meta">
			<time>10月 26, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://www.acwing.com/problem/content/description/137/" target="_blank" rel="noopener">AcWing 135. 最大子序和 </a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个长度为n的整数序列，从中找出一段长度不超过m的连续子序列，使得子序列中所有数的和最大。</p>
<p>输入格式<br>第一行输入两个整数n,m。</p>
<p>第二行输入n个数，代表长度为n的整数序列。</p>
<p>同一行数之间用空格隔开。</p>
<p>输出格式<br>输出一个整数，代表该序列的最大子序和。</p>
<p>数据范围<br>1≤n,m≤300000</p>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入样例：</span><br><span class="line">6 4</span><br><span class="line">1 -3 5 1 -2 3</span><br><span class="line">输出样例：</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>求一个区间长度为M的序列和可以用前缀和相减的形式来得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k = sum[i]- sum[i-M]</span><br></pre></td></tr></table></figure>
<p>而要求当前区间P内的最大值，可以找到该区间（sum[i-1]–sum[i-m]）内的最小值，用sum[i]减去该值，得到以sum[i]为终点的区间的最大值，对于每个区间，都求得一个最大值，再到这些之内取最大即为答案。</p>
<p>所以现在的问题变为：给定一个区间，如何找出给区间内的最小值。</p>
<p>如果暴力求，会使总的复杂度为O(N2)，不符合要求。<br>再看一下要解决的问题，我们想到使用单调队列，可以在线求出一组序列的最值，所以我们使用一个大小为M的队列来维护最值。</p>
<p>这样总的复杂度就为线性的了。</p>
<h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 1e6+10;</span><br><span class="line">long long a[MAXN],sum[MAXN],ans = -1e10;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    deque&lt;int&gt; q;</span><br><span class="line">    int N,M;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    for(int i = 0; i &lt; N; i++) cin &gt;&gt; a[i];</span><br><span class="line">    for(int i = 1; i &lt;= N; i++) sum[i] = sum[i-1] + a[i-1]; //前缀和</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        while(q.size() &amp;&amp; q.front() &lt; i - M) q.pop_front(); //超出窗口范围，清除</span><br><span class="line">        ans = max(ans, sum[i]-sum[q.front()]); //更新值</span><br><span class="line">        while(q.size() &amp;&amp; sum[q.back()] &gt; sum[i]) q.pop_back(); //维护单调性质</span><br><span class="line">        q.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/10/26/AcWin-135-最大子序和/">阅读更多</a> 	
	</div>	
    
</article>     
     	




 
   <nav class="paginator">
    

   <span class="page-number"> Page <strong>1</strong>, Total <strong>118</strong> . </span>

    
        <a class="next" href="/page/2/"> 
            下一页
            <i class="iconfont icon-right"></i>
        </a>
    
  </nav> 

          </div> 
      </div>            
    
    <a id="page-backTop">
      <span>
        <i class="iconfont icon-backtotop"></i>
      </span>
    </a> 

  
    
    <div class="search-container sildeUpMin">
        <div class="search-header">
            <input type="text" placeholder="输入你想搜索的" id="search-input" class="search-input">
            <span class="search-cancel">
                <i class="iconfont icon-cancel">
            </i></span>
        </div>
        <div id="search-result" class="search-result"></div>
    </div>
 
     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon" src="/images/logo.png">   
      

         
            

            <a class="mobile-menu-link" href="/">首页
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">归档
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">标签
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">关于
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">搜索 </a>                 
            
         
      
</div>        
    



     
    




<footer id="footer">	    

		
		<div class="footer-copyright">
		&copy;
				
		2017-
		
		2020		
	
		BeckoninGshy&#39;s Blog
		<br>

		Theme  <a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank">Nayo</a>
		</div>			
	 
</footer>   

    <script src="/nayo.bundle.js"></script>           
  </body>        
</html>