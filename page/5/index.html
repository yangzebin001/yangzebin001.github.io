<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  
  
  <title>  BeckoninGshy </title>

 
  
    <link rel="icon" href="/images/logo.png">
  


  <link rel="stylesheet" href="/nayo.min.css"> 
</head>  
  <body>   
    
      <header class="header">
	
  <nav class="header-inner">        

    <span class="iconfont icon-menu mobile-toggle"></span>   	

    <div class="header-logo">
      <a href="/">
        <img class="header-logo-img" src="/images/logo.png">
      </a>
    </div>

    <div class="header-menu">          
              
          
            <a class="header-menu-link" id="header-menu-home" href="/">
              <i class="iconfont icon-home">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-archives" href="/archives">
              <i class="iconfont icon-archives">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-tags" href="/tags">
              <i class="iconfont icon-tags">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-about" href="/about">
              <i class="iconfont icon-about">  
            </i></a>     
          
              
          
              <a class="header-menu-link" id="header-menu-search">
                <i class="iconfont icon-search">  
              </i></a>
          
                  
    </div>  
    
  </nav>
</header>

   

      <div class="container">       
          
          
            <div class="container-inner">  
          

          




<div class="profile sildeUpMin">
	
		<img class="avatar" src="/images/logo.png">

		<p class="author">Welcome to BeckoninGshy&#39;s Bolg</p>
		
		<div class="social">
   		      	
			<a target="_blank" class="social-links" href="https://github.com/yangzebin001">		
				<i class="iconfont icon-Github">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="">		
				<i class="iconfont icon-Facebook">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="">		
				<i class="iconfont icon-Instagram">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="https://music.163.com/#/user/home?id=117201882">		
				<i class="iconfont icon-Neteasemusic">
			</i></a>	
	    
    	</div>		
</div>


    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/07/13/LeetCode-106-从中序与后序遍历序列构造二叉树/">106-从中序与后序遍历序列构造二叉树</a>  
	       
		 

		<div class="article-meta">
			<time>7月 13, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. 从中序与后序遍历序列构造二叉树</a></p>
<h3 id="根据一棵树的中序遍历与后序遍历构造二叉树。"><a href="#根据一棵树的中序遍历与后序遍历构造二叉树。" class="headerlink" title="根据一棵树的中序遍历与后序遍历构造二叉树。"></a>根据一棵树的中序遍历与后序遍历构造二叉树。</h3><blockquote>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
</blockquote>
<p>例如，给出</p>
<p>中序遍历 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure>
<p>后序遍历 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postorder = [9,15,7,20,3]</span><br></pre></td></tr></table></figure>
<p>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* makeTree(vector&lt;int&gt;&amp; postorder, int&amp; postindex, vector&lt;int&gt;&amp; inorder,int left, int right)&#123;</span><br><span class="line">        if(left &lt;= right)&#123;</span><br><span class="line">            for(int i = 0; i &lt; inorder.size(); i++)&#123;</span><br><span class="line">                if(postorder[postindex] == inorder[i])&#123;</span><br><span class="line"></span><br><span class="line">                    TreeNode* root = new TreeNode(postorder[postindex--]);</span><br><span class="line">                    root-&gt;right = makeTree(postorder,postindex,inorder,i+1,right);</span><br><span class="line">                    root-&gt;left = makeTree(postorder,postindex,inorder,left,i-1);  </span><br><span class="line">                    return root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        int postindex = postorder.size()-1;</span><br><span class="line">        return makeTree(postorder,postindex,inorder,0,inorder.size()-1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>根据后序遍历的特点，每棵子树的根节点总是最后遍历到。</p>
<p>所以用一个按引用传递的指针指向后序数组的末尾，用该值在中序数组中查找，并将该值当做当前树的根节点。</p>
<p>该值位置的左边为以该节点为根节点的左子树的范围，位置右边为右子树的范围，然后不断更新这个范围，递归下去即可，注意边界值。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/07/13/LeetCode-106-从中序与后序遍历序列构造二叉树/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/06/02/正则表达式全解——正则基础/">正则表达式全解——正则基础</a>  
	       
		 

		<div class="article-meta">
			<time>6月 02, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h3 id="正则基础"><a href="#正则基础" class="headerlink" title="正则基础"></a>正则基础</h3><h5 id=""><a href="#" class="headerlink" title="^"></a>^</h5><p>表示一行的开始</p>
<h5 id="-1"><a href="#-1" class="headerlink" title="$"></a>$</h5><p>表示一行的结束</p>
<h5 id="…"><a href="#…" class="headerlink" title="[…]"></a>[…]</h5><p>表示其中的字符是选择性（逻辑或）的，要么是a,要么是b,要么是…。</p>
<blockquote>
<p>c[a|b]t 可以匹配到cat、cbt<br>[a-z]、[0-9]、[0-9A-Za-z]是支持的。<br>[^$] 匹配空行<br>像 . * + ?  这些词在[]中仅表示字面的意思，利用这一特性，如果想表示原本含义，例如要匹配 . ，可以写为[.]</p>
</blockquote>
<h5 id="…-1"><a href="#…-1" class="headerlink" title="[^…]"></a>[^…]</h5><p>表示匹配不是其中的字符。为上一条的取反</p>
<h5 id="-2"><a href="#-2" class="headerlink" title="-"></a>-</h5><p>连字符，表示一个范围，见上一条。</p>
<blockquote>
<p>如果要匹配  - ，请将 - 写在开始位置，如果[-a-z]，匹配-或者是小写字母。</p>
</blockquote>
<h5 id="-3"><a href="#-3" class="headerlink" title="."></a>.</h5><p>   表示任意字符（除了换行符），</p>
<h5 id="-4"><a href="#-4" class="headerlink" title="|"></a>|</h5><p>表示或者</p>
<blockquote>
<p>(cat|dog) 表示要么cat,要么dog,<br>注意：这和[…]不同的是，[…]匹配其中的单个字符，(..|…)可以匹配不同的字符组。</p>
</blockquote>
<h5 id="-5"><a href="#-5" class="headerlink" title="?"></a>?</h5><p>表示可选项，类似于单选框，匹配零个或一个。</p>
<h5 id="-6"><a href="#-6" class="headerlink" title="+"></a>+</h5><p>表示出现一次或多次。</p>
<h5 id="-7"><a href="#-7" class="headerlink" title="*"></a>*</h5><p>表示匹配零次或多次。</p>
<h5 id="min-max"><a href="#min-max" class="headerlink" title="{min,max}"></a>{min,max}</h5><p>表示匹配之前的子表达式重复min到max次。（闭区间）</p>
<blockquote>
<p>{count} 表示匹配count次。</p>
</blockquote>
<h5 id="括号与反向引用"><a href="#括号与反向引用" class="headerlink" title="括号与反向引用"></a>括号与反向引用</h5><p>([0-9]){2,3}add\1    \1表示第一个括号中的内容再次使用。</p>
<h5 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h5><p>像 . * + ?  这些词在正则中有特殊的含义，要想使用它原本的含义，使用\来进行转义。</p>
<h5 id="…-2"><a href="#…-2" class="headerlink" title="(…)"></a>(…)</h5><p>括号的作用：1.限制多选结构，2.分组，3.捕获文本。</p>
<h5 id="一些特殊的字符"><a href="#一些特殊的字符" class="headerlink" title="一些特殊的字符"></a>一些特殊的字符</h5><ul>
<li>\t 制表符</li>
<li>\n换行符</li>
<li>\r 回车符</li>
<li>\s 任何空白字符(例如空格符、制表符、换行符等)</li>
<li>\S 除\s之外的任何字符(所以用(\s|\S) * )来表示任意字符。</li>
<li>\w 相当于[a-zA-Z0-9] 所以经常用\w+来表示一个单词 </li>
<li>\W \w取反，也就是[^a-zA-Z0-9] </li>
<li>\d  相当于[0-9] 也就是数字</li>
<li>\D \d取反，也就是[^0-9]</li>
</ul>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/06/02/正则表达式全解——正则基础/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/06/01/写在大一期末考试之际/">写在大一期末考试之际</a>  
	       
		 

		<div class="article-meta">
			<time>6月 01, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<h3 id="写在大一期末考试之际"><a href="#写在大一期末考试之际" class="headerlink" title="写在大一期末考试之际"></a>写在大一期末考试之际</h3><p>最近发生了很多各种各样的事，面对即将到来的期末考试，自己真的很没有底气，因为只有自己知道，对于大部分的课程，学的是如何糟糕。我不看重的课程不说，但数学学科的课程自己也没学到什么，一方面是老师的原因，但最多的是自己的问题，学习的重心绝对的向专业偏移，即使是专业，每天学的都是些业务类的技术，如果是这样，我觉得我可以立即辍学，这也不是我上大学的初衷，一定要向研究的方向转变，把数学基础提上来才是我大学应该做的事，大学时光1/4已经过去了，自己却没有调整到合适的状态，实属不应该。不过，也有些收获，算法竞赛这块是我没有预料到的，同时回想自己大一上学期学算法的时候是我最想要的状态，我不知道自己是不是喜欢，但无暇他顾地专心只搞一件事是我想要的，而通过学习它我可以进入这种状态，后来学长又找我说想打acm，我知道这个的难度，也知道意味着什么，但是我觉得人应该有些梦想，先让我做一年试试。</p>
<p>同时，我的学习方法也有很多的不足，很低效，我觉得得花些时间来调整下，通常都是学的快，忘的更快，再要用的时候，又要重新学（虽然会快很多），这也是我写博客项目的原因，一个是记录，一个是整理。记录是记录时光的流逝，整理是整理学习成果。要好好把博客写好了。慢就是快，就像姜文说的：步子迈大了，容易扯着蛋。我时刻提醒自己，一定不能浮起来，要沉下去。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/06/01/写在大一期末考试之际/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-98-验证二叉搜索树/">LeetCode-98-验证二叉搜索树</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/comments/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></p>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; v;</span><br><span class="line">        inorder(root,v);</span><br><span class="line">        for(int i = 1; i &lt; v.size(); i++)&#123;</span><br><span class="line">            if(v[i-1]-&gt;val &gt;= v[i]-&gt;val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void inorder(TreeNode* node, vector&lt;TreeNode*&gt; &amp;v)&#123;</span><br><span class="line">        if(!node) return;</span><br><span class="line">        inorder(node-&gt;left,v);</span><br><span class="line">        v.push_back(node);</span><br><span class="line">        inorder(node-&gt;right,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>利用二叉搜索树的中序遍历是升序的特性。</p>
<p>将每个元素push进一个vector中，如果vector中元素不是按升序排列，这该树不是二叉搜索树。</p>
<h3 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        return helper(root,NULL,NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    //返回该结点是否在指定区间内。</span><br><span class="line">    bool helper(TreeNode *node, TreeNode *min, TreeNode *max)&#123;</span><br><span class="line">        if(!node) return true;</span><br><span class="line">        if((min &amp;&amp; node-&gt;val &lt;= min-&gt;val) || (max &amp;&amp; node-&gt;val &gt;= max-&gt;val)) return false;</span><br><span class="line">        //左子节点的值不能比当前结点的值大，右节点的值不能不当前结点小。</span><br><span class="line">        return helper(node-&gt;left, min, node) &amp;&amp; helper(node-&gt;right, node, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据题目给的三条性质，所有结点及其下面的所有结点均可以构成二叉搜索树，</p>
<p>所以对于非叶子结点，可以以当前结点为根据，划分区间，区间内的点必须比左端点大，比右端点小。</p>
<p>用一个递归函数来不断更新该区间，判断该结点是否在区间内即可。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-98-验证二叉搜索树/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-922-按奇偶排序数-II/">LeetCode-922-按奇偶排序数-II</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/submissions/" target="_blank" rel="noopener">922. 按奇偶排序数组 II</a></p>
<p>给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。</p>
<p>对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int len = A.size();</span><br><span class="line">        int j = 1;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            while(i &lt; len &amp;&amp; (A[i] &amp; 1) == 0) i+=2;</span><br><span class="line">            while(j &lt; len &amp;&amp; (A[j] &amp; 1) != 0) j+=2;</span><br><span class="line">            if(i &gt;= len || j &gt;= len) break;</span><br><span class="line">            std::swap(A[i],A[j]);</span><br><span class="line">            i+=2;</span><br><span class="line">            j+=2;</span><br><span class="line">        &#125;</span><br><span class="line">        return A;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>设置两个指针。<br>一个指针只走奇数下标，一个指针只走偶数下标。<br>当碰到不符合条件（奇数下标的值不是奇数，偶数下标的值不是偶数）就停下并交换两个值，之后接着走，直到指针越界为止。</p>
<blockquote>
<p>看评论有人用栈或者另外准备两个数组的，速度比原地交换还快，不知道为什么。实现也比较简单，就不赘述了。</p>
</blockquote>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-922-按奇偶排序数-II/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-78-子集/">LeetCode-78-子集</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/subsets/comments/" target="_blank" rel="noopener">78. 子集</a></p>
<h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><p>对于每一项相对每个子集来说，都有放与不放两种选择。</p>
<p>创建一个放元素的递归函数，该函数的作用为将一项<strong>放</strong>和<strong>不放</strong>两种选择进行描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">        vector&lt;int&gt; item;</span><br><span class="line">        result.push_back(item);</span><br><span class="line">        </span><br><span class="line">        putitem(0, nums, item, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    //把一项放进result中。</span><br><span class="line">    void putitem(int i, vector&lt;int&gt;&amp; nums,vector&lt;int&gt; item, vector&lt;vector&lt;int&gt; &gt; &amp;result)&#123;</span><br><span class="line">        if(i == nums.size())&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //每个元素都有放和不放两种选择。</span><br><span class="line">        //放</span><br><span class="line">        item.push_back(nums[i]);</span><br><span class="line">        result.push_back(item);</span><br><span class="line">        putitem(i+1, nums, item, result);</span><br><span class="line">        //不放</span><br><span class="line">        item.pop_back();</span><br><span class="line">        putitem(i+1, nums, item, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h3><h5 id="遍历，遇到一个数就把所有子集加上该数组成新的子集，遍历完毕即是所有子集"><a href="#遍历，遇到一个数就把所有子集加上该数组成新的子集，遍历完毕即是所有子集" class="headerlink" title="遍历，遇到一个数就把所有子集加上该数组成新的子集，遍历完毕即是所有子集"></a>遍历，遇到一个数就把所有子集加上该数组成新的子集，遍历完毕即是所有子集</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">        vector&lt;int&gt; item;</span><br><span class="line">        result.push_back(item);</span><br><span class="line">        for(int i =0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            int s = result.size();</span><br><span class="line">            for(int j = 0; j &lt; s;j++)&#123;</span><br><span class="line">                result.push_back(result[j]);</span><br><span class="line">                result[j].push_back(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Solution3（位运算）："><a href="#Solution3（位运算）：" class="headerlink" title="Solution3（位运算）："></a>Solution3（位运算）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">        //子集一共有2的n次方种，使用位运算来解。</span><br><span class="line">        //每一位代表一个元素。</span><br><span class="line">        //如，100 代表[3]、011代表[2,1]。</span><br><span class="line">        int all_set = 1 &lt;&lt; nums.size();//2的n次方种；</span><br><span class="line">        for(int i = 0; i &lt; all_set; i++)&#123;</span><br><span class="line">            vector&lt;int&gt; item;</span><br><span class="line">            for(int j = 0; j &lt; nums.size(); j++)&#123;</span><br><span class="line">                //如果i的第j位为1，说明，有这一位所代表的元素。</span><br><span class="line">                // （1 &lt;&lt; j）第j位为1，其他位为0。</span><br><span class="line">                // i &amp; (1 &lt;&lt; j)， i 这个数中，j这一位是不是为1。（i中是否包含这个元素）</span><br><span class="line">                if(i &amp; (1 &lt;&lt; j))&#123;</span><br><span class="line">                    item.push_back(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //将该子集放入集合中。</span><br><span class="line">            result.push_back(item);</span><br><span class="line">            item.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-78-子集/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-88-合并两个有序数组/">LeetCode-88-合并两个有序数组</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/merge-sorted-array/submissions/" target="_blank" rel="noopener">88. 合并两个有序数组</a></p>
<p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p>
<blockquote>
<p>说明:</p>
<p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int tail = m + n -1;</span><br><span class="line">        int nums1tail = m-1;</span><br><span class="line">        int nums2tail = n-1;</span><br><span class="line">        while(nums1tail &gt;= 0 &amp;&amp; nums2tail &gt;= 0)&#123;</span><br><span class="line">            if(nums1[nums1tail] &gt;= nums2[nums2tail])&#123;</span><br><span class="line">                nums1[tail] = nums1[nums1tail--];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                nums1[tail] = nums2[nums2tail--];</span><br><span class="line">            &#125;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        while(nums2tail &gt;= 0)</span><br><span class="line">            nums1[tail--] = nums2[nums2tail--];</span><br><span class="line">        while(nums1tail &gt;= 0)</span><br><span class="line">            nums1[tail--] = nums1[nums1tail--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与归并排序的merge代码类似，不过是从数组的末尾往前比较。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-88-合并两个有序数组/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-92-反转链-II/">LeetCode-92-反转链-II</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a></p>
<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* reverseBetween(struct ListNode* head, int m, int n) &#123;</span><br><span class="line">    int chang_len = n-m+1;//逆置的结点个数。</span><br><span class="line">    struct ListNode* prevHead = NULL;//记录开始逆置结点的前驱。</span><br><span class="line">    struct ListNode* result = head;//用于最后返回。</span><br><span class="line">    while(head &amp;&amp; --m)&#123; //到达开始逆置的位置。</span><br><span class="line">        prevHead = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    struct ListNode * modify_list_tail = head;//将该结点之前当前开始逆置的结点。</span><br><span class="line">    struct ListNode * newHead = NULL;//用于逆置结点。</span><br><span class="line">    while(head &amp;&amp; chang_len)&#123;</span><br><span class="line">        struct ListNode * next = head-&gt;next;</span><br><span class="line">        head-&gt;next = newHead;</span><br><span class="line">        newHead = head;</span><br><span class="line">        head = next;</span><br><span class="line">        chang_len--;</span><br><span class="line">    &#125;</span><br><span class="line">    //此时head就到了n处，modify_list_tail就到了逆置段的最后一个结点。</span><br><span class="line">    //将modify_list_tail 与 head连接。</span><br><span class="line">    modify_list_tail-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">    if(prevHead)&#123; //如果prevHead不为空，说明不是从第一个几点开始逆置的。 m &gt; 1。</span><br><span class="line">        prevHead-&gt;next = newHead;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        result = newHead; //如果prevHead为空， 则说明是从第一个就开始逆置，直接将逆置后的头结点赋值给res，m=1。</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>解决这个问题主要是要找关键节点。</p>
<p>这个题的关键节点为：</p>
<ul>
<li>要逆置的结点的前一个结点（prevHead）。</li>
<li>要逆置的第一个结点。（直接用head来探测）。</li>
<li>要逆置的最后一个结点。（此结点为逆置前的第一个结点，逆置后就变为了最后一个结点）</li>
<li>要逆置的最后一个结点的后一个结点。（在用head逆置后，head就到了逆置后的这个结点。）</li>
</ul>
<ol>
<li>找到前两个结点。</li>
<li>从m开始，到n，一共需要n-m+1个结点需要逆置。所以要逆置n-m+1次。</li>
<li>将逆置后的尾结点 与 逆置段后面一个结点相连。</li>
<li>如果结点是从开始逆置，将逆置后的头结点返回。否则，将前面的结点与逆置后的头结点链接返回。</li>
</ol>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-92-反转链-II/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-59-螺旋矩-II/">LeetCode-59-螺旋矩-II</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">59. 螺旋矩阵 II</a></p>
<p>给定一个正整数 n，生成一个包含 1 到 n² 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
<p>与<a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. 螺旋矩阵</a>类似。</p>
<p>只需要依次给新数组中的相应元素赋值即可。</p>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n<span class="number">-1</span>, up = <span class="number">0</span>, down = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; up &lt; down)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i = left, j = up;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; right)&#123;</span><br><span class="line">                res[j][i] = k++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">while</span>(j &lt; down)&#123;</span><br><span class="line">                res[j][i] = k++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &gt; left)&#123;</span><br><span class="line">                res[j][i] = k++;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; up)&#123;</span><br><span class="line">                res[j][i] = k++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            up++;</span><br><span class="line">            down--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//形不成圈（单列或者单行）</span></span><br><span class="line">        <span class="keyword">if</span>(up == down)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">                res[up][left++] = k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(up &lt;= down)&#123;</span><br><span class="line">                res[up++][left] = k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-59-螺旋矩-II/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-693-交替位二进制数/">LeetCode-693-交替位二进制数</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/" target="_blank" rel="noopener">693. 交替位二进制数</a></p>
<p>给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: 5</p>
<p>输出: True</p>
<p>解释:<br>5的二进制数是: 101</p>
</blockquote>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasAlternatingBits(int n) &#123;</span><br><span class="line">        //如果是奇偶交替，则n ^ (n &gt;&gt; 1) 会使有效位全为1，</span><br><span class="line">        int temp = n ^ (n &gt;&gt; 1);</span><br><span class="line">        //有效位全为1 再加1， 得到有效位前面为1，后面全为0，再与该数与，则全部清零。</span><br><span class="line">        return (temp &amp; (temp+1)) == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-693-交替位二进制数/">阅读更多</a> 	
	</div>	
    
</article>     
     	




 
   <nav class="paginator">
    
        <a class="prev" href="/page/4/"> 
            <i class="iconfont icon-left"></i>
            上一页
        </a>
    

   <span class="page-number"> Page <strong>5</strong>, Total <strong>123</strong> . </span>

    
        <a class="next" href="/page/6/"> 
            下一页
            <i class="iconfont icon-right"></i>
        </a>
    
  </nav> 

          </div> 
      </div>            
    
    <a id="page-backTop">
      <span>
        <i class="iconfont icon-backtotop"></i>
      </span>
    </a> 

  
    
    <div class="search-container sildeUpMin">
        <div class="search-header">
            <input type="text" placeholder="输入你想搜索的" id="search-input" class="search-input">
            <span class="search-cancel">
                <i class="iconfont icon-cancel">
            </i></span>
        </div>
        <div id="search-result" class="search-result"></div>
    </div>
 
     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon" src="/images/logo.png">   
      

         
            

            <a class="mobile-menu-link" href="/">首页
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">归档
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">标签
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">关于
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">搜索 </a>                 
            
         
      
</div>        
    



     
    




<footer id="footer">	    

		
		<div class="footer-copyright">
		&copy;
				
		2017-
		
		2020		
	
		BeckoninGshy&#39;s Blog
		<br>

		Theme  <a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank">Nayo</a>
		</div>			
	 
</footer>   

    <script src="/nayo.bundle.js"></script>           
  </body>        
</html>