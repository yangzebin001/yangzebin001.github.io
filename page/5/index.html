<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  
  
  <title>  BeckoninGshy </title>

 
  
    <link rel="icon" href="/images/logo.png">
  


  <link rel="stylesheet" href="/nayo.min.css"> 
</head>  
  <body>   
    
      <header class="header">
	
  <nav class="header-inner">        

    <span class="iconfont icon-menu mobile-toggle"></span>   	

    <div class="header-logo">
      <a href="/">
        <img class="header-logo-img" src="/images/logo.png">
      </a>
    </div>

    <div class="header-menu">          
              
          
            <a class="header-menu-link" id="header-menu-home" href="/">
              <i class="iconfont icon-home">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-archives" href="/archives">
              <i class="iconfont icon-archives">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-tags" href="/tags">
              <i class="iconfont icon-tags">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-about" href="/about">
              <i class="iconfont icon-about">  
            </i></a>     
          
              
          
              <a class="header-menu-link" id="header-menu-search">
                <i class="iconfont icon-search">  
              </i></a>
          
                  
    </div>  
    
  </nav>
</header>

   

      <div class="container">       
          
          
            <div class="container-inner">  
          

          




<div class="profile sildeUpMin">
	
		<img class="avatar" src="/images/logo.png">

		<p class="author">Welcome to BeckoninGshy&#39;s Bolg</p>
		
		<div class="social">
   		      	
			<a target="_blank" class="social-links" href="https://github.com/yangzebin001">		
				<i class="iconfont icon-Github">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="">		
				<i class="iconfont icon-Facebook">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="">		
				<i class="iconfont icon-Instagram">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="https://music.163.com/#/user/home?id=117201882">		
				<i class="iconfont icon-Neteasemusic">
			</i></a>	
	    
    	</div>		
</div>


    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/07/31/Dijkstra算法学习总结/">Dijkstra算法学习总结</a>  
	       
		 

		<div class="article-meta">
			<time>7月 31, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p>单源最短路径算法</p>
<h2 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h2><p>对于图G（V，E）维护一个集合S,存放已经被访问过的顶点（准备期间只有源点s），每次从集合V-S中选择与起点s的距离最小的一个顶点（记为u），访问u并加入集合S，并令u为中介点，更新起点s与所有从u能达到的顶点v之间的最短距离。这样执行n次（n为顶点个数），直到集合S包含所有顶点。</p>
<p><img src="https://note.youdao.com/favicon.ico" alt="算法书上的图"></p>
<h4 id="适用范围：有向无负权图"><a href="#适用范围：有向无负权图" class="headerlink" title="适用范围：有向无负权图"></a>适用范围：有向无负权图</h4><h3 id="1-优先队列版-复杂度O-ElogE"><a href="#1-优先队列版-复杂度O-ElogE" class="headerlink" title="1.优先队列版 复杂度O(ElogE)"></a>1.优先队列版 复杂度O(ElogE)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line"></span><br><span class="line">struct qnode&#123;</span><br><span class="line">    int v,d;</span><br><span class="line">    qnode(int _v=0,int _d=0):v(_v),d(_d)&#123;&#125;</span><br><span class="line">    friend bool operator &lt;(const qnode &amp;r)const&#123;</span><br><span class="line">        return d&gt;r.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Edge&#123;</span><br><span class="line">    int v,cost;</span><br><span class="line">    Edge(int _v=0,int _cost=0):v(_v),cost(_cost)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">const int MAXN = 100010;</span><br><span class="line">vector&lt;Edge&gt; E[MAXN];</span><br><span class="line">//是否访问标志</span><br><span class="line">int vis[MAXN];</span><br><span class="line">//到源点的最短距离，准备期间设置为无穷大，表示不可及。</span><br><span class="line">int dis[MAXN]; </span><br><span class="line">//加边</span><br><span class="line">void add_edge(int u,int v,int w)&#123;</span><br><span class="line">    E[u].push_back(Edge(v,w));</span><br><span class="line">&#125;</span><br><span class="line">//初始化(从0开始编号)</span><br><span class="line">void init(int n)&#123;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        E[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Dijkstra(int s,int n)&#123;</span><br><span class="line">    for(int i=0;i&lt;n;i++)vis[i] = 0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)dis[i] = (i == s ? 0 : INF);</span><br><span class="line">    priority_queue&lt;qnode&gt; q;//声明优先队列：每次从队列中取出的是具有最高优先权的元素。</span><br><span class="line">    //优先队列第一个参数为比较类型，第二个为容器类型，第三个为比较函数。</span><br><span class="line">	//greater实现小顶堆//less 实现大顶堆（默认为大顶堆）</span><br><span class="line">	q.push(qnode(s,dis[s]));//先将源点推进优先队列</span><br><span class="line">	qnode temp;</span><br><span class="line">    while(!q.empty())&#123;//当队列空时所有边已被访问</span><br><span class="line">        temp = q.top();q.pop();</span><br><span class="line">        //当前顶点</span><br><span class="line">        int u = temp.v;</span><br><span class="line">        if(vis[u])continue;</span><br><span class="line">        vis[u] = true;</span><br><span class="line">        //每一条与u相邻的边都要更新</span><br><span class="line">        for(int i=0;i&lt;E[u].size();i++)&#123;</span><br><span class="line">            //邻点</span><br><span class="line">            int v = E[u][i].v;</span><br><span class="line">            //权重</span><br><span class="line">            int cost = E[u][i].cost;</span><br><span class="line">            //松弛操作，更新权重时机</span><br><span class="line">            if(!vis[v] &amp;&amp; dis[u] + cost &lt; dis[v])&#123;</span><br><span class="line">                dis[v] = dis[u] + cost;</span><br><span class="line">                //把每一个更新的长度加进队列</span><br><span class="line">                q.push(qnode(v,dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-邻接矩阵版-复杂度O-N-2-记录路径版"><a href="#2-邻接矩阵版-复杂度O-N-2-记录路径版" class="headerlink" title="2.邻接矩阵版 复杂度O(N^2) 记录路径版"></a>2.邻接矩阵版 复杂度O(N^2) 记录路径版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">const int MAXN = 10000;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">bool vis[MAXN];//访问记录</span><br><span class="line">int pre[MAXN];//父节点</span><br><span class="line">int cost[MAXN][MAXN];//权重矩阵</span><br><span class="line">int lowcost[MAXN];//记录最短路径</span><br><span class="line"></span><br><span class="line">//初始化矩阵为无穷。</span><br><span class="line">void Init(int N)&#123;</span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">		for(int j = 0; j &lt; N; j++)&#123;</span><br><span class="line">			cost[i][j] = INF;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//如果INF是满十六进制表示。如：const int INF = 0x3f3f3f3f;</span><br><span class="line">	//则可以使用memset(cost,INF,sizeof(cost));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//cost:权重矩阵,lowcost:最短路径，n:数据范围,beg:源点</span><br><span class="line">void Dijkstra(int cost[][MAXN],int lowcost[],int n,int beg)&#123;</span><br><span class="line">	//初始化各值</span><br><span class="line">	for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">		lowcost[i] = INF;</span><br><span class="line">		vis[i] = false;</span><br><span class="line">		pre[i] = -1;</span><br><span class="line">	&#125;</span><br><span class="line">	//设置源点</span><br><span class="line">	lowcost[beg] = 0;</span><br><span class="line">	for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">		int k = -1;</span><br><span class="line">		int Min = INF;</span><br><span class="line">		//找到目前最短路径数组中到源点最短的节点。</span><br><span class="line">		for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">			if(!vis[i] &amp;&amp; lowcost[i] &lt; Min)&#123;</span><br><span class="line">				Min = lowcost[i];</span><br><span class="line">				k = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//找不到，说明节点都已经全部访问。</span><br><span class="line">		if(k == -1)break;</span><br><span class="line">		//记录该节点。</span><br><span class="line">		vis[k] = true;</span><br><span class="line">		//松弛操作。更新每条与该节点相连并且还未访问到的节点的路径。</span><br><span class="line">		for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">			if(!vis[i] &amp;&amp; lowcost[k] + cost[k][i] &lt; lowcost[i])&#123;</span><br><span class="line">			    //发现一条更短的路径，更新。</span><br><span class="line">				lowcost[i] = lowcost[k] + cost[k][i];</span><br><span class="line">				//更新父节点。</span><br><span class="line">				pre[i] = k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题通用思路"><a href="#解题通用思路" class="headerlink" title="解题通用思路"></a>解题通用思路</h3><p>做关于Dijkstra算法的题，通常不会只出一个裸的寻找最短路径，而是会给出一个或多个次级标尺。通常不会超出三个维度：</p>
<ul>
<li>边权</li>
<li>点权</li>
<li>多少条最短路径，或该路径的长度。</li>
</ul>
<p>通常是多个维度组合起来寻找最优解。</p>
<p>遇到这类问题，可通过将每条最短路径都保存下来，依次进行处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; paths[MAXN];</span><br><span class="line">//在其松弛操作中，将路径保存</span><br><span class="line">for(int j = 0; j &lt; N; j++)&#123;</span><br><span class="line">	if(!vis[j] &amp;&amp; G[k][j] != INF)&#123;</span><br><span class="line">		if(dis[j] &gt; dis[k] + G[k][j])&#123;</span><br><span class="line">			dis[j] = dis[k] + G[k][j];</span><br><span class="line">			paths[j].clear();</span><br><span class="line">			paths[j].push_back(k);</span><br><span class="line">		&#125;else if(dis[j] == dis[k] + G[k][j])&#123;</span><br><span class="line">			paths[j].push_back(k);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; ans;//用于存放每一个最短路径</span><br><span class="line">vector&lt;int&gt; p;</span><br><span class="line">//计算每条路径，注意，这样的路径是反序并且不包含源点的，如需要，则单独计算。</span><br><span class="line">void makeMinPath(vector&lt;vector&lt;int&gt; &gt; &amp;ans,vector&lt;int&gt; p,int j)&#123;</span><br><span class="line">	if(j == 0)&#123;</span><br><span class="line">		ans.push_back(p);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i = 0; i &lt; paths[j].size(); i++)&#123;</span><br><span class="line">		p.push_back(paths[j][i]);</span><br><span class="line">		makeMinPath(ans,p,paths[j][i]);</span><br><span class="line">		p.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后就可以根据要求计算每一条路径，并挑出符合问题的解了。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/07/31/Dijkstra算法学习总结/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/07/19/AVL树详解/">AVL树详解</a>  
	       
		 

		<div class="article-meta">
			<time>7月 19, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>我们在学习二叉搜索树的时候，发现无论是查找还是插入元素在理想情况下都可以达到O(logN)级别，但是由于插入的顺序，数的结构也会不同，这种理想情况很难保持甚至最坏的情况会退化成链表。导致性能下降。这时就需要一个能实现高度自动平衡的树结构。就出现了平衡树，<br>今天讲的是平衡树的一种：AVL树。</p>
<h3 id="初识AVL树"><a href="#初识AVL树" class="headerlink" title="初识AVL树"></a>初识AVL树</h3><p>AVL树得名与 Adelson-Velsky和 Landis两位发明者的首字母，它是自平衡的二叉搜索树，具有二叉树搜索树的性质（左子树的结点都比当前结点小，右子树都比当前结点大），同时它又是平衡二叉树，能够自适应高度。在AVL树中，<strong>任意节点的两个子树的高度差不超过1</strong>，这也是将不平衡的子树调整为平衡子树的重要指标。</p>
<h3 id="AVL树的调整策略"><a href="#AVL树的调整策略" class="headerlink" title="AVL树的调整策略"></a>AVL树的调整策略</h3><p>AVL是在进行插入节点时，通过检测是否破坏了平衡条件，进而通过进行一定程度的节点旋转来达到整棵树的平衡。</p>
<h3 id="简单情形"><a href="#简单情形" class="headerlink" title="简单情形"></a>简单情形</h3><p>我们知道一个树如果只有一个或两个时，树是平衡的。所以问题会出现在第三个节点插入的位置，如果是下图：</p>
<p><img src="https://note.youdao.com/favicon.ico" alt="单左旋后"></p>
<p>则是平衡的。</p>
<p>先来看最简单的不平衡情况：</p>
<p><img src="https://note.youdao.com/favicon.ico" alt="单左旋前"></p>
<p>当把根节点的右节点“提”到根节点的位置，将旧根节点当新的根节点的左子节点。就可达到平衡状态。</p>
<p><img src="/images/placeholder.png" alt="单左旋后" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p>
<p>具体到树中，可以归结为以下四种情况：</p>
<h4 id="1-左旋"><a href="#1-左旋" class="headerlink" title="1.左旋"></a>1.左旋</h4><p>上述是最特殊的只有三个节点的情况，下面我们将它代入一般的二叉树来研究：</p>
<p>对于一个节点，当右子树的高度比左子树高一个高度的时候，此时新进来的节点也需要插入右子树。当然，如果新插入节点以后，右子树还维持原来的高度，那么这颗树就还是平衡的。问题出在当新插入节点后，右子树的高度增加了，这时破坏了平衡树两个子树的高度差不超过一的性质，就需要调整使其达到平衡状态。这时，我们首先考虑比较好处理的情况，也就是插在右子树的右边的情况。</p>
<p><img src="/images/placeholder.png" alt="左旋前" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p>
<p>调整的策略：</p>
<p>此时我们需要将当前节点的右子树“提”到当前节点的位置，当前节点“下降”为其右子树的左子树，具体操作过程如图：</p>
<p><img src="/images/placeholder.png" alt="左旋中1" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p>
<p><img src="/images/placeholder.png" alt="左旋中2" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p>
<p>调整之后变为：</p>
<p><img src="/images/placeholder.png" alt="左旋后" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p>
<p>到此，树变成了平衡的，由于整棵树要往左边旋转，所以左旋的操作就右子树的地位上移，根节点的地位下降。</p>
<h3 id="2-右旋"><a href="#2-右旋" class="headerlink" title="2.右旋"></a>2.右旋</h3><p>现在我们有了左旋的经验，很容易推出需要进行右旋操作的时机：</p>
<p>对于一个节点，当左子树的高度原先就比右子树的高度多一时，插入节点又使左子树的高度增加，并且插在了左子树的左边的时候，就需要调整了：</p>
<p><img src="/images/placeholder.png" alt="右旋前" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p>
<p><img src="/images/placeholder.png" alt="右旋中1" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p>
<p><img src="/images/placeholder.png" alt="右旋中2" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p>
<p><img src="/images/placeholder.png" alt="右旋后" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p>
<p>树变为平衡的。</p>
<p>至此，单旋转就学习完毕，下面学习双旋转。</p>
<h3 id="3-右左旋"><a href="#3-右左旋" class="headerlink" title="3.右左旋"></a>3.右左旋</h3><p>前面我们学习单旋转时，插入节点都是与其子树同向的位置，这种情况由于倾斜的状况比较明显，所以只要找到中间的位置，将其“提”到“根节点”的位置，就可以达到平衡。而当其中子树失去平衡是由于所处子树往相反的方向插入，导致倾斜的状况不容易看出，所以需要经过两次旋转来达到平衡状态。<br>如下图：</p>
<p><img src="/images/placeholder.png" alt="右左旋前" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p>
<p>我们可以观察到，在当前的结点的右子树的倾斜情况与我们刚才介绍到的右旋的情况很相似：</p>
<p><img src="/images/placeholder.png" alt="右左旋前1" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p>
<p>所以将右子树按右旋处理，处理之后变为：</p>
<p><img src="/images/placeholder.png" alt="左旋前" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p>
<p>这时我们惊奇的发现它变成了我们前面介绍的左旋前时的情形。这种情况我们已经会处理了：将右子节点“提”上来，把当前“根”节点变为右子节点的左子树，最后就调整到平衡状态了。</p>
<p><img src="/images/placeholder.png" alt="左旋后" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p>
<h3 id="4-左右旋"><a href="#4-左右旋" class="headerlink" title="4.左右旋"></a>4.左右旋</h3><p>同样地，左右旋也可通过先将左子树左旋，再将当前根节点右旋的调整来达到平衡状态。</p>
<p><img src="/images/placeholder.png" alt="左右旋前" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p>
<p>先将左子树左旋：</p>
<p><img src="/images/placeholder.png" alt="左右旋前1" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p>
<p><img src="/images/placeholder.png" alt="右旋前" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p>
<p>再进行右旋：</p>
<p><img src="/images/placeholder.png" alt="右旋后" data-src="https://note.youdao.com/favicon.ico" class="lazyload"></p>
<p>达到平衡状态。</p>
<hr>
<p>到此，二叉树的调整策略就介绍完了，下面上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">typedef struct AVLNode* AVLTree;</span><br><span class="line">struct AVLNode&#123;</span><br><span class="line">	int data;</span><br><span class="line">	AVLTree left;</span><br><span class="line">	AVLTree right;</span><br><span class="line">	int height;</span><br><span class="line">	AVLNode(int data):data(data)&#123;</span><br><span class="line">		left = NULL;</span><br><span class="line">		right = NULL;</span><br><span class="line">		height = 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Max(int a, int b)&#123;</span><br><span class="line">	return a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetHeight(AVLTree t)&#123;</span><br><span class="line">	if(!t) return 0;</span><br><span class="line">	return t-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//右旋 </span><br><span class="line">AVLTree SingleRightRotation(AVLTree A)&#123;</span><br><span class="line">	//先记录左子树,将左节点的右子树变为根节点的左子树，再将根节点作为左节点的右子树。 </span><br><span class="line">	AVLTree l = A-&gt;left;</span><br><span class="line">	A-&gt;left = l-&gt;right;</span><br><span class="line">	l-&gt;right = A;</span><br><span class="line">	//更新两节点的高度。 </span><br><span class="line">	A-&gt;height = Max(GetHeight(A-&gt;left),GetHeight(A-&gt;right))+1;</span><br><span class="line">	l-&gt;height = Max(GetHeight(l-&gt;left),A-&gt;height) + 1;</span><br><span class="line">	return l; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//左旋 </span><br><span class="line">AVLTree SingleLeftRotation(AVLTree A)&#123;</span><br><span class="line">	//先记录右子树,将右节点的左子树变为根节点的右子树，再将根节点作为右节点的左子树。 </span><br><span class="line">	AVLTree r = A-&gt;right;</span><br><span class="line">	A-&gt;right = r-&gt;left;</span><br><span class="line">	r-&gt;left = A;</span><br><span class="line">	//更新两节点的高度。 </span><br><span class="line">	A-&gt;height = Max(GetHeight(A-&gt;left),GetHeight(A-&gt;right)) + 1;</span><br><span class="line">	r-&gt;height = Max(GetHeight(r-&gt;right),A-&gt;height) + 1;</span><br><span class="line">	return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//右左旋 </span><br><span class="line">AVLTree DoubleRightLeftRotation(AVLTree A)&#123;</span><br><span class="line">	//将左子树右旋 </span><br><span class="line">	A-&gt;right = SingleRightRotation(A-&gt;right);</span><br><span class="line">	//再将当前节点左旋 </span><br><span class="line">	return SingleLeftRotation(A);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//左右旋 </span><br><span class="line">AVLTree DoubleLeftRightRotation(AVLTree A)&#123;</span><br><span class="line">	//将右子树左旋 </span><br><span class="line">	A-&gt;left = SingleLeftRotation(A-&gt;left);</span><br><span class="line">	//再将当前节点右旋 </span><br><span class="line">	return SingleRightRotation(A);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">AVLTree Insert(AVLTree T, int X)&#123;</span><br><span class="line">	if(!T)&#123;</span><br><span class="line">		T = new AVLNode(X);</span><br><span class="line">	&#125;else if(X &lt; T-&gt;data)&#123;</span><br><span class="line">		T-&gt;left = Insert(T-&gt;left,X);</span><br><span class="line">		if(GetHeight(T-&gt;left)- GetHeight(T-&gt;right) == 2)&#123;</span><br><span class="line">			if(X &lt; T-&gt;left-&gt;data)&#123; //右旋 </span><br><span class="line">				T = SingleRightRotation(T);</span><br><span class="line">			&#125;else&#123; //左右旋 </span><br><span class="line">				T = DoubleLeftRightRotation(T);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else if(X &gt; T-&gt;data)&#123;</span><br><span class="line">		T-&gt;right = Insert(T-&gt;right,X);</span><br><span class="line">		if(GetHeight(T-&gt;right)- GetHeight(T-&gt;left) == 2)&#123;</span><br><span class="line">			if(X &gt; T-&gt;right-&gt;data)&#123; //左旋 </span><br><span class="line">				T = SingleLeftRotation(T);</span><br><span class="line">			&#125;else&#123; //右左旋 </span><br><span class="line">				T = DoubleRightLeftRotation(T);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//更新高度 </span><br><span class="line">	T-&gt;height = Max(GetHeight(T-&gt;left),GetHeight(T-&gt;right))+1;</span><br><span class="line">	return T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/07/19/AVL树详解/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/07/13/LeetCode-106-从中序与后序遍历序列构造二叉树/">106-从中序与后序遍历序列构造二叉树</a>  
	       
		 

		<div class="article-meta">
			<time>7月 13, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. 从中序与后序遍历序列构造二叉树</a></p>
<h3 id="根据一棵树的中序遍历与后序遍历构造二叉树。"><a href="#根据一棵树的中序遍历与后序遍历构造二叉树。" class="headerlink" title="根据一棵树的中序遍历与后序遍历构造二叉树。"></a>根据一棵树的中序遍历与后序遍历构造二叉树。</h3><blockquote>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
</blockquote>
<p>例如，给出</p>
<p>中序遍历 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure>
<p>后序遍历 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postorder = [9,15,7,20,3]</span><br></pre></td></tr></table></figure>
<p>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* makeTree(vector&lt;int&gt;&amp; postorder, int&amp; postindex, vector&lt;int&gt;&amp; inorder,int left, int right)&#123;</span><br><span class="line">        if(left &lt;= right)&#123;</span><br><span class="line">            for(int i = 0; i &lt; inorder.size(); i++)&#123;</span><br><span class="line">                if(postorder[postindex] == inorder[i])&#123;</span><br><span class="line"></span><br><span class="line">                    TreeNode* root = new TreeNode(postorder[postindex--]);</span><br><span class="line">                    root-&gt;right = makeTree(postorder,postindex,inorder,i+1,right);</span><br><span class="line">                    root-&gt;left = makeTree(postorder,postindex,inorder,left,i-1);  </span><br><span class="line">                    return root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        int postindex = postorder.size()-1;</span><br><span class="line">        return makeTree(postorder,postindex,inorder,0,inorder.size()-1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>根据后序遍历的特点，每棵子树的根节点总是最后遍历到。</p>
<p>所以用一个按引用传递的指针指向后序数组的末尾，用该值在中序数组中查找，并将该值当做当前树的根节点。</p>
<p>该值位置的左边为以该节点为根节点的左子树的范围，位置右边为右子树的范围，然后不断更新这个范围，递归下去即可，注意边界值。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/07/13/LeetCode-106-从中序与后序遍历序列构造二叉树/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/06/02/正则表达式全解——正则基础/">正则表达式全解——正则基础</a>  
	       
		 

		<div class="article-meta">
			<time>6月 02, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h3 id="正则基础"><a href="#正则基础" class="headerlink" title="正则基础"></a>正则基础</h3><h5 id=""><a href="#" class="headerlink" title="^"></a>^</h5><p>表示一行的开始</p>
<h5 id="-1"><a href="#-1" class="headerlink" title="$"></a>$</h5><p>表示一行的结束</p>
<h5 id="…"><a href="#…" class="headerlink" title="[…]"></a>[…]</h5><p>表示其中的字符是选择性（逻辑或）的，要么是a,要么是b,要么是…。</p>
<blockquote>
<p>c[a|b]t 可以匹配到cat、cbt<br>[a-z]、[0-9]、[0-9A-Za-z]是支持的。<br>[^$] 匹配空行<br>像 . * + ?  这些词在[]中仅表示字面的意思，利用这一特性，如果想表示原本含义，例如要匹配 . ，可以写为[.]</p>
</blockquote>
<h5 id="…-1"><a href="#…-1" class="headerlink" title="[^…]"></a>[^…]</h5><p>表示匹配不是其中的字符。为上一条的取反</p>
<h5 id="-2"><a href="#-2" class="headerlink" title="-"></a>-</h5><p>连字符，表示一个范围，见上一条。</p>
<blockquote>
<p>如果要匹配  - ，请将 - 写在开始位置，如果[-a-z]，匹配-或者是小写字母。</p>
</blockquote>
<h5 id="-3"><a href="#-3" class="headerlink" title="."></a>.</h5><p>   表示任意字符（除了换行符），</p>
<h5 id="-4"><a href="#-4" class="headerlink" title="|"></a>|</h5><p>表示或者</p>
<blockquote>
<p>(cat|dog) 表示要么cat,要么dog,<br>注意：这和[…]不同的是，[…]匹配其中的单个字符，(..|…)可以匹配不同的字符组。</p>
</blockquote>
<h5 id="-5"><a href="#-5" class="headerlink" title="?"></a>?</h5><p>表示可选项，类似于单选框，匹配零个或一个。</p>
<h5 id="-6"><a href="#-6" class="headerlink" title="+"></a>+</h5><p>表示出现一次或多次。</p>
<h5 id="-7"><a href="#-7" class="headerlink" title="*"></a>*</h5><p>表示匹配零次或多次。</p>
<h5 id="min-max"><a href="#min-max" class="headerlink" title="{min,max}"></a>{min,max}</h5><p>表示匹配之前的子表达式重复min到max次。（闭区间）</p>
<blockquote>
<p>{count} 表示匹配count次。</p>
</blockquote>
<h5 id="括号与反向引用"><a href="#括号与反向引用" class="headerlink" title="括号与反向引用"></a>括号与反向引用</h5><p>([0-9]){2,3}add\1    \1表示第一个括号中的内容再次使用。</p>
<h5 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h5><p>像 . * + ?  这些词在正则中有特殊的含义，要想使用它原本的含义，使用\来进行转义。</p>
<h5 id="…-2"><a href="#…-2" class="headerlink" title="(…)"></a>(…)</h5><p>括号的作用：1.限制多选结构，2.分组，3.捕获文本。</p>
<h5 id="一些特殊的字符"><a href="#一些特殊的字符" class="headerlink" title="一些特殊的字符"></a>一些特殊的字符</h5><ul>
<li>\t 制表符</li>
<li>\n换行符</li>
<li>\r 回车符</li>
<li>\s 任何空白字符(例如空格符、制表符、换行符等)</li>
<li>\S 除\s之外的任何字符(所以用(\s|\S) * )来表示任意字符。</li>
<li>\w 相当于[a-zA-Z0-9] 所以经常用\w+来表示一个单词 </li>
<li>\W \w取反，也就是[^a-zA-Z0-9] </li>
<li>\d  相当于[0-9] 也就是数字</li>
<li>\D \d取反，也就是[^0-9]</li>
</ul>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/06/02/正则表达式全解——正则基础/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/06/01/写在大一期末考试之际/">写在大一期末考试之际</a>  
	       
		 

		<div class="article-meta">
			<time>6月 01, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<h3 id="写在大一期末考试之际"><a href="#写在大一期末考试之际" class="headerlink" title="写在大一期末考试之际"></a>写在大一期末考试之际</h3><p>最近发生了很多各种各样的事，面对即将到来的期末考试，自己真的很没有底气，因为只有自己知道，对于大部分的课程，学的是如何糟糕。我不看重的课程不说，但数学学科的课程自己也没学到什么，一方面是老师的原因，但最多的是自己的问题，学习的重心绝对的向专业偏移，即使是专业，每天学的都是些业务类的技术，如果是这样，我觉得我可以立即辍学，这也不是我上大学的初衷，一定要向研究的方向转变，把数学基础提上来才是我大学应该做的事，大学时光1/4已经过去了，自己却没有调整到合适的状态，实属不应该。不过，也有些收获，算法竞赛这块是我没有预料到的，同时回想自己大一上学期学算法的时候是我最想要的状态，我不知道自己是不是喜欢，但无暇他顾地专心只搞一件事是我想要的，而通过学习它我可以进入这种状态，后来学长又找我说想打acm，我知道这个的难度，也知道意味着什么，但是我觉得人应该有些梦想，先让我做一年试试。</p>
<p>同时，我的学习方法也有很多的不足，很低效，我觉得得花些时间来调整下，通常都是学的快，忘的更快，再要用的时候，又要重新学（虽然会快很多），这也是我写博客项目的原因，一个是记录，一个是整理。记录是记录时光的流逝，整理是整理学习成果。要好好把博客写好了。慢就是快，就像姜文说的：步子迈大了，容易扯着蛋。我时刻提醒自己，一定不能浮起来，要沉下去。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/06/01/写在大一期末考试之际/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-98-验证二叉搜索树/">LeetCode-98-验证二叉搜索树</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/comments/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></p>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; v;</span><br><span class="line">        inorder(root,v);</span><br><span class="line">        for(int i = 1; i &lt; v.size(); i++)&#123;</span><br><span class="line">            if(v[i-1]-&gt;val &gt;= v[i]-&gt;val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void inorder(TreeNode* node, vector&lt;TreeNode*&gt; &amp;v)&#123;</span><br><span class="line">        if(!node) return;</span><br><span class="line">        inorder(node-&gt;left,v);</span><br><span class="line">        v.push_back(node);</span><br><span class="line">        inorder(node-&gt;right,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>利用二叉搜索树的中序遍历是升序的特性。</p>
<p>将每个元素push进一个vector中，如果vector中元素不是按升序排列，这该树不是二叉搜索树。</p>
<h3 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        return helper(root,NULL,NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    //返回该结点是否在指定区间内。</span><br><span class="line">    bool helper(TreeNode *node, TreeNode *min, TreeNode *max)&#123;</span><br><span class="line">        if(!node) return true;</span><br><span class="line">        if((min &amp;&amp; node-&gt;val &lt;= min-&gt;val) || (max &amp;&amp; node-&gt;val &gt;= max-&gt;val)) return false;</span><br><span class="line">        //左子节点的值不能比当前结点的值大，右节点的值不能不当前结点小。</span><br><span class="line">        return helper(node-&gt;left, min, node) &amp;&amp; helper(node-&gt;right, node, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据题目给的三条性质，所有结点及其下面的所有结点均可以构成二叉搜索树，</p>
<p>所以对于非叶子结点，可以以当前结点为根据，划分区间，区间内的点必须比左端点大，比右端点小。</p>
<p>用一个递归函数来不断更新该区间，判断该结点是否在区间内即可。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-98-验证二叉搜索树/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-922-按奇偶排序数-II/">LeetCode-922-按奇偶排序数-II</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/submissions/" target="_blank" rel="noopener">922. 按奇偶排序数组 II</a></p>
<p>给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。</p>
<p>对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int len = A.size();</span><br><span class="line">        int j = 1;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            while(i &lt; len &amp;&amp; (A[i] &amp; 1) == 0) i+=2;</span><br><span class="line">            while(j &lt; len &amp;&amp; (A[j] &amp; 1) != 0) j+=2;</span><br><span class="line">            if(i &gt;= len || j &gt;= len) break;</span><br><span class="line">            std::swap(A[i],A[j]);</span><br><span class="line">            i+=2;</span><br><span class="line">            j+=2;</span><br><span class="line">        &#125;</span><br><span class="line">        return A;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>设置两个指针。<br>一个指针只走奇数下标，一个指针只走偶数下标。<br>当碰到不符合条件（奇数下标的值不是奇数，偶数下标的值不是偶数）就停下并交换两个值，之后接着走，直到指针越界为止。</p>
<blockquote>
<p>看评论有人用栈或者另外准备两个数组的，速度比原地交换还快，不知道为什么。实现也比较简单，就不赘述了。</p>
</blockquote>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-922-按奇偶排序数-II/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-92-反转链-II/">LeetCode-92-反转链-II</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a></p>
<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* reverseBetween(struct ListNode* head, int m, int n) &#123;</span><br><span class="line">    int chang_len = n-m+1;//逆置的结点个数。</span><br><span class="line">    struct ListNode* prevHead = NULL;//记录开始逆置结点的前驱。</span><br><span class="line">    struct ListNode* result = head;//用于最后返回。</span><br><span class="line">    while(head &amp;&amp; --m)&#123; //到达开始逆置的位置。</span><br><span class="line">        prevHead = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    struct ListNode * modify_list_tail = head;//将该结点之前当前开始逆置的结点。</span><br><span class="line">    struct ListNode * newHead = NULL;//用于逆置结点。</span><br><span class="line">    while(head &amp;&amp; chang_len)&#123;</span><br><span class="line">        struct ListNode * next = head-&gt;next;</span><br><span class="line">        head-&gt;next = newHead;</span><br><span class="line">        newHead = head;</span><br><span class="line">        head = next;</span><br><span class="line">        chang_len--;</span><br><span class="line">    &#125;</span><br><span class="line">    //此时head就到了n处，modify_list_tail就到了逆置段的最后一个结点。</span><br><span class="line">    //将modify_list_tail 与 head连接。</span><br><span class="line">    modify_list_tail-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">    if(prevHead)&#123; //如果prevHead不为空，说明不是从第一个几点开始逆置的。 m &gt; 1。</span><br><span class="line">        prevHead-&gt;next = newHead;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        result = newHead; //如果prevHead为空， 则说明是从第一个就开始逆置，直接将逆置后的头结点赋值给res，m=1。</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>解决这个问题主要是要找关键节点。</p>
<p>这个题的关键节点为：</p>
<ul>
<li>要逆置的结点的前一个结点（prevHead）。</li>
<li>要逆置的第一个结点。（直接用head来探测）。</li>
<li>要逆置的最后一个结点。（此结点为逆置前的第一个结点，逆置后就变为了最后一个结点）</li>
<li>要逆置的最后一个结点的后一个结点。（在用head逆置后，head就到了逆置后的这个结点。）</li>
</ul>
<ol>
<li>找到前两个结点。</li>
<li>从m开始，到n，一共需要n-m+1个结点需要逆置。所以要逆置n-m+1次。</li>
<li>将逆置后的尾结点 与 逆置段后面一个结点相连。</li>
<li>如果结点是从开始逆置，将逆置后的头结点返回。否则，将前面的结点与逆置后的头结点链接返回。</li>
</ol>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-92-反转链-II/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-88-合并两个有序数组/">LeetCode-88-合并两个有序数组</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/merge-sorted-array/submissions/" target="_blank" rel="noopener">88. 合并两个有序数组</a></p>
<p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p>
<blockquote>
<p>说明:</p>
<p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int tail = m + n -1;</span><br><span class="line">        int nums1tail = m-1;</span><br><span class="line">        int nums2tail = n-1;</span><br><span class="line">        while(nums1tail &gt;= 0 &amp;&amp; nums2tail &gt;= 0)&#123;</span><br><span class="line">            if(nums1[nums1tail] &gt;= nums2[nums2tail])&#123;</span><br><span class="line">                nums1[tail] = nums1[nums1tail--];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                nums1[tail] = nums2[nums2tail--];</span><br><span class="line">            &#125;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        while(nums2tail &gt;= 0)</span><br><span class="line">            nums1[tail--] = nums2[nums2tail--];</span><br><span class="line">        while(nums1tail &gt;= 0)</span><br><span class="line">            nums1[tail--] = nums1[nums1tail--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与归并排序的merge代码类似，不过是从数组的末尾往前比较。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-88-合并两个有序数组/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-78-子集/">LeetCode-78-子集</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/subsets/comments/" target="_blank" rel="noopener">78. 子集</a></p>
<h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><p>对于每一项相对每个子集来说，都有放与不放两种选择。</p>
<p>创建一个放元素的递归函数，该函数的作用为将一项<strong>放</strong>和<strong>不放</strong>两种选择进行描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">        vector&lt;int&gt; item;</span><br><span class="line">        result.push_back(item);</span><br><span class="line">        </span><br><span class="line">        putitem(0, nums, item, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    //把一项放进result中。</span><br><span class="line">    void putitem(int i, vector&lt;int&gt;&amp; nums,vector&lt;int&gt; item, vector&lt;vector&lt;int&gt; &gt; &amp;result)&#123;</span><br><span class="line">        if(i == nums.size())&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //每个元素都有放和不放两种选择。</span><br><span class="line">        //放</span><br><span class="line">        item.push_back(nums[i]);</span><br><span class="line">        result.push_back(item);</span><br><span class="line">        putitem(i+1, nums, item, result);</span><br><span class="line">        //不放</span><br><span class="line">        item.pop_back();</span><br><span class="line">        putitem(i+1, nums, item, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h3><h5 id="遍历，遇到一个数就把所有子集加上该数组成新的子集，遍历完毕即是所有子集"><a href="#遍历，遇到一个数就把所有子集加上该数组成新的子集，遍历完毕即是所有子集" class="headerlink" title="遍历，遇到一个数就把所有子集加上该数组成新的子集，遍历完毕即是所有子集"></a>遍历，遇到一个数就把所有子集加上该数组成新的子集，遍历完毕即是所有子集</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">        vector&lt;int&gt; item;</span><br><span class="line">        result.push_back(item);</span><br><span class="line">        for(int i =0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            int s = result.size();</span><br><span class="line">            for(int j = 0; j &lt; s;j++)&#123;</span><br><span class="line">                result.push_back(result[j]);</span><br><span class="line">                result[j].push_back(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Solution3（位运算）："><a href="#Solution3（位运算）：" class="headerlink" title="Solution3（位运算）："></a>Solution3（位运算）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">        //子集一共有2的n次方种，使用位运算来解。</span><br><span class="line">        //每一位代表一个元素。</span><br><span class="line">        //如，100 代表[3]、011代表[2,1]。</span><br><span class="line">        int all_set = 1 &lt;&lt; nums.size();//2的n次方种；</span><br><span class="line">        for(int i = 0; i &lt; all_set; i++)&#123;</span><br><span class="line">            vector&lt;int&gt; item;</span><br><span class="line">            for(int j = 0; j &lt; nums.size(); j++)&#123;</span><br><span class="line">                //如果i的第j位为1，说明，有这一位所代表的元素。</span><br><span class="line">                // （1 &lt;&lt; j）第j位为1，其他位为0。</span><br><span class="line">                // i &amp; (1 &lt;&lt; j)， i 这个数中，j这一位是不是为1。（i中是否包含这个元素）</span><br><span class="line">                if(i &amp; (1 &lt;&lt; j))&#123;</span><br><span class="line">                    item.push_back(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //将该子集放入集合中。</span><br><span class="line">            result.push_back(item);</span><br><span class="line">            item.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-78-子集/">阅读更多</a> 	
	</div>	
    
</article>     
     	




 
   <nav class="paginator">
    
        <a class="prev" href="/page/4/"> 
            <i class="iconfont icon-left"></i>
            上一页
        </a>
    

   <span class="page-number"> Page <strong>5</strong>, Total <strong>125</strong> . </span>

    
        <a class="next" href="/page/6/"> 
            下一页
            <i class="iconfont icon-right"></i>
        </a>
    
  </nav> 

          </div> 
      </div>            
    
    <a id="page-backTop">
      <span>
        <i class="iconfont icon-backtotop"></i>
      </span>
    </a> 

  
    
    <div class="search-container sildeUpMin">
        <div class="search-header">
            <input type="text" placeholder="输入你想搜索的" id="search-input" class="search-input">
            <span class="search-cancel">
                <i class="iconfont icon-cancel">
            </i></span>
        </div>
        <div id="search-result" class="search-result"></div>
    </div>
 
     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon lazyload" src="/images/placeholder.png" data-src="/images/logo.png">   
      

         
            

            <a class="mobile-menu-link" href="/">首页
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">归档
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">标签
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">关于
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">搜索 </a>                 
            
         
      
</div>        
    



     
    




<footer id="footer">	    

		
		<div class="footer-copyright">
		&copy;
				
		2017-
		
		2020		
	
		BeckoninGshy&#39;s Blog
		<br>

		Theme  <a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank">Nayo</a>
		</div>			
	 
</footer>   

    <script src="/nayo.bundle.js"></script>           
  </body>        
</html>