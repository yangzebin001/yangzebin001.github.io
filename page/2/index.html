<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  
  
  <title>  BeckoninGshy </title>

 
  
    <link rel="icon" href="/images/logo.png">
  


  <link rel="stylesheet" href="/nayo.min.css"> 
</head>  
  <body>   
    
      <header class="header">
	
  <nav class="header-inner">        

    <span class="iconfont icon-menu mobile-toggle"></span>   	

    <div class="header-logo">
      <a href="/">
        <img class="header-logo-img" src="/images/logo.png">
      </a>
    </div>

    <div class="header-menu">          
              
          
            <a class="header-menu-link" id="header-menu-home" href="/">
              <i class="iconfont icon-home">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-archives" href="/archives">
              <i class="iconfont icon-archives">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-tags" href="/tags">
              <i class="iconfont icon-tags">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-about" href="/about">
              <i class="iconfont icon-about">  
            </i></a>     
          
              
          
              <a class="header-menu-link" id="header-menu-search">
                <i class="iconfont icon-search">  
              </i></a>
          
                  
    </div>  
    
  </nav>
</header>

   

      <div class="container">       
          
          
            <div class="container-inner">  
          

          




<div class="profile sildeUpMin">
	
		<img class="avatar" src="/images/logo.png">

		<p class="author">Welcome to BeckoninGshy&#39;s Bolg</p>
		
		<div class="social">
   		      	
			<a target="_blank" class="social-links" href="https://github.com/yangzebin001">		
				<i class="iconfont icon-Github">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="">		
				<i class="iconfont icon-Facebook">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="">		
				<i class="iconfont icon-Instagram">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="https://music.163.com/#/user/home?id=117201882">		
				<i class="iconfont icon-Neteasemusic">
			</i></a>	
	    
    	</div>		
</div>


    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/12/26/LeetCode-394-字符串解码/">LeetCode-394-字符串解码</a>  
	       
		 

		<div class="article-meta">
			<time>12月 26, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394. 字符串解码</a></p>
<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.</span><br><span class="line">s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.</span><br><span class="line">s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;.</span><br></pre></td></tr></table></figure>
<h3 id="Solution1（递归法）："><a href="#Solution1（递归法）：" class="headerlink" title="Solution1（递归法）："></a>Solution1（递归法）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string decodeString(string s) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        string ans = &quot;&quot;;</span><br><span class="line">        while(i &lt; s.size())&#123;</span><br><span class="line">            ans += dfs(s,i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    string dfs(string s, int &amp;i)&#123;</span><br><span class="line">        int num = 0,flag = 0;</span><br><span class="line">        string t = &quot;&quot;, tt = &quot;&quot;;</span><br><span class="line">        while(i &lt; s.size() &amp;&amp; s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;)&#123;</span><br><span class="line">            num = num * 10 + (s[i]-&apos;0&apos;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &lt; s.size() &amp;&amp; s[i] == &apos;[&apos;) flag = 1, i++;</span><br><span class="line">        while(i &lt; s.size() &amp;&amp; s[i] != &apos;]&apos;)&#123;</span><br><span class="line">            if(s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                t += dfs(s,i);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            t += s[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(t.size() &gt; 0)&#123;</span><br><span class="line">            tt = t;</span><br><span class="line">            while(--num &gt; 0) tt += t;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &lt; s.size() &amp;&amp; s[i] == &apos;]&apos;) i++;</span><br><span class="line">        return tt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>很正常的思路就是递归，每遇到数字就递归到下一层，等下一层的结束后，返回到当前层接着处理，在遇到’]’或者走到最后时，结束这一层的处理。</p>
<h3 id="Solution2（栈）："><a href="#Solution2（栈）：" class="headerlink" title="Solution2（栈）："></a>Solution2（栈）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string decodeString(string s) &#123;</span><br><span class="line">        stack&lt;int&gt; numstk;</span><br><span class="line">        stack&lt;string&gt; strstk;</span><br><span class="line">        int num = 0;</span><br><span class="line">        string cur = &quot;&quot;; //当前层可以形成的串</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++)&#123;</span><br><span class="line">            if(s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                num = num * 10 + (s[i]-&apos;0&apos;);</span><br><span class="line">            &#125;else if(s[i] == &apos;[&apos;)&#123;</span><br><span class="line">                //模拟递归，该去下一层了。</span><br><span class="line">                numstk.push(num);</span><br><span class="line">                strstk.push(cur);</span><br><span class="line">                num = 0;</span><br><span class="line">                cur = &quot;&quot;;</span><br><span class="line">            &#125;else if(s[i] == &apos;]&apos;)&#123;</span><br><span class="line">                //这一层已经完成处理</span><br><span class="line">                for(int j = 0; j &lt; numstk.top(); j++)&#123;</span><br><span class="line">                    strstk.top() += cur;  </span><br><span class="line">                &#125;</span><br><span class="line">                //返回上一层</span><br><span class="line">                cur = strstk.top();</span><br><span class="line">                strstk.pop();</span><br><span class="line">                numstk.pop();</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                cur += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>使用栈就是为了能保留当前层的信息，这里的进入下一层的时机和递归版略有差别，在到达’[‘的时候才进入下一层，主要是为了确定num的值和保存之前正处理的串的信息，在’]’的时候要处理完当前层，并且返回上一层。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/12/26/LeetCode-394-字符串解码/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/12/02/LeetCode-117-填充每个节点的下一个右侧节点指-II/">LeetCode-117-填充每个节点的下一个右侧节点指-II</a>  
	       
		 

		<div class="article-meta">
			<time>12月 02, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117. 填充每个节点的下一个右侧节点指针 II</a></p>
<p>此题为<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. 填充每个节点的下一个右侧节点指针</a>的进阶版本。</p>
<p>给定一个二叉树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>进阶：</p>
<ul>
<li>你只能使用常量级额外空间。</li>
<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,null,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,7,#]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li>树中的节点数小于 6000</li>
<li>100 &lt;= node.val &lt;= 100</li>
</ul>
<h3 id="Solution1（迭代版）："><a href="#Solution1（迭代版）：" class="headerlink" title="Solution1（迭代版）："></a>Solution1（迭代版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        if(!root) return NULL;</span><br><span class="line">        Node* head = root;</span><br><span class="line">        Node* pre = NULL;</span><br><span class="line">        while(root)&#123;</span><br><span class="line">            Node* sub = NULL;</span><br><span class="line">            while(pre)&#123;</span><br><span class="line">                if(pre-&gt;left)&#123;</span><br><span class="line">                    if(sub) sub-&gt;next = pre-&gt;left;</span><br><span class="line">                    sub = pre-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                if(pre-&gt;right)&#123;</span><br><span class="line">                    if(sub) sub-&gt;next = pre-&gt;right;</span><br><span class="line">                    sub = pre-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = root;</span><br><span class="line">            while(root)&#123;</span><br><span class="line">                if(root-&gt;left)&#123;</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else if(root-&gt;right)&#123;</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    root = root-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>与上一题类似，先设置下父指针，找到父指针下所有存在的结点相连接，然后找到下一层的第一个结点，将其继续当做父节点。</p>
<h3 id="Solution2（递归版）："><a href="#Solution2（递归版）：" class="headerlink" title="Solution2（递归版）："></a>Solution2（递归版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        </span><br><span class="line">        if(!root || (!root-&gt;left &amp;&amp; !root-&gt;right)) return root;</span><br><span class="line">        //先把当前结点连接</span><br><span class="line">        if(root-&gt;left &amp;&amp; root-&gt;right) root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">        Node* sub = root-&gt;right ? root-&gt;right : root-&gt;left;</span><br><span class="line">        //跳过没有子节点的节点</span><br><span class="line">        Node* head = root-&gt;next;</span><br><span class="line">        while(head &amp;&amp; !head-&gt;left &amp;&amp; !head-&gt;right)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        sub-&gt;next = head ? (head-&gt;left ? head-&gt;left : head-&gt;right) : NULL;</span><br><span class="line">        connect(root-&gt;right);</span><br><span class="line">        connect(root-&gt;left);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>如果是叶子节点或空节点，则直接返回。<br>如果有两个子节点，先把两节点之间连接，把右节点当做下一层要操作的节点。<br>如果只有一个子节点，把该节点当做下一层要操作的节点。</p>
<p>将下一层的节点连接（寻找当前层的非叶子结点，将它的子节点与该结点的下一层节点连接）。</p>
<h5 id="这里注意一定要先构建右子树，再构建左子树，因为寻找父节点的兄弟节点是从左到右遍历的，如果右子树未构建好就遍历，则会出错。"><a href="#这里注意一定要先构建右子树，再构建左子树，因为寻找父节点的兄弟节点是从左到右遍历的，如果右子树未构建好就遍历，则会出错。" class="headerlink" title="这里注意一定要先构建右子树，再构建左子树，因为寻找父节点的兄弟节点是从左到右遍历的，如果右子树未构建好就遍历，则会出错。"></a>这里注意一定要先构建右子树，再构建左子树，因为寻找父节点的兄弟节点是从左到右遍历的，如果右子树未构建好就遍历，则会出错。</h5>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/12/02/LeetCode-117-填充每个节点的下一个右侧节点指-II/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/11/25/LeetCode-116-填充每个节点的下一个右侧节点指针/">LeetCode-116-填充每个节点的下一个右侧节点指针</a>  
	       
		 

		<div class="article-meta">
			<time>11月 25, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<h3 id="Solution1（递归版）："><a href="#Solution1（递归版）：" class="headerlink" title="Solution1（递归版）："></a>Solution1（递归版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        if(!root) return NULL;</span><br><span class="line">        Node* l = root-&gt;left;</span><br><span class="line">        Node* r = root-&gt;right;</span><br><span class="line">        while(l)&#123;</span><br><span class="line">            l-&gt;next = r;</span><br><span class="line">            l = l-&gt;right;</span><br><span class="line">            r = r-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        connect(root-&gt;left);</span><br><span class="line">        connect(root-&gt;right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Solution2（迭代版）："><a href="#Solution2（迭代版）：" class="headerlink" title="Solution2（迭代版）："></a>Solution2（迭代版）：</h3><p>一层一层的考虑，由于每个结点往后连需要用到其父节点的信息，所以我们可以在下一层结点的next指针连接完毕后，在往下一层移动时，父结点就可以利用已经连接好的next指针进行平滑的向右移动了。这样直到最后一层结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        if(!root) return root;</span><br><span class="line">        Node* pre = NULL;</span><br><span class="line">        Node* cur = root;</span><br><span class="line">        while(cur)&#123;</span><br><span class="line">            while(pre)&#123;</span><br><span class="line">                pre-&gt;left-&gt;next = pre-&gt;right;</span><br><span class="line">                if(pre-&gt;next)&#123;</span><br><span class="line">                    pre-&gt;right-&gt;next = pre-&gt;next-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/11/25/LeetCode-116-填充每个节点的下一个右侧节点指针/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/11/25/01背包问题详解/">01背包问题详解</a>  
	       
		 

		<div class="article-meta">
			<time>11月 25, 2019</time>
			
				<span class="iconfont icon-star"></span>
				            
						<a class="article-tag" href="/tags/DP/">DP</a>           
				            
						<a class="article-tag" href="/tags/背包问题/">背包问题</a>           
				
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		
			<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>有 N 件物品和一个容量是 V的背包。每件物品只能使用一次。</p>
<p>第 i件物品的体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积<strong>不超过</strong>背包容量，且<strong>总价值最大</strong>。<br>输出最大价值。</p>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/11/25/01背包问题详解/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/11/25/背包九讲/">背包九讲</a>  
	       
		 

		<div class="article-meta">
			<time>11月 25, 2019</time>
			
				<span class="iconfont icon-star"></span>
				            
						<a class="article-tag" href="/tags/DP/">DP</a>           
				            
						<a class="article-tag" href="/tags/背包问题/">背包问题</a>           
				
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		
			<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p>有 N 件物品和一个容量是 V的背包。每件物品只能使用一次。</p>
<p>第 i件物品的体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积<strong>不超过</strong>背包容量，且<strong>总价值最大</strong>。<br>输出最大价值。</p>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/11/25/背包九讲/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/10/26/POJ-3614-Sunscreen/">POJ-3614-Sunscreen</a>  
	       
		 

		<div class="article-meta">
			<time>10月 26, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="http://poj.org/problem?id=3614" target="_blank" rel="noopener">POJ-3614-Sunscreen</a></p>
<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>To avoid unsightly burns while tanning, each of the C (1 ≤ C ≤ 2500) cows must cover her hide with sunscreen when they’re at the beach. Cow i has a minimum and maximum SPF rating (1 ≤ minSPFi ≤ 1,000; minSPFi ≤ maxSPFi ≤ 1,000) that will work. If the SPF rating is too low, the cow suffers sunburn; if the SPF rating is too high, the cow doesn’t tan at all……..</p>
<p>The cows have a picnic basket with L (1 ≤ L ≤ 2500) bottles of sunscreen lotion, each bottle i with an SPF rating SPFi (1 ≤ SPFi ≤ 1,000). Lotion bottle i can cover coveri cows with lotion. A cow may lotion from only one bottle.</p>
<p>What is the maximum number of cows that can protect themselves while tanning given the available lotions?</p>
<h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><ul>
<li><p>Line 1: Two space-separated integers: C and L</p>
</li>
<li><p>Lines 2..C+1: Line i describes cow i’s lotion requires with two integers: minSPFi and maxSPFi</p>
</li>
<li><p>Lines C+2..C+L+1: Line i+C+1 describes a sunscreen lotion bottle i with space-separated integers: SPFi and coveri</p>
</li>
</ul>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>A single line with an integer that is the maximum number of cows that can be protected while tanning</p>
<h3 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">3 10</span><br><span class="line">2 5</span><br><span class="line">1 5</span><br><span class="line">6 2</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure>
<h3 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>有C头牛，每个牛Ci在一个给定的区间上需要涂防晒霜，有L种防晒霜，给出每个防晒霜适合的数值SPF[i]和个数cover[i]，求能最多满足牛的个数。</p>
<h3 id="贪心策略："><a href="#贪心策略：" class="headerlink" title="贪心策略："></a>贪心策略：</h3><p>按区间的开始位置递减排序，依次考虑每头牛。<br>对于每头牛，选取满足在此区间内最大的防晒霜。</p>
<h3 id="Solution1（暴力版）："><a href="#Solution1（暴力版）：" class="headerlink" title="Solution1（暴力版）："></a>Solution1（暴力版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">const int MAXN = 5000+10;</span><br><span class="line">int C,L;</span><br><span class="line">PII p[MAXN];</span><br><span class="line">PII q[MAXN];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;C,&amp;L);</span><br><span class="line">    for(int i = 0; i &lt; C; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;p[i].first,&amp;p[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p,p+C);</span><br><span class="line">    for(int i = 0; i &lt; L; i++)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">        q[i].first = a;</span><br><span class="line">        q[i].second = b;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q,q+L);</span><br><span class="line">	//从开始位置大到小考察每头牛。</span><br><span class="line">    for(int i = C-1; i &gt;= 0; i--)&#123;</span><br><span class="line">		//同样，对于每头牛，考察在该牛区间内最右的防晒霜。</span><br><span class="line">        for(int j = L-1; j &gt;= 0; j--)&#123;</span><br><span class="line">            if(q[j].second &gt; 0 &amp;&amp; q[j].first &gt;= p[i].first &amp;&amp; q[j].first &lt;= p[i].second)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                q[j].second--;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solution2（平衡树版）："><a href="#Solution2（平衡树版）：" class="headerlink" title="Solution2（平衡树版）："></a>Solution2（平衡树版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 2510;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">int N,M;</span><br><span class="line">PII cows[MAXN];</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt;M;</span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        cin &gt;&gt; cows[i].first &gt;&gt; cows[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(cows,cows+N);</span><br><span class="line">    map&lt;int,int&gt; spfa;</span><br><span class="line">    for(int i = 0; i &lt; M; i++)&#123;</span><br><span class="line">        int spa,cover;</span><br><span class="line">        cin &gt;&gt; spa &gt;&gt; cover;</span><br><span class="line">        spfa[spa] += cover;</span><br><span class="line">    &#125;</span><br><span class="line">    spfa[0] = spfa[1001] = N;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = N-1; i &gt;= 0; i--)&#123;</span><br><span class="line">        map&lt;int,int&gt;::iterator it = spfa.upper_bound(cows[i].second);</span><br><span class="line">        --it;</span><br><span class="line">        if(cows[i].first &lt;= it-&gt;first &amp;&amp; cows[i].second &gt;= it-&gt;first)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            if(-- it-&gt;second == 0) spfa.erase(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/10/26/POJ-3614-Sunscreen/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/10/26/AcWin-135-最大子序和/">AcWin-135-最大子序和</a>  
	       
		 

		<div class="article-meta">
			<time>10月 26, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://www.acwing.com/problem/content/description/137/" target="_blank" rel="noopener">AcWing 135. 最大子序和 </a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个长度为n的整数序列，从中找出一段长度不超过m的连续子序列，使得子序列中所有数的和最大。</p>
<p>输入格式<br>第一行输入两个整数n,m。</p>
<p>第二行输入n个数，代表长度为n的整数序列。</p>
<p>同一行数之间用空格隔开。</p>
<p>输出格式<br>输出一个整数，代表该序列的最大子序和。</p>
<p>数据范围<br>1≤n,m≤300000</p>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入样例：</span><br><span class="line">6 4</span><br><span class="line">1 -3 5 1 -2 3</span><br><span class="line">输出样例：</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>求一个区间长度为M的序列和可以用前缀和相减的形式来得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k = sum[i]- sum[i-M]</span><br></pre></td></tr></table></figure>
<p>而要求当前区间P内的最大值，可以找到该区间（sum[i-1]–sum[i-m]）内的最小值，用sum[i]减去该值，得到以sum[i]为终点的区间的最大值，对于每个区间，都求得一个最大值，再到这些之内取最大即为答案。</p>
<p>所以现在的问题变为：给定一个区间，如何找出给区间内的最小值。</p>
<p>如果暴力求，会使总的复杂度为O(N2)，不符合要求。<br>再看一下要解决的问题，我们想到使用单调队列，可以在线求出一组序列的最值，所以我们使用一个大小为M的队列来维护最值。</p>
<p>这样总的复杂度就为线性的了。</p>
<h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 1e6+10;</span><br><span class="line">long long a[MAXN],sum[MAXN],ans = -1e10;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    deque&lt;int&gt; q;</span><br><span class="line">    int N,M;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    for(int i = 0; i &lt; N; i++) cin &gt;&gt; a[i];</span><br><span class="line">    for(int i = 1; i &lt;= N; i++) sum[i] = sum[i-1] + a[i-1]; //前缀和</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        while(q.size() &amp;&amp; q.front() &lt; i - M) q.pop_front(); //超出窗口范围，清除</span><br><span class="line">        ans = max(ans, sum[i]-sum[q.front()]); //更新值</span><br><span class="line">        while(q.size() &amp;&amp; sum[q.back()] &gt; sum[i]) q.pop_back(); //维护单调性质</span><br><span class="line">        q.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/10/26/AcWin-135-最大子序和/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/10/09/POJ-Telephon-Lines(二分+最短路)/">POJ-Telephon-Lines(二分+最短路)</a>  
	       
		 

		<div class="article-meta">
			<time>10月 09, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="http://poj.org/problem?id=3662/" target="_blank" rel="noopener">POJ-Telephone Lines</a></p>
<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>Farmer John wants to set up a telephone line at his farm. Unfortunately, the phone company is uncooperative, so he needs to pay for some of the cables required to connect his farm to the phone system.</p>
<p>There are N (1 ≤ N ≤ 1,000) forlorn telephone poles conveniently numbered 1..N that are scattered around Farmer John’s property; no cables connect any them. A total of P (1 ≤ P ≤ 10,000) pairs of poles can be connected by a cable; the rest are too far apart.</p>
<p>The i-th cable can connect the two distinct poles Ai and Bi, with length Li (1 ≤ Li ≤ 1,000,000) units if used. The input data set never names any {Ai, Bi} pair more than once. Pole 1 is already connected to the phone system, and pole N is at the farm. Poles 1 and N need to be connected by a path of cables; the rest of the poles might be used or might not be used.</p>
<p>As it turns out, the phone company is willing to provide Farmer John with K (0 ≤ K &lt; N) lengths of cable for free. Beyond that he will have to pay a price equal to the length of the longest remaining cable he requires (each pair of poles is connected with a separate cable), or 0 if he does not need any additional cables.</p>
<p>Determine the minimum amount that Farmer John must pay.</p>
<h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><ul>
<li>Line 1: Three space-separated integers: N, P, and K</li>
<li>Lines 2..P+1: Line i+1 contains the three space-separated integers: Ai, Bi, and Li</li>
</ul>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><ul>
<li>Line 1: A single integer, the minimum amount Farmer John can pay. If it is impossible to connect the farm to the phone company, print -1.</li>
</ul>
<h3 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">5 7 1</span><br><span class="line">1 2 5</span><br><span class="line">3 1 4</span><br><span class="line">2 4 8</span><br><span class="line">3 2 3</span><br><span class="line">5 2 9</span><br><span class="line">3 4 7</span><br><span class="line">4 5 6</span><br></pre></td></tr></table></figure>
<h3 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>一电话公司要链接编号1和N的电话，中间可能需要架设多条电话线，线缆厂商可以免费给电话公司铺设k条电缆，超过k条之后，要按其余的线缆中最长的进行相应收费费用与长度相同，求电话公司需要付的最小费用。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>其实就是求无向图中，从1到N中，使最多可以“宽恕”k条最长边之后最长的边的长度尽可能小的路径。</p>
<p>单独求这样一个问题好像很复杂，我们稍加分析发现，答案一定在给定的边长、零或者不存在这样的路径这三种情况中，我们先假定一个答案，用这个答案去试探从1-N的路径有没有符合条件的。</p>
<p>具体的判断就是求一条大于答案的边长数最小的一条路径。可以使用最短路来求，松弛条件根据到当前边的超过答案的数量中选择更小的一条边。我们最后判断到达N后其数量是否超过k，就能判断这是否是一条符合条件的边。</p>
<p>然后将存放所有可能是答案的数组排序后进行二分。</p>
<p>这里求“最短路”用了两个最短路模板：</p>
<h3 id="Solution1（Dijkstra）："><a href="#Solution1（Dijkstra）：" class="headerlink" title="Solution1（Dijkstra）："></a>Solution1（Dijkstra）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Date: 2019-10-07 18:55:30</span><br><span class="line"> * @LastEditors: BeckoninGshy</span><br><span class="line"> * @LastEditTime: 2019-10-08 22:59:49</span><br><span class="line"> */</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 10000+10;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">int n,p,k;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int b,ca;</span><br><span class="line">    node(int _b,int _ca):b(_b),ca(_ca)&#123;&#125;</span><br><span class="line">    node()&#123;&#125;</span><br><span class="line">    bool operator&lt;(const node &amp;q)const&#123;</span><br><span class="line">        return ca &gt; q.ca;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; V[MAXN];</span><br><span class="line">int dis[MAXN]; //dis存超过目标值x的电话线条数。</span><br><span class="line">int vis[MAXN];</span><br><span class="line">int cost[MAXN];</span><br><span class="line">int Dijkstra(int x)&#123;</span><br><span class="line">    memset(dis,INF,sizeof(dis));</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    dis[1] = 0;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    q.push(node(1,dis[1]));</span><br><span class="line">    node temp;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        temp = q.top(); q.pop();</span><br><span class="line">        int u = temp.b;</span><br><span class="line">        if(vis[u])continue;</span><br><span class="line">        vis[u] = 1;</span><br><span class="line">        for(int i = 0; i &lt; V[u].size(); i++)&#123;</span><br><span class="line">            int v = V[u][i].b;</span><br><span class="line">            int c = V[u][i].ca;</span><br><span class="line">            c = c &gt; x ? 1 : 0;</span><br><span class="line">            //更新到当前结点的超过x的条数</span><br><span class="line">            if(!vis[v] &amp;&amp; dis[v] &gt; dis[u] + c)&#123;</span><br><span class="line">                </span><br><span class="line">                dis[v] = dis[u] + c;</span><br><span class="line">                q.push(node(v,dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //是</span><br><span class="line">    return dis[n]&lt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;p,&amp;k);</span><br><span class="line">    for(int i = 0; i &lt; p; i++)&#123;</span><br><span class="line">        int a,b,c;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        V[a].push_back(node(b,c));</span><br><span class="line">        V[b].push_back(node(a,c));</span><br><span class="line">        cost[i+1] = c; </span><br><span class="line">    &#125;</span><br><span class="line">    //按长度进行二分，根据超过该长度的个数是否超过k来确定边界。</span><br><span class="line">    sort(cost+1,cost+1+p);</span><br><span class="line">    if(!Dijkstra(cost[p]))&#123;</span><br><span class="line">        printf(&quot;-1\\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //答案有可能是0，所以从0开始。</span><br><span class="line">    int l = 0, r = p-1;</span><br><span class="line">    while(l &lt; r)&#123;</span><br><span class="line">        int mid = l+r&gt;&gt;1;</span><br><span class="line">        if(Dijkstra(cost[mid])) r = mid;</span><br><span class="line">        else l = mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,cost[l]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solution2（SPFA）："><a href="#Solution2（SPFA）：" class="headerlink" title="Solution2（SPFA）："></a>Solution2（SPFA）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Date: 2019-10-07 18:55:30</span><br><span class="line"> * @LastEditors: BeckoninGshy</span><br><span class="line"> * @LastEditTime: 2019-10-09 19:32:17</span><br><span class="line"> */</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 10000+10;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">int n,p,k;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int b,ca;</span><br><span class="line">    node(int _b,int _ca):b(_b),ca(_ca)&#123;&#125;</span><br><span class="line">    node()&#123;&#125;</span><br><span class="line">    bool operator&lt;(const node &amp;q)const&#123;</span><br><span class="line">        return ca &gt; q.ca;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; V[MAXN];</span><br><span class="line">int dis[MAXN]; //dis存超过目标值x的电话线条数。</span><br><span class="line">int vis[MAXN];</span><br><span class="line">int inq[MAXN];</span><br><span class="line">int cost[MAXN];</span><br><span class="line">int SPFA(int x)&#123;</span><br><span class="line">    memset(dis,INF,sizeof(dis));</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    memset(inq,0,sizeof(inq));</span><br><span class="line">    </span><br><span class="line">    dis[1] = 0;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    q.push(1);</span><br><span class="line">    node temp;</span><br><span class="line">    inq[1] = 1;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u = q.front(); q.pop();</span><br><span class="line">        inq[u] = false;</span><br><span class="line">        for(int i = 0; i &lt; V[u].size(); i++)&#123;</span><br><span class="line">            int v = V[u][i].b;</span><br><span class="line">            int c = V[u][i].ca;</span><br><span class="line">            c = c &gt; x ? 1 : 0;</span><br><span class="line">            //更新到当前结点的超过x的条数</span><br><span class="line">            if(dis[v] &gt; dis[u] + c)&#123;</span><br><span class="line">                </span><br><span class="line">                dis[v] = dis[u] + c;</span><br><span class="line">                if(!inq[v])&#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    inq[v] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //是</span><br><span class="line">    return dis[n]&lt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;p,&amp;k);</span><br><span class="line">    for(int i = 0; i &lt; p; i++)&#123;</span><br><span class="line">        int a,b,c;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        V[a].push_back(node(b,c));</span><br><span class="line">        V[b].push_back(node(a,c));</span><br><span class="line">        cost[i+1] = c; </span><br><span class="line">    &#125;</span><br><span class="line">    //按长度进行二分，根据超过该长度的个数是否超过k来确定边界。</span><br><span class="line">    sort(cost+1,cost+1+p);</span><br><span class="line">    if(!SPFA(cost[p]))&#123;</span><br><span class="line">        printf(&quot;-1\\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //答案有可能是0，所以从0开始。</span><br><span class="line">    int l = 0, r = p-1;</span><br><span class="line">    while(l &lt; r)&#123;</span><br><span class="line">        int mid = l+r&gt;&gt;1;</span><br><span class="line">        if(SPFA(cost[mid])) r = mid;</span><br><span class="line">        else l = mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,cost[l]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/10/09/POJ-Telephon-Lines(二分+最短路)/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/10/07/POJ-2010-Mo-Universit--Financia-Aid（优先队列或二分）/">POJ-2010-Mo-Universit--Financia-Aid（优先队列或二分）</a>  
	       
		 

		<div class="article-meta">
			<time>10月 07, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="http://poj.org/problem?id=2010" target="_blank" rel="noopener">POJ-2010-Moo University - Financial Aid</a></p>
<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>Bessie noted that although humans have many universities they can attend, cows have none. To remedy this problem, she and her fellow cows formed a new university called The University of Wisconsin-Farmside,”Moo U” for short.</p>
<p>Not wishing to admit dumber-than-average cows, the founders created an incredibly precise admission exam called the Cow Scholastic Aptitude Test (CSAT) that yields scores in the range 1..2,000,000,000.</p>
<p>Moo U is very expensive to attend; not all calves can afford it.In fact, most calves need some sort of financial aid (0 &lt;= aid &lt;=100,000). The government does not provide scholarships to calves,so all the money must come from the university’s limited fund (whose total money is F, 0 &lt;= F &lt;= 2,000,000,000).</p>
<p>Worse still, Moo U only has classrooms for an odd number N (1 &lt;= N &lt;= 19,999) of the C (N &lt;= C &lt;= 100,000) calves who have applied.Bessie wants to admit exactly N calves in order to maximize educational opportunity. She still wants the median CSAT score of the admitted calves to be as high as possible.</p>
<p>Recall that the median of a set of integers whose size is odd is the middle value when they are sorted. For example, the median of the set {3, 8, 9, 7, 5} is 7, as there are exactly two values above 7 and exactly two values below it.</p>
<p>Given the score and required financial aid for each calf that applies, the total number of calves to accept, and the total amount of money Bessie has for financial aid, determine the maximum median score Bessie can obtain by carefully admitting an optimal set of calves.</p>
<h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><ul>
<li><p>Line 1: Three space-separated integers N, C, and F</p>
</li>
<li><p>Lines 2..C+1: Two space-separated integers per line. The first is the calf’s CSAT score; the second integer is the required amount of financial aid the calf needs</p>
</li>
</ul>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><ul>
<li>Line 1: A single integer, the maximum median score that Bessie can achieve. If there is insufficient money to admit N calves,output -1.</li>
</ul>
<h3 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 5 70</span><br><span class="line">30 25</span><br><span class="line">50 21</span><br><span class="line">20 20</span><br><span class="line">5 18</span><br><span class="line">35 30</span><br></pre></td></tr></table></figure>
<h3 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35</span><br></pre></td></tr></table></figure>
<h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><p>Sample output:If Bessie accepts the calves with CSAT scores of 5, 35, and 50, the median is 35. The total financial aid required is 18 + 30 + 21 = 69 &lt;= 70. </p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>奶牛大学招收N名学生（奇数），有C名候选学生，该大学可以承受最多F的贷款，求能招收的学生中，中位数尽可能的大，如果没有满足条件的学生，输出-1。</p>
<h3 id="思路1（优先队列）："><a href="#思路1（优先队列）：" class="headerlink" title="思路1（优先队列）："></a>思路1（优先队列）：</h3><p>以学生成绩排序，然后以每个学生为中位数，寻找比他成绩低的学生中尽可能贷款少的N/2个学生，和比他成绩高的学生中尽可能贷款少的N/2个学生。结果就是满足:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aid：cur_i+lower_i+upper_i &lt;= F</span><br></pre></td></tr></table></figure>
<p>中最大的那个。</p>
<p>难度就是如何保持尽可能少的贷款。</p>
<p>这里选择维持一个长度始终为N/2长度的优先队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Date: 2019-10-06 17:36:17</span><br><span class="line"> * @LastEditors: BeckoninGshy</span><br><span class="line"> * @LastEditTime: 2019-10-07 16:04:57</span><br><span class="line"> */</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 1e5+10;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line"></span><br><span class="line">PII arr[MAXN];</span><br><span class="line">int M,N,S;</span><br><span class="line">int lowa[MAXN],upa[MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;M,&amp;N,&amp;S);</span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;arr[i].first,&amp;arr[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    int half = M/2;</span><br><span class="line">    sort(arr,arr+N);</span><br><span class="line">    memset(lowa,INF,sizeof(lowa));</span><br><span class="line">    memset(upa,INF,sizeof(upa));</span><br><span class="line">    priority_queue&lt;int&gt; q;</span><br><span class="line">    //确定以每个人为中位数， 比自己分数低的人的最小aid总和</span><br><span class="line">    int total = 0;</span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        if(q.size() == half) lowa[i] = total;</span><br><span class="line">        total += arr[i].second;</span><br><span class="line">        q.push(arr[i].second);</span><br><span class="line">        if(q.size() &gt; half)&#123;</span><br><span class="line">            total -= q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(q.size()) q.pop();</span><br><span class="line">    total = 0;</span><br><span class="line">    //确定以每个人为中位数， 比自己分数高的人的最小aid总和</span><br><span class="line">    for(int i = N-1; i &gt;= 0; i--)&#123;</span><br><span class="line">        if(q.size() == half) upa[i] = total;</span><br><span class="line">        q.push(arr[i].second);</span><br><span class="line">        total += arr[i].second;</span><br><span class="line">        if(q.size() &gt; half)&#123;</span><br><span class="line">            total -= q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = -1;</span><br><span class="line">    //从后往前寻找第一个满足条件的</span><br><span class="line">    for(int i = N-1; i &gt;= 0; i--)&#123;</span><br><span class="line">        if(arr[i].second + lowa[i] + upa[i] &lt;= S) &#123;ans = arr[i].first;break;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路2（二分）："><a href="#思路2（二分）：" class="headerlink" title="思路2（二分）："></a>思路2（二分）：</h3><p>先对成绩排序，按成绩进行二分，对是否满足是中位数和sum &lt;= F两个性质进行判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Date: 2019-10-06 17:36:17</span><br><span class="line"> * @LastEditors: BeckoninGshy</span><br><span class="line"> * @LastEditTime: 2019-10-07 17:18:16</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 1e5+10;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line"></span><br><span class="line">struct cow&#123;</span><br><span class="line">    int csat,aid;</span><br><span class="line">    bool operator &lt;(const cow &amp;q)const&#123;</span><br><span class="line">        if(csat == q.csat) return aid &lt; q.aid;</span><br><span class="line">        return csat &lt; q.csat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;cows[MAXN];</span><br><span class="line">struct n&#123;</span><br><span class="line">    int index,aid;</span><br><span class="line">    bool operator &lt;(const n &amp;q)const&#123;</span><br><span class="line">        return aid &lt; q.aid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[MAXN];</span><br><span class="line">int M,N,S,half,ans = -1;</span><br><span class="line">int aid[MAXN];</span><br><span class="line"></span><br><span class="line">int check(int x)&#123;</span><br><span class="line">    int l = 0, r = 0, sum = cows[x].aid;</span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        //在原位置的左边，且符合规定</span><br><span class="line">        if(l &lt; half &amp;&amp; node[i].index &lt; x &amp;&amp; sum + node[i].aid &lt;= S)&#123;</span><br><span class="line">            l++;</span><br><span class="line">            sum += node[i].aid;</span><br><span class="line">        //在原位置的右边，且符合规定</span><br><span class="line">        &#125;else if(r &lt; half &amp;&amp; node[i].index &gt; x &amp;&amp; sum + node[i].aid &lt;= S)&#123;</span><br><span class="line">            r++;</span><br><span class="line">            sum += node[i].aid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //都到不了half，说明无法满足小于等于S。</span><br><span class="line">    if(l &lt; half &amp;&amp; r &lt; half) return -1;</span><br><span class="line">    if(l &lt; half) return 1;</span><br><span class="line">    else if(r &lt; half) return 0;</span><br><span class="line">    //l = r = half 找到了一个符合条件的，更新答案，继续寻找后面。</span><br><span class="line">    ans = cows[x].csat;</span><br><span class="line">    return 1;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;M,&amp;N,&amp;S);</span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;cows[i].csat,&amp;cows[i].aid);</span><br><span class="line">    &#125;</span><br><span class="line">    half = M/2;</span><br><span class="line">    sort(cows,cows+N);//先按分数排序</span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        node[i].index = i; //记录位置关系</span><br><span class="line">        node[i].aid = cows[i].aid;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node,node+N); //排序是为了寻找尽可能小的aid</span><br><span class="line">    int l = 0, r = N-1;</span><br><span class="line">    while(l &lt; r)&#123;</span><br><span class="line">        int mid = l+r+1&gt;&gt;1;</span><br><span class="line">        //试探中位数。</span><br><span class="line">        int f = check(mid);</span><br><span class="line">        if(f == 1) l = mid;</span><br><span class="line">        else if(f == 0) r = mid-1;</span><br><span class="line">        else break;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/10/07/POJ-2010-Mo-Universit--Financia-Aid（优先队列或二分）/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/10/05/POJ-3579-Median(二分套二分)/">POJ-3579-Median(二分套二分)</a>  
	       
		 

		<div class="article-meta">
			<time>10月 05, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="http://poj.org/problem?id=3579" target="_blank" rel="noopener">POJ-3579-Median</a></p>
<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>Given N numbers, X1, X2, … , XN, let us calculate the difference of every pair of numbers: ∣Xi - Xj∣ (1 ≤ i ＜ j ≤ N). We can get C(N,2) differences through this work, and now your task is to find the median of the differences as quickly as you can!</p>
<p>Note in this problem, the median is defined as the (m/2)-th  smallest number if m,the amount of the differences, is even. For example, you have to find the third smallest one in the case of m = 6.</p>
<h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><p>The input consists of several test cases.<br>In each test case, N will be given in the first line. Then N numbers are given, representing X1, X2, … , XN, ( Xi ≤ 1,000,000,000  3 ≤ N ≤ 1,00,000 )</p>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>For each test case, output the median in a separate line.</p>
<h3 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 3 2 4</span><br><span class="line">3</span><br><span class="line">1 10 2</span><br></pre></td></tr></table></figure>
<h3 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定N个数，求每两个数的差的绝对值一共C(N,2)个，排序后的中位数。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>首先对于差的绝对值，我们只需要预先对数组进行排序，作后面对前面的差就不会出现负数。</p>
<p>我们考虑二分来解决该问题。答案是排序后的中位数，具有单调性，所以可以使用二分。我们先找到一个目标值，用这个目标值去判断是否为要求的中位数。</p>
<p>如何判断该数是否满足条件呢？<br>如果枚举全部这C(N,2)个数需要O(N2)的复杂度，超出了题目的要求，所以要寻找新的方案。我们已经将原数组排好序了，以每一项开始到数组最后，我们二分的寻找这里的所有的关系（i与i+1,i+2,…,N-1）中，满足：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[j] - arr[i] &lt;= x</span><br></pre></td></tr></table></figure>
<p>的一共有几项。</p>
<p>统计出项数与中位数作比较，就可以判断目标值是否满足条件。</p>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Date: 2019-10-05 13:59:05</span><br><span class="line"> * @LastEditors: BeckoninGshy</span><br><span class="line"> * @LastEditTime: 2019-10-05 14:48:00</span><br><span class="line"> */</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN = 1e5+10;</span><br><span class="line"></span><br><span class="line">int N;</span><br><span class="line">int arr[MAXN];</span><br><span class="line"></span><br><span class="line">bool check(int x)&#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    int M = N*(N-1)/2;</span><br><span class="line">    M = (M+1)/2;</span><br><span class="line">    for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        int l = i, r = N-1;</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            int mid = l + r + 1 &gt;&gt; 1;</span><br><span class="line">            if(arr[mid] - arr[i] &lt;= x) l = mid;</span><br><span class="line">            else r = mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt += l-i;</span><br><span class="line">        // arr[mid] - arr[i] &lt;= x -----&gt; arr[mid] &lt;= arr[i]+x</span><br><span class="line">        // 所以找arr[i]+x 的 upper_bound。</span><br><span class="line">        // (upper_bound(arr,arr+N,arr[i]+x)-arr)-1 长度</span><br><span class="line">        // (upper_bound(arr,arr+N,arr[i]+x)-arr)-i-1 //减去偏移量</span><br><span class="line">        // cnt += (upper_bound(arr,arr+N,arr[i]+x)-arr)-i-1;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt &gt;= M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); </span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;N)!=EOF &amp;&amp; N)&#123;</span><br><span class="line">        for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr,arr+N);</span><br><span class="line">        int l = 0, r = arr[N-1];</span><br><span class="line">        //对结果进行二分</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            int mid = l+r&gt;&gt;1;</span><br><span class="line">            // 检查该结果是否大于等于总数的一半，</span><br><span class="line">            if(check(mid)) r = mid;</span><br><span class="line">            else l = mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\\n&quot;,l);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/10/05/POJ-3579-Median(二分套二分)/">阅读更多</a> 	
	</div>	
    
</article>     
     	




 
   <nav class="paginator">
    
        <a class="prev" href="/"> 
            <i class="iconfont icon-left"></i>
            上一页
        </a>
    

   <span class="page-number"> Page <strong>2</strong>, Total <strong>125</strong> . </span>

    
        <a class="next" href="/page/3/"> 
            下一页
            <i class="iconfont icon-right"></i>
        </a>
    
  </nav> 

          </div> 
      </div>            
    
    <a id="page-backTop">
      <span>
        <i class="iconfont icon-backtotop"></i>
      </span>
    </a> 

  
    
    <div class="search-container sildeUpMin">
        <div class="search-header">
            <input type="text" placeholder="输入你想搜索的" id="search-input" class="search-input">
            <span class="search-cancel">
                <i class="iconfont icon-cancel">
            </i></span>
        </div>
        <div id="search-result" class="search-result"></div>
    </div>
 
     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon" src="/images/logo.png">   
      

         
            

            <a class="mobile-menu-link" href="/">首页
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">归档
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">标签
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">关于
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">搜索 </a>                 
            
         
      
</div>        
    



     
    




<footer id="footer">	    

		
		<div class="footer-copyright">
		&copy;
				
		2017-
		
		2020		
	
		BeckoninGshy&#39;s Blog
		<br>

		Theme  <a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank">Nayo</a>
		</div>			
	 
</footer>   

    <script src="/nayo.bundle.js"></script>           
  </body>        
</html>