<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  
  
  <title>  BeckoninGshy </title>

 
  
    <link rel="icon" href="/images/logo.png">
  


  <link rel="stylesheet" href="/nayo.min.css"> 
</head>  
  <body>   
    
      <header class="header">
	
  <nav class="header-inner">        

    <span class="iconfont icon-menu mobile-toggle"></span>   	

    <div class="header-logo">
      <a href="/">
        <img class="header-logo-img" src="/images/logo.png">
      </a>
    </div>

    <div class="header-menu">          
              
          
            <a class="header-menu-link" id="header-menu-home" href="/">
              <i class="iconfont icon-home">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-archives" href="/archives">
              <i class="iconfont icon-archives">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-tags" href="/tags">
              <i class="iconfont icon-tags">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-about" href="/about">
              <i class="iconfont icon-about">  
            </i></a>     
          
              
          
              <a class="header-menu-link" id="header-menu-search">
                <i class="iconfont icon-search">  
              </i></a>
          
                  
    </div>  
    
  </nav>
</header>

   

      <div class="container">       
          
          
            <div class="container-inner">  
          

          




<div class="profile sildeUpMin">
	
		<img class="avatar" src="/images/logo.png">

		<p class="author">Welcome to BeckoninGshy&#39;s Bolg</p>
		
		<div class="social">
   		      	
			<a target="_blank" class="social-links" href="https://github.com/yangzebin001">		
				<i class="iconfont icon-Github">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="">		
				<i class="iconfont icon-Facebook">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="">		
				<i class="iconfont icon-Instagram">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="https://music.163.com/#/user/home?id=117201882">		
				<i class="iconfont icon-Neteasemusic">
			</i></a>	
	    
    	</div>		
</div>


    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-240-搜索二维矩-II/">LeetCode-240-搜索二维矩-II</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii" target="_blank" rel="noopener">240. 搜索二维矩阵 II</a></p>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = matrix[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; matrix.size() &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == matrix[i][j]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[i][j]) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; matrix[i][j]) j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p> 从矩阵的左上角出发，如果比目标值大，向左移，如果比目标值小，向下移。出界或找到则结束。</p>
<p> 对于一列，如果比当前值小，说明不在当前列中，列减一（缩小搜索范围）。<br> 对于一行，如果比当前值小，则往前移动一个位置。</p>
<p> 经过不断缩小范围（以经过的点划矩形），就可以得知目标值是否存在矩阵中。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-240-搜索二维矩-II/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-234.回文链表/">LeetCode-234.回文链表</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/submissions/" target="_blank" rel="noopener">234.回文链表</a></p>
<h3 id="请判断一个链表是否为回文链表。"><a href="#请判断一个链表是否为回文链表。" class="headerlink" title="请判断一个链表是否为回文链表。"></a>请判断一个链表是否为回文链表。</h3><h5 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//获得链表长度</span><br><span class="line">int getListLength(ListNode* head)&#123;</span><br><span class="line">    int len = 0;</span><br><span class="line">    while(head)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        ListNode* head1 = head;</span><br><span class="line">        int listlen = getListLength(head1);</span><br><span class="line">        if(listlen &lt;= 1) return true;</span><br><span class="line">        int mid = listlen/2;</span><br><span class="line">        std::stack&lt;int&gt; s;</span><br><span class="line">        while(mid &amp;&amp; head)&#123;</span><br><span class="line">            s.push(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            mid--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(listlen%2 != 0)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(head)&#123;</span><br><span class="line">            if(head-&gt;val != s.top())&#123;</span><br><span class="line">               return false; </span><br><span class="line">            &#125;</span><br><span class="line">            s.pop();</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h5><p>借助stack。</p>
<p>将mid之前的元素值都push进stack中，然后到mid之后，将每个元素与栈顶值比较。不相等退出，相等继续下一轮。</p>
<hr>
<h5 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//获得链表长度</span><br><span class="line">int getListLength(ListNode* head)&#123;</span><br><span class="line">    int len = 0;</span><br><span class="line">    while(head)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据位置与所给链表，向后移动position步。</span><br><span class="line">ListNode* getNodeByPosition(ListNode* head,int position)&#123;</span><br><span class="line">    while(position&gt;0)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        position--;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        //存储头结点。</span><br><span class="line">        ListNode* first = head;</span><br><span class="line">        ListNode* head1 = head;</span><br><span class="line">        int listlen = getListLength(head);</span><br><span class="line">        int midposition = listlen/2;</span><br><span class="line">        //如果链表长度&lt;=1，直接返回true;</span><br><span class="line">        if(listlen &lt;= 1) return true;</span><br><span class="line">        //到达需要翻转的长度，对于偶数，为（listlen/2）+1，对于奇数，为listlen/2;</span><br><span class="line">        ListNode* mid = getNodeByPosition(head1,midposition);</span><br><span class="line">        //翻转mid之后的指针。</span><br><span class="line">        ListNode * newHead = NULL;</span><br><span class="line">        int position = listlen-midposition;</span><br><span class="line">        while(mid &amp;&amp; position)&#123;</span><br><span class="line">            ListNode* next = mid-&gt;next;</span><br><span class="line">            mid-&gt;next = newHead;</span><br><span class="line">            newHead = mid;</span><br><span class="line">            mid = next;</span><br><span class="line">            position--;</span><br><span class="line">        &#125;</span><br><span class="line">        //将翻转之后的链表与开头的链表的内容比较，向后比较listlen/2;</span><br><span class="line">        //如果是偶数，则元素都会比较到，如果是奇数，最后一个元素不会比较到。他在原来的链表中就处于中心位置，不必比较。</span><br><span class="line">        while(first &amp;&amp; newHead &amp;&amp; midposition)&#123;</span><br><span class="line">            //只要不相等，就为false;</span><br><span class="line">            if(first-&gt;val != newHead-&gt;val) return false;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            newHead = newHead-&gt;next;</span><br><span class="line">            midposition--;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>将链表的后半段翻转，从翻转位置开始与从头结点开始，依次比较（listlen/2次）。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-234.回文链表/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-235-二叉搜索树的最近公共祖先/">LeetCode-235-二叉搜索树的最近公共祖先</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">235. 二叉搜索树的最近公共祖先</a></p>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<h3 id="Solution1（递归版）："><a href="#Solution1（递归版）：" class="headerlink" title="Solution1（递归版）："></a>Solution1（递归版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)&#123;</span><br><span class="line">            return lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">        &#125;else if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)&#123;</span><br><span class="line">            return lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ONELINE版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        return ((root-&gt;val - p-&gt;val) * (root-&gt;val - q-&gt;val) &lt; 1) ? root: lowestCommonAncestor(root-&gt;val &lt; p-&gt;val ? root-&gt;right : root-&gt;left, p, q ) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(root-&gt;val - p-&gt;val) * (root-&gt;val - q-&gt;val) &lt; 1</span><br></pre></td></tr></table></figure>
<p>这段代码表示给定的两个结点是否在当前节点的两个不同的子树上，或者两个节点中有节点与当前所在节点相同。如果是，则该节点就是最近公共祖先。如果不是，说明在同一棵子树上，转移到该子树上继续递归调用。</p>
<h3 id="Solution2（迭代版）："><a href="#Solution2（迭代版）：" class="headerlink" title="Solution2（迭代版）："></a>Solution2（迭代版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        while((root-&gt;val - p-&gt;val) * (root-&gt;val - q-&gt;val) &gt; 0)&#123;</span><br><span class="line">            root = root-&gt;val &gt; p-&gt;val ? root-&gt;left : root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与上面思路类似。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-235-二叉搜索树的最近公共祖先/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-22-括号生成/">LeetCode-22-括号生成</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></p>
<h3 id="给出-n-代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。"><a href="#给出-n-代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。" class="headerlink" title="给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。"></a>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</h3><p>例如，给出 n = 3，生成结果为：</p>
<blockquote>
<p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p>
</blockquote>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        putone(&quot;&quot;,n,n,result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    void putone(string item, int left, int right, vector&lt;string&gt; &amp;result)&#123;</span><br><span class="line">       if(left == 0 &amp;&amp; right == 0)&#123;</span><br><span class="line">           result.push_back(item);</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">        //只要left还能放。</span><br><span class="line">        if(left &gt; 0)&#123;</span><br><span class="line">            putone(item+ &quot;(&quot;,left-1,right,result);</span><br><span class="line">        &#125;</span><br><span class="line">        //left放的比right多，</span><br><span class="line">        if(left &lt; right)&#123;</span><br><span class="line">            putone(item+ &quot;)&quot;,left,right-1,result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用递归+回溯来解决。</p>
<p>该题主要是要找放括号的时机。</p>
<p>首先要先放左括号。</p>
<p>第二，只要放左括号的个数比右括号多，就可以放右括号。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-22-括号生成/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-167-两数之-I--输入有序数组/">LeetCode-167-两数之-I--输入有序数组</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></p>
<p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<blockquote>
<p>说明:</p>
<p>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br>示例:</p>
<p>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p>
</blockquote>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</span><br><span class="line">        vector&lt;int&gt; a;</span><br><span class="line">        int lower = 0;</span><br><span class="line">        int higher = numbers.size()-1;</span><br><span class="line">        while(lower &lt; higher)&#123;</span><br><span class="line">            if(numbers[lower] + numbers[higher] &lt; target)&#123;</span><br><span class="line">                lower++;</span><br><span class="line">            &#125;else if(numbers[lower] + numbers[higher] &gt; target)&#123;</span><br><span class="line">                higher--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                a.push_back(lower+1);</span><br><span class="line">                a.push_back(higher+1);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用双指针技巧，一个从前扫描，一个从后扫描。符合条件退出。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-167-两数之-I--输入有序数组/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-190-颠倒二进制位/">LeetCode-190-颠倒二进制位</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">190. 颠倒二进制位</a></p>
<p>颠倒给定的 32 位无符号整数的二进制位。</p>
<blockquote>
<p>示例 1：</p>
<p>输入: 00000010100101000001111010011100</p>
<p>输出: 00111001011110000010100101000000</p>
<p>解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，<br>      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</p>
</blockquote>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    uint32_t reverseBits(uint32_t n) &#123;</span><br><span class="line">        uint32_t t = 0;</span><br><span class="line">        int i = 32;</span><br><span class="line">        while(i--)&#123;</span><br><span class="line">            t &lt;&lt;= 1;</span><br><span class="line">            //获得原数第一位的状态。</span><br><span class="line">            int a = n&amp;1;</span><br><span class="line">            //将该状态赋给该数第一位。</span><br><span class="line">            t |= a;</span><br><span class="line">            //原数右移。</span><br><span class="line">            n &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路：</p>
<p>初始化一个全位置为0的数，将原数的最后一位赋给该数的最后一位，原数右移，该数左移，如此32次。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-190-颠倒二进制位/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-191-位1的个-&- 231-2的幂/">LeetCode-191-位1的个-&amp;- 231-2的幂</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">191. 位1的个数</a></p>
<h3 id="编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为-‘1’-的个数（也被称为汉明重量）。"><a href="#编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为-‘1’-的个数（也被称为汉明重量）。" class="headerlink" title="编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。"></a>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</h3><h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingWeight(uint32_t n) &#123;</span><br><span class="line">        int cot = 0;</span><br><span class="line">        while(n)&#123;</span><br><span class="line">            cot += n&amp;1;</span><br><span class="line">            n &gt;&gt;= 1; </span><br><span class="line">        &#125;</span><br><span class="line">        return cot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>将每一位移到最后一位检查是否为1，到0为止，最后返回个数。</p>
<p>由于是无符号整型，每次都会执行32次，所以时间复杂度是O(1)。</p>
<p>Solution2（优化）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingWeight(uint32_t n) &#123;</span><br><span class="line">        int cot = 0;</span><br><span class="line">        while(n)&#123;</span><br><span class="line">            n &amp;= (n-1);</span><br><span class="line">            cot++;</span><br><span class="line">        &#125;</span><br><span class="line">        return cot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看了官方题解，这种方法是每一次将最后一个1给消除。这样顶多执行k次，k就为1的个数。这样就又优化了一点点计算。</p>
<blockquote>
<p>eg：</p>
<p>11010 &amp; 11001 = 11000</p>
<p>11000 &amp; 10111 = 10000</p>
<p>10000 &amp; 01111 = 0</p>
</blockquote>
<h3 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231. 2的幂"></a>231. 2的幂</h3><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p>
<p>有了上面的思路：</p>
<p>这道题就可以写成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPowerOfTwo(int n) &#123;</span><br><span class="line">        return n &gt; 0 &amp;&amp; !(n &amp; (n-1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2的n次方在二进制中就是只有1个位置是1，其他全是0（对于正数）。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-191-位1的个-&- 231-2的幂/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-142-环形链-II/">LeetCode-142-环形链-II</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></p>
<h3 id="给定一个链表，返回链表开始入环的第一个节点。-如果链表无环，则返回-null。"><a href="#给定一个链表，返回链表开始入环的第一个节点。-如果链表无环，则返回-null。" class="headerlink" title="给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。"></a>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</h3><h5 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        std::set&lt;ListNode*&gt; node_set;</span><br><span class="line">        while(head)&#123;</span><br><span class="line">            if(node_set.find(head) == node_set.end())&#123;</span><br><span class="line">                node_set.insert(head);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与141号问题的Solutions1一个思路，直接使用set。只不过返回的是结点不是boolean值罢了。</p>
<hr>
<h5 id="Solutions2"><a href="#Solutions2" class="headerlink" title="Solutions2:"></a>Solutions2:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode * head1 = head;</span><br><span class="line">        ListNode * slow = head;</span><br><span class="line">        ListNode * fast = head;</span><br><span class="line">        //fast走一步，slow走两步</span><br><span class="line">        while(fast)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            if(fast)&#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;else&#123; //没有环退出</span><br><span class="line">                return NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            //有环退出循环</span><br><span class="line">            if(fast == slow)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //说明有环</span><br><span class="line">        while(head1 &amp;&amp; fast)&#123;</span><br><span class="line">            if(head1 == fast)&#123;</span><br><span class="line">                return fast;</span><br><span class="line">            &#125;</span><br><span class="line">            head1 = head1-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        //不会走到这步，只是为了保证函数正常运行</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>这种方法只会使用O(1)的空间。</p>
<p>该方法的思路需要一点数学基础：</p>
<p>在一个有环的链表中，slow指针与fast指针相遇，从该相遇的位置开始，与链表的头位置开始，两者走同样的步数，如果两者相交，就走到了环的开始位置。</p>
<p><img src="http://pkjge38r4.bkt.clouddn.com/18-12-30/36603912.jpg" alt="image"></p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-142-环形链-II/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-153-寻找旋转排序数组中的最小值/">LeetCode-153-寻找旋转排序数组中的最小值</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></p>
<h5 id="假设按照升序排序的数组在预先未知的某个点上进行了旋转。"><a href="#假设按照升序排序的数组在预先未知的某个点上进行了旋转。" class="headerlink" title="假设按照升序排序的数组在预先未知的某个点上进行了旋转。"></a>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</h5><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<h5 id="请找出其中最小的元素。"><a href="#请找出其中最小的元素。" class="headerlink" title="请找出其中最小的元素。"></a>请找出其中最小的元素。</h5><p>你可以假设数组中不存在重复元素。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int lo = 0;</span><br><span class="line">        int hi = nums.size()-1;</span><br><span class="line">        while(lo &lt; hi)&#123;</span><br><span class="line">            int mid = (lo+hi)/2;</span><br><span class="line">            //如果比右边大，说明在逆序数组中。</span><br><span class="line">            //从mid位置的下一个元素继续查找。</span><br><span class="line">            if(nums[mid] &gt; nums[hi])&#123;</span><br><span class="line">                lo = mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果不比右边的大，说明已在正序数组中。</span><br><span class="line">            // 缩小右边的范围。</span><br><span class="line">            else&#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //hi == lo</span><br><span class="line">        return nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用<strong>二分法</strong>。</p>
<p>当中间元素比右边界要大时，说明在逆序数组中，这时，令lo = mid + 1。</p>
<p>否则说明在顺序数组中，不断缩小范围直到 lo = hi 时，返回。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-153-寻找旋转排序数组中的最小值/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-136-只出现一次的数字/">LeetCode-136-只出现一次的数字</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></p>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<blockquote>
<p>示例 1:</p>
<p>输入: [2,2,1]<br>输出: 1</p>
</blockquote>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int a = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            a = a ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用异或来消除相同的元素。<br>异或：<br>两数相同，异或为0；<br>两数不同，异或为1；</p>
<ul>
<li>a ^ a = 0;</li>
<li>a ^ 0 = a;</li>
</ul>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-136-只出现一次的数字/">阅读更多</a> 	
	</div>	
    
</article>     
     	




 
   <nav class="paginator">
    
        <a class="prev" href="/page/5/"> 
            <i class="iconfont icon-left"></i>
            上一页
        </a>
    

   <span class="page-number"> Page <strong>6</strong>, Total <strong>118</strong> . </span>

    
        <a class="next" href="/page/7/"> 
            下一页
            <i class="iconfont icon-right"></i>
        </a>
    
  </nav> 

          </div> 
      </div>            
    
    <a id="page-backTop">
      <span>
        <i class="iconfont icon-backtotop"></i>
      </span>
    </a> 

  
    
    <div class="search-container sildeUpMin">
        <div class="search-header">
            <input type="text" placeholder="输入你想搜索的" id="search-input" class="search-input">
            <span class="search-cancel">
                <i class="iconfont icon-cancel">
            </i></span>
        </div>
        <div id="search-result" class="search-result"></div>
    </div>
 
     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon" src="/images/logo.png">   
      

         
            

            <a class="mobile-menu-link" href="/">首页
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">归档
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">标签
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">关于
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">搜索 </a>                 
            
         
      
</div>        
    



     
    




<footer id="footer">	    

		
		<div class="footer-copyright">
		&copy;
				
		2017-
		
		2020		
	
		BeckoninGshy&#39;s Blog
		<br>

		Theme  <a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank">Nayo</a>
		</div>			
	 
</footer>   

    <script src="/nayo.bundle.js"></script>           
  </body>        
</html>