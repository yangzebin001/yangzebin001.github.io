<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  
  
  <title>  BeckoninGshy </title>

 
  
    <link rel="icon" href="/images/logo.png">
  


  <link rel="stylesheet" href="/nayo.min.css"> 
</head>  
  <body>   
    
      <header class="header">
	
  <nav class="header-inner">        

    <span class="iconfont icon-menu mobile-toggle"></span>   	

    <div class="header-logo">
      <a href="/">
        <img class="header-logo-img" src="/images/logo.png">
      </a>
    </div>

    <div class="header-menu">          
              
          
            <a class="header-menu-link" id="header-menu-home" href="/">
              <i class="iconfont icon-home">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-archives" href="/archives">
              <i class="iconfont icon-archives">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-tags" href="/tags">
              <i class="iconfont icon-tags">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-about" href="/about">
              <i class="iconfont icon-about">  
            </i></a>     
          
              
          
              <a class="header-menu-link" id="header-menu-search">
                <i class="iconfont icon-search">  
              </i></a>
          
                  
    </div>  
    
  </nav>
</header>

   

      <div class="container">       
          
          
            <div class="container-inner">  
          

          




<div class="profile sildeUpMin">
	
		<img class="avatar" src="/images/logo.png">

		<p class="author">Welcome to BeckoninGshy&#39;s Bolg</p>
		
		<div class="social">
   		      	
			<a target="_blank" class="social-links" href="https://github.com/yangzebin001">		
				<i class="iconfont icon-Github">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="">		
				<i class="iconfont icon-Facebook">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="">		
				<i class="iconfont icon-Instagram">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="https://music.163.com/#/user/home?id=117201882">		
				<i class="iconfont icon-Neteasemusic">
			</i></a>	
	    
    	</div>		
</div>


    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-59-螺旋矩-II/">LeetCode-59-螺旋矩-II</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">59. 螺旋矩阵 II</a></p>
<p>给定一个正整数 n，生成一个包含 1 到 n² 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
<p>与<a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. 螺旋矩阵</a>类似。</p>
<p>只需要依次给新数组中的相应元素赋值即可。</p>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n<span class="number">-1</span>, up = <span class="number">0</span>, down = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; up &lt; down)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i = left, j = up;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; right)&#123;</span><br><span class="line">                res[j][i] = k++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">while</span>(j &lt; down)&#123;</span><br><span class="line">                res[j][i] = k++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &gt; left)&#123;</span><br><span class="line">                res[j][i] = k++;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; up)&#123;</span><br><span class="line">                res[j][i] = k++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            up++;</span><br><span class="line">            down--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//形不成圈（单列或者单行）</span></span><br><span class="line">        <span class="keyword">if</span>(up == down)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">                res[up][left++] = k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(up &lt;= down)&#123;</span><br><span class="line">                res[up++][left] = k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-59-螺旋矩-II/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-693-交替位二进制数/">LeetCode-693-交替位二进制数</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/" target="_blank" rel="noopener">693. 交替位二进制数</a></p>
<p>给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: 5</p>
<p>输出: True</p>
<p>解释:<br>5的二进制数是: 101</p>
</blockquote>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasAlternatingBits(int n) &#123;</span><br><span class="line">        //如果是奇偶交替，则n ^ (n &gt;&gt; 1) 会使有效位全为1，</span><br><span class="line">        int temp = n ^ (n &gt;&gt; 1);</span><br><span class="line">        //有效位全为1 再加1， 得到有效位前面为1，后面全为0，再与该数与，则全部清零。</span><br><span class="line">        return (temp &amp; (temp+1)) == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-693-交替位二进制数/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-476-数字的补数/">LeetCode-476-数字的补数</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/number-complement/" target="_blank" rel="noopener">476. 数字的补数</a></p>
<p>给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。</p>
<p>注意:</p>
<ul>
<li>给定的整数保证在32位带符号整数的范围内。</li>
<li>你可以假定二进制数不包含前导零位。<br>示例 1:</li>
</ul>
<blockquote>
<p>输入: 5</p>
<p>输出: 2</p>
<p>解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。</p>
</blockquote>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findComplement(int num) &#123;</span><br><span class="line">        int cot = 0;</span><br><span class="line">        int temp = num;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            if(num == 0) break;</span><br><span class="line">            num = num &gt;&gt; 1;</span><br><span class="line">            cot++;</span><br><span class="line">        &#125; </span><br><span class="line">        int mark = 0xffffffff;</span><br><span class="line">        return ~temp ^ (mark &lt;&lt; cot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先找到该数是从哪一位开始才算有效（即不包含前面零的位置。）<br>再将该数所有位取反，<br>然后用全位置的1左移cot次，与值异或即可。</p>
<blockquote>
<p>异或：不同为一，相同为零，所以当前面的零取反后成为一后，相应位置与1异或，会恢复成为0，之后的有效位还保持不变。</p>
</blockquote>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-476-数字的补数/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-51-N皇后/">LeetCode-51-N皇后</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></p>
<p>该题为著名的n皇后问题。</p>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        vector&lt;string&gt; mark;</span><br><span class="line">        vector&lt;string&gt; queenposition;</span><br><span class="line">        vector&lt;vector&lt;string&gt; &gt; map;</span><br><span class="line">        //初始化。</span><br><span class="line">        string a = &quot;&quot;;</span><br><span class="line">        for(int i = 0; i &lt; n;i++)&#123;</span><br><span class="line">            a = a + &quot;.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            queenposition.push_back(a);</span><br><span class="line">            mark.push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dfs(mark,queenposition,map,0,n);</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">    void putOneQueen(vector&lt;string&gt; &amp;mark,int x,int y,int n)&#123;</span><br><span class="line">        static const int dx[8] = &#123;-1,-1,-1,0,0,1,1,1&#125;;</span><br><span class="line">        static const int dy[8] = &#123;-1,0,1,-1,1,-1,0,1&#125;;</span><br><span class="line">        </span><br><span class="line">        mark[x][y] = &apos;1&apos;;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; 8; i++)&#123;</span><br><span class="line">            int nx = x + dx[i],ny = y+dy[i]; </span><br><span class="line">            while(0 &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; n)&#123;</span><br><span class="line">                mark[nx][ny] = &apos;1&apos;;</span><br><span class="line">                nx += dx[i];</span><br><span class="line">                ny += dy[i];	</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    void dfs(vector&lt;string&gt; &amp;mark,vector&lt;string&gt; &amp;queenposition,vector&lt;vector&lt;string&gt; &gt; &amp;map,int col,int n)&#123;</span><br><span class="line">        //出口</span><br><span class="line">        if(col == n)&#123;</span><br><span class="line">            map.push_back(queenposition);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; n;i++)&#123;</span><br><span class="line">            if(mark[col][i] == &apos;.&apos;)&#123;//可以放皇后 </span><br><span class="line">                vector&lt;string&gt; temp_mark = mark;//记录回溯前的镜像。</span><br><span class="line">                //放皇后。 </span><br><span class="line">                queenposition[col][i] = &apos;Q&apos;;</span><br><span class="line">                putOneQueen(mark,col,i,n);</span><br><span class="line">                //递归调用。 </span><br><span class="line">                dfs(mark,queenposition,map,col+1,n);</span><br><span class="line">                //回溯 </span><br><span class="line">                mark = temp_mark;</span><br><span class="line">                queenposition[col][i] = &apos;.&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该题考查对递归与回溯算法的掌握。</p>
<p>使用一个矩阵来存储是否可以放皇后的状态。<br>每当一行放置了一个皇后后，更新其状态，并在下一行中挑选合适的位置来放置该行的皇后。</p>
<p>直到每一行都放置了皇后，保存状态，返回上一个递归过程。</p>
<p>回溯主要针对矩阵的状态和皇后放置的位置，以便利于递归返回过程中的再次使用。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-51-N皇后/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-45-跳跃游-II/">LeetCode-45-跳跃游-II</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></p>
<p>此题<a href="https://leetcode-cn.com/problems/jump-game/comments/" target="_blank" rel="noopener">55. 跳跃游戏</a>的进阶版</p>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>按照前面题的思路，依然是从后往前搜索。<strong>每次搜索能跳到当前位置的最远位置。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 选择当前能跳到当前点的最远的距离。</span><br><span class="line">        int max_index = nums.size()-1;</span><br><span class="line">        int current_max_index = max_index;</span><br><span class="line">        int step = 0;</span><br><span class="line">        //当没有到达开头位置，进行循环。</span><br><span class="line">        while(max_index &gt; 0)&#123;</span><br><span class="line">            //记录能跳到当前数组的最前面的点。</span><br><span class="line">            for(int i = max_index-1; i &gt;= 0; i--)&#123;</span><br><span class="line">                if(i + nums[i] &gt;= max_index)&#123;</span><br><span class="line">                    current_max_index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             //更新能跳的最远的点。</span><br><span class="line">            max_index = current_max_index;</span><br><span class="line">            //步数更新</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        return step;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用了两层循环，发现能ac，但是又排在了末名。</p>
<p>看了大神的代码，写出了下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size() &lt; 2)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //当前可到达的最远距离。</span><br><span class="line">        int current_max_index = nums[0];</span><br><span class="line">        //遍历各个位置中，可到达的最远距离。</span><br><span class="line">        int pre_max_max_index = nums[0];</span><br><span class="line">        int jump = 1;</span><br><span class="line">        </span><br><span class="line">        for(int i = 1; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            //更新当前可达到的最远距离。</span><br><span class="line">            if(i &gt; current_max_index)&#123;</span><br><span class="line">                jump++;</span><br><span class="line">                current_max_index = pre_max_max_index;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pre_max_max_index &lt; nums[i] + i)&#123;</span><br><span class="line">                //更新</span><br><span class="line">                pre_max_max_index = nums[i] + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return jump;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>跳到当前所能跳到的最远的位置所在的位置中</strong>。</p>
<p>记录当前位置所能到达的最远的位置。</p>
<p>如果做到了该最远位置，更新一下。继续走。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-45-跳跃游-II/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-389-找不同/">LeetCode-389-找不同</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/find-the-difference/submissions/" target="_blank" rel="noopener">389. 找不同</a></p>
<p>给定两个字符串 s 和 t，它们只包含小写字母。</p>
<p>字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。</p>
<p>请找出在 t 中被添加的字母。</p>
<blockquote>
<p>示例:</p>
<p>输入：<br>s = “abcd”<br>t = “abcde”</p>
<p>输出：<br>e</p>
<p>解释：<br>‘e’ 是那个被添加的字母。</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    char findTheDifference(string s, string t) &#123;</span><br><span class="line">        char e = 0;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++) e ^= s[i];</span><br><span class="line">        for(int i = 0; i &lt; t.size(); i++) e ^= t[i];</span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与<a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a>一样的思路，考察异或的使用。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-389-找不同/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-40-组合总-II/">LeetCode-40-组合总-II</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></p>
<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<blockquote>
<p>示例 1: </p>
<p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]</p>
<p>示例 2:</p>
<p>输入: candidates = [2,5,2,1,2], target = 5,<br>所求解集为:<br>[<br>  [1,2,2],<br>  [5]<br>]</p>
</blockquote>
<p>该题为<a href="https://leetcode-cn.com/problems/subsets-ii/submissions/" target="_blank" rel="noopener">90. 子集 II</a>的升级版</p>
<p>与上题相同的是，都要保证元素的非重复性，所以与上题使用set部分的代码是一致的。</p>
<p>区别在于在进行递归的过程中，需要随时对条件进行判断，只有满足等于target，才往result中添加。</p>
<p>并且在剪枝的时候，如果元素之和已经比target大，就没有必要进行下去了，直接退出即可。</p>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">        vector&lt;int&gt; item;</span><br><span class="line">        //去重所使用的集合</span><br><span class="line">        set&lt;vector&lt;int&gt;&gt; item_set;</span><br><span class="line">        //对nums进行排序。</span><br><span class="line">        sort(candidates.begin(),candidates.end());</span><br><span class="line">        putitem(0, candidates, result, item, item_set,target, 0);</span><br><span class="line">        return result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    void putitem(int i, vector&lt;int&gt;&amp; nums,vector&lt;vector&lt;int&gt; &gt; &amp;result, vector&lt;int&gt; &amp;item, set&lt;vector&lt;int&gt;&gt; &amp;item_set,int target, int sum)&#123;</span><br><span class="line">        if(i &gt;= nums.size() || sum &gt; target) return;</span><br><span class="line">        </span><br><span class="line">        sum += nums[i];</span><br><span class="line">        item.push_back(nums[i]);</span><br><span class="line">        //如果没有重复，就加入到最终的集合里。</span><br><span class="line">        if(sum == target &amp;&amp; item_set.find(item) == item_set.end())&#123;</span><br><span class="line">            result.push_back(item);</span><br><span class="line">            //加入去重集合中。</span><br><span class="line">            item_set.insert(item);</span><br><span class="line">        &#125;</span><br><span class="line">        putitem(i+1, nums, result, item, item_set, target, sum);</span><br><span class="line">        sum -= nums[i];</span><br><span class="line">        item.pop_back();</span><br><span class="line">        putitem(i+1, nums, result, item, item_set, target, sum);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-40-组合总-II/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-240-搜索二维矩-II/">LeetCode-240-搜索二维矩-II</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii" target="_blank" rel="noopener">240. 搜索二维矩阵 II</a></p>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = matrix[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; matrix.size() &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == matrix[i][j]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[i][j]) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; matrix[i][j]) j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p> 从矩阵的左上角出发，如果比目标值大，向左移，如果比目标值小，向下移。出界或找到则结束。</p>
<p> 对于一列，如果比当前值小，说明不在当前列中，列减一（缩小搜索范围）。<br> 对于一行，如果比当前值小，则往前移动一个位置。</p>
<p> 经过不断缩小范围（以经过的点划矩形），就可以得知目标值是否存在矩阵中。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-240-搜索二维矩-II/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-234.回文链表/">LeetCode-234.回文链表</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/submissions/" target="_blank" rel="noopener">234.回文链表</a></p>
<h3 id="请判断一个链表是否为回文链表。"><a href="#请判断一个链表是否为回文链表。" class="headerlink" title="请判断一个链表是否为回文链表。"></a>请判断一个链表是否为回文链表。</h3><h5 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//获得链表长度</span><br><span class="line">int getListLength(ListNode* head)&#123;</span><br><span class="line">    int len = 0;</span><br><span class="line">    while(head)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        ListNode* head1 = head;</span><br><span class="line">        int listlen = getListLength(head1);</span><br><span class="line">        if(listlen &lt;= 1) return true;</span><br><span class="line">        int mid = listlen/2;</span><br><span class="line">        std::stack&lt;int&gt; s;</span><br><span class="line">        while(mid &amp;&amp; head)&#123;</span><br><span class="line">            s.push(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            mid--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(listlen%2 != 0)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(head)&#123;</span><br><span class="line">            if(head-&gt;val != s.top())&#123;</span><br><span class="line">               return false; </span><br><span class="line">            &#125;</span><br><span class="line">            s.pop();</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h5><p>借助stack。</p>
<p>将mid之前的元素值都push进stack中，然后到mid之后，将每个元素与栈顶值比较。不相等退出，相等继续下一轮。</p>
<hr>
<h5 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//获得链表长度</span><br><span class="line">int getListLength(ListNode* head)&#123;</span><br><span class="line">    int len = 0;</span><br><span class="line">    while(head)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据位置与所给链表，向后移动position步。</span><br><span class="line">ListNode* getNodeByPosition(ListNode* head,int position)&#123;</span><br><span class="line">    while(position&gt;0)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        position--;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        //存储头结点。</span><br><span class="line">        ListNode* first = head;</span><br><span class="line">        ListNode* head1 = head;</span><br><span class="line">        int listlen = getListLength(head);</span><br><span class="line">        int midposition = listlen/2;</span><br><span class="line">        //如果链表长度&lt;=1，直接返回true;</span><br><span class="line">        if(listlen &lt;= 1) return true;</span><br><span class="line">        //到达需要翻转的长度，对于偶数，为（listlen/2）+1，对于奇数，为listlen/2;</span><br><span class="line">        ListNode* mid = getNodeByPosition(head1,midposition);</span><br><span class="line">        //翻转mid之后的指针。</span><br><span class="line">        ListNode * newHead = NULL;</span><br><span class="line">        int position = listlen-midposition;</span><br><span class="line">        while(mid &amp;&amp; position)&#123;</span><br><span class="line">            ListNode* next = mid-&gt;next;</span><br><span class="line">            mid-&gt;next = newHead;</span><br><span class="line">            newHead = mid;</span><br><span class="line">            mid = next;</span><br><span class="line">            position--;</span><br><span class="line">        &#125;</span><br><span class="line">        //将翻转之后的链表与开头的链表的内容比较，向后比较listlen/2;</span><br><span class="line">        //如果是偶数，则元素都会比较到，如果是奇数，最后一个元素不会比较到。他在原来的链表中就处于中心位置，不必比较。</span><br><span class="line">        while(first &amp;&amp; newHead &amp;&amp; midposition)&#123;</span><br><span class="line">            //只要不相等，就为false;</span><br><span class="line">            if(first-&gt;val != newHead-&gt;val) return false;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            newHead = newHead-&gt;next;</span><br><span class="line">            midposition--;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>将链表的后半段翻转，从翻转位置开始与从头结点开始，依次比较（listlen/2次）。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-234.回文链表/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/05/30/LeetCode-235-二叉搜索树的最近公共祖先/">LeetCode-235-二叉搜索树的最近公共祖先</a>  
	       
		 

		<div class="article-meta">
			<time>5月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">235. 二叉搜索树的最近公共祖先</a></p>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<h3 id="Solution1（递归版）："><a href="#Solution1（递归版）：" class="headerlink" title="Solution1（递归版）："></a>Solution1（递归版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)&#123;</span><br><span class="line">            return lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">        &#125;else if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)&#123;</span><br><span class="line">            return lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ONELINE版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        return ((root-&gt;val - p-&gt;val) * (root-&gt;val - q-&gt;val) &lt; 1) ? root: lowestCommonAncestor(root-&gt;val &lt; p-&gt;val ? root-&gt;right : root-&gt;left, p, q ) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(root-&gt;val - p-&gt;val) * (root-&gt;val - q-&gt;val) &lt; 1</span><br></pre></td></tr></table></figure>
<p>这段代码表示给定的两个结点是否在当前节点的两个不同的子树上，或者两个节点中有节点与当前所在节点相同。如果是，则该节点就是最近公共祖先。如果不是，说明在同一棵子树上，转移到该子树上继续递归调用。</p>
<h3 id="Solution2（迭代版）："><a href="#Solution2（迭代版）：" class="headerlink" title="Solution2（迭代版）："></a>Solution2（迭代版）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        while((root-&gt;val - p-&gt;val) * (root-&gt;val - q-&gt;val) &gt; 0)&#123;</span><br><span class="line">            root = root-&gt;val &gt; p-&gt;val ? root-&gt;left : root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与上面思路类似。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/05/30/LeetCode-235-二叉搜索树的最近公共祖先/">阅读更多</a> 	
	</div>	
    
</article>     
     	




 
   <nav class="paginator">
    
        <a class="prev" href="/page/5/"> 
            <i class="iconfont icon-left"></i>
            上一页
        </a>
    

   <span class="page-number"> Page <strong>6</strong>, Total <strong>125</strong> . </span>

    
        <a class="next" href="/page/7/"> 
            下一页
            <i class="iconfont icon-right"></i>
        </a>
    
  </nav> 

          </div> 
      </div>            
    
    <a id="page-backTop">
      <span>
        <i class="iconfont icon-backtotop"></i>
      </span>
    </a> 

  
    
    <div class="search-container sildeUpMin">
        <div class="search-header">
            <input type="text" placeholder="输入你想搜索的" id="search-input" class="search-input">
            <span class="search-cancel">
                <i class="iconfont icon-cancel">
            </i></span>
        </div>
        <div id="search-result" class="search-result"></div>
    </div>
 
     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon" src="/images/logo.png">   
      

         
            

            <a class="mobile-menu-link" href="/">首页
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">归档
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">标签
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">关于
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">搜索 </a>                 
            
         
      
</div>        
    



     
    




<footer id="footer">	    

		
		<div class="footer-copyright">
		&copy;
				
		2017-
		
		2020		
	
		BeckoninGshy&#39;s Blog
		<br>

		Theme  <a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank">Nayo</a>
		</div>			
	 
</footer>   

    <script src="/nayo.bundle.js"></script>           
  </body>        
</html>