<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  
  
  <title>  BeckoninGshy </title>

 
  
    <link rel="icon" href="/images/logo.png">
  


  <link rel="stylesheet" href="/nayo.min.css"> 
</head>  
  <body>   
    
      <header class="header">
	
  <nav class="header-inner">        

    <span class="iconfont icon-menu mobile-toggle"></span>   	

    <div class="header-logo">
      <a href="/">
        <img class="header-logo-img" src="/images/logo.png">
      </a>
    </div>

    <div class="header-menu">          
              
          
            <a class="header-menu-link" id="header-menu-home" href="/">
              <i class="iconfont icon-home">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-archives" href="/archives">
              <i class="iconfont icon-archives">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-tags" href="/tags">
              <i class="iconfont icon-tags">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-about" href="/about">
              <i class="iconfont icon-about">  
            </i></a>     
          
              
          
              <a class="header-menu-link" id="header-menu-search">
                <i class="iconfont icon-search">  
              </i></a>
          
                  
    </div>  
    
  </nav>
</header>

   

      <div class="container">       
          
          
            <div class="container-inner">  
          

          




<div class="profile sildeUpMin">
	
		<img class="avatar" src="/images/logo.png">

		<p class="author">Welcome to BeckoninGshy&#39;s Bolg</p>
		
		<div class="social">
   		      	
			<a target="_blank" class="social-links" href="https://github.com/yangzebin001">		
				<i class="iconfont icon-Github">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="">		
				<i class="iconfont icon-Facebook">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="">		
				<i class="iconfont icon-Instagram">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="https://music.163.com/#/user/home?id=117201882">		
				<i class="iconfont icon-Neteasemusic">
			</i></a>	
	    
    	</div>		
</div>


    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/08/25/POJ-1416-Shreddin-Company/">POJ-1416-Shreddin-Company</a>  
	       
		 

		<div class="article-meta">
			<time>8月 25, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="http://poj.org/problem?id=1416" target="_blank" rel="noopener">POJ-1416</a></p>
<h3 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h3><p>You have just been put in charge of developing a new shredder for the Shredding Company Although a “normal” shredder would just shred sheets of paper into little pieces so that the contents would become unreadable, this new shredder needs to have the following unusual basic characteristics.</p>
<ul>
<li><p>1.The shredder takes as input a target number and a sheet of paper with a number written on it.</p>
</li>
<li><p>2.It shreds (or cuts) the sheet into pieces each of which has one or more digits on it.</p>
</li>
<li><p>3.The sum of the numbers written on each piece is the closest possible number to the target number, without going over it.</p>
</li>
</ul>
<p>For example, suppose that the target number is 50, and the sheet of paper has the number 12346. The shredder would cut the sheet into four pieces, where one piece has 1, another has 2, the third has 34, and the fourth has 6. This is because their sum 43 (= 1 + 2 + 34 + 6) is closest to the target number 50 of all possible combinations without going over 50. For example, a combination where the pieces are 1, 23, 4, and 6 is not valid, because the sum of this combination 34 (= 1 + 23 + 4 + 6) is less than the above combination’s 43. The combination of 12, 34, and 6 is not valid either, because the sum 52 (= 12 + 34 + 6) is greater than the target number of 50.</p>
<p>Figure 1. Shredding a sheet of paper having the number 12346 when the target number is 50</p>
<p>There are also three special rules :</p>
<ul>
<li>1.If the target number is the same as the number on the sheet of paper, then the paper is not cut.</li>
</ul>
<p>For example, if the target number is 100 and the number on the sheet of paper is also 100, then the paper is not cut.</p>
<ul>
<li><p>2.If it is not possible to make any combination whose sum is less than or equal to the target number, then error is printed on a display. For example, if the target number is 1 and the number on the sheet of paper is 123, it is not possible to make any valid combination, as the combination with the smallest possible sum is 1, 2, 3. The sum for this combination is 6, which is greater than the target number, and thus error is printed.</p>
</li>
<li><p>3.If there is more than one possible combination where the sum is closest to the target number without going over it, then rejected is printed on a display. For example, if the target number is 15, and the number on the sheet of paper is 111, then there are two possible combinations with the highest possible sum of 12: (a) 1 and 11 and (b) 11 and 1; thus rejected is printed. In order to develop such a shredder, you have decided to first make a simple program that would simulate the above characteristics and rules. Given two numbers, where the first is the target number and the second is the number on the sheet of paper to be shredded, you need to figure out how the shredder should “cut up” the second number.</p>
</li>
</ul>
<h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><p>The input consists of several test cases, each on one line, as follows :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tl num1</span><br><span class="line">t2 num2</span><br><span class="line">...</span><br><span class="line">tn numn</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<p>Each test case consists of the following two positive integers, which are separated by one space : (1) the first integer (ti above) is the target number, (2) the second integer (numi above) is the number that is on the paper to be shredded.</p>
<p>Neither integers may have a 0 as the first digit, e.g., 123 is allowed but 0123 is not. You may assume that both integers are at most 6 digits in length. A line consisting of two zeros signals the end of the input.</p>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>For each test case in the input, the corresponding output takes one of the following three types :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum part1 part2 ...</span><br><span class="line">rejected</span><br><span class="line">error</span><br></pre></td></tr></table></figure>
<p>In the first type, partj and sum have the following meaning :</p>
<p>1.Each partj is a number on one piece of shredded paper. The order of partj corresponds to the order of the original digits on the sheet of paper.</p>
<p>2.sum is the sum of the numbers after being shredded, i.e., sum = part1 + part2 +…</p>
<p>Each number should be separated by one space.<br>The message error is printed if it is not possible to make any combination, and rejected if there is<br>more than one possible combination.<br>No extra characters including spaces are allowed at the beginning of each line, nor at the end of each line.</p>
<h3 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">50 12346</span><br><span class="line">376 144139</span><br><span class="line">927438 927438</span><br><span class="line">18 3312</span><br><span class="line">9 3142</span><br><span class="line">25 1299</span><br><span class="line">111 33333</span><br><span class="line">103 862150</span><br><span class="line">6 1104</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<h3 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">43 1 2 34 6</span><br><span class="line">283 144 139</span><br><span class="line">927438 927438</span><br><span class="line">18 3 3 12</span><br><span class="line">error</span><br><span class="line">21 1 2 9 9</span><br><span class="line">rejected</span><br><span class="line">103 86 2 15 0</span><br><span class="line">rejected</span><br></pre></td></tr></table></figure>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你一个有n个数的纸条，一个目标值，你可以任意剪纸条，要找出剪出的数的和最接近并且小于目标数的分解方式。</p>
<p>如果该数可以由多个分解方式组成，则输出error；如果无论如何分解都比目标值大，则输出rejected。如果分解值和目标数相同，则直接输出。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>首先对于剪纸条，无论如何剪，相邻数的位置关系并不会发生变化，只是选择元素的个数会发生变化，则可以dfs枚举所有的可能————对于某一过程，可以选择从该数开始到纸条结尾，每次都选择增加一个数，然后进行下一层的dfs，即可取得所有的分解组合。</p>
<p>接下来要保留选择数的路径，我们使用一个数的每一位来记录当前选择了几个数（N最大为6位，所以一位足够表示）。</p>
<p>然后，对于大于目标数的情况，只有当最小分解方式（每一位都被分解）之和都比目标值大，则可以直接输出rejected。该步可在dfs之前判断。</p>
<p>对于error的情况，只要在每次更新当前值的时候，也更新其相同的次数，如果大于1，则符合该情况。</p>
<p>可以小小的剪枝下：当过程中的取值比目标值大的话，就可以直接剪掉。</p>
<p>最后就是编码的时刻了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; ans;</span><br><span class="line">int num; //目标数</span><br><span class="line">int npath; //最优路径</span><br><span class="line">int curNum; //当前数，dfs中间值</span><br><span class="line">int cntNum; //当前数的出现次数。</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">将结果数组中的各值相加</span><br><span class="line">*/</span><br><span class="line">int getNum(vector&lt;vector&lt;int&gt; &gt; t, int n)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    int cont = 0;</span><br><span class="line">    for(int j = 0; j &lt; t.size(); j++)&#123;</span><br><span class="line">        int c = 0;</span><br><span class="line">        cont += t[j].size();</span><br><span class="line">        for(int k = 0; k &lt; t[j].size(); k++)&#123;</span><br><span class="line">            c = c*10 + t[j][k];</span><br><span class="line">        &#125;    </span><br><span class="line">        ans +=c;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">i:当前位置</span><br><span class="line">n：总长度</span><br><span class="line">path：记录每次分割长度</span><br><span class="line">s：总数据</span><br><span class="line">t：结果数组。</span><br><span class="line">*/</span><br><span class="line">void dfs(int i,int n,int path,char s[],vector&lt;vector&lt;int&gt; &gt; t)&#123;</span><br><span class="line">    int tt = getNum(t,n);</span><br><span class="line">    //如果过程中已经比当前数大了，直接剪掉</span><br><span class="line">    if(tt &gt; num) return;</span><br><span class="line">    </span><br><span class="line">    if(i == n)&#123;</span><br><span class="line">        //在当前一轮结束时更新离目标数最近并小于目标数的值、次数与路径。</span><br><span class="line">        if(curNum &lt; tt)&#123;</span><br><span class="line">            cntNum = 1;</span><br><span class="line">            curNum = tt;</span><br><span class="line">            npath = path;</span><br><span class="line">        &#125;else if(curNum == tt)&#123;</span><br><span class="line">            cntNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    dfs核心：</span><br><span class="line">    输入：1234</span><br><span class="line">    生成下列排列</span><br><span class="line">    1 2 3 4 </span><br><span class="line">    1 2 34 </span><br><span class="line">    1 23 4 </span><br><span class="line">    1 234 </span><br><span class="line">    12 3 4 </span><br><span class="line">    12 34 </span><br><span class="line">    123 4 </span><br><span class="line">    1234</span><br><span class="line">    */</span><br><span class="line">    vector&lt;int&gt; a;</span><br><span class="line">    for(int j = i; j &lt; n; j++)&#123;</span><br><span class="line">        a.push_back(s[j]-&apos;0&apos;);</span><br><span class="line">        t.push_back(a);</span><br><span class="line">        dfs(j+1,n,path*10+j-i+1,s,t);</span><br><span class="line">        t.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据path输出各个数。</span><br><span class="line">void show(char s[],int path)&#123;</span><br><span class="line">    vector&lt;int&gt; a;</span><br><span class="line">    while(path)&#123;</span><br><span class="line">        a.push_back(path%10);</span><br><span class="line">        path/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(a.begin(),a.end());</span><br><span class="line">    int j = 0;</span><br><span class="line">    for(int i = 0; i &lt; a.size(); i++)&#123;</span><br><span class="line">        printf(&quot; &quot;);</span><br><span class="line">        for(int k = 0; k &lt; a[i]; k++)&#123;</span><br><span class="line">            printf(&quot;%c&quot;,s[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    int a;</span><br><span class="line">    char s[1000];</span><br><span class="line">    while(scanf(&quot;%d%s&quot;,&amp;a,s) &amp;&amp; a)&#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; t;</span><br><span class="line">        num = a;</span><br><span class="line">        curNum = 0;</span><br><span class="line">        cntNum = 0;</span><br><span class="line"></span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0; i &lt; strlen(s); i++)&#123;</span><br><span class="line">            sum += s[i]-&apos;0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        //给定数的每一位相加都比目标数大</span><br><span class="line">        if(sum &gt; a)&#123;</span><br><span class="line">            printf(&quot;error\\n&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            dfs(0,strlen(s),0,s,t);</span><br><span class="line">            if(cntNum &gt; 1)&#123;</span><br><span class="line">                printf(&quot;rejected\\n&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                printf(&quot;%d&quot;,curNum);</span><br><span class="line">                show(s,npath);</span><br><span class="line">                printf(&quot;\\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/08/25/POJ-1416-Shreddin-Company/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/08/23/POJ-3083-Childre-o-th-Cand-Corn/">POJ-3083-Childre-o-th-Cand-Corn</a>  
	       
		 

		<div class="article-meta">
			<time>8月 23, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="http://poj.org/problem?id=3083" target="_blank" rel="noopener">POJ-3083</a></p>
<h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><p>The cornfield maze is a popular Halloween treat. Visitors are shown the entrance and must wander through the maze facing zombies, chainsaw-wielding psychopaths, hippies, and other terrors on their quest to find the exit.</p>
<p>One popular maze-walking strategy guarantees that the visitor will eventually find the exit. Simply choose either the right or left wall, and follow it. Of course, there’s no guarantee which strategy (left or right) will be better, and the path taken is seldom the most efficient. (It also doesn’t work on mazes with exits that are not on the edge; those types of mazes are not represented in this problem.)</p>
<p>As the proprieter of a cornfield that is about to be converted into a maze, you’d like to have a computer program that can determine the left and right-hand paths along with the shortest path so that you can figure out which layout has the best chance of confounding visitors.</p>
<h4 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h4><p>Input to this problem will begin with a line containing a single integer n indicating the number of mazes. Each maze will consist of one line with a width, w, and height, h (3 &lt;= w, h &lt;= 40), followed by h lines of w characters each that represent the maze layout. Walls are represented by hash marks (‘#’), empty space by periods (‘.’), the start by an ‘S’ and the exit by an ‘E’.</p>
<p>Exactly one ‘S’ and one ‘E’ will be present in the maze, and they will always be located along one of the maze edges and never in a corner. The maze will be fully enclosed by walls (‘#’), with the only openings being the ‘S’ and ‘E’. The ‘S’ and ‘E’ will also be separated by at least one wall (‘#’).</p>
<p>You may assume that the maze exit is always reachable from the start point.</p>
<h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><p>For each maze in the input, output on a single line the number of (not necessarily unique) squares that a person would visit (including the ‘S’ and ‘E’) for (in order) the left, right, and shortest paths, separated by a single space each. Movement from one square to another is only allowed in the horizontal or vertical direction; movement along the diagonals is not allowed.</p>
<h4 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">8 8</span><br><span class="line">########</span><br><span class="line">#......#</span><br><span class="line">#.####.#</span><br><span class="line">#.####.#</span><br><span class="line">#.####.#</span><br><span class="line">#.####.#</span><br><span class="line">#...#..#</span><br><span class="line">#S#E####</span><br><span class="line">9 5</span><br><span class="line">#########</span><br><span class="line">#.#.#.#.#</span><br><span class="line">S.......E</span><br><span class="line">#.#.#.#.#</span><br><span class="line">#########</span><br></pre></td></tr></table></figure>
<h4 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">37 5 5</span><br><span class="line">17 17 9</span><br></pre></td></tr></table></figure>
<h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有一张地图，# 是墙壁，. 是路，S是点，E是终点。（S和E在地图边缘且不在四个对角）</p>
<p>问：优先选择左边到达终点的路径长度（目前朝向的左边为优先选边，顺时针），优先选择右边到达终点的路径长度（目前朝向的右边为优先选边，逆时针），和最短的路径长度。</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>该题使用dfs（前两问）加bfs（后一问）来解答，由于有一个优先选择当前方向的左边或者右边位置，所以需要处理一个当前的朝向问题。比普通的dfs要复杂一点。但是根据定义的方向数组，只要知道了向左转就是当前的朝向减一个单位，右转为当前的朝向加一个单位，以此为起始探测方向，并且处理好顺逆时针关系就可以化解该题。</p>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN = 50;</span><br><span class="line">char m[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">int N,M;</span><br><span class="line">int sx,sy,ex,ey;</span><br><span class="line">int ans;</span><br><span class="line">int flag;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y,d;</span><br><span class="line">    node()&#123;&#125;</span><br><span class="line">    node(int _x,int _y, int _d):x(_x),y(_y),d(_d)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//从左顺时针</span><br><span class="line">int dx[] = &#123;0,-1,0,1&#125;;</span><br><span class="line">int dy[] = &#123;-1,0,1,0&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void dfs(int x, int y, int pos,int t,int s)&#123;</span><br><span class="line">    // printf(&quot;%d %d %d\\n&quot;,x,y,d);</span><br><span class="line">    if(flag) return;</span><br><span class="line">    if(x == ex &amp;&amp; y == ey)&#123;</span><br><span class="line">        flag = 1;</span><br><span class="line">        ans = max(ans,s);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //t = -1 表示顺时针，t = 1 表示逆时针</span><br><span class="line">    //pp : 当前的方向</span><br><span class="line">    //如果是左优先，就将当前方向-1开始顺时针，</span><br><span class="line">    //如果是右优先，就将当前方向+1开始逆时针。</span><br><span class="line">    for(int i = 1,pp = (pos+t+4)%4; i &lt;= 4; i++,pp = (pp-t+4)%4)&#123;</span><br><span class="line">        int nx = dx[pp] + x;</span><br><span class="line">        int ny = dy[pp] + y;</span><br><span class="line">        if(nx &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; M &amp;&amp; m[nx][ny] == &apos;.&apos;)&#123;</span><br><span class="line">            dfs(nx,ny,pp,t,s+1);</span><br><span class="line">            if(flag) return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void bfs(int x,int y)&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.push(node(x,y,1));</span><br><span class="line">    m[x][y] = &apos;#&apos;;</span><br><span class="line">    node temp;</span><br><span class="line">    while(q.size())&#123;</span><br><span class="line">        temp = q.front();q.pop();</span><br><span class="line">        if(temp.x == ex &amp;&amp; temp.y == ey)&#123;</span><br><span class="line">            ans = temp.d;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">            int nx = dx[i] + temp.x;</span><br><span class="line">            int ny = dy[i] + temp.y;</span><br><span class="line">            if(nx &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; M &amp;&amp; m[nx][ny] == &apos;.&apos;)&#123;</span><br><span class="line">                m[nx][ny] = &apos;#&apos;;</span><br><span class="line">                q.push(node(nx,ny,temp.d+1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        int pos = 0;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;M,&amp;N);</span><br><span class="line">        // memset(m,0,sizeof(m));</span><br><span class="line">        for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,m[i]);</span><br><span class="line">            for(int j = 0; j &lt; M; j++)&#123;</span><br><span class="line">                if(m[i][j] == &apos;S&apos;)&#123;</span><br><span class="line">                    sx = i,sy = j; m[i][j] = &apos;.&apos;;</span><br><span class="line">                &#125;else if(m[i][j] == &apos;E&apos;)&#123;</span><br><span class="line">                    ex = i,ey = j; m[i][j] = &apos;.&apos;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        //     for(int j = 0; j &lt; M; j++)&#123;</span><br><span class="line">        //         printf(&quot;%c&quot;,m[i][j]);</span><br><span class="line">        //     &#125;</span><br><span class="line">        //     printf(&quot;\\n&quot;);</span><br><span class="line">        // &#125;</span><br><span class="line">        /*</span><br><span class="line">        pos = 0 表示向上为初始方向</span><br><span class="line">        pos = 1 表示向右为初始方向</span><br><span class="line">        pos = 2 表示向下为初始方向</span><br><span class="line">        pos = 3 表示向左为初始方向</span><br><span class="line">        */</span><br><span class="line">        if(sx == 0) pos = 2;</span><br><span class="line">        if(sx == N-1) pos = 0;</span><br><span class="line">        if(sy == 0) pos = 1;</span><br><span class="line">        if(sy == M-1) pos = 3;</span><br><span class="line">        ans = 0;</span><br><span class="line">        flag = 0;</span><br><span class="line">        dfs(sx,sy,pos,-1,1);</span><br><span class="line">        printf(&quot;%d&quot;,ans);</span><br><span class="line">        ans = 0;</span><br><span class="line">        flag = 0;</span><br><span class="line">        dfs(sx,sy,pos,1,1);</span><br><span class="line">        printf(&quot; %d&quot;,ans);</span><br><span class="line">        ans = 0;</span><br><span class="line">        bfs(sx,sy);</span><br><span class="line">        printf(&quot; %d\\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/08/23/POJ-3083-Childre-o-th-Cand-Corn/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/08/16/LeetCode-473-火柴拼正方形/">LeetCode-473-火柴拼正方形</a>  
	       
		 

		<div class="article-meta">
			<time>8月 16, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/matchsticks-to-square/" target="_blank" rel="noopener">473. 火柴拼正方形</a></p>
<p>还记得童话《卖火柴的小女孩》吗？现在，你知道小女孩有多少根火柴，请找出一种能使用所有火柴拼成一个正方形的方法。不能折断火柴，可以把火柴连接起来，并且每根火柴都要用到。</p>
<p>输入为小女孩拥有火柴的数目，每根火柴用其长度表示。输出即为是否能用所有的火柴拼成正方形。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,2,2,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释: 能拼成一个边长为2的正方形，每边两根火柴。</p>
</blockquote>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,3,3,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释: 不能用所有火柴拼成一个正方形。</p>
</blockquote>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h5><p>给定的火柴长度和在 0 到 10^9之间。火柴数组的长度不超过15。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int part;</span><br><span class="line">    vector&lt;bool&gt; vis;</span><br><span class="line">    bool f = true;</span><br><span class="line">    bool makesquare(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++) sum += nums[i];</span><br><span class="line">        if(!sum || sum%4) return false;</span><br><span class="line">        part = sum / 4;</span><br><span class="line">        vis = vector&lt;bool&gt;(nums.size());</span><br><span class="line">        //从大到小枚举所有边</span><br><span class="line">        sort(nums.begin(),nums.end(),greater&lt;int&gt;());</span><br><span class="line">        return dfs(nums,0,0,part);</span><br><span class="line">    &#125;</span><br><span class="line">    //u:当前选了几个数，sum：当前的和，k:选到了第几层</span><br><span class="line">    bool dfs(vector&lt;int&gt; &amp;nums,int u,int cur,int length)&#123;</span><br><span class="line">        if(cur == length) u+=1,cur=0;</span><br><span class="line">        if(u == 4) return true;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            //</span><br><span class="line">            if(!vis[i] &amp;&amp; cur+nums[i] &lt;= length)&#123;</span><br><span class="line">                vis[i] = true;</span><br><span class="line">                if(dfs(nums,u,cur+nums[i],length)) return true;</span><br><span class="line">                vis[i] = false;</span><br><span class="line">                //如果当前木棒拼接失败，并且是第一个，则剪掉。</span><br><span class="line">                if(cur == 0) return false;</span><br><span class="line">                //如果当前木棒拼接失败，并且是最后一个，则剪掉。</span><br><span class="line">                if(cur + nums[i] == length) return false;</span><br><span class="line">                //如果当前木棒拼接失败，跳过所有相同长度的木棒。</span><br><span class="line">                while(i+1 &lt; nums.size() &amp;&amp; nums[i] == nums[i+1]) i++;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>剪枝策略：</p>
<ul>
<li>从小到大枚举所有边</li>
<li>每条边内部的木棒长度规定为从大到小</li>
<li>如果当前木棒拼接失败，则跳过接下来所有长度相同的木棒。</li>
<li>如果当前木棒拼接失败，且是当前边的第一个，则直接剪掉当前分支。</li>
<li>如果当前木棒拼接失败，且是当前边的最后一个，则直接剪掉当前分支。</li>
</ul>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/08/16/LeetCode-473-火柴拼正方形/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/08/16/LeetCode-216-组合总-III/">LeetCode-216-组合总-III</a>  
	       
		 

		<div class="article-meta">
			<time>8月 16, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/combination-sum-iii/" target="_blank" rel="noopener">216. 组合总和 III</a></p>
<p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p>说明：</p>
<ul>
<li><p>所有数字都是正整数。</p>
</li>
<li><p>解集不能包含重复的组合。 </p>
</li>
</ul>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br></pre></td></tr></table></figure>
<h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        dfs(0,1,0,k,n);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    //u:当前选择数的个数，a：当前可以枚举的位置，sum:当前组合数的和。</span><br><span class="line">    void dfs(int u,int a,int sum,int k,int n)&#123;</span><br><span class="line">        if(u == k &amp;&amp; sum == n)&#123;</span><br><span class="line">            ans.push_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(a == 10)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum &gt; n) return;</span><br><span class="line">        for(int i = a; i &lt; 10; i++)&#123;</span><br><span class="line">            tmp.push_back(i);</span><br><span class="line">            dfs(u+1,i+1,sum+i,k,n);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/08/16/LeetCode-216-组合总-III/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/08/16/LeetCode-47-全排-II/">LeetCode-47-全排-II</a>  
	       
		 

		<div class="article-meta">
			<time>8月 16, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></p>
<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><p>输入: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,1,2]</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="Solution1-set去重-："><a href="#Solution1-set去重-：" class="headerlink" title="Solution1(set去重)："></a>Solution1(set去重)：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">    vector&lt;bool&gt; bt;</span><br><span class="line">    int n;</span><br><span class="line">    set&lt;vector&lt;int&gt;&gt; s;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        bt = vector&lt;bool&gt;(n);</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        dfs(0,0,nums);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(int u,int start,vector&lt;int&gt; &amp;nums)&#123;</span><br><span class="line">        if(u == n)&#123;</span><br><span class="line">            if(!s.count(tmp))&#123;</span><br><span class="line">            ans.push_back(tmp);</span><br><span class="line">                s.insert(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            if(!bt[i])&#123;</span><br><span class="line">                bt[i] = true;</span><br><span class="line">                tmp.push_back(nums[i]);</span><br><span class="line">                dfs(u+1,start,nums);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">                bt[i] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>去重问题，首先想到set，比较简单粗暴的都放到set容器里，有重复就不往答案里面去。</p>
<h3 id="Solution2（排序去重）："><a href="#Solution2（排序去重）：" class="headerlink" title="Solution2（排序去重）："></a>Solution2（排序去重）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">    vector&lt;bool&gt; bt;</span><br><span class="line">    int n;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        bt = vector&lt;bool&gt;(n);</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        dfs(0,0,nums);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    bool judge(int i,vector&lt;int&gt; nums)&#123;</span><br><span class="line">        for(int j = 0; j &lt; i; j++)&#123;</span><br><span class="line">            if(nums[i] == nums[j])&#123;</span><br><span class="line">                if(!bt[j]) return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void dfs(int u,int start,vector&lt;int&gt; &amp;nums)&#123;</span><br><span class="line">        if(u == n)&#123;</span><br><span class="line">            ans.push_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            //如果所选是重复数，并且前面都选过了，才能选择当前的。</span><br><span class="line">            if(!bt[i] &amp;&amp; (i == 0 ? 1 : nums[i-1] == nums[i] ? bt[i-1] : 1))&#123;</span><br><span class="line">                bt[i] = true;</span><br><span class="line">                tmp.push_back(nums[i]);</span><br><span class="line">                dfs(u+1,start,nums);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">                bt[i] = false;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>选择不重复元素的全排列我们已经解决过了，现在我们研究如何去重的问题。</p>
<p>首先我们发现去重的原因是两个位置不同的相同的数在交换之后，整体排列不变，这样就会产生重复，为了达到去重的目的，我们人为规定，当前元素必须在所有在它之前的元素都已经被选了以后，它才能选。这样，相同元素的相对位置就固定下来，不会发生交换重复问题。所以为了方便，我们把相同的元素排在一起，这时需要先排序。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/08/16/LeetCode-47-全排-II/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/08/13/费解的开关/">费解的开关</a>  
	       
		 

		<div class="article-meta">
			<time>8月 13, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://www.acwing.com/problem/content/97/" target="_blank" rel="noopener">费解的开关</a></p>
<p>你玩过“拉灯”游戏吗？25盏灯排成一个5x5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。</p>
<p>我们用数字“1”表示一盏开着的灯，用数字“0”表示关着的灯。下面这种状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10111</span><br><span class="line">01101</span><br><span class="line">10111</span><br><span class="line">10000</span><br><span class="line">11011</span><br></pre></td></tr></table></figure>
<p>在改变了最左上角的灯的状态后将变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01111</span><br><span class="line">11101</span><br><span class="line">10111</span><br><span class="line">10000</span><br><span class="line">11011</span><br></pre></td></tr></table></figure>
<p>再改变它正中间的灯后状态将变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01111</span><br><span class="line">11001</span><br><span class="line">11001</span><br><span class="line">10100</span><br><span class="line">11011</span><br></pre></td></tr></table></figure>
<p>给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。<br>输入格式</p>
<p>第一行输入正整数n，代表数据中共有n个待解决的游戏初始状态。</p>
<p>以下若干行数据分为n组，每组数据有5行，每行5个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。<br>输出格式</p>
<p>一共输出n行数据，每行有一个小于等于6的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。</p>
<p>对于某一个游戏初始状态，若6步以内无法使所有灯变亮，则输出“-1”。</p>
<h4 id="数据范围：0-lt-n≤500"><a href="#数据范围：0-lt-n≤500" class="headerlink" title="数据范围：0&lt;n≤500"></a>数据范围：0&lt;n≤500</h4><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">00111</span><br><span class="line">01011</span><br><span class="line">10001</span><br><span class="line">11010</span><br><span class="line">11100</span><br><span class="line"></span><br><span class="line">11101</span><br><span class="line">11101</span><br><span class="line">11110</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line"></span><br><span class="line">01111</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11111</span><br></pre></td></tr></table></figure>
<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<h3 id="Solution1（TLE）："><a href="#Solution1（TLE）：" class="headerlink" title="Solution1（TLE）："></a>Solution1（TLE）：</h3><p>我们可以枚举每个开关的状态，然后查看是否全亮，每个开关两个状态（开和关），一共有25个开关，所以复杂度为O(2^25) = 33554432次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int m;</span><br><span class="line">int ans = 26;</span><br><span class="line">void flip(int k)&#123;</span><br><span class="line">    int i = k / 5,j = k % 5;</span><br><span class="line">    m ^= 1 &lt;&lt; k;</span><br><span class="line">    if(j-1 &gt;= 0) m ^= (1 &lt;&lt; (i * 5 + (j-1)));</span><br><span class="line">    if(j+1 &lt; 5) m ^= (1 &lt;&lt; (i *5 + (j+1)));</span><br><span class="line">    if(i-1 &gt;= 0) m ^= (1 &lt;&lt; ((i-1) *5 + j));</span><br><span class="line">    if(i+1 &lt; 5) m ^= (1 &lt;&lt; ((i+1) *5 + j));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int k,int d)&#123;</span><br><span class="line">    if(m == (1&lt;&lt;25)-1)&#123;</span><br><span class="line">        ans = min(ans,d);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(k &gt;= 26) return;</span><br><span class="line">    dfs(k+1,d);</span><br><span class="line">    flip(k);</span><br><span class="line">    dfs(k+1,d+1);</span><br><span class="line">    flip(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    getchar();</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        char c[10];</span><br><span class="line">        m = 0;</span><br><span class="line">        ans = 26;</span><br><span class="line">        for(int i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,c);</span><br><span class="line">            for(int j = 0; j &lt; 5; j++)&#123;</span><br><span class="line">                if(c[j] == &apos;1&apos;) m |= (1 &lt;&lt; (i*5+j));</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%s\\n&quot;,c);</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%#x\\n&quot;,m);</span><br><span class="line">        dfs(0,0);</span><br><span class="line">        if(ans &gt; 6) ans = -1;</span><br><span class="line">        printf(&quot;%d\\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h3><p>我们可以从行的角度来看：<br>如果当前行确定了，我们要让所有的开关打开，就要选把当前行中关闭的灯的下面位置的切换状态。<br>归纳到一般情况，当第一行的状态确定了，我们为了使所有的开关打开，去下一行改变状态，使得当前行的所有灯打开。如此4次后，由于到达了最后一行，这时，我们检查最后一行的灯是否全部亮，（前面4行已经全部亮了）。如果全亮，则当前的选择为一个可选方案，这时更新翻转的次数。</p>
<p>复杂度为O(n * 2^5)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line"></span><br><span class="line">char m[10][10];</span><br><span class="line">int ans = INF;</span><br><span class="line">int dx[5] = &#123;0,-1,0,1,0&#125;;</span><br><span class="line">int dy[5] = &#123;0,0,1,0,-1&#125;;</span><br><span class="line">void flip(int x,int y)&#123;</span><br><span class="line">    for(int i = 0; i &lt;5; i++)&#123;</span><br><span class="line">        int xi = x + dx[i];</span><br><span class="line">        int yi = y + dy[i];</span><br><span class="line">        if(xi &gt;= 0 &amp;&amp; xi &lt; 5 &amp;&amp; yi &gt;= 0 &amp;&amp; yi &lt; 5)&#123;</span><br><span class="line">            m[xi][yi] ^= 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    char backup[10][10];</span><br><span class="line">    int res = 0;</span><br><span class="line">    memcpy(backup,m,sizeof(m));</span><br><span class="line">    for(int i = 0; i &lt; 1 &lt;&lt; 5; i++)&#123;</span><br><span class="line">        res = 0;</span><br><span class="line">        for(int j = 0; j &lt; 5; j++)&#123;</span><br><span class="line">            if(i &gt;&gt; j &amp; 1)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                flip(0,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 0; j &lt; 4; j++)&#123;</span><br><span class="line">            for(int k = 0; k &lt; 5; k++)&#123;</span><br><span class="line">                if(m[j][k] == &apos;0&apos;)&#123;</span><br><span class="line">                    flip(j+1,k);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bool flag = true;</span><br><span class="line">        for(int j = 0; j &lt; 5; j++)&#123;</span><br><span class="line">            if(m[4][j] == &apos;0&apos;)&#123;</span><br><span class="line">                flag = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag) ans = min(ans,res);</span><br><span class="line">        memcpy(m,backup,sizeof(backup));    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    // freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    getchar();</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        ans = INF;</span><br><span class="line">        for(int i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,m[i]);</span><br><span class="line">            // printf(&quot;%s\\n&quot;,m[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">        if(ans &gt; 6) ans = -1;</span><br><span class="line">        printf(&quot;%d\\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/08/13/费解的开关/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/08/13/POJ-1062-昂贵的聘礼/">POJ-1062-昂贵的聘礼</a>  
	       
		 

		<div class="article-meta">
			<time>8月 13, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="http://poj.org/problem?id=1062" target="_blank" rel="noopener">POJ-1062</a></p>
<p>年轻的探险家来到了一个印第安部落里。在那里他和酋长的女儿相爱了，于是便向酋长去求亲。酋长要他用10000个金币作为聘礼才答应把女儿嫁给他。探险家拿不出这么多金币，便请求酋长降低要求。酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要8000金币。如果你能够弄来他的水晶球，那么只要5000金币就行了。”探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。另外他要告诉你的是，在这个部落里，等级观念十分森严。地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。他是一个外来人，所以可以不受这些限制。但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。因此你需要在考虑所有的情况以后给他提供一个最好的方案。</p>
<p>为了方便起见，我们把所有的物品从1开始进行编号，酋长的允诺也看作一个物品，并且编号总是1。每个物品都有对应的价格P，主人的地位等级L，以及一系列的替代品Ti和该替代品所对应的”优惠”Vi。如果两人地位等级差距超过了M，就不能”间接交易”。你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。</p>
<p>输入第一行是两个整数M，N（1 &lt;= N &lt;= 100），依次表示地位等级差距限制和物品的总数。接下来按照编号从小到大依次给出了N个物品的描述。每个物品的描述开头是三个非负整数P、L、X（X &lt; N），依次表示该物品的价格、主人的地位等级和替代品总数。接下来X行每行包括两个整数T和V，分别表示替代品的编号和”优惠价格”。</p>
<p>输出最少需要的金币数。</p>
<h4 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 4</span><br><span class="line">10000 3 2</span><br><span class="line">2 8000</span><br><span class="line">3 5000</span><br><span class="line">1000 2 1</span><br><span class="line">4 200</span><br><span class="line">3000 2 1</span><br><span class="line">4 200</span><br><span class="line">50 2 0</span><br></pre></td></tr></table></figure>
<h4 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5250</span><br></pre></td></tr></table></figure>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>一开始需要n金币，每个物品都有自己的价值，你可以用其他物品来抵消一部分金币（优惠价格），而用来抵消的物品也可以由其他物品来抵消该物品的一部分，如此往复。并且主人是分等级的，要确保交换物品过程中任何两个人的等级差距都不能超过M。<br>问最少需要的金币数量。</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>把每个物品看成结点，B物品可以抵消A物品的一部分,表示A有一条边指向B,边权是替代品的优惠价格，点权为该物品的价值。</p>
<p>可以求第一个物品到其他物品的最短路，松弛操作为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dis[v] &gt; dis[u] + u到v的边权</span><br></pre></td></tr></table></figure>
<p>这样求得的dis为每个顶点到起点的优惠价格，而到当前点的总花费为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dis[i] + coin[i] //优惠价格+当前物品的价格</span><br></pre></td></tr></table></figure>
<p>而题目还有一层约束条件为物品交换不能超过等级差距。<br>我们就需要检查每个点到起点的等级差了。<br>例如起点的等级为5，等级差距为3，则要枚举的区间为 3 ~ 5、4 ~ 6、5 ~ 7 ，在每个区间中，求符合等级差距的点，并求起点到该点的最短路（这里比较绕，建议多思考下）。最后答案取一个最小值即可。</p>
<h4 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 110;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">    int to,cost;</span><br><span class="line">    Edge()&#123;&#125;;</span><br><span class="line">    Edge(int _to,int _cost)&#123;</span><br><span class="line">        to = _to;</span><br><span class="line">        cost = _cost;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct qnode&#123;</span><br><span class="line">    int v,cost;</span><br><span class="line">    qnode(int _v, int _cost)&#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        cost = _cost;</span><br><span class="line">    &#125;</span><br><span class="line">    qnode()&#123;&#125;</span><br><span class="line">    bool operator &lt;(const qnode &amp;b)const&#123;</span><br><span class="line">        return cost &gt; b.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line">int coin[MAXN]; //价值多少金币 </span><br><span class="line">int dis[MAXN];	//最少优惠 </span><br><span class="line">int vis[MAXN];	</span><br><span class="line">int pos[MAXN];  //等级 </span><br><span class="line">int M,N;</span><br><span class="line">int ans;</span><br><span class="line"> void Dijkstra(int S,int N)&#123;</span><br><span class="line"> 	for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line"> 		dis[i] = S== i ? 0 : INF;</span><br><span class="line">	 &#125;</span><br><span class="line">     priority_queue&lt;qnode&gt; pq;</span><br><span class="line">     pq.push(qnode(S,dis[S]));</span><br><span class="line">     qnode temp;</span><br><span class="line">     while(pq.size())&#123;</span><br><span class="line">         temp = pq.top();pq.pop();</span><br><span class="line">         int u = temp.v;</span><br><span class="line">         if(vis[u])continue;</span><br><span class="line">         vis[u] = 1;</span><br><span class="line">         for(int i = 0; i &lt; G[u].size(); i++)&#123;</span><br><span class="line">             int v = G[u][i].to;</span><br><span class="line">             int vc = G[u][i].cost;</span><br><span class="line">             if(!vis[v] &amp;&amp; dis[v] &gt; dis[u] + vc)&#123;</span><br><span class="line">                dis[v] = dis[u] + vc;	</span><br><span class="line">                //更新答案 </span><br><span class="line">                ans = min(ans,dis[v] + coin[v]);</span><br><span class="line">                pq.push(qnode(v,dis[v]));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">//     for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">//     	ans = min(ans,dis[i] + coin[i]);		</span><br><span class="line">//	 &#125; </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">void init(int N)&#123;</span><br><span class="line">	for(int i = 0; i &lt;= N; i++)&#123;</span><br><span class="line">		G[i].clear();</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;M,&amp;N);</span><br><span class="line">    init(N);</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        int c,r,n;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;c,&amp;r,&amp;n);</span><br><span class="line">        coin[i] = c;</span><br><span class="line">        pos[i] = r;</span><br><span class="line"></span><br><span class="line">        for(int j = 1; j &lt;= n; j++)&#123;</span><br><span class="line">            int t,cost;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;t,&amp;cost);</span><br><span class="line">            G[i].push_back(Edge(t,cost));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //设最大值为起始值 </span><br><span class="line">    ans = coin[1];</span><br><span class="line">    for(int i = 0; i &lt;= M; i++)&#123;</span><br><span class="line">    	//更新每个点是否在当前区间内 </span><br><span class="line">    	for(int j = 1; j &lt;= N; j++)&#123;</span><br><span class="line">    		if(pos[j] &gt;= pos[1]-M+i &amp;&amp; pos[j] &lt;= pos[1]+i) vis[j] = 0;</span><br><span class="line">    		else vis[j] = 1;</span><br><span class="line">		&#125;</span><br><span class="line">		//求一下当前区间的最短路。 </span><br><span class="line">		Dijkstra(1,N);</span><br><span class="line">	&#125;</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/08/13/POJ-1062-昂贵的聘礼/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/08/09/POJ-2965-Th-Pilot-Brothers-refrigerator/">POJ-2965-Th-Pilot-Brothers-refrigerator</a>  
	       
		 

		<div class="article-meta">
			<time>8月 09, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="http://poj.org/problem?id=2965" target="_blank" rel="noopener">POJ-2965</a></p>
<h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有一个4X4的冰箱阵列，当你改变一个冰箱门的状态（开或关），同行同列的冰箱门也会发生改变，给定一个序列，问从全部的冰箱门打开（“-”为开、“+”为关）到给定序列需要几步，以及具体的打开方式。</p>
<h5 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-+--</span><br><span class="line">----</span><br><span class="line">----</span><br><span class="line">-+--</span><br></pre></td></tr></table></figure>
<h5 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">1 1</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">4 1</span><br><span class="line">4 3</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure>
<h3 id="Solution1（枚举）"><a href="#Solution1（枚举）" class="headerlink" title="Solution1（枚举）:"></a>Solution1（枚举）:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int m[4][4];</span><br><span class="line">int dx[16],dy[16],ans[16][2];</span><br><span class="line">int ansn = 40;</span><br><span class="line">bool isComplete()&#123;</span><br><span class="line">    for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; 4; j++)&#123;</span><br><span class="line">            if(m[i][j] == 1) return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void flip(int i, int j)&#123;</span><br><span class="line">    for(int k = 0; k &lt; 4; k++)&#123;</span><br><span class="line">        m[k][j] = !m[k][j];</span><br><span class="line">        m[i][k] = !m[i][k];</span><br><span class="line">    &#125;</span><br><span class="line">    //m[i][j]被翻转了两次，再翻转抵消一次。</span><br><span class="line">    m[i][j] = !m[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//d:翻转的次数，s:要翻转的序号</span><br><span class="line">void dfs(int d, int s)&#123;</span><br><span class="line">    if(isComplete())&#123;</span><br><span class="line">        ansn = min(ansn,d);</span><br><span class="line">        for(int i = 0; i &lt; ansn; i++)&#123;</span><br><span class="line">            ans[i][0] = dx[i];</span><br><span class="line">            ans[i][1] = dy[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(s &gt;= 16) return;</span><br><span class="line">    dfs(d,s+1);</span><br><span class="line">    flip(s/4,s%4);</span><br><span class="line">    dx[d] = s/4;</span><br><span class="line">    dy[d] = s%4;</span><br><span class="line">    dfs(d+1,s+1);</span><br><span class="line">    flip(s/4,s%4);</span><br><span class="line">    dx[d] = 0;</span><br><span class="line">    dy[d] = 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; 4; j++)&#123;</span><br><span class="line">            char c;</span><br><span class="line">            scanf(&quot;%c&quot;,&amp;c);</span><br><span class="line">            m[i][j] = c == &apos;+&apos; ? 1 : 0;</span><br><span class="line">        &#125;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(0,0);</span><br><span class="line">    printf(&quot;%d\\n&quot;,ansn);</span><br><span class="line">    for(int i = 0; i &lt; ansn; i++)&#123;</span><br><span class="line">        printf(&quot;%d %d\\n&quot;,ans[i][0]+1,ans[i][1]+1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>直接枚举所有的状态，每个冰箱门都有转换和不转换两种状态，一共有16个冰箱门，所以有2的16次方种状态。<br>在所有的序列中取一个步数最小的即可。</p>
<h3 id="Solution2（位运算压缩）："><a href="#Solution2（位运算压缩）：" class="headerlink" title="Solution2（位运算压缩）："></a>Solution2（位运算压缩）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dx[16],ans[16];</span><br><span class="line">int ansn = 40;</span><br><span class="line">int state;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void flip(int i, int j)&#123;</span><br><span class="line">    for(int k = 0; k &lt; 4; k++)&#123;</span><br><span class="line">        state = state ^ (1&lt;&lt; (i*4+k));</span><br><span class="line">        state = state ^ (1 &lt;&lt; (k*4+j));</span><br><span class="line">    &#125;</span><br><span class="line">    state = state ^ (1 &lt;&lt; (i*4+j));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//d:翻转的次数，s:要翻转的序号</span><br><span class="line">void dfs(int d, int s)&#123;</span><br><span class="line">    if(!state)&#123;</span><br><span class="line">        //更新结果</span><br><span class="line">        ansn = min(ansn,d);</span><br><span class="line">        for(int i = 0; i &lt; ansn; i++)&#123;</span><br><span class="line">            ans[i] = dx[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(s &gt;= 16) return;</span><br><span class="line">    dfs(d,s+1);</span><br><span class="line">    //翻转</span><br><span class="line">    flip(s/4,s%4);</span><br><span class="line">    //保留翻转的位置</span><br><span class="line">    dx[d] = 1 &lt;&lt; s;</span><br><span class="line">    dfs(d+1,s+1);</span><br><span class="line">    //回溯</span><br><span class="line">    flip(s/4,s%4);</span><br><span class="line">    dx[d] = 0;</span><br><span class="line">&#125;</span><br><span class="line">int Pos(int a)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    while(a)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        a &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; 4; j++)&#123;</span><br><span class="line">            char c;</span><br><span class="line">            scanf(&quot;%c&quot;,&amp;c);</span><br><span class="line">            // m[i][j] = c == &apos;+&apos; ? 1 : 0;</span><br><span class="line">            if(c == &apos;+&apos;)</span><br><span class="line">                state = state | (1 &lt;&lt; (i*4+j));</span><br><span class="line">        &#125;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(0,0);</span><br><span class="line">    printf(&quot;%d\\n&quot;,ansn);</span><br><span class="line">    for(int i = 0; i &lt; ansn; i++)&#123;</span><br><span class="line">        int a  = Pos(ans[i])-1;</span><br><span class="line">        printf(&quot;%d %d\\n&quot;,a/4+1,a%4+1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>在上一题解的基础上，我们发现没有必要用二维数组来存储状态，可以使用一个16位的整数来存储，第几位二进制位表示第几个冰箱的状态。</p>
<p>记录改变冰箱的位置也同样可以使用一个16位的整数来存储。1表示该冰箱门改变了状态，所有的改变不会超过16个，使用16个整数就可以表示全部的移动的过程。</p>
<p>然后更新结果，并提取出来每一位即可。</p>
<h3 id="Solution3（找规律）："><a href="#Solution3（找规律）：" class="headerlink" title="Solution3（找规律）："></a>Solution3（找规律）：</h3><p>通过找规律我们发现：</p>
<ul>
<li><p>一个冰箱门状态改变两次等于不变。</p>
</li>
<li><p>在上一条的基础上，如果以某一冰箱门为基准，将该冰箱门所在的行列上所有的冰箱门都翻转一次，该冰箱门改变，其他冰箱门都不变。</p>
</li>
</ul>
<p>所以我们只要从结果反向推，将每个关闭的冰箱门所在的行列的冰箱门都翻转，更新每个冰箱门的改变的次数，结果状态就为当所有的关闭的冰箱门都被打开后的状态。当次数为奇数说明我们需要改变，偶数则忽略。最后遍历一遍结果数组，取出次数为奇数的冰箱门的坐标即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int record[16][16];</span><br><span class="line"></span><br><span class="line">void flip(int i, int j)&#123;</span><br><span class="line">    for(int k = 0; k &lt; 4; k++)&#123;</span><br><span class="line">        record[i][k]++;</span><br><span class="line">        record[k][j]++;</span><br><span class="line">    &#125;</span><br><span class="line">    record[i][j]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; 4; j++)&#123;</span><br><span class="line">            char c;</span><br><span class="line">            scanf(&quot;%c&quot;,&amp;c);</span><br><span class="line">            if(c == &apos;+&apos;) flip(i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for(int i = 0; i &lt;4; i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; 4; j++)&#123;</span><br><span class="line">            if(record[i][j]&amp;1) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\\n&quot;,cnt);</span><br><span class="line">    for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; 4; j++)&#123;</span><br><span class="line">            if(record[i][j]&amp;1)&#123;</span><br><span class="line">                printf(&quot;%d %d\\n&quot;,i+1,j+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/08/09/POJ-2965-Th-Pilot-Brothers-refrigerator/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/08/06/LeetCode-785-判断二分图/">LeetCode-785-判断二分图</a>  
	       
		 

		<div class="article-meta">
			<time>8月 06, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/is-graph-bipartite/" target="_blank" rel="noopener">785. 判断二分图</a></p>
<p>给定一个无向图graph，当这个图为二分图时返回true。</p>
<p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p>
<p>graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">输出: true</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;。</span><br></pre></td></tr></table></figure>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">输出: false</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br></pre></td></tr></table></figure>
<p>我们不能将节点分割成两个独立的子集。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><ul>
<li><p>graph 的长度范围为 [1, 100]。</p>
</li>
<li><p>graph[i] 中的元素的范围为 [0, graph.length - 1]。</p>
</li>
<li><p>graph[i] 不会包含 i 或者有重复的值。</p>
</li>
<li><p>图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。</p>
</li>
</ul>
<h5 id="一个裸二分图染色题。"><a href="#一个裸二分图染色题。" class="headerlink" title="一个裸二分图染色题。"></a>一个裸二分图染色题。</h5><h3 id="Solution1（DFS）："><a href="#Solution1（DFS）：" class="headerlink" title="Solution1（DFS）："></a>Solution1（DFS）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;</span><br><span class="line">        int vis[graph.size()] = &#123;false&#125;;</span><br><span class="line">        for(int i = 0; i &lt; graph.size(); i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; graph[i].size(); j++)&#123;</span><br><span class="line">                if(vis[graph[i][j]] == 0 &amp;&amp; !dfs(graph,vis,graph[i][j],1)) return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool dfs(vector&lt;vector&lt;int&gt;&gt;&amp; G,int vis[],int j, int c)&#123;</span><br><span class="line">        vis[j] = c;</span><br><span class="line">        for(int i = 0; i &lt; G[j].size(); i++)&#123;</span><br><span class="line">            if(vis[G[j][i]] == c) return false;</span><br><span class="line">            if(vis[G[j][i]] == 0 &amp;&amp; !dfs(G,vis,G[j][i],-c)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>二分染色题。<br>重点在dfs函数的编写，到达当前结点，先染色，再判断与之相连的结点的颜色是否被染过，如果没有染过，则染与当前结点不同的颜色，如果染过色且与当前结点颜色相同则表示不符合要求，颜色不同则可以直接忽略。</p>
<h3 id="Solution2（BFS）"><a href="#Solution2（BFS）" class="headerlink" title="Solution2（BFS）:"></a>Solution2（BFS）:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;</span><br><span class="line">        int vis[graph.size()] = &#123;0&#125;;</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        int curr = -1;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            if(q.size() == 0)&#123;</span><br><span class="line">                int k;</span><br><span class="line">                for(k = 0; k &lt; graph.size(); k++)&#123;</span><br><span class="line">                    if(vis[k] == 0)&#123;</span><br><span class="line">                        q.push(k);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(k == graph.size()) break;</span><br><span class="line">            &#125;</span><br><span class="line">            curr *= -1;</span><br><span class="line">            int len = q.size();</span><br><span class="line">            for(int j = 0; j &lt; len; j++)&#123;</span><br><span class="line">                int f = q.front(); q.pop();</span><br><span class="line">                vis[f] = curr;</span><br><span class="line">                for(int i = 0; i &lt; graph[f].size(); i++)&#123;</span><br><span class="line">                    if(vis[graph[f][i]] == curr) return false;</span><br><span class="line">                    if(vis[graph[f][i]] == 0)&#123;</span><br><span class="line">                        q.push(graph[f][i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>与DFS思路相同，只不过改写为BFS版。</p>
<blockquote>
<p>注意：给定的图有可能为多棵树组成的森林。所以每个树都要考虑到。</p>
</blockquote>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/08/06/LeetCode-785-判断二分图/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/08/06/LeetCode-207-课程表/">LeetCode-207-课程表</a>  
	       
		 

		<div class="article-meta">
			<time>8月 06, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">207. 课程表</a></p>
<p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h5><blockquote>
<p>输入: 2, [[1,0]] </p>
<p>输出: true</p>
<p>解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</p>
</blockquote>
<h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h5><blockquote>
<p>输入: 2, [[1,0],[0,1]]</p>
<p>输出: false</p>
<p>解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</p>
</blockquote>
<h3 id="Solution1（DFS）"><a href="#Solution1（DFS）" class="headerlink" title="Solution1（DFS）:"></a>Solution1（DFS）:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        if(numCourses &lt;= 0) return true;</span><br><span class="line">        vector&lt;int&gt; G[numCourses];</span><br><span class="line">        int vis[numCourses] = &#123;0&#125;;</span><br><span class="line">        for(int i = 0; i &lt; numCourses; i++) G[i].clear();</span><br><span class="line">        for(int i = 0; i &lt; prerequisites.size(); i++)&#123;</span><br><span class="line">            G[prerequisites[i][1]].push_back(prerequisites[i][0]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; numCourses; i++)&#123;</span><br><span class="line">            if(!vis[i])&#123;</span><br><span class="line">                if(!dfs(G,vis,i)) return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool dfs(vector&lt;int&gt; G[], int vis[],int j)&#123;</span><br><span class="line">        vis[j] = 2;</span><br><span class="line">        for(int i = 0; i &lt; G[j].size(); i++)&#123;</span><br><span class="line">            if(vis[G[j][i]] == 2) return false;</span><br><span class="line">            if(!vis[G[j][i]])&#123;</span><br><span class="line">                if(!dfs(G,vis,G[j][i])) return false;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        vis[j] = 1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h5><p>把该题看做判断一个有向图是否有环的问题。<br>进而可以看做一个染色问题：</p>
<ul>
<li><p>如果该节点没有被访问过，则是白色（用0表示）。</p>
</li>
<li><p>如果该节点正在访问，但是没有访问结束，则是灰色（用2表示）。</p>
</li>
<li><p>如果该节点已经访问，则是黑色（用1表示）。</p>
</li>
</ul>
<p>只有在DFS中维护颜色数组（我这里为vis数组）即可。</p>
<h3 id="Solution2（拓扑排序）："><a href="#Solution2（拓扑排序）：" class="headerlink" title="Solution2（拓扑排序）："></a>Solution2（拓扑排序）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        int inDegree[numCourses] = &#123;0&#125;;</span><br><span class="line">        vector&lt;int&gt; G[numCourses];</span><br><span class="line">        for(int i = 0; i &lt; prerequisites.size(); i++)&#123;</span><br><span class="line">            G[prerequisites[i][1]].push_back(prerequisites[i][0]);</span><br><span class="line">            inDegree[prerequisites[i][0]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        int inqnum = 0;</span><br><span class="line">        for(int i = 0; i &lt; numCourses; i++)&#123;</span><br><span class="line">            if(inDegree[i] == 0)&#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(q.size())&#123;</span><br><span class="line">            inqnum++;</span><br><span class="line">            int f = q.front();q.pop();</span><br><span class="line">            for(int i = 0; i &lt; G[f].size(); i++)&#123;</span><br><span class="line">                inDegree[G[f][i]]--;</span><br><span class="line">                if(inDegree[G[f][i]] == 0)&#123;</span><br><span class="line">                    q.push(G[f][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return inqnum == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>利用拓扑排序，每次将节点入度为零所在的边删去并更新边的另一端节点的入度信息，如果在多轮“删边”之后还有结点，说明有环。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/08/06/LeetCode-207-课程表/">阅读更多</a> 	
	</div>	
    
</article>     
     	




 
   <nav class="paginator">
    
        <a class="prev" href="/page/3/"> 
            <i class="iconfont icon-left"></i>
            上一页
        </a>
    

   <span class="page-number"> Page <strong>4</strong>, Total <strong>125</strong> . </span>

    
        <a class="next" href="/page/5/"> 
            下一页
            <i class="iconfont icon-right"></i>
        </a>
    
  </nav> 

          </div> 
      </div>            
    
    <a id="page-backTop">
      <span>
        <i class="iconfont icon-backtotop"></i>
      </span>
    </a> 

  
    
    <div class="search-container sildeUpMin">
        <div class="search-header">
            <input type="text" placeholder="输入你想搜索的" id="search-input" class="search-input">
            <span class="search-cancel">
                <i class="iconfont icon-cancel">
            </i></span>
        </div>
        <div id="search-result" class="search-result"></div>
    </div>
 
     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon" src="/images/logo.png">   
      

         
            

            <a class="mobile-menu-link" href="/">首页
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">归档
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">标签
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">关于
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">搜索 </a>                 
            
         
      
</div>        
    



     
    




<footer id="footer">	    

		
		<div class="footer-copyright">
		&copy;
				
		2017-
		
		2020		
	
		BeckoninGshy&#39;s Blog
		<br>

		Theme  <a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank">Nayo</a>
		</div>			
	 
</footer>   

    <script src="/nayo.bundle.js"></script>           
  </body>        
</html>