<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  
  
  <title>  BeckoninGshy </title>

 
  
    <link rel="icon" href="/images/logo.png">
  


  <link rel="stylesheet" href="/nayo.min.css"> 
</head>  
  <body>   
    
      <header class="header">
	
  <nav class="header-inner">        

    <span class="iconfont icon-menu mobile-toggle"></span>   	

    <div class="header-logo">
      <a href="/">
        <img class="header-logo-img" src="/images/logo.png">
      </a>
    </div>

    <div class="header-menu">          
              
          
            <a class="header-menu-link" id="header-menu-home" href="/">
              <i class="iconfont icon-home">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-archives" href="/archives">
              <i class="iconfont icon-archives">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-tags" href="/tags">
              <i class="iconfont icon-tags">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-about" href="/about">
              <i class="iconfont icon-about">  
            </i></a>     
          
              
          
              <a class="header-menu-link" id="header-menu-search">
                <i class="iconfont icon-search">  
              </i></a>
          
                  
    </div>  
    
  </nav>
</header>

   

      <div class="container">       
          
          
            <div class="container-inner">  
          

          




<div class="profile sildeUpMin">
	
		<img class="avatar" src="/images/logo.png">

		<p class="author">Welcome to BeckoninGshy&#39;s Bolg</p>
		
		<div class="social">
   		      	
			<a target="_blank" class="social-links" href="https://github.com/yangzebin001">		
				<i class="iconfont icon-Github">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="">		
				<i class="iconfont icon-Facebook">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="">		
				<i class="iconfont icon-Instagram">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="https://music.163.com/#/user/home?id=117201882">		
				<i class="iconfont icon-Neteasemusic">
			</i></a>	
	    
    	</div>		
</div>


    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/09/05/洛谷-P1901-发射站/">洛谷-P1901-发射站</a>  
	       
		 

		<div class="article-meta">
			<time>9月 05, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://www.luogu.org/problem/P1901" target="_blank" rel="noopener">P1901 发射站</a></p>
<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>某地有 N 个能量发射站排成一行，每个发射站 i 都有不相同的高度 Hi，并能向两边（当 然两端的只能向一边）同时发射能量值为 Vi 的能量，并且发出的能量只被两边最近的且比 它高的发射站接收。</p>
<p>显然，每个发射站发来的能量有可能被 0 或 1 或 2 个其他发射站所接受，特别是为了安 全，每个发射站接收到的能量总和是我们很关心的问题。由于数据很多，现只需要你帮忙计 算出接收最多能量的发射站接收的能量是多少。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第 1 行：一个整数 N;</p>
<p>第 2 到 N+1 行：第 i+1 行有两个整数 Hi 和 Vi，表示第 i 个人发射站的高度和发射的能量值。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出仅一行，表示接收最多能量的发射站接收到的能量值，答案不超过 longint。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4 2 </span><br><span class="line">3 5 </span><br><span class="line">6 10</span><br></pre></td></tr></table></figure>
<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<h3 id="说明-提示："><a href="#说明-提示：" class="headerlink" title="说明/提示："></a>说明/提示：</h3><p>对于 40%的数据，1&lt;=N&lt;=5000；1&lt;=Hi&lt;=100000；1&lt;=Vi&lt;=10000;</p>
<p>对于 70%的数据，1&lt;=N&lt;=100000；1&lt;=Hi&lt;=2,000,000,000；1&lt;=Vi&lt;=10000;</p>
<p>对于 100%的数据，1&lt;=N&lt;=1000000;1&lt;=Hi&lt;=2,000,000,000；1&lt;=Vi&lt;=10000。</p>
<h3 id="题目解析："><a href="#题目解析：" class="headerlink" title="题目解析："></a>题目解析：</h3><p>题目中有一句至关重要的话：发出的能量只被两边最近的且比 它高的发射站接收。</p>
<p>这句话揭露了解法：使用单调栈。</p>
<p>将题目精简下，留其核心就是要分别求每个数左边和右边碰到的第一个比它大的数的位置。</p>
<p>这是经典的单调栈可以解决的问题，所以直接写两个单调栈：一个求左边的位置，一个求右边的位置，找到位置后将其能量值存起来，在其中找一个最大值即可。</p>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Date: 2019-09-05 21:32:02</span><br><span class="line"> * @LastEditors: BeckoninGshy</span><br><span class="line"> * @LastEditTime: 2019-09-05 23:10:34</span><br><span class="line"> */</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line">const int MAXN = 1000010;</span><br><span class="line"></span><br><span class="line">LL arr[MAXN],s[MAXN],sum[MAXN],N,ans = -1;</span><br><span class="line">stack&lt;LL&gt; stk;</span><br><span class="line">int main()&#123;</span><br><span class="line">    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;N);</span><br><span class="line">    arr[0] = 2000000100;</span><br><span class="line">    arr[N+1] = 2000000100;</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;arr[i],&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    //找一个数左右两边离该数最近的并且比该数大的数的位置</span><br><span class="line">    </span><br><span class="line">    //单调递减栈。 找当前数的右边目标数</span><br><span class="line">    for(int i = 1; i &lt;= N+1; i++)&#123;</span><br><span class="line">        //找到了比当前栈顶大的数，更新值</span><br><span class="line">        while(stk.size() &amp;&amp; arr[i] &gt; arr[stk.top()])&#123;</span><br><span class="line">            sum[i] += s[stk.top()];</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    stk.pop();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //单调递减栈。 找当前数的左边目标数</span><br><span class="line">    for(int i = N; i &gt;= 0; i--)&#123;</span><br><span class="line">        //找到了比当前栈顶大的数，更新值</span><br><span class="line">        while(stk.size() &amp;&amp; arr[i] &gt; arr[stk.top()])&#123;</span><br><span class="line">            sum[i] += s[stk.top()];</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    stk.pop();</span><br><span class="line">    for(int i = 1; i &lt;= N; i++) ans = max(ans,sum[i]);</span><br><span class="line">    printf(&quot;%lld&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/09/05/洛谷-P1901-发射站/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/08/30/最小生成树相关算法学习总结/">最小生成树相关算法学习总结</a>  
	       
		 

		<div class="article-meta">
			<time>8月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>最小生成树是一副连通加权无向图中一棵权值最小的生成树。</p>
<p>在现实生活中，经常要求在类似网络的复杂关系中，既要面面俱到（任意两个结点之间都可以访问到），又要使所用成本尽可能的小。最小生成树就是解决相关问题的。</p>
<p>一个连通图可能有多个不同的最小生成树，但是其权值之和一定相等。一棵最小生成树一定有N个顶点，N-1条边。通过对生成树关注的角度不同，有相应两种不同但同样常用的算法。</p>
<h2 id="一、Prim算法："><a href="#一、Prim算法：" class="headerlink" title="一、Prim算法："></a>一、Prim算法：</h2><p>prim算法是按每一步为一棵生长中的树添加一条边，该数最开始只有一个顶点，然后会添加v-1条边。</p>
<p>每次总是选择一条与生长中的树和图中与该树相连的部分所形成的具有最小权值的横切边添加到该生成树中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int G[MAXN][MAXN];//权值矩阵</span><br><span class="line">int vis[MAXN];//记录访问</span><br><span class="line">int lowc[MAXN];//记录与树连接的边的权重</span><br><span class="line">memset(G,INF,sizeof(G));</span><br><span class="line">memset(vis,false,sizeof(vis));</span><br><span class="line">memset(lowc,INF,sizeof(lowc));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//标号0-n-1，返回最小生成树的权值，返回-1表示不连通</span><br><span class="line">int Prim(int n)&#123;</span><br><span class="line">	int ans = 0;</span><br><span class="line">	</span><br><span class="line">	//从0节点开始</span><br><span class="line">	vis[0] = true;</span><br><span class="line">	//首先更新与0结点直接相连的边的权值。</span><br><span class="line">	for(int i = 1; i &lt; n; i++) lowc[i] = G[0][i];</span><br><span class="line">    //循环n-1次</span><br><span class="line">	for(int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">		int minc = INF;</span><br><span class="line">		int p = -1;</span><br><span class="line">		//找到与当前树相连并且权值最小的边。</span><br><span class="line">		for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">			if(!vis[j]&amp;&amp;minc &gt; lowc[j])&#123;</span><br><span class="line">				minc = lowc[j];</span><br><span class="line">				p = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//不连通</span><br><span class="line">		if(minc == INF) return -1;</span><br><span class="line">		//更新树的权值</span><br><span class="line">		ans += minc;</span><br><span class="line">		vis[p] = true;</span><br><span class="line">		//继续更新新树的最小权值数组。</span><br><span class="line">		for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">			if(!vis[j]&amp;&amp;lowc[j] &gt; G[p][j])</span><br><span class="line">				lowc[j] = G[p][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、-Kruskal算法"><a href="#二、-Kruskal算法" class="headerlink" title="二、 Kruskal算法"></a>二、 Kruskal算法</h2><h4 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h4><ul>
<li>新建图G，G中拥有原图中相同的节点，但没有边。</li>
</ul>
<ul>
<li>将原图中所有的边按权值从小到大排序</li>
</ul>
<ul>
<li>从权值最小的边开始，如果这条边连接的两个结点与图G中不在同一个连通分量重，则添加这条边到图G中。</li>
</ul>
<ul>
<li>重复3，直至图G中所有的结点都在同一个连通分量中。一共需要合并n-1次。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">const int MAXN = 1010;//最大点数 </span><br><span class="line">const int MAXM = 10000;//最大边数</span><br><span class="line"> </span><br><span class="line">int F[MAXN]; //并查集使用</span><br><span class="line"></span><br><span class="line">//存储边的信息，起点，终点，权值</span><br><span class="line">struct Edge&#123;</span><br><span class="line">	int u,v,w;</span><br><span class="line">&#125;edge[MAXM]; </span><br><span class="line">int tol = 0;//边数，加边前赋值为0</span><br><span class="line"></span><br><span class="line">//加边函数</span><br><span class="line">void addedge(int u,int v,int w)&#123;</span><br><span class="line">	edge[tol].u = u;</span><br><span class="line">	edge[tol].v = v;</span><br><span class="line">	edge[tol++].w = w;</span><br><span class="line">&#125; </span><br><span class="line">//比较函数，排序用</span><br><span class="line">bool cmp(Edge a,Edge b)&#123;</span><br><span class="line">	return a.w &lt; b.w;</span><br><span class="line">&#125; </span><br><span class="line">//查找元素所属集合。路径压缩版</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	return F[x] == -1 ? x : F[x] = find(F[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//传入点数，返回最小生成树的权值，如果不连通返回-1</span><br><span class="line">int Kruskal(int n)&#123;</span><br><span class="line">	memset(F,-1,sizeof(F));</span><br><span class="line">	//先对边排序</span><br><span class="line">	sort(edge,edge+tol,cmp);</span><br><span class="line">	int cnt = 0; //计算加入的边数。</span><br><span class="line">	int ans = 0;</span><br><span class="line">	//最多循环tol次</span><br><span class="line">	for(int i = 0; i &lt; tol; i++)&#123;</span><br><span class="line">		int u = edge[i].u;</span><br><span class="line">		int v = edge[i].v;</span><br><span class="line">		int w = edge[i].w;</span><br><span class="line">		int t1 = find(u);</span><br><span class="line">		int t2 = find(v);</span><br><span class="line">		//如果属于不同集合，合并</span><br><span class="line">		if(t1 != t2)&#123;</span><br><span class="line">			ans+= w;</span><br><span class="line">			F[t1] = t2;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		//共需合并n-1次，已经完成，可提前结束</span><br><span class="line">		if(cnt == n-1) break;</span><br><span class="line">	&#125; </span><br><span class="line">	if(cnt &lt; n-1) return -1;//不连通</span><br><span class="line">	return ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于稀疏图，选择Kruskal算法较优，而对于稠密图，Prim算法会更高效。</p>
</blockquote>
<p>此外还有最大生成树，其实只要将图中的权值取反一下，就可以求得最大生成树，或者在kruskal算法，按从大到小排序之后再合并，得出来的也是最大生成树。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/08/30/最小生成树相关算法学习总结/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/08/30/POJ-3660-Co-Contest/">POJ-3660-Co-Contest</a>  
	       
		 

		<div class="article-meta">
			<time>8月 30, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="http://poj.org/problem?id=3660" target="_blank" rel="noopener">POJ-3660-Cow Contest</a></p>
<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>N (1 ≤ N ≤ 100) cows, conveniently numbered 1..N, are participating in a programming contest. As we all know, some cows code better than others. Each cow has a certain constant skill rating that is unique among the competitors.</p>
<p>The contest is conducted in several head-to-head rounds, each between two cows. If cow A has a greater skill level than cow B (1 ≤ A ≤ N; 1 ≤ B ≤ N; A ≠ B), then cow A will always beat cow B.</p>
<p>Farmer John is trying to rank the cows by skill level. Given a list the results of M (1 ≤ M ≤ 4,500) two-cow rounds, determine the number of cows whose ranks can be precisely determined from the results. It is guaranteed that the results of the rounds will not be contradictory.</p>
<h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><ul>
<li>Line 1: Two space-separated integers: N and M</li>
</ul>
<ul>
<li>Lines 2..M+1: Each line contains two space-separated integers that describe the competitors and results (the first integer, A, is the winner) of a single round of competition: A and B</li>
</ul>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>Line 1: A single integer representing the number of cows whose ranks can be determined
　</p>
<h4 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">4 3</span><br><span class="line">4 2</span><br><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure>
<h4 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>有N头牛，现在给出M个输赢列表（第一代表赢，第二代表输），并且实力是绝对的（这句话很重要）。要求你确定谁的排名是确定的，输出确定的个数。</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>使用传递闭包来确定赢的关系，并通过判断其中一头牛与其他牛是否都有联系（赢了别的牛，或输给了别的牛）。如果与其余N-1条牛都有联系，说明该牛的排名是确定的。</p>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 200;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line"></span><br><span class="line">int G[MAXN][MAXN];</span><br><span class="line">int N,M;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    memset(G,0,sizeof(G));</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;N,&amp;M);</span><br><span class="line">    for(int i = 0; i &lt; M; i++)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">        //生成a赢b的关系图</span><br><span class="line">        G[a][b] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int k = 1; k &lt;= N; k++)</span><br><span class="line">        for(int i = 1; i &lt;= N; i++)</span><br><span class="line">            for(int j = 1; j &lt;= N; j++)</span><br><span class="line">                //B&gt;C，A&gt;B，说明A&gt;C</span><br><span class="line">                if(G[i][k] &amp;&amp; G[k][j]) G[i][j] = 1;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    只有当一个点与其他个点都有联系（或赢或输）,才可以确定该点</span><br><span class="line">    */</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int j = 1; j &lt;= N; j++)&#123;</span><br><span class="line">        // 又因为该题有唯一的赢输判定，所以与其他各点都有联系可以直接表示为加的和为N-1</span><br><span class="line">        // 否则只能一一判定当前点与其他个点的关系。</span><br><span class="line">            sum = sum + G[i][j] + G[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum == N-1) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\\n&quot;,ans);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/08/30/POJ-3660-Co-Contest/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/08/25/POJ-1416-Shreddin-Company/">POJ-1416-Shreddin-Company</a>  
	       
		 

		<div class="article-meta">
			<time>8月 25, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="http://poj.org/problem?id=1416" target="_blank" rel="noopener">POJ-1416</a></p>
<h3 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h3><p>You have just been put in charge of developing a new shredder for the Shredding Company Although a “normal” shredder would just shred sheets of paper into little pieces so that the contents would become unreadable, this new shredder needs to have the following unusual basic characteristics.</p>
<ul>
<li><p>1.The shredder takes as input a target number and a sheet of paper with a number written on it.</p>
</li>
<li><p>2.It shreds (or cuts) the sheet into pieces each of which has one or more digits on it.</p>
</li>
<li><p>3.The sum of the numbers written on each piece is the closest possible number to the target number, without going over it.</p>
</li>
</ul>
<p>For example, suppose that the target number is 50, and the sheet of paper has the number 12346. The shredder would cut the sheet into four pieces, where one piece has 1, another has 2, the third has 34, and the fourth has 6. This is because their sum 43 (= 1 + 2 + 34 + 6) is closest to the target number 50 of all possible combinations without going over 50. For example, a combination where the pieces are 1, 23, 4, and 6 is not valid, because the sum of this combination 34 (= 1 + 23 + 4 + 6) is less than the above combination’s 43. The combination of 12, 34, and 6 is not valid either, because the sum 52 (= 12 + 34 + 6) is greater than the target number of 50.</p>
<p>Figure 1. Shredding a sheet of paper having the number 12346 when the target number is 50</p>
<p>There are also three special rules :</p>
<ul>
<li>1.If the target number is the same as the number on the sheet of paper, then the paper is not cut.</li>
</ul>
<p>For example, if the target number is 100 and the number on the sheet of paper is also 100, then the paper is not cut.</p>
<ul>
<li><p>2.If it is not possible to make any combination whose sum is less than or equal to the target number, then error is printed on a display. For example, if the target number is 1 and the number on the sheet of paper is 123, it is not possible to make any valid combination, as the combination with the smallest possible sum is 1, 2, 3. The sum for this combination is 6, which is greater than the target number, and thus error is printed.</p>
</li>
<li><p>3.If there is more than one possible combination where the sum is closest to the target number without going over it, then rejected is printed on a display. For example, if the target number is 15, and the number on the sheet of paper is 111, then there are two possible combinations with the highest possible sum of 12: (a) 1 and 11 and (b) 11 and 1; thus rejected is printed. In order to develop such a shredder, you have decided to first make a simple program that would simulate the above characteristics and rules. Given two numbers, where the first is the target number and the second is the number on the sheet of paper to be shredded, you need to figure out how the shredder should “cut up” the second number.</p>
</li>
</ul>
<h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><p>The input consists of several test cases, each on one line, as follows :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tl num1</span><br><span class="line">t2 num2</span><br><span class="line">...</span><br><span class="line">tn numn</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<p>Each test case consists of the following two positive integers, which are separated by one space : (1) the first integer (ti above) is the target number, (2) the second integer (numi above) is the number that is on the paper to be shredded.</p>
<p>Neither integers may have a 0 as the first digit, e.g., 123 is allowed but 0123 is not. You may assume that both integers are at most 6 digits in length. A line consisting of two zeros signals the end of the input.</p>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>For each test case in the input, the corresponding output takes one of the following three types :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum part1 part2 ...</span><br><span class="line">rejected</span><br><span class="line">error</span><br></pre></td></tr></table></figure>
<p>In the first type, partj and sum have the following meaning :</p>
<p>1.Each partj is a number on one piece of shredded paper. The order of partj corresponds to the order of the original digits on the sheet of paper.</p>
<p>2.sum is the sum of the numbers after being shredded, i.e., sum = part1 + part2 +…</p>
<p>Each number should be separated by one space.<br>The message error is printed if it is not possible to make any combination, and rejected if there is<br>more than one possible combination.<br>No extra characters including spaces are allowed at the beginning of each line, nor at the end of each line.</p>
<h3 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">50 12346</span><br><span class="line">376 144139</span><br><span class="line">927438 927438</span><br><span class="line">18 3312</span><br><span class="line">9 3142</span><br><span class="line">25 1299</span><br><span class="line">111 33333</span><br><span class="line">103 862150</span><br><span class="line">6 1104</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<h3 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">43 1 2 34 6</span><br><span class="line">283 144 139</span><br><span class="line">927438 927438</span><br><span class="line">18 3 3 12</span><br><span class="line">error</span><br><span class="line">21 1 2 9 9</span><br><span class="line">rejected</span><br><span class="line">103 86 2 15 0</span><br><span class="line">rejected</span><br></pre></td></tr></table></figure>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你一个有n个数的纸条，一个目标值，你可以任意剪纸条，要找出剪出的数的和最接近并且小于目标数的分解方式。</p>
<p>如果该数可以由多个分解方式组成，则输出error；如果无论如何分解都比目标值大，则输出rejected。如果分解值和目标数相同，则直接输出。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>首先对于剪纸条，无论如何剪，相邻数的位置关系并不会发生变化，只是选择元素的个数会发生变化，则可以dfs枚举所有的可能————对于某一过程，可以选择从该数开始到纸条结尾，每次都选择增加一个数，然后进行下一层的dfs，即可取得所有的分解组合。</p>
<p>接下来要保留选择数的路径，我们使用一个数的每一位来记录当前选择了几个数（N最大为6位，所以一位足够表示）。</p>
<p>然后，对于大于目标数的情况，只有当最小分解方式（每一位都被分解）之和都比目标值大，则可以直接输出rejected。该步可在dfs之前判断。</p>
<p>对于error的情况，只要在每次更新当前值的时候，也更新其相同的次数，如果大于1，则符合该情况。</p>
<p>可以小小的剪枝下：当过程中的取值比目标值大的话，就可以直接剪掉。</p>
<p>最后就是编码的时刻了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; ans;</span><br><span class="line">int num; //目标数</span><br><span class="line">int npath; //最优路径</span><br><span class="line">int curNum; //当前数，dfs中间值</span><br><span class="line">int cntNum; //当前数的出现次数。</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">将结果数组中的各值相加</span><br><span class="line">*/</span><br><span class="line">int getNum(vector&lt;vector&lt;int&gt; &gt; t, int n)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    int cont = 0;</span><br><span class="line">    for(int j = 0; j &lt; t.size(); j++)&#123;</span><br><span class="line">        int c = 0;</span><br><span class="line">        cont += t[j].size();</span><br><span class="line">        for(int k = 0; k &lt; t[j].size(); k++)&#123;</span><br><span class="line">            c = c*10 + t[j][k];</span><br><span class="line">        &#125;    </span><br><span class="line">        ans +=c;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">i:当前位置</span><br><span class="line">n：总长度</span><br><span class="line">path：记录每次分割长度</span><br><span class="line">s：总数据</span><br><span class="line">t：结果数组。</span><br><span class="line">*/</span><br><span class="line">void dfs(int i,int n,int path,char s[],vector&lt;vector&lt;int&gt; &gt; t)&#123;</span><br><span class="line">    int tt = getNum(t,n);</span><br><span class="line">    //如果过程中已经比当前数大了，直接剪掉</span><br><span class="line">    if(tt &gt; num) return;</span><br><span class="line">    </span><br><span class="line">    if(i == n)&#123;</span><br><span class="line">        //在当前一轮结束时更新离目标数最近并小于目标数的值、次数与路径。</span><br><span class="line">        if(curNum &lt; tt)&#123;</span><br><span class="line">            cntNum = 1;</span><br><span class="line">            curNum = tt;</span><br><span class="line">            npath = path;</span><br><span class="line">        &#125;else if(curNum == tt)&#123;</span><br><span class="line">            cntNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    dfs核心：</span><br><span class="line">    输入：1234</span><br><span class="line">    生成下列排列</span><br><span class="line">    1 2 3 4 </span><br><span class="line">    1 2 34 </span><br><span class="line">    1 23 4 </span><br><span class="line">    1 234 </span><br><span class="line">    12 3 4 </span><br><span class="line">    12 34 </span><br><span class="line">    123 4 </span><br><span class="line">    1234</span><br><span class="line">    */</span><br><span class="line">    vector&lt;int&gt; a;</span><br><span class="line">    for(int j = i; j &lt; n; j++)&#123;</span><br><span class="line">        a.push_back(s[j]-&apos;0&apos;);</span><br><span class="line">        t.push_back(a);</span><br><span class="line">        dfs(j+1,n,path*10+j-i+1,s,t);</span><br><span class="line">        t.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据path输出各个数。</span><br><span class="line">void show(char s[],int path)&#123;</span><br><span class="line">    vector&lt;int&gt; a;</span><br><span class="line">    while(path)&#123;</span><br><span class="line">        a.push_back(path%10);</span><br><span class="line">        path/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(a.begin(),a.end());</span><br><span class="line">    int j = 0;</span><br><span class="line">    for(int i = 0; i &lt; a.size(); i++)&#123;</span><br><span class="line">        printf(&quot; &quot;);</span><br><span class="line">        for(int k = 0; k &lt; a[i]; k++)&#123;</span><br><span class="line">            printf(&quot;%c&quot;,s[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    int a;</span><br><span class="line">    char s[1000];</span><br><span class="line">    while(scanf(&quot;%d%s&quot;,&amp;a,s) &amp;&amp; a)&#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; t;</span><br><span class="line">        num = a;</span><br><span class="line">        curNum = 0;</span><br><span class="line">        cntNum = 0;</span><br><span class="line"></span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0; i &lt; strlen(s); i++)&#123;</span><br><span class="line">            sum += s[i]-&apos;0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        //给定数的每一位相加都比目标数大</span><br><span class="line">        if(sum &gt; a)&#123;</span><br><span class="line">            printf(&quot;error\\n&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            dfs(0,strlen(s),0,s,t);</span><br><span class="line">            if(cntNum &gt; 1)&#123;</span><br><span class="line">                printf(&quot;rejected\\n&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                printf(&quot;%d&quot;,curNum);</span><br><span class="line">                show(s,npath);</span><br><span class="line">                printf(&quot;\\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/08/25/POJ-1416-Shreddin-Company/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/08/23/POJ-3083-Childre-o-th-Cand-Corn/">POJ-3083-Childre-o-th-Cand-Corn</a>  
	       
		 

		<div class="article-meta">
			<time>8月 23, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="http://poj.org/problem?id=3083" target="_blank" rel="noopener">POJ-3083</a></p>
<h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><p>The cornfield maze is a popular Halloween treat. Visitors are shown the entrance and must wander through the maze facing zombies, chainsaw-wielding psychopaths, hippies, and other terrors on their quest to find the exit.</p>
<p>One popular maze-walking strategy guarantees that the visitor will eventually find the exit. Simply choose either the right or left wall, and follow it. Of course, there’s no guarantee which strategy (left or right) will be better, and the path taken is seldom the most efficient. (It also doesn’t work on mazes with exits that are not on the edge; those types of mazes are not represented in this problem.)</p>
<p>As the proprieter of a cornfield that is about to be converted into a maze, you’d like to have a computer program that can determine the left and right-hand paths along with the shortest path so that you can figure out which layout has the best chance of confounding visitors.</p>
<h4 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h4><p>Input to this problem will begin with a line containing a single integer n indicating the number of mazes. Each maze will consist of one line with a width, w, and height, h (3 &lt;= w, h &lt;= 40), followed by h lines of w characters each that represent the maze layout. Walls are represented by hash marks (‘#’), empty space by periods (‘.’), the start by an ‘S’ and the exit by an ‘E’.</p>
<p>Exactly one ‘S’ and one ‘E’ will be present in the maze, and they will always be located along one of the maze edges and never in a corner. The maze will be fully enclosed by walls (‘#’), with the only openings being the ‘S’ and ‘E’. The ‘S’ and ‘E’ will also be separated by at least one wall (‘#’).</p>
<p>You may assume that the maze exit is always reachable from the start point.</p>
<h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><p>For each maze in the input, output on a single line the number of (not necessarily unique) squares that a person would visit (including the ‘S’ and ‘E’) for (in order) the left, right, and shortest paths, separated by a single space each. Movement from one square to another is only allowed in the horizontal or vertical direction; movement along the diagonals is not allowed.</p>
<h4 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">8 8</span><br><span class="line">########</span><br><span class="line">#......#</span><br><span class="line">#.####.#</span><br><span class="line">#.####.#</span><br><span class="line">#.####.#</span><br><span class="line">#.####.#</span><br><span class="line">#...#..#</span><br><span class="line">#S#E####</span><br><span class="line">9 5</span><br><span class="line">#########</span><br><span class="line">#.#.#.#.#</span><br><span class="line">S.......E</span><br><span class="line">#.#.#.#.#</span><br><span class="line">#########</span><br></pre></td></tr></table></figure>
<h4 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">37 5 5</span><br><span class="line">17 17 9</span><br></pre></td></tr></table></figure>
<h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>有一张地图，# 是墙壁，. 是路，S是点，E是终点。（S和E在地图边缘且不在四个对角）</p>
<p>问：优先选择左边到达终点的路径长度（目前朝向的左边为优先选边，顺时针），优先选择右边到达终点的路径长度（目前朝向的右边为优先选边，逆时针），和最短的路径长度。</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>该题使用dfs（前两问）加bfs（后一问）来解答，由于有一个优先选择当前方向的左边或者右边位置，所以需要处理一个当前的朝向问题。比普通的dfs要复杂一点。但是根据定义的方向数组，只要知道了向左转就是当前的朝向减一个单位，右转为当前的朝向加一个单位，以此为起始探测方向，并且处理好顺逆时针关系就可以化解该题。</p>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN = 50;</span><br><span class="line">char m[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">int N,M;</span><br><span class="line">int sx,sy,ex,ey;</span><br><span class="line">int ans;</span><br><span class="line">int flag;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y,d;</span><br><span class="line">    node()&#123;&#125;</span><br><span class="line">    node(int _x,int _y, int _d):x(_x),y(_y),d(_d)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//从左顺时针</span><br><span class="line">int dx[] = &#123;0,-1,0,1&#125;;</span><br><span class="line">int dy[] = &#123;-1,0,1,0&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void dfs(int x, int y, int pos,int t,int s)&#123;</span><br><span class="line">    // printf(&quot;%d %d %d\\n&quot;,x,y,d);</span><br><span class="line">    if(flag) return;</span><br><span class="line">    if(x == ex &amp;&amp; y == ey)&#123;</span><br><span class="line">        flag = 1;</span><br><span class="line">        ans = max(ans,s);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //t = -1 表示顺时针，t = 1 表示逆时针</span><br><span class="line">    //pp : 当前的方向</span><br><span class="line">    //如果是左优先，就将当前方向-1开始顺时针，</span><br><span class="line">    //如果是右优先，就将当前方向+1开始逆时针。</span><br><span class="line">    for(int i = 1,pp = (pos+t+4)%4; i &lt;= 4; i++,pp = (pp-t+4)%4)&#123;</span><br><span class="line">        int nx = dx[pp] + x;</span><br><span class="line">        int ny = dy[pp] + y;</span><br><span class="line">        if(nx &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; M &amp;&amp; m[nx][ny] == &apos;.&apos;)&#123;</span><br><span class="line">            dfs(nx,ny,pp,t,s+1);</span><br><span class="line">            if(flag) return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void bfs(int x,int y)&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.push(node(x,y,1));</span><br><span class="line">    m[x][y] = &apos;#&apos;;</span><br><span class="line">    node temp;</span><br><span class="line">    while(q.size())&#123;</span><br><span class="line">        temp = q.front();q.pop();</span><br><span class="line">        if(temp.x == ex &amp;&amp; temp.y == ey)&#123;</span><br><span class="line">            ans = temp.d;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">            int nx = dx[i] + temp.x;</span><br><span class="line">            int ny = dy[i] + temp.y;</span><br><span class="line">            if(nx &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; M &amp;&amp; m[nx][ny] == &apos;.&apos;)&#123;</span><br><span class="line">                m[nx][ny] = &apos;#&apos;;</span><br><span class="line">                q.push(node(nx,ny,temp.d+1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        int pos = 0;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;M,&amp;N);</span><br><span class="line">        // memset(m,0,sizeof(m));</span><br><span class="line">        for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,m[i]);</span><br><span class="line">            for(int j = 0; j &lt; M; j++)&#123;</span><br><span class="line">                if(m[i][j] == &apos;S&apos;)&#123;</span><br><span class="line">                    sx = i,sy = j; m[i][j] = &apos;.&apos;;</span><br><span class="line">                &#125;else if(m[i][j] == &apos;E&apos;)&#123;</span><br><span class="line">                    ex = i,ey = j; m[i][j] = &apos;.&apos;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // for(int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        //     for(int j = 0; j &lt; M; j++)&#123;</span><br><span class="line">        //         printf(&quot;%c&quot;,m[i][j]);</span><br><span class="line">        //     &#125;</span><br><span class="line">        //     printf(&quot;\\n&quot;);</span><br><span class="line">        // &#125;</span><br><span class="line">        /*</span><br><span class="line">        pos = 0 表示向上为初始方向</span><br><span class="line">        pos = 1 表示向右为初始方向</span><br><span class="line">        pos = 2 表示向下为初始方向</span><br><span class="line">        pos = 3 表示向左为初始方向</span><br><span class="line">        */</span><br><span class="line">        if(sx == 0) pos = 2;</span><br><span class="line">        if(sx == N-1) pos = 0;</span><br><span class="line">        if(sy == 0) pos = 1;</span><br><span class="line">        if(sy == M-1) pos = 3;</span><br><span class="line">        ans = 0;</span><br><span class="line">        flag = 0;</span><br><span class="line">        dfs(sx,sy,pos,-1,1);</span><br><span class="line">        printf(&quot;%d&quot;,ans);</span><br><span class="line">        ans = 0;</span><br><span class="line">        flag = 0;</span><br><span class="line">        dfs(sx,sy,pos,1,1);</span><br><span class="line">        printf(&quot; %d&quot;,ans);</span><br><span class="line">        ans = 0;</span><br><span class="line">        bfs(sx,sy);</span><br><span class="line">        printf(&quot; %d\\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/08/23/POJ-3083-Childre-o-th-Cand-Corn/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/08/16/LeetCode-473-火柴拼正方形/">LeetCode-473-火柴拼正方形</a>  
	       
		 

		<div class="article-meta">
			<time>8月 16, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/matchsticks-to-square/" target="_blank" rel="noopener">473. 火柴拼正方形</a></p>
<p>还记得童话《卖火柴的小女孩》吗？现在，你知道小女孩有多少根火柴，请找出一种能使用所有火柴拼成一个正方形的方法。不能折断火柴，可以把火柴连接起来，并且每根火柴都要用到。</p>
<p>输入为小女孩拥有火柴的数目，每根火柴用其长度表示。输出即为是否能用所有的火柴拼成正方形。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,2,2,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释: 能拼成一个边长为2的正方形，每边两根火柴。</p>
</blockquote>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,3,3,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释: 不能用所有火柴拼成一个正方形。</p>
</blockquote>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h5><p>给定的火柴长度和在 0 到 10^9之间。火柴数组的长度不超过15。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int part;</span><br><span class="line">    vector&lt;bool&gt; vis;</span><br><span class="line">    bool f = true;</span><br><span class="line">    bool makesquare(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++) sum += nums[i];</span><br><span class="line">        if(!sum || sum%4) return false;</span><br><span class="line">        part = sum / 4;</span><br><span class="line">        vis = vector&lt;bool&gt;(nums.size());</span><br><span class="line">        //从大到小枚举所有边</span><br><span class="line">        sort(nums.begin(),nums.end(),greater&lt;int&gt;());</span><br><span class="line">        return dfs(nums,0,0,part);</span><br><span class="line">    &#125;</span><br><span class="line">    //u:当前选了几个数，sum：当前的和，k:选到了第几层</span><br><span class="line">    bool dfs(vector&lt;int&gt; &amp;nums,int u,int cur,int length)&#123;</span><br><span class="line">        if(cur == length) u+=1,cur=0;</span><br><span class="line">        if(u == 4) return true;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            //</span><br><span class="line">            if(!vis[i] &amp;&amp; cur+nums[i] &lt;= length)&#123;</span><br><span class="line">                vis[i] = true;</span><br><span class="line">                if(dfs(nums,u,cur+nums[i],length)) return true;</span><br><span class="line">                vis[i] = false;</span><br><span class="line">                //如果当前木棒拼接失败，并且是第一个，则剪掉。</span><br><span class="line">                if(cur == 0) return false;</span><br><span class="line">                //如果当前木棒拼接失败，并且是最后一个，则剪掉。</span><br><span class="line">                if(cur + nums[i] == length) return false;</span><br><span class="line">                //如果当前木棒拼接失败，跳过所有相同长度的木棒。</span><br><span class="line">                while(i+1 &lt; nums.size() &amp;&amp; nums[i] == nums[i+1]) i++;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>剪枝策略：</p>
<ul>
<li>从小到大枚举所有边</li>
<li>每条边内部的木棒长度规定为从大到小</li>
<li>如果当前木棒拼接失败，则跳过接下来所有长度相同的木棒。</li>
<li>如果当前木棒拼接失败，且是当前边的第一个，则直接剪掉当前分支。</li>
<li>如果当前木棒拼接失败，且是当前边的最后一个，则直接剪掉当前分支。</li>
</ul>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/08/16/LeetCode-473-火柴拼正方形/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/08/16/LeetCode-216-组合总-III/">LeetCode-216-组合总-III</a>  
	       
		 

		<div class="article-meta">
			<time>8月 16, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/combination-sum-iii/" target="_blank" rel="noopener">216. 组合总和 III</a></p>
<p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p>说明：</p>
<ul>
<li><p>所有数字都是正整数。</p>
</li>
<li><p>解集不能包含重复的组合。 </p>
</li>
</ul>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br></pre></td></tr></table></figure>
<h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        dfs(0,1,0,k,n);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    //u:当前选择数的个数，a：当前可以枚举的位置，sum:当前组合数的和。</span><br><span class="line">    void dfs(int u,int a,int sum,int k,int n)&#123;</span><br><span class="line">        if(u == k &amp;&amp; sum == n)&#123;</span><br><span class="line">            ans.push_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(a == 10)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum &gt; n) return;</span><br><span class="line">        for(int i = a; i &lt; 10; i++)&#123;</span><br><span class="line">            tmp.push_back(i);</span><br><span class="line">            dfs(u+1,i+1,sum+i,k,n);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/08/16/LeetCode-216-组合总-III/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/08/16/LeetCode-47-全排-II/">LeetCode-47-全排-II</a>  
	       
		 

		<div class="article-meta">
			<time>8月 16, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></p>
<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><p>输入: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,1,2]</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="Solution1-set去重-："><a href="#Solution1-set去重-：" class="headerlink" title="Solution1(set去重)："></a>Solution1(set去重)：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">    vector&lt;bool&gt; bt;</span><br><span class="line">    int n;</span><br><span class="line">    set&lt;vector&lt;int&gt;&gt; s;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        bt = vector&lt;bool&gt;(n);</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        dfs(0,0,nums);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(int u,int start,vector&lt;int&gt; &amp;nums)&#123;</span><br><span class="line">        if(u == n)&#123;</span><br><span class="line">            if(!s.count(tmp))&#123;</span><br><span class="line">            ans.push_back(tmp);</span><br><span class="line">                s.insert(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            if(!bt[i])&#123;</span><br><span class="line">                bt[i] = true;</span><br><span class="line">                tmp.push_back(nums[i]);</span><br><span class="line">                dfs(u+1,start,nums);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">                bt[i] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>去重问题，首先想到set，比较简单粗暴的都放到set容器里，有重复就不往答案里面去。</p>
<h3 id="Solution2（排序去重）："><a href="#Solution2（排序去重）：" class="headerlink" title="Solution2（排序去重）："></a>Solution2（排序去重）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">    vector&lt;bool&gt; bt;</span><br><span class="line">    int n;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        bt = vector&lt;bool&gt;(n);</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        dfs(0,0,nums);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    bool judge(int i,vector&lt;int&gt; nums)&#123;</span><br><span class="line">        for(int j = 0; j &lt; i; j++)&#123;</span><br><span class="line">            if(nums[i] == nums[j])&#123;</span><br><span class="line">                if(!bt[j]) return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void dfs(int u,int start,vector&lt;int&gt; &amp;nums)&#123;</span><br><span class="line">        if(u == n)&#123;</span><br><span class="line">            ans.push_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            //如果所选是重复数，并且前面都选过了，才能选择当前的。</span><br><span class="line">            if(!bt[i] &amp;&amp; (i == 0 ? 1 : nums[i-1] == nums[i] ? bt[i-1] : 1))&#123;</span><br><span class="line">                bt[i] = true;</span><br><span class="line">                tmp.push_back(nums[i]);</span><br><span class="line">                dfs(u+1,start,nums);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">                bt[i] = false;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>选择不重复元素的全排列我们已经解决过了，现在我们研究如何去重的问题。</p>
<p>首先我们发现去重的原因是两个位置不同的相同的数在交换之后，整体排列不变，这样就会产生重复，为了达到去重的目的，我们人为规定，当前元素必须在所有在它之前的元素都已经被选了以后，它才能选。这样，相同元素的相对位置就固定下来，不会发生交换重复问题。所以为了方便，我们把相同的元素排在一起，这时需要先排序。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/08/16/LeetCode-47-全排-II/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/08/13/费解的开关/">费解的开关</a>  
	       
		 

		<div class="article-meta">
			<time>8月 13, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="https://www.acwing.com/problem/content/97/" target="_blank" rel="noopener">费解的开关</a></p>
<p>你玩过“拉灯”游戏吗？25盏灯排成一个5x5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。</p>
<p>我们用数字“1”表示一盏开着的灯，用数字“0”表示关着的灯。下面这种状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10111</span><br><span class="line">01101</span><br><span class="line">10111</span><br><span class="line">10000</span><br><span class="line">11011</span><br></pre></td></tr></table></figure>
<p>在改变了最左上角的灯的状态后将变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01111</span><br><span class="line">11101</span><br><span class="line">10111</span><br><span class="line">10000</span><br><span class="line">11011</span><br></pre></td></tr></table></figure>
<p>再改变它正中间的灯后状态将变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01111</span><br><span class="line">11001</span><br><span class="line">11001</span><br><span class="line">10100</span><br><span class="line">11011</span><br></pre></td></tr></table></figure>
<p>给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。<br>输入格式</p>
<p>第一行输入正整数n，代表数据中共有n个待解决的游戏初始状态。</p>
<p>以下若干行数据分为n组，每组数据有5行，每行5个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。<br>输出格式</p>
<p>一共输出n行数据，每行有一个小于等于6的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。</p>
<p>对于某一个游戏初始状态，若6步以内无法使所有灯变亮，则输出“-1”。</p>
<h4 id="数据范围：0-lt-n≤500"><a href="#数据范围：0-lt-n≤500" class="headerlink" title="数据范围：0&lt;n≤500"></a>数据范围：0&lt;n≤500</h4><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">00111</span><br><span class="line">01011</span><br><span class="line">10001</span><br><span class="line">11010</span><br><span class="line">11100</span><br><span class="line"></span><br><span class="line">11101</span><br><span class="line">11101</span><br><span class="line">11110</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line"></span><br><span class="line">01111</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11111</span><br></pre></td></tr></table></figure>
<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<h3 id="Solution1（TLE）："><a href="#Solution1（TLE）：" class="headerlink" title="Solution1（TLE）："></a>Solution1（TLE）：</h3><p>我们可以枚举每个开关的状态，然后查看是否全亮，每个开关两个状态（开和关），一共有25个开关，所以复杂度为O(2^25) = 33554432次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int m;</span><br><span class="line">int ans = 26;</span><br><span class="line">void flip(int k)&#123;</span><br><span class="line">    int i = k / 5,j = k % 5;</span><br><span class="line">    m ^= 1 &lt;&lt; k;</span><br><span class="line">    if(j-1 &gt;= 0) m ^= (1 &lt;&lt; (i * 5 + (j-1)));</span><br><span class="line">    if(j+1 &lt; 5) m ^= (1 &lt;&lt; (i *5 + (j+1)));</span><br><span class="line">    if(i-1 &gt;= 0) m ^= (1 &lt;&lt; ((i-1) *5 + j));</span><br><span class="line">    if(i+1 &lt; 5) m ^= (1 &lt;&lt; ((i+1) *5 + j));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int k,int d)&#123;</span><br><span class="line">    if(m == (1&lt;&lt;25)-1)&#123;</span><br><span class="line">        ans = min(ans,d);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(k &gt;= 26) return;</span><br><span class="line">    dfs(k+1,d);</span><br><span class="line">    flip(k);</span><br><span class="line">    dfs(k+1,d+1);</span><br><span class="line">    flip(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    getchar();</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        char c[10];</span><br><span class="line">        m = 0;</span><br><span class="line">        ans = 26;</span><br><span class="line">        for(int i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,c);</span><br><span class="line">            for(int j = 0; j &lt; 5; j++)&#123;</span><br><span class="line">                if(c[j] == &apos;1&apos;) m |= (1 &lt;&lt; (i*5+j));</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%s\\n&quot;,c);</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%#x\\n&quot;,m);</span><br><span class="line">        dfs(0,0);</span><br><span class="line">        if(ans &gt; 6) ans = -1;</span><br><span class="line">        printf(&quot;%d\\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solution2："><a href="#Solution2：" class="headerlink" title="Solution2："></a>Solution2：</h3><p>我们可以从行的角度来看：<br>如果当前行确定了，我们要让所有的开关打开，就要选把当前行中关闭的灯的下面位置的切换状态。<br>归纳到一般情况，当第一行的状态确定了，我们为了使所有的开关打开，去下一行改变状态，使得当前行的所有灯打开。如此4次后，由于到达了最后一行，这时，我们检查最后一行的灯是否全部亮，（前面4行已经全部亮了）。如果全亮，则当前的选择为一个可选方案，这时更新翻转的次数。</p>
<p>复杂度为O(n * 2^5)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line"></span><br><span class="line">char m[10][10];</span><br><span class="line">int ans = INF;</span><br><span class="line">int dx[5] = &#123;0,-1,0,1,0&#125;;</span><br><span class="line">int dy[5] = &#123;0,0,1,0,-1&#125;;</span><br><span class="line">void flip(int x,int y)&#123;</span><br><span class="line">    for(int i = 0; i &lt;5; i++)&#123;</span><br><span class="line">        int xi = x + dx[i];</span><br><span class="line">        int yi = y + dy[i];</span><br><span class="line">        if(xi &gt;= 0 &amp;&amp; xi &lt; 5 &amp;&amp; yi &gt;= 0 &amp;&amp; yi &lt; 5)&#123;</span><br><span class="line">            m[xi][yi] ^= 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    char backup[10][10];</span><br><span class="line">    int res = 0;</span><br><span class="line">    memcpy(backup,m,sizeof(m));</span><br><span class="line">    for(int i = 0; i &lt; 1 &lt;&lt; 5; i++)&#123;</span><br><span class="line">        res = 0;</span><br><span class="line">        for(int j = 0; j &lt; 5; j++)&#123;</span><br><span class="line">            if(i &gt;&gt; j &amp; 1)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                flip(0,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 0; j &lt; 4; j++)&#123;</span><br><span class="line">            for(int k = 0; k &lt; 5; k++)&#123;</span><br><span class="line">                if(m[j][k] == &apos;0&apos;)&#123;</span><br><span class="line">                    flip(j+1,k);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bool flag = true;</span><br><span class="line">        for(int j = 0; j &lt; 5; j++)&#123;</span><br><span class="line">            if(m[4][j] == &apos;0&apos;)&#123;</span><br><span class="line">                flag = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag) ans = min(ans,res);</span><br><span class="line">        memcpy(m,backup,sizeof(backup));    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    // freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    getchar();</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        ans = INF;</span><br><span class="line">        for(int i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,m[i]);</span><br><span class="line">            // printf(&quot;%s\\n&quot;,m[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">        if(ans &gt; 6) ans = -1;</span><br><span class="line">        printf(&quot;%d\\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/08/13/费解的开关/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2019/08/13/POJ-1062-昂贵的聘礼/">POJ-1062-昂贵的聘礼</a>  
	       
		 

		<div class="article-meta">
			<time>8月 13, 2019</time>
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p><a href="http://poj.org/problem?id=1062" target="_blank" rel="noopener">POJ-1062</a></p>
<p>年轻的探险家来到了一个印第安部落里。在那里他和酋长的女儿相爱了，于是便向酋长去求亲。酋长要他用10000个金币作为聘礼才答应把女儿嫁给他。探险家拿不出这么多金币，便请求酋长降低要求。酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要8000金币。如果你能够弄来他的水晶球，那么只要5000金币就行了。”探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。另外他要告诉你的是，在这个部落里，等级观念十分森严。地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。他是一个外来人，所以可以不受这些限制。但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。因此你需要在考虑所有的情况以后给他提供一个最好的方案。</p>
<p>为了方便起见，我们把所有的物品从1开始进行编号，酋长的允诺也看作一个物品，并且编号总是1。每个物品都有对应的价格P，主人的地位等级L，以及一系列的替代品Ti和该替代品所对应的”优惠”Vi。如果两人地位等级差距超过了M，就不能”间接交易”。你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。</p>
<p>输入第一行是两个整数M，N（1 &lt;= N &lt;= 100），依次表示地位等级差距限制和物品的总数。接下来按照编号从小到大依次给出了N个物品的描述。每个物品的描述开头是三个非负整数P、L、X（X &lt; N），依次表示该物品的价格、主人的地位等级和替代品总数。接下来X行每行包括两个整数T和V，分别表示替代品的编号和”优惠价格”。</p>
<p>输出最少需要的金币数。</p>
<h4 id="输入示例："><a href="#输入示例：" class="headerlink" title="输入示例："></a>输入示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 4</span><br><span class="line">10000 3 2</span><br><span class="line">2 8000</span><br><span class="line">3 5000</span><br><span class="line">1000 2 1</span><br><span class="line">4 200</span><br><span class="line">3000 2 1</span><br><span class="line">4 200</span><br><span class="line">50 2 0</span><br></pre></td></tr></table></figure>
<h4 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5250</span><br></pre></td></tr></table></figure>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>一开始需要n金币，每个物品都有自己的价值，你可以用其他物品来抵消一部分金币（优惠价格），而用来抵消的物品也可以由其他物品来抵消该物品的一部分，如此往复。并且主人是分等级的，要确保交换物品过程中任何两个人的等级差距都不能超过M。<br>问最少需要的金币数量。</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>把每个物品看成结点，B物品可以抵消A物品的一部分,表示A有一条边指向B,边权是替代品的优惠价格，点权为该物品的价值。</p>
<p>可以求第一个物品到其他物品的最短路，松弛操作为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dis[v] &gt; dis[u] + u到v的边权</span><br></pre></td></tr></table></figure>
<p>这样求得的dis为每个顶点到起点的优惠价格，而到当前点的总花费为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dis[i] + coin[i] //优惠价格+当前物品的价格</span><br></pre></td></tr></table></figure>
<p>而题目还有一层约束条件为物品交换不能超过等级差距。<br>我们就需要检查每个点到起点的等级差了。<br>例如起点的等级为5，等级差距为3，则要枚举的区间为 3 ~ 5、4 ~ 6、5 ~ 7 ，在每个区间中，求符合等级差距的点，并求起点到该点的最短路（这里比较绕，建议多思考下）。最后答案取一个最小值即可。</p>
<h4 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 110;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">    int to,cost;</span><br><span class="line">    Edge()&#123;&#125;;</span><br><span class="line">    Edge(int _to,int _cost)&#123;</span><br><span class="line">        to = _to;</span><br><span class="line">        cost = _cost;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct qnode&#123;</span><br><span class="line">    int v,cost;</span><br><span class="line">    qnode(int _v, int _cost)&#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        cost = _cost;</span><br><span class="line">    &#125;</span><br><span class="line">    qnode()&#123;&#125;</span><br><span class="line">    bool operator &lt;(const qnode &amp;b)const&#123;</span><br><span class="line">        return cost &gt; b.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line">int coin[MAXN]; //价值多少金币 </span><br><span class="line">int dis[MAXN];	//最少优惠 </span><br><span class="line">int vis[MAXN];	</span><br><span class="line">int pos[MAXN];  //等级 </span><br><span class="line">int M,N;</span><br><span class="line">int ans;</span><br><span class="line"> void Dijkstra(int S,int N)&#123;</span><br><span class="line"> 	for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line"> 		dis[i] = S== i ? 0 : INF;</span><br><span class="line">	 &#125;</span><br><span class="line">     priority_queue&lt;qnode&gt; pq;</span><br><span class="line">     pq.push(qnode(S,dis[S]));</span><br><span class="line">     qnode temp;</span><br><span class="line">     while(pq.size())&#123;</span><br><span class="line">         temp = pq.top();pq.pop();</span><br><span class="line">         int u = temp.v;</span><br><span class="line">         if(vis[u])continue;</span><br><span class="line">         vis[u] = 1;</span><br><span class="line">         for(int i = 0; i &lt; G[u].size(); i++)&#123;</span><br><span class="line">             int v = G[u][i].to;</span><br><span class="line">             int vc = G[u][i].cost;</span><br><span class="line">             if(!vis[v] &amp;&amp; dis[v] &gt; dis[u] + vc)&#123;</span><br><span class="line">                dis[v] = dis[u] + vc;	</span><br><span class="line">                //更新答案 </span><br><span class="line">                ans = min(ans,dis[v] + coin[v]);</span><br><span class="line">                pq.push(qnode(v,dis[v]));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">//     for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">//     	ans = min(ans,dis[i] + coin[i]);		</span><br><span class="line">//	 &#125; </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">void init(int N)&#123;</span><br><span class="line">	for(int i = 0; i &lt;= N; i++)&#123;</span><br><span class="line">		G[i].clear();</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;M,&amp;N);</span><br><span class="line">    init(N);</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        int c,r,n;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;c,&amp;r,&amp;n);</span><br><span class="line">        coin[i] = c;</span><br><span class="line">        pos[i] = r;</span><br><span class="line"></span><br><span class="line">        for(int j = 1; j &lt;= n; j++)&#123;</span><br><span class="line">            int t,cost;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;t,&amp;cost);</span><br><span class="line">            G[i].push_back(Edge(t,cost));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //设最大值为起始值 </span><br><span class="line">    ans = coin[1];</span><br><span class="line">    for(int i = 0; i &lt;= M; i++)&#123;</span><br><span class="line">    	//更新每个点是否在当前区间内 </span><br><span class="line">    	for(int j = 1; j &lt;= N; j++)&#123;</span><br><span class="line">    		if(pos[j] &gt;= pos[1]-M+i &amp;&amp; pos[j] &lt;= pos[1]+i) vis[j] = 0;</span><br><span class="line">    		else vis[j] = 1;</span><br><span class="line">		&#125;</span><br><span class="line">		//求一下当前区间的最短路。 </span><br><span class="line">		Dijkstra(1,N);</span><br><span class="line">	&#125;</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2019/08/13/POJ-1062-昂贵的聘礼/">阅读更多</a> 	
	</div>	
    
</article>     
     	




 
   <nav class="paginator">
    
        <a class="prev" href="/page/2/"> 
            <i class="iconfont icon-left"></i>
            上一页
        </a>
    

   <span class="page-number"> Page <strong>3</strong>, Total <strong>118</strong> . </span>

    
        <a class="next" href="/page/4/"> 
            下一页
            <i class="iconfont icon-right"></i>
        </a>
    
  </nav> 

          </div> 
      </div>            
    
    <a id="page-backTop">
      <span>
        <i class="iconfont icon-backtotop"></i>
      </span>
    </a> 

  
    
    <div class="search-container sildeUpMin">
        <div class="search-header">
            <input type="text" placeholder="输入你想搜索的" id="search-input" class="search-input">
            <span class="search-cancel">
                <i class="iconfont icon-cancel">
            </i></span>
        </div>
        <div id="search-result" class="search-result"></div>
    </div>
 
     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon" src="/images/logo.png">   
      

         
            

            <a class="mobile-menu-link" href="/">首页
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">归档
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">标签
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">关于
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">搜索 </a>                 
            
         
      
</div>        
    



     
    




<footer id="footer">	    

		
		<div class="footer-copyright">
		&copy;
				
		2017-
		
		2020		
	
		BeckoninGshy&#39;s Blog
		<br>

		Theme  <a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank">Nayo</a>
		</div>			
	 
</footer>   

    <script src="/nayo.bundle.js"></script>           
  </body>        
</html>